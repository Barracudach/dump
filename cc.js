System.register([], function (t, e) {
  "use strict";
  return {
    execute: function () {
      function i(t, e, i, s) {
        i &&
          Object.defineProperty(t, e, {
            enumerable: i.enumerable,
            configurable: i.configurable,
            writable: i.writable,
            value: i.initializer ? i.initializer.call(s) : void 0,
          });
      }
      function s(t, e, i, s, n) {
        var r = {};
        return (
          Object.keys(s).forEach(function (t) {
            r[t] = s[t];
          }),
          (r.enumerable = !!r.enumerable),
          (r.configurable = !!r.configurable),
          ("value" in r || r.initializer) && (r.writable = !0),
          (r = i
            .slice()
            .reverse()
            .reduce(function (i, s) {
              return s(t, e, i) || i;
            }, r)),
          n &&
            void 0 !== r.initializer &&
            ((r.value = r.initializer ? r.initializer.call(n) : void 0),
            (r.initializer = void 0)),
          void 0 === r.initializer &&
            (Object.defineProperty(t, e, r), (r = null)),
          r
        );
      }
      function n(t, e) {
        const i = "undefined" == typeof window ? global : window;
        return void 0 === i[t] ? (i[t] = e) : i[t];
      }
      t({
        BitMask: oe,
        CCClass: hi,
        Enum: ce,
        Eventify: or,
        WorldNode3DToLocalNodeUI: Nr,
        WorldNode3DToWorldNodeUI: Lr,
        __checkObsoleteInNamespace__: function (t) {
          return (
            ot ||
              (ot =
                "undefined" == typeof Proxy
                  ? {}
                  : new Proxy(t, {
                      get: (t, e, i) => (at(e), Reflect.get(t, e, i)),
                    })),
            ot
          );
        },
        __checkObsolete__: function (t) {
          for (let e of t) at(e);
        },
        _resetDebugSetting: M,
        absMax: Fi,
        absMaxComponent: Bi,
        applyMixins: lc,
        approx: Ti,
        assert: D,
        assertID: j,
        assertIsNonNullable: function () {},
        assertIsTrue: function () {},
        assertsArrayIndex: he,
        bezier: Wh,
        bezierByTime: Qh,
        binarySearch: function (t, e) {
          return la(t, e, 0);
        },
        binarySearchBy: function (t, e, i) {
          let s = 0,
            n = t.length - 1,
            r = n >>> 1;
          for (; s <= n; r = (s + n) >>> 1) {
            const a = t[r];
            if (i(a, e) < 0) n = r - 1;
            else {
              if (!(i(a, e) > 0)) return r;
              s = r + 1;
            }
          }
          return ~s;
        },
        binarySearchEpsilon: la,
        ccenum: de,
        clamp: Si,
        clamp01: Ei,
        color: Ji,
        computeRatioByType: cK,
        createDefaultPipeline: L6,
        debug: x,
        debugID: U,
        deprecateModuleExportedName: rt,
        deserialize: Bp,
        enumerableProps: Ui,
        equals: yi,
        error: R,
        errorID: G,
        find: aS,
        flattenCodeArray: hc,
        floatToHalf: Hi,
        formerlySerializedAs: La,
        fragmentText: qC,
        getBaselineOffset: function () {
          return 0;
        },
        getEnglishWordPartAtFirst: YC,
        getEnglishWordPartAtLast: KC,
        getError: X,
        getPathFromRoot: function (t, e) {
          let i = t,
            s = "";
          for (; null !== i && i !== e; )
            (s = `${i.name}/${s}`), (i = i.parent);
          return s.slice(0, -1);
        },
        getSerializationMetadata: function (t) {
          return t[Pa];
        },
        getSymbolAt: GC,
        getSymbolCodeAt: VC,
        getSymbolLength: HC,
        getWorldTransformUntilRoot: Hz,
        halfToFloat: Gi,
        instantiate: Jj,
        inverseLerp: Li,
        isCCClassOrFastDefined: li,
        isCCObject: Zn,
        isDisplayStats: Y,
        isEnglishWordPartAtFirst: function (t) {
          return FC.test(t);
        },
        isEnglishWordPartAtLast: function (t) {
          return BC.test(t);
        },
        isUnicodeCJK: UC,
        isUnicodeSpace: kC,
        isValid: Qn,
        lerp: vi,
        log: I,
        logID: B,
        mat4: ys,
        murmurhash2_32_gc: tc,
        nextPow2: Mi,
        pingPong: Ni,
        pseudoRandom: Ri,
        pseudoRandomRange: Di,
        pseudoRandomRangeInt: xi,
        quat: _s,
        random: Ci,
        randomRange: Ii,
        randomRangeInt: wi,
        rect: xs,
        repeat: Pi,
        safeMeasureText: zC,
        sampleAnimationCurve: lK,
        setDefaultLogTimes: function (t) {
          t > 0 && (et = t);
        },
        setDisplayStats: K,
        setPropertyEnumType: Je,
        setPropertyEnumTypeOnAttrs: ti,
        setRandGenerator: Oi,
        shift: nc,
        size: Rs,
        toDegree: Ai,
        toRadian: bi,
        tween: tdt,
        tweenUtil: edt,
        v2: Es,
        v3: Ki,
        v4: Xi,
        warn: w,
        warnID: z,
      }),
        n("CC_WECHAT", !1),
        n("CC_BAIDU", !1),
        n("CC_XIAOMI", !1),
        n("CC_ALIPAY", !1),
        n("CC_BYTEDANCE", !1),
        n("CC_OPPO", !1),
        n("CC_VIVO", !1),
        n("CC_HUAWEI", !1),
        n("CC_COCOSPLAY", !1),
        n("CC_QTT", !1),
        n("CC_LINKSURE", !1);
      n("CC_EDITOR", !1),
        n("CC_PREVIEW", !1),
        n("CC_BUILD", !0),
        n("CC_TEST", !1),
        n("CC_DEBUG", !1),
        n("CC_DEV", !1),
        n("CC_MINIGAME", !1),
        n("CC_RUNTIME_BASED", !1),
        n("CC_SUPPORT_JIT", !0),
        n("CC_JSB", !0);
      const r = "undefined" == typeof window ? global : window,
        a = t("cclegacy", { _global: r });
      a.internal = {};
      const o = t("VERSION", "3.8.4");
      (r.CocosEngine = a.ENGINE_VERSION = o), (r.cc = a);
      const h =
        void 0 !== globalThis.jsb && void 0 !== jsb.window
          ? jsb.window
          : globalThis;
      r.ccwindow = h;
      const l = 2147483647;
      function c(t) {
        return (t > 0) - (t < 0);
      }
      function u(t, e) {
        return t ^ ((t ^ e) & -(t < e));
      }
      function _(t) {
        let e, i;
        return (
          (e = (t > 65535) << 4),
          (i = ((t >>>= e) > 255) << 3),
          (e |= i),
          (i = ((t >>>= i) > 15) << 2),
          (e |= i),
          (i = ((t >>>= i) > 3) << 1),
          (e |= i),
          e | ((t >>>= i) >> 1)
        );
      }
      function d(t) {
        return (
          (16843009 *
            (((t =
              (858993459 & (t -= (t >>> 1) & 1431655765)) +
              ((t >>> 2) & 858993459)) +
              (t >>> 4)) &
              252645135)) >>>
          24
        );
      }
      function p(t) {
        let e = 32;
        return (
          (t &= -t) && e--,
          65535 & t && (e -= 16),
          16711935 & t && (e -= 8),
          252645135 & t && (e -= 4),
          858993459 & t && (e -= 2),
          1431655765 & t && (e -= 1),
          e
        );
      }
      function m(t) {
        return (
          --t,
          (t |= t >>> 1),
          (t |= t >>> 2),
          (t |= t >>> 4),
          (t |= t >>> 8),
          1 + (t |= t >>> 16)
        );
      }
      const f = new Array(256);
      ((t) => {
        for (let e = 0; e < 256; ++e) {
          let i = e,
            s = e,
            n = 7;
          for (i >>>= 1; i; i >>>= 1) (s <<= 1), (s |= 1 & i), --n;
          t[e] = (s << n) & 255;
        }
      })(f);
      var g = Object.freeze({
        __proto__: null,
        INT_BITS: 32,
        INT_MAX: l,
        INT_MIN: -2147483648,
        sign: c,
        abs: function (t) {
          const e = t >> 31;
          return (t ^ e) - e;
        },
        min: function (t, e) {
          return e ^ ((t ^ e) & -(t < e));
        },
        max: u,
        isPow2: function (t) {
          return !(t & (t - 1) || !t);
        },
        log2: _,
        log10: function (t) {
          return t >= 1e9
            ? 9
            : t >= 1e8
            ? 8
            : t >= 1e7
            ? 7
            : t >= 1e6
            ? 6
            : t >= 1e5
            ? 5
            : t >= 1e4
            ? 4
            : t >= 1e3
            ? 3
            : t >= 100
            ? 2
            : t >= 10
            ? 1
            : 0;
        },
        popCount: d,
        countTrailingZeros: p,
        nextPow2: m,
        prevPow2: function (t) {
          return (
            (t |= t >>> 1),
            (t |= t >>> 2),
            (t |= t >>> 4),
            (t |= t >>> 8),
            (t |= t >>> 16) - (t >>> 1)
          );
        },
        parity: function (t) {
          return (
            (t ^= t >>> 16),
            (t ^= t >>> 8),
            (t ^= t >>> 4),
            (27030 >>> (t &= 15)) & 1
          );
        },
        reverse: function (t) {
          return (
            (f[255 & t] << 24) |
            (f[(t >>> 8) & 255] << 16) |
            (f[(t >>> 16) & 255] << 8) |
            f[(t >>> 24) & 255]
          );
        },
        interleave2: function (t, e) {
          return (
            (t =
              1431655765 &
              ((t =
                858993459 &
                ((t =
                  252645135 &
                  ((t = 16711935 & ((t &= 65535) | (t << 8))) | (t << 4))) |
                  (t << 2))) |
                (t << 1))) |
            ((e =
              1431655765 &
              ((e =
                858993459 &
                ((e =
                  252645135 &
                  ((e = 16711935 & ((e &= 65535) | (e << 8))) | (e << 4))) |
                  (e << 2))) |
                (e << 1))) <<
              1)
          );
        },
        deinterleave2: function (t, e) {
          return (
            ((t =
              65535 &
              ((t =
                16711935 &
                ((t =
                  252645135 &
                  ((t =
                    858993459 & ((t = (t >>> e) & 1431655765) | (t >>> 1))) |
                    (t >>> 2))) |
                  (t >>> 4))) |
                (t >>> 16))) <<
              16) >>
            16
          );
        },
        interleave3: function (t, e, i) {
          return (
            (t =
              1227133513 &
              ((t =
                3272356035 &
                ((t =
                  251719695 &
                  ((t = 4278190335 & ((t &= 1023) | (t << 16))) | (t << 8))) |
                  (t << 4))) |
                (t << 2))),
            (t |=
              (e =
                1227133513 &
                ((e =
                  3272356035 &
                  ((e =
                    251719695 &
                    ((e = 4278190335 & ((e &= 1023) | (e << 16))) | (e << 8))) |
                    (e << 4))) |
                  (e << 2))) << 1) |
              ((i =
                1227133513 &
                ((i =
                  3272356035 &
                  ((i =
                    251719695 &
                    ((i = 4278190335 & ((i &= 1023) | (i << 16))) | (i << 8))) |
                    (i << 4))) |
                  (i << 2))) <<
                2)
          );
        },
        deinterleave3: function (t, e) {
          return (
            ((t =
              1023 &
              ((t =
                4278190335 &
                ((t =
                  251719695 &
                  ((t =
                    3272356035 & ((t = (t >>> e) & 1227133513) | (t >>> 2))) |
                    (t >>> 4))) |
                  (t >>> 8))) |
                (t >>> 16))) <<
              22) >>
            22
          );
        },
        nextCombination: function (t) {
          const e = t | (t - 1);
          return (e + 1) | (((~e & -~e) - 1) >>> (p(t) + 1));
        },
      });
      t("bits", g);
      const y = h.document,
        T = `https://github.com/cocos/cocos-engine/blob/${o}/EngineErrorMap.md`;
      let S = null,
        E = console.log.bind(console),
        v = E,
        b = E,
        A = (t, e, ...i) => {
          t || console.log(`ASSERT: ${O(e, ...i)}`);
        },
        C = E;
      function O(...t) {
        return a.js.formatStr.apply(null, t);
      }
      function I(...t) {
        return E(...t);
      }
      function w(...t) {
        return v(...t);
      }
      function R(...t) {
        return b(...t);
      }
      function D(t, e, ...i) {
        return A(t, e, ...i);
      }
      function x(...t) {
        return C(...t);
      }
      function M(t) {
        if (((E = v = b = A = C = () => {}), t !== W.NONE)) {
          if (t > W.ERROR) {
            const e = (t) => {
              if (a.game.canvas) {
                if (!S) {
                  const t = y.createElement("Div");
                  t.setAttribute("id", "logInfoDiv"),
                    t.setAttribute("width", "200");
                  const e = a.game.canvas.height;
                  t.setAttribute("height", `${e}`);
                  const i = t.style;
                  (i.zIndex = "99999"),
                    (i.position = "absolute"),
                    (i.top = i.left = "0"),
                    (S = y.createElement("textarea")),
                    S.setAttribute("rows", "20"),
                    S.setAttribute("cols", "30"),
                    S.setAttribute("disabled", "true");
                  const s = S.style;
                  (s.backgroundColor = "transparent"),
                    (s.borderBottom = "1px solid #cccccc"),
                    (s.borderTopWidth =
                      s.borderLeftWidth =
                      s.borderRightWidth =
                        "0px"),
                    (s.borderTopStyle =
                      s.borderLeftStyle =
                      s.borderRightStyle =
                        "none"),
                    (s.padding = "0px"),
                    (s.margin = "0px"),
                    t.appendChild(S),
                    a.game.canvas.parentNode.appendChild(t);
                }
                (S.value = `${S.value + t}\r\n`),
                  (S.scrollTop = S.scrollHeight);
              }
            };
            (b = (...t) => {
              e(`ERROR :  ${O(...t)}`);
            }),
              (A = (t, i, ...s) => {
                t || e(`ASSERT: ${O(i, ...s)}`);
              }),
              t !== W.ERROR_FOR_WEB_PAGE &&
                (v = (...t) => {
                  e(`WARN :  ${O(...t)}`);
                }),
              t === W.INFO_FOR_WEB_PAGE &&
                (E = (...t) => {
                  e(O(...t));
                });
          } else
            console &&
              (console.error || (console.error = console.log),
              console.warn || (console.warn = console.log),
              (b = console.error.bind
                ? console.error.bind(console)
                : console.error),
              (A = (t, e, ...i) => {
                if (!t) {
                  const t = O(e, ...i);
                  throw new Error(t);
                }
              }));
          if (
            (t !== W.ERROR &&
              (v = console.warn.bind
                ? console.warn.bind(console)
                : console.warn),
            t <= W.INFO && (E = console.log),
            t <= W.VERBOSE && "function" == typeof console.debug)
          ) {
            const t = console.debug.bind(console);
            C = (...e) => t(...e);
          }
        }
      }
      function P(t) {
        {
          const e = t.stack;
          return void (e
            ? (window.OnJSException instanceof Function &&
                window.OnJSException("(see stack)", t.message, t.stack),
              R(`${t}\n${e}`))
            : R(t));
        }
      }
      function N(t) {
        return (e, ...i) => {
          const s = `${t} ${e}, please go to ${T}#${e} to see details.`;
          return 0 === i.length ? s : `${s} Arguments: ${i.join(", ")}`;
        };
      }
      const L = N("Log");
      function B(t, ...e) {
        I(L(t, ...e));
      }
      const F = N("Debug");
      function U(t, ...e) {
        x(F(t, ...e));
      }
      const k = N("Warning");
      function z(t, ...e) {
        w(k(t, ...e));
      }
      const H = N("Error");
      function G(t, ...e) {
        R(H(t, ...e));
      }
      const V = N("Assert");
      function j(t, e, ...i) {
        t || D(!1, V(e, ...i));
      }
      let W;
      function X(t, ...e) {
        return H(t, ...e);
      }
      function Y() {
        return !!a.profiler && a.profiler.isShowingStats();
      }
      function K(t) {
        a.profiler && (t ? a.profiler.showStats() : a.profiler.hideStats());
      }
      t("DebugMode", W),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.VERBOSE = 1)] = "VERBOSE"),
            (t[(t.INFO = 2)] = "INFO"),
            (t[(t.WARN = 3)] = "WARN"),
            (t[(t.ERROR = 4)] = "ERROR"),
            (t[(t.INFO_FOR_WEB_PAGE = 5)] = "INFO_FOR_WEB_PAGE"),
            (t[(t.WARN_FOR_WEB_PAGE = 6)] = "WARN_FOR_WEB_PAGE"),
            (t[(t.ERROR_FOR_WEB_PAGE = 7)] = "ERROR_FOR_WEB_PAGE");
        })(W || t("DebugMode", (W = {})));
      var q = Object.freeze({
        __proto__: null,
        log: I,
        warn: w,
        error: R,
        assert: D,
        debug: x,
        _resetDebugSetting: M,
        _throw: P,
        logID: B,
        debugID: U,
        warnID: z,
        errorID: G,
        assertID: j,
        get DebugMode() {
          return W;
        },
        getError: X,
        isDisplayStats: Y,
        setDisplayStats: K,
      });
      let $,
        Z,
        Q,
        J,
        tt,
        et = 10;
      t("replaceProperty", $), t("removeProperty", Z), t("markAsWarning", Q);
      let it = 0;
      const st = new Map();
      (J = (t, e, i, s, n, r, a) => {
        const o = st.get(r);
        o &&
          o.logTimes > o.count &&
          (n(
            `'%s' is deprecated, please use '%s' instead. ${a}`,
            `${t}.${e}`,
            `${i}.${s}`
          ),
          o.count++);
      }),
        t(
          "replaceProperty",
          ($ = (t, e, i) => {
            null != t &&
              i.forEach((i) => {
                const s = it++;
                st.set(s, {
                  id: s,
                  count: 0,
                  logTimes: void 0 !== i.logTimes ? i.logTimes : et,
                });
                const n = null != i.target ? i.target : t,
                  r = null != i.newName ? i.newName : i.name,
                  a = null != i.targetName ? i.targetName : e,
                  o = n === t,
                  h = i.suggest ? `(${i.suggest})` : "";
                if (null != i.customFunction)
                  t[i.name] = function () {
                    return (
                      J(e, i.name, a, r, w, s, h),
                      i.customFunction.call(this, ...arguments)
                    );
                  };
                else if (null != i.customSetter || null != i.customGetter) {
                  const n = null != i.customSetter,
                    o = null != i.customGetter;
                  n && o
                    ? Object.defineProperty(t, i.name, {
                        get() {
                          return (
                            J(e, i.name, a, r, w, s, h),
                            i.customGetter.call(this)
                          );
                        },
                        set(t) {
                          J(e, i.name, a, r, w, s, h),
                            i.customSetter.call(this, t);
                        },
                        enumerable: !1,
                      })
                    : n
                    ? Object.defineProperty(t, i.name, {
                        set(t) {
                          J(e, i.name, a, r, w, s, h),
                            i.customSetter.call(this, t);
                        },
                        enumerable: !1,
                      })
                    : o &&
                      Object.defineProperty(t, i.name, {
                        get() {
                          return (
                            J(e, i.name, a, r, w, s, h),
                            i.customGetter.call(this)
                          );
                        },
                        enumerable: !1,
                      });
                } else
                  Object.defineProperty(t, i.name, {
                    get() {
                      return J(e, i.name, a, r, w, s, h), o ? this[r] : n[r];
                    },
                    set(t) {
                      J(e, i.name, a, r, w, s, h),
                        o ? (this[r] = t) : (n[r] = t);
                    },
                    enumerable: !1,
                  });
              });
          })
        ),
        (tt = (t, e, i, s, n) => {
          const r = st.get(s);
          r &&
            r.logTimes > r.count &&
            (i(`'%s' has been removed. ${n}`, `${t}.${e}`), r.count++);
        }),
        t(
          "removeProperty",
          (Z = (t, e, i) => {
            null != t &&
              i.forEach((i) => {
                const s = it++;
                st.set(s, {
                  id: s,
                  count: 0,
                  logTimes: void 0 !== i.logTimes ? i.logTimes : et,
                });
                const n = i.suggest ? `(${i.suggest})` : "";
                Object.defineProperty(t, i.name, {
                  get: () => tt(e, i.name, R, s, n),
                  set() {
                    tt(e, i.name, R, s, n);
                  },
                  enumerable: !1,
                });
              });
          })
        ),
        t("markAsWarning", (Q = () => {}));
      const nt = {};
      function rt(t) {
        for (let e in t) {
          const i = t[e];
          nt[e] = i;
        }
      }
      function at(t) {
        const e = nt[t];
        if (!e) return;
        const { newName: i, since: s, removed: n } = e;
        n
          ? i
            ? G(16003, t, s, i)
            : G(16002, t, s)
          : i
          ? z(16001, t, s, i)
          : z(16e3, t, s);
      }
      let ot;
      var ht;
      class lt {
        constructor(t) {
          (this.id = 0 | (998 * Math.random())),
            (this.prefix = t ? t + "." : "");
        }
        getNewId() {
          return this.prefix + (++this.id).toString();
        }
      }
      (ht = lt), (lt.global = new ht("global"));
      const ct = new lt("TmpCId."),
        ut =
          "undefined" == typeof Symbol ? "__aliases__" : Symbol("[[Aliases]]"),
        _t = "__cid__";
      function dt(t) {
        return "number" == typeof t || t instanceof Number;
      }
      function pt(t) {
        return "string" == typeof t || t instanceof String;
      }
      function mt(t) {
        for (const e in t) return !1;
        return !0;
      }
      const ft = (() => {
          const t = {
            value: void 0,
            enumerable: !1,
            writable: !1,
            configurable: !0,
          };
          return (e, i, s, n, r) => {
            (t.value = s),
              (t.writable = n),
              (t.enumerable = r),
              Object.defineProperty(e, i, t),
              (t.value = void 0);
          };
        })(),
        gt = (() => {
          const t = { get: void 0, set: void 0, enumerable: !1 };
          return (e, i, s, n, r = !1, a = !1) => {
            "boolean" == typeof n &&
              (console.log(
                "Set `setter` to boolean is deprecated. Please don not use like this again."
              ),
              (r = n),
              (n = void 0)),
              (t.get = s),
              (t.set = n),
              (t.enumerable = r),
              (t.configurable = a),
              Object.defineProperty(e, i, t),
              (t.get = void 0),
              (t.set = void 0);
          };
        })(),
        yt = (() => {
          const t = { get: void 0, enumerable: !1, configurable: !1 };
          return (e, i, s, n, r) => {
            (t.get = s),
              (t.enumerable = n),
              (t.configurable = r),
              Object.defineProperty(e, i, t),
              (t.get = void 0);
          };
        })(),
        Tt = (() => {
          const t = { set: void 0, enumerable: !1, configurable: !1 };
          return (e, i, s, n, r) => {
            (t.set = s),
              (t.enumerable = n),
              (t.configurable = r),
              Object.defineProperty(e, i, t),
              (t.set = void 0);
          };
        })();
      function St(t) {
        const e = Object.create(null);
        if (t) {
          const t = ".",
            i = "/";
          (e[t] = 1), (e[i] = 1), delete e[t], delete e[i];
        }
        return e;
      }
      function Et(t) {
        if ("function" == typeof t) {
          const e = t.prototype;
          if (e && e.hasOwnProperty("__classname__") && e.__classname__)
            return e.__classname__;
          let i = "";
          if ((t.name && (i = t.name), t.toString)) {
            let e;
            const s = t.toString();
            (e =
              "[" === s.charAt(0)
                ? /\[\w+\s*(\w+)\]/.exec(s)
                : /function\s*(\w+)/.exec(s)),
              e && 2 === e.length && (i = e[1]);
          }
          return "Object" !== i ? i : "";
        }
        return t && t.constructor ? Et(t.constructor) : "";
      }
      function vt(t, e, i, s) {
        const n = /([^.]+)$/,
          r = n.exec(e)[0],
          a = n.exec(i)[0];
        function o() {
          return this[a];
        }
        s
          ? gt(t, r, o, function (t) {
              this[a] = t;
            })
          : yt(t, r, o);
      }
      function bt(t, e, i, s) {
        for (const n in i) vt(t, `${e}.${n}`, i[n], s);
      }
      const At = /(%d)|(%s)/,
        Ct = /%s/;
      function Ot(t, ...e) {
        if (0 === arguments.length) return "";
        if (0 === e.length) return `${t}`;
        const i = "string" == typeof t && At.test(t);
        if (i)
          for (const i of e) {
            const e = "number" == typeof i ? At : Ct;
            if (e.test(t)) {
              const s = `${i}`;
              t = t.replace(e, s);
            } else t += ` ${i}`;
          }
        else for (const i of e) t += ` ${i}`;
        return t;
      }
      function It() {
        const t = arguments.length - 1,
          e = new Array(t);
        for (let i = 0; i < t; ++i) e[i] = arguments[i + 1];
        return e;
      }
      function wt(t, e) {
        for (; t; ) {
          const i = Object.getOwnPropertyDescriptor(t, e);
          if (i) return i;
          t = Object.getPrototypeOf(t);
        }
        return null;
      }
      function Rt(t, e, i) {
        const s = wt(e, t);
        s && Object.defineProperty(i, t, s);
      }
      function Dt(t, e, i) {
        const s = Object.getOwnPropertyNames(t);
        for (let n = 0, r = s.length; n < r; ++n) {
          const r = s[n];
          -1 === i.indexOf(r) && Rt(r, t, e);
        }
      }
      function xt(t, ...e) {
        t = t || {};
        for (const i of e)
          if (i) {
            if ("object" != typeof i) {
              G(5402, i);
              continue;
            }
            for (const e in i) e in t || Rt(e, i, t);
          }
        return t;
      }
      function Mt(t, ...e) {
        t = t || {};
        for (const i of e)
          if (i) {
            if ("object" != typeof i) {
              G(5403, i);
              continue;
            }
            for (const e in i) Rt(e, i, t);
          }
        return t;
      }
      function Pt(t, e) {
        for (const i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
        return (
          (t.prototype = Object.create(e.prototype, {
            constructor: { value: t, writable: !0, configurable: !0 },
          })),
          t
        );
      }
      function Nt(t) {
        const e = t.prototype,
          i = e && Object.getPrototypeOf(e);
        return i && i.constructor;
      }
      function Lt(t, e) {
        if (t && e) {
          if ("function" != typeof t) return !1;
          if ("function" != typeof e) return !1;
          if (t === e) return !0;
          for (;;) {
            if (!(t = Nt(t))) return !1;
            if (t === e) return !0;
          }
        }
        return !1;
      }
      function Bt(t) {
        for (const e of Object.keys(t)) delete t[e];
      }
      const Ft = St(!0),
        Ut = St(!0);
      function kt(t, e, i) {
        return function (s, n) {
          if (
            (n.prototype.hasOwnProperty(t) && delete e[n.prototype[t]],
            ft(n.prototype, t, s),
            s)
          ) {
            const r = e[s];
            !i && r && r !== n ? G(16334, t, s, "") : (e[s] = n);
          }
        };
      }
      const zt = kt("__cid__", Ft, !1),
        Ht = kt("__classname__", Ut, !0);
      function Gt(t, e) {
        if ((Ht(t, e), !e.prototype.hasOwnProperty(_t))) {
          const i = t || ct.getNewId();
          i && zt(i, e);
        }
      }
      function Vt(t, e) {
        const i = Ut[e],
          s = Ft[e];
        let n = !0;
        if (
          (i && i !== t && (G(16335, e), (n = !1)),
          s && s !== t && (G(16336, e), (n = !1)),
          n)
        ) {
          let i = t[ut];
          i || ((i = []), (t[ut] = i)), i.push(e), (Ut[e] = t), (Ft[e] = t);
        }
      }
      function jt(...t) {
        for (const e of t) {
          const t = e.prototype,
            i = t.__cid__;
          i && delete Ft[i];
          const s = t.__classname__;
          s && delete Ut[s];
          const n = t[ut];
          if (n)
            for (let t = 0; t < n.length; ++t) {
              const e = n[t];
              delete Ut[e], delete Ft[e];
            }
        }
      }
      function Wt(t) {
        return Xt(t);
      }
      function Xt(t) {
        return Ft[t];
      }
      function Yt(t) {
        return Ut[t];
      }
      function Kt(t, e) {
        return qt(t, e);
      }
      function qt(t, e) {
        let i;
        if (
          ((e = void 0 === e || e),
          "function" == typeof t && t.prototype.hasOwnProperty(_t))
        )
          return (i = t.prototype.__cid__), i;
        if (t && t.constructor) {
          const e = t.constructor.prototype;
          if (e && e.hasOwnProperty(_t)) return (i = t.__cid__), i;
        }
        return "";
      }
      class $t {
        get() {
          return this._get();
        }
        constructor(t, e) {
          this.count = 0;
          const i = void 0 === e ? t : e,
            s = void 0 === e ? null : t;
          (this._pool = new Array(i)), (this._cleanup = s);
        }
        _get() {
          if (this.count > 0) {
            --this.count;
            const t = this._pool[this.count];
            return (this._pool[this.count] = null), t;
          }
          return null;
        }
        put(t) {
          const e = this._pool;
          if (this.count < e.length) {
            if (this._cleanup && !1 === this._cleanup(t)) return;
            (e[this.count] = t), ++this.count;
          }
        }
        resize(t) {
          t >= 0 &&
            ((this._pool.length = t), this.count > t && (this.count = t));
        }
      }
      class Zt {
        constructor(t) {
          (this.i = 0), (this.array = t);
        }
        get length() {
          return this.array.length;
        }
        set length(t) {
          (this.array.length = t), this.i >= t && (this.i = t - 1);
        }
        remove(t) {
          const e = this.array.indexOf(t);
          e >= 0 && this.removeAt(e);
        }
        removeAt(t) {
          this.array.splice(t, 1), t <= this.i && --this.i;
        }
        fastRemove(t) {
          const e = this.array.indexOf(t);
          e >= 0 && this.fastRemoveAt(e);
        }
        fastRemoveAt(t) {
          const e = this.array;
          (e[t] = e[e.length - 1]), --e.length, t <= this.i && --this.i;
        }
        push(t) {
          this.array.push(t);
        }
      }
      function Qt(t, e) {
        t.splice(e, 1);
      }
      function Jt(t, e) {
        const i = t.length;
        e < 0 || e >= i || ((t[e] = t[i - 1]), (t.length = i - 1));
      }
      function te(t, e) {
        const i = t.indexOf(e);
        return i >= 0 && (Qt(t, i), !0);
      }
      function ee(t, e) {
        const i = t.indexOf(e);
        i >= 0 && ((t[i] = t[t.length - 1]), --t.length);
      }
      function ie(t, e) {
        const i = t.findIndex(e);
        if (i >= 0) {
          const e = t[i];
          return Qt(t, i), e;
        }
      }
      function se(t, e) {
        return t.indexOf(e) >= 0;
      }
      var ne = Object.freeze({
        __proto__: null,
        MutableForwardIterator: Zt,
        removeAt: Qt,
        fastRemoveAt: Jt,
        remove: te,
        fastRemove: ee,
        removeIf: ie,
        verifyType: function (t, e) {
          if (t && t.length > 0)
            for (const i of t) if (!(i instanceof e)) return B(1300), !1;
          return !0;
        },
        removeArray: function (t, e) {
          for (let i = 0, s = e.length; i < s; i++) te(t, e[i]);
        },
        appendObjectsAt: function (t, e, i) {
          return t.splice.apply(t, [i, 0, ...e]), t;
        },
        contains: se,
        copy: function (t) {
          const e = t.length,
            i = new Array(e);
          for (let s = 0; s < e; s += 1) i[s] = t[s];
          return i;
        },
      });
      const re = {
        IDGenerator: lt,
        Pool: $t,
        array: ne,
        isNumber: dt,
        isString: pt,
        isEmptyObject: mt,
        getPropertyDescriptor: wt,
        addon: xt,
        mixin: Mt,
        extend: Pt,
        getSuper: Nt,
        isChildClassOf: Lt,
        clear: Bt,
        value: ft,
        getset: gt,
        get: yt,
        set: Tt,
        unregisterClass: jt,
        getClassName: Et,
        setClassName: Gt,
        setClassAlias: Vt,
        getClassByName: Yt,
        getClassById: Xt,
        get _registeredClassNames() {
          return { ...Ut };
        },
        set _registeredClassNames(t) {
          Bt(Ut), Object.assign(Ut, t);
        },
        get _registeredClassIds() {
          return { ...Ft };
        },
        set _registeredClassIds(t) {
          Bt(Ft), Object.assign(Ft, t);
        },
        _getClassId: Kt,
        getClassId: qt,
        _setClassId: zt,
        _getClassById: Wt,
        obsolete: vt,
        obsoletes: bt,
        formatStr: Ot,
        shiftArguments: It,
        createMap: St,
      };
      a.js = re;
      var ae = Object.freeze({
        __proto__: null,
        array: ne,
        js: re,
        IDGenerator: lt,
        Pool: $t,
        isNumber: dt,
        isString: pt,
        isEmptyObject: mt,
        value: ft,
        getset: gt,
        get: yt,
        set: Tt,
        createMap: St,
        getClassName: Et,
        obsolete: vt,
        obsoletes: bt,
        formatStr: Ot,
        shiftArguments: It,
        getPropertyDescriptor: wt,
        copyAllProperties: Dt,
        addon: xt,
        mixin: Mt,
        extend: Pt,
        getSuper: Nt,
        isChildClassOf: Lt,
        clear: Bt,
        _idToClass: Ft,
        _nameToClass: Ut,
        _setClassId: zt,
        setClassName: Gt,
        setClassAlias: Vt,
        unregisterClass: jt,
        _getClassById: Wt,
        getClassById: Xt,
        getClassByName: Yt,
        _getClassId: Kt,
        getClassId: qt,
      });
      function oe(t) {
        if ("__bitmask__" in t) return t;
        ft(t, "__bitmask__", null, !0);
        let e = -1;
        const i = Object.keys(t);
        for (let s = 0; s < i.length; s++) {
          const n = i[s];
          let r = t[n];
          if (-1 === r) (r = ++e), (t[n] = r);
          else if ("number" == typeof r) e = r;
          else if ("string" == typeof r && Number.isInteger(parseFloat(n)))
            continue;
          const a = `${r}`;
          n !== a && ft(t, a, n);
        }
        return t;
      }
      function he(t, e) {
        e >= 0 && t.length, t.length;
      }
      t("js", ae),
        (oe.isBitMask = (t) =>
          t && Object.prototype.hasOwnProperty.call(t, "__bitmask__")),
        (oe.getList = (t) => (t.__bitmask__ ? t.__bitmask__ : oe.update(t))),
        (oe.update = (t) => {
          Array.isArray(t.__bitmask__) || (t.__bitmask__ = []);
          const e = t.__bitmask__;
          e.length = 0;
          for (const i in t) {
            const s = t[i];
            Number.isInteger(s) && e.push({ name: i, value: s });
          }
          return e.sort((t, e) => t.value - e.value), e;
        }),
        (a.BitMask = oe);
      const le = Object.prototype.hasOwnProperty;
      function ce(t) {
        return "__enums__" in t
          ? t
          : (ft(t, "__enums__", null, !0), ce.update(t));
      }
      function ue(t) {
        le.call(t, "__enums__");
      }
      function _e(t) {
        ue(t);
        const e = t.__enums__ || [];
        e.length = 0;
        let i = !0;
        for (const s in t) {
          const n = t[s],
            r = Number.isInteger(n);
          r || (i = !1),
            (r || ("string" == typeof n && t[n] !== Number.parseInt(s))) &&
              e.push({ name: s, value: n });
        }
        return i && e.sort((t, e) => t.value - e.value), (t.__enums__ = e), e;
      }
      function de(t) {
        "__enums__" in t || ft(t, "__enums__", null, !0);
      }
      (ce.update = (t) => {
        let e = -1;
        const i = Object.keys(t);
        for (let s = 0; s < i.length; s++) {
          const n = i[s];
          let r = t[n];
          if (-1 === r) (r = ++e), (t[n] = r);
          else if ("number" == typeof r) e = r;
          else if ("string" == typeof r && Number.isInteger(parseFloat(n)))
            continue;
          const a = `${r}`;
          n !== a && ft(t, a, n);
        }
        return Array.isArray(t.__enums__) && _e(t), t;
      }),
        ce || t("Enum", (ce = {})),
        (ce.isEnum = (t) => t && le.call(t, "__enums__")),
        (ce.getList = (t) => (ue(t), t.__enums__ ? t.__enums__ : _e(t))),
        (ce.sortList = (t, e) => {
          ue(t), Array.isArray(t.__enums__) && t.__enums__.sort(e);
        }),
        (a.Enum = ce);
      class pe {
        clone() {
          return G(100, `${Et(this)}.clone`), this;
        }
        equals(t) {
          return !1;
        }
        set(t) {
          G(100, `${Et(this)}.set`);
        }
        toString() {
          return "";
        }
      }
      var me;
      t("ValueType", pe),
        Gt("cc.ValueType", pe),
        (a.ValueType = pe),
        (function (t) {
          (t.PATH = "path"),
            (t.ENGINE = "engine"),
            (t.ASSETS = "assets"),
            (t.SCRIPTING = "scripting"),
            (t.PHYSICS = "physics"),
            (t.RENDERING = "rendering"),
            (t.LAUNCH = "launch"),
            (t.SCREEN = "screen"),
            (t.SPLASH_SCREEN = "splashScreen"),
            (t.ANIMATION = "animation"),
            (t.PROFILING = "profiling"),
            (t.PLUGINS = "plugins"),
            (t.XR = "xr");
        })(me || (me = {}));
      class fe {
        constructor() {
          (this._settings = {}), (this._override = {});
        }
        init(t = "", i = {}) {
          for (const t in i) {
            const e = i[t];
            if (e) for (const i in e) this.overrideSettings(t, i, e[i]);
          }
          return t
            ? window.oh && "napi" === window.scriptEngineType
              ? new Promise((t, i) => {
                  e.import("../settings.js")
                    .then((e) => {
                      (this._settings = e.default), t();
                    })
                    .catch((t) => i(t));
                })
              : new Promise((e, i) => {
                  if (t.startsWith("http")) {
                    const s = new XMLHttpRequest();
                    s.open("GET", t),
                      (s.responseType = "text"),
                      (s.onload = () => {
                        (this._settings = JSON.parse(s.response)), e();
                      }),
                      (s.onerror = () => {
                        i(new Error("request settings failed!"));
                      }),
                      s.send(null);
                  } else {
                    const s = fsUtils.readJsonSync(t);
                    s instanceof Error ? i(s) : ((this._settings = s), e());
                  }
                })
            : Promise.resolve();
        }
        overrideSettings(t, e, i) {
          t in this._override || (this._override[t] = {}),
            (this._override[t][e] = i);
        }
        querySettings(t, e) {
          if (t in this._override) {
            const i = this._override[t];
            if (i && e in i) return i[e];
          }
          if (t in this._settings) {
            const i = this._settings[t];
            if (i && e in i) return i[e];
          }
          return null;
        }
      }
      t("Settings", fe), (fe.Category = me);
      const ge = t("settings", new fe());
      let ye;
      (a.settings = ge),
        (function (t) {
          (t[(t.PORTRAIT = 1)] = "PORTRAIT"),
            (t[(t.PORTRAIT_UPSIDE_DOWN = 2)] = "PORTRAIT_UPSIDE_DOWN"),
            (t[(t.LANDSCAPE_LEFT = 4)] = "LANDSCAPE_LEFT"),
            (t[(t.LANDSCAPE_RIGHT = 8)] = "LANDSCAPE_RIGHT"),
            (t[(t.LANDSCAPE = 12)] = "LANDSCAPE"),
            (t[(t.AUTO = 13)] = "AUTO");
        })(ye || (ye = {}));
      const Te = t("macro", {
        SUPPORT_TEXTURE_FORMATS: [
          ".dds",
          ".astc",
          ".pkm",
          ".pvr",
          ".webp",
          ".jpg",
          ".jpeg",
          ".bmp",
          ".png",
        ],
        KEY: {
          none: 0,
          back: 6,
          menu: 18,
          backspace: 8,
          tab: 9,
          enter: 13,
          shift: 16,
          ctrl: 17,
          alt: 18,
          pause: 19,
          capslock: 20,
          escape: 27,
          space: 32,
          pageup: 33,
          pagedown: 34,
          end: 35,
          home: 36,
          left: 37,
          up: 38,
          right: 39,
          down: 40,
          select: 41,
          insert: 45,
          Delete: 46,
          0: 48,
          1: 49,
          2: 50,
          3: 51,
          4: 52,
          5: 53,
          6: 54,
          7: 55,
          8: 56,
          9: 57,
          a: 65,
          b: 66,
          c: 67,
          d: 68,
          e: 69,
          f: 70,
          g: 71,
          h: 72,
          i: 73,
          j: 74,
          k: 75,
          l: 76,
          m: 77,
          n: 78,
          o: 79,
          p: 80,
          q: 81,
          r: 82,
          s: 83,
          t: 84,
          u: 85,
          v: 86,
          w: 87,
          x: 88,
          y: 89,
          z: 90,
          num0: 96,
          num1: 97,
          num2: 98,
          num3: 99,
          num4: 100,
          num5: 101,
          num6: 102,
          num7: 103,
          num8: 104,
          num9: 105,
          "*": 106,
          "+": 107,
          "-": 109,
          numdel: 110,
          "/": 111,
          f1: 112,
          f2: 113,
          f3: 114,
          f4: 115,
          f5: 116,
          f6: 117,
          f7: 118,
          f8: 119,
          f9: 120,
          f10: 121,
          f11: 122,
          f12: 123,
          numlock: 144,
          scrolllock: 145,
          ";": 186,
          semicolon: 186,
          equal: 187,
          "=": 187,
          ",": 188,
          comma: 188,
          dash: 189,
          ".": 190,
          period: 190,
          forwardslash: 191,
          grave: 192,
          "[": 219,
          openbracket: 219,
          backslash: 220,
          "]": 221,
          closebracket: 221,
          quote: 222,
          dpadLeft: 1e3,
          dpadRight: 1001,
          dpadUp: 1003,
          dpadDown: 1004,
          dpadCenter: 1005,
        },
        RAD: Math.PI / 180,
        DEG: 180 / Math.PI,
        REPEAT_FOREVER: Number.MAX_VALUE - 1,
        FLT_EPSILON: 1.192092896e-7,
        ORIENTATION_PORTRAIT: ye.PORTRAIT,
        ORIENTATION_PORTRAIT_UPSIDE_DOWN: ye.PORTRAIT_UPSIDE_DOWN,
        ORIENTATION_LANDSCAPE: ye.LANDSCAPE,
        ORIENTATION_LANDSCAPE_LEFT: ye.LANDSCAPE_LEFT,
        ORIENTATION_LANDSCAPE_RIGHT: ye.LANDSCAPE_RIGHT,
        ORIENTATION_AUTO: ye.AUTO,
        ENABLE_TILEDMAP_CULLING: !0,
        TOUCH_TIMEOUT: 5e3,
        ENABLE_TRANSPARENT_CANVAS: !1,
        ENABLE_WEBGL_ANTIALIAS: !0,
        ENABLE_FLOAT_OUTPUT: !1,
        CLEANUP_IMAGE_CACHE: !1,
        ENABLE_MULTI_TOUCH: !0,
        MAX_LABEL_CANVAS_POOL_SIZE: 20,
        ENABLE_WEBGL_HIGHP_STRUCT_VALUES: !1,
        BATCHER2D_MEM_INCREMENT: 288,
        CUSTOM_PIPELINE_NAME: "Builtin",
        init() {
          this.CLEANUP_IMAGE_CACHE = !0;
          const t = ge.querySettings(fe.Category.ENGINE, "macros");
          if (t) for (const e in t) Te[e] = t[e];
        },
      });
      a.macro = Te;
      const Se = /^(?:cc|dragonBones|sp|ccsg)\..+/,
        Ee = new Array(123);
      for (let t = 0; t < 123; ++t) Ee[t] = 64;
      for (let t = 0; t < 64; ++t)
        Ee[
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charCodeAt(
            t
          )
        ] = t;
      const ve = Ee;
      function be(t, e, i) {
        function s(t, e, i, s) {
          const n = Object.getOwnPropertyDescriptor(t, e);
          if (n) n.get && i && (t[i] = n.get), n.set && s && (t[s] = n.set);
          else {
            const n = t[i];
            gt(t, e, n, t[s]);
          }
        }
        let n;
        const r = t.prototype;
        for (let t = 0, i = e.length; t < i; ++t) {
          n = e[t];
          const i = n[0].toUpperCase() + n.slice(1);
          s(r, n, `get${i}`, `set${i}`);
        }
        for (n in i) {
          const t = i[n];
          s(r, n, t[0], t[1]);
        }
      }
      function Ae(t, e, i, s) {
        const n = t[e];
        n
          ? Array.isArray(n)
            ? s
              ? (n.push(n[0]), (n[0] = i))
              : n.push(i)
            : (t[e] = s ? [i, n] : [n, i])
          : (t[e] = i);
      }
      function Ce(t, e) {
        if ("function" == typeof t.contains) return t.contains(e);
        if ("function" == typeof t.compareDocumentPosition)
          return !!(16 & t.compareDocumentPosition(e));
        {
          let i = e.parentNode;
          if (i)
            do {
              if (i === t) return !0;
              i = i.parentNode;
            } while (null !== i);
          return !1;
        }
      }
      function Oe(t) {
        return "object" == typeof window && "function" == typeof Node
          ? t instanceof Node
          : !!t &&
              "object" == typeof t &&
              "number" == typeof t.nodeType &&
              "string" == typeof t.nodeName;
      }
      function Ie(t, ...e) {
        t &&
          (function (t, e, ...i) {
            var s;
            const n = performance.now(),
              r =
                requestAnimationFrame ||
                window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame;
            if (
              void 0 === r ||
              (null !== (s = globalThis.__globalXR) &&
                void 0 !== s &&
                s.isWebXR)
            )
              return setTimeout(t, e, ...i);
            const a = () => {
              performance.now() - n < e ? r(a) : t(...i);
            };
            r(a);
          })(() => {
            t(...e);
          }, 0);
      }
      function we(t) {
        return !(!t || t.constructor !== Object) && mt(t);
      }
      function Re(t, e, i) {
        if (e > i) {
          const t = e;
          (e = i), (i = t);
        }
        return t < e ? e : t < i ? t : i;
      }
      function De(t) {
        return t * Te.RAD;
      }
      function xe(t) {
        return t * Te.DEG;
      }
      (a.misc = {
        BUILTIN_CLASSID_RE: Se,
        BASE64_VALUES: ve,
        propertyDefine: be,
        pushToMap: Ae,
        contains: Ce,
        isDomNode: Oe,
        callInNextTick: Ie,
        isPlainEmptyObj_DEV: we,
        clampf: Re,
        degreesToRadians: De,
        radiansToDegrees: xe,
      }),
        t(
          "misc",
          Object.freeze({
            __proto__: null,
            BUILTIN_CLASSID_RE: Se,
            BASE64_VALUES: ve,
            propertyDefine: be,
            pushToMap: Ae,
            contains: Ce,
            isDomNode: Oe,
            callInNextTick: Ie,
            tryCatchFunctor_EDITOR: function (t) {
              return Function(
                "target",
                `try {\n  target.${t}();\n}\ncatch (e) {\n  cc._throw(e);\n}`
              );
            },
            isPlainEmptyObj_DEV: we,
            clampf: Re,
            degreesToRadians: De,
            radiansToDegrees: xe,
          })
        );
      const Me = "$_$";
      function Pe(t, e) {
        const i = e ? Object.create(e) : {};
        return ft(t, "__attrs__", i), i;
      }
      function Ne(t) {
        if ("function" != typeof t) return Pe(t, Be(t.constructor));
        let e;
        const i = a.Class.getInheritanceChain(t);
        for (let t = i.length - 1; t >= 0; t--) {
          const s = i[t];
          (s.hasOwnProperty("__attrs__") && s.__attrs__) ||
            ((e = i[t + 1]), Pe(s, e && e.__attrs__));
        }
        return (e = i[0]), Pe(t, e && e.__attrs__), t.__attrs__;
      }
      function Le(t, e) {
        const i = Be(t),
          s = e + Me,
          n = {};
        for (const t in i) t.startsWith(s) && (n[t.slice(s.length)] = i[t]);
        return n;
      }
      function Be(t) {
        return (t.hasOwnProperty("__attrs__") && t.__attrs__) || Ne(t);
      }
      function Fe(t, e, i, s) {
        Be(t)[e + Me + i] = s;
      }
      class Ue {
        constructor(t, e) {
          (this.name = t), (this.default = e);
        }
        toString() {
          return this.name;
        }
      }
      const ke = t("CCInteger", new Ue("Integer", 0));
      (a.Integer = ke), (a.CCInteger = ke);
      const ze = t("CCFloat", new Ue("Float", 0));
      (a.Float = ze), (a.CCFloat = ze);
      const He = t("CCBoolean", new Ue("Boolean", !1));
      (a.Boolean = He), (a.CCBoolean = He);
      const Ge = t("CCString", new Ue("String", ""));
      function Ve(t, e) {
        return function (i, s) {
          const n = `"${Et(i)}.${s}"`,
            r = Le(i, s);
          let a = r.type;
          if (
            (a === ke || a === ze
              ? (a = "Number")
              : (a !== Ge && a !== He) || (a = `${a}`),
            a !== t)
          )
            return void z(3604, n);
          if (!r.hasOwnProperty("default")) return;
          const o = r.default;
          if (void 0 === o) return;
          if (Array.isArray(o) || we(o)) return;
          const h = typeof o,
            l = t.toLowerCase();
          if (h === l)
            if ("object" === l) {
              if (!o || o instanceof r.ctor) return;
              z(3605, n, Et(r.ctor));
            } else "Number" !== t && z(3606, e, n, t);
          else {
            if ("function" === h) return;
            t === Ge.default && null == o ? z(3607, n) : z(3611, e, n, h);
          }
          delete r.type;
        };
      }
      (a.String = Ge), (a.CCString = Ge);
      var je = Object.freeze({
        __proto__: null,
        DELIMETER: Me,
        createAttrsSingle: Pe,
        createAttrs: Ne,
        attr: Le,
        getClassAttrs: Be,
        setClassAttr: Fe,
        PrimitiveType: Ue,
        CCInteger: ke,
        CCFloat: ze,
        CCBoolean: He,
        CCString: Ge,
        getTypeChecker_ET: Ve,
        getObjTypeChecker_ET: function (t) {
          return function (e, i) {
            Ve("Object", "type")(e, i);
            const s = Be(e)[`${i + Me}default`],
              n = a.Class.getDefault(s);
            if (!Array.isArray(n) && Lt(t, a.ValueType)) {
              const n = Et(t),
                r = Ot(
                  'No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.',
                  Et(e),
                  i,
                  n
                );
              s ? I(r) : z(3612, r, n, Et(e), i, n);
            }
          };
        },
      });
      const We = {
        default: {},
        serializable: {},
        editorOnly: {},
        formerlySerializedAs: {},
      };
      function Xe(t, e, i, s) {
        if (!t.get && !t.set && t.hasOwnProperty("default")) {
          const n = `_N$${e}`;
          (t.get = function () {
            return this[n];
          }),
            (t.set = function (t) {
              const e = this[n];
              (this[n] = t), i.call(this, e);
            });
          const r = {};
          s[n] = r;
          for (const e in We) {
            const i = We[e];
            t.hasOwnProperty(e) &&
              ((r[e] = t[e]), i.canUsedInGet || delete t[e]);
          }
        }
      }
      function Ye(t, e, i, s) {
        if (Array.isArray(e)) {
          if (!(e.length > 0)) return G(5508, i, s);
          t.type = e = e[0];
        }
        "function" == typeof e &&
          (e === String
            ? (t.type = a.String)
            : e === Boolean
            ? (t.type = a.Boolean)
            : e === Number && (t.type = a.Float));
      }
      function Ke(t, e, i) {
        const s =
          t || void 0 === e ? { _short: !0 } : { _short: !0, default: e };
        return i && (s.type = i), s;
      }
      function qe(t, e) {
        if (!t || t.constructor !== Object) {
          if (Array.isArray(t) && t.length > 0) return Ke(e, [], t);
          if ("function" == typeof t) {
            const i = t;
            return Ke(e, Lt(i, a.ValueType) ? new i() : null, i);
          }
          return t instanceof Ue ? Ke(e, void 0, t) : Ke(e, t);
        }
        return null;
      }
      let $e,
        Ze = [];
      function Qe() {
        return Ze[Ze.length - 1];
      }
      function Je(t, e, i) {
        ti(Be(t), e, i);
      }
      function ti(t, e, i) {
        (t[`${e}$_$type`] = "Enum"), (t[`${e}$_$enumList`] = ce.getList(i));
      }
      (a._RF = {
        push: function (t, e, i, s) {
          void 0 === i && ((i = e), (e = "")),
            Ze.push({
              uuid: e,
              script: i,
              module: t,
              exports: t.exports,
              beh: null,
              importMeta: s,
            });
        },
        pop: function () {
          const t = Ze.pop(),
            e = t.module;
          let i = e.exports;
          if (i === t.exports) {
            for (const t in i) return;
            e.exports = i = t.cls;
          }
        },
        peek: Qe,
      }),
        (function (t) {
          (t[(t.STANDALONE = 1)] = "STANDALONE"),
            (t[(t.IMPLICIT_VISIBLE = 2)] = "IMPLICIT_VISIBLE"),
            (t[(t.IMPLICIT_SERIALIZABLE = 4)] = "IMPLICIT_SERIALIZABLE");
        })($e || ($e = {}));
      const ei = Me,
        ii = "__ctors__",
        si = t("ENUM_TAG", "Enum"),
        ni = t("BITMASK_TAG", "BitMask");
      function ri(t, e, i, s) {
        !(function (t, e) {
          !(function (t, e) {
            t.indexOf(e) < 0 && t.push(e);
          })(t.__props__, e);
        })(t, i),
          ui(t, s, e, i);
      }
      function ai(t, e, i, s) {
        const n = s.get;
        s.set, n && (ui(t, s, e, i), Fe(t, i, "serializable", !1));
      }
      function oi(t) {
        return "function" == typeof t ? t() : t;
      }
      function hi(t) {
        let e = t.name;
        const i = t.extends,
          s = (function (t, e, i) {
            const s = a.Component,
              n = Qe();
            if (n && Lt(e, s)) {
              if (Lt(n.cls, s)) return G(3615), null;
              t = t || n.script;
            }
            const r = (function (t, e, i) {
              const s = i.ctor;
              return (
                ft(s, ii, !0, !0), s.prototype, e && (s.$super = e), Gt(t, s), s
              );
            })(t, e, i);
            if (n)
              if (Lt(e, s)) {
                const t = n.uuid;
                t && zt(t, r), (n.cls = r);
              } else Lt(n.cls, s) || (n.cls = r);
            return r;
          })(e, i, t);
        e || (e = a.js.getClassName(s)),
          (s._sealed = !0),
          i && (i._sealed = !1),
          (function (t, e, i, s) {
            if (
              ((t.__props__ = []),
              s && s.__props__ && (t.__props__ = s.__props__.slice()),
              i)
            ) {
              !(function (t, e) {
                for (const i in t) {
                  let s = t[i];
                  const n = qe(s, !1);
                  if ((n && (s = t[i] = n), s)) {
                    const n = s.notify;
                    n && Xe(s, i, n, t), "type" in s && Ye(s, s.type, e, i);
                  }
                }
              })(i, e);
              for (const s in i) {
                const n = i[s];
                n.get || n.set ? ai(t, e, s, n) : ri(t, e, s, n);
              }
            }
            const n = Be(t);
            t.__values__ = t.__props__.filter(
              (t) => !1 !== n[`${t}$_$serializable`]
            );
          })(s, e, t.properties, i);
        const n = t.editor;
        return (
          n && Lt(i, a.Component) && a.Component._registerEditorProps(s, n), s
        );
      }
      function li(t) {
        var e;
        return null == t || null === (e = t.hasOwnProperty) || void 0 === e
          ? void 0
          : e.call(t, "__values__");
      }
      (hi._isCCClass = function (t) {
        var e;
        return null == t || null === (e = t.hasOwnProperty) || void 0 === e
          ? void 0
          : e.call(t, ii);
      }),
        (hi.fastDefine = function (t, e, i) {
          Gt(t, e);
          const s = (e.__props__ = e.__values__ = Object.keys(i)),
            n = Be(e);
          for (let t = 0; t < s.length; t++) {
            const e = s[t];
            (n[`${e + ei}visible`] = !1), (n[`${e + ei}default`] = i[e]);
          }
        }),
        (hi.Attr = je),
        (hi.attr = Le),
        (hi.isCCClassOrFastDefined = li),
        (hi.getInheritanceChain = function (t) {
          const e = [];
          for (; (t = Nt(t)); ) t !== Object && e.push(t);
          return e;
        });
      const ci = {
        Integer: "Number",
        Float: "Number",
        Boolean: "Boolean",
        String: "String",
      };
      function ui(t, e, i, s) {
        let n = null,
          r = "";
        function a() {
          return (r = s + ei), (n = Be(t));
        }
        "type" in e && void 0 === e.type && z(3660, s, i);
        const o = e.type;
        o &&
          (ci[o]
            ? ((n || a())[`${r}type`] = o)
            : "Object" === o ||
              ("object" == typeof o
                ? ce.isEnum(o)
                  ? ti(n || a(), s, o)
                  : oe.isBitMask(o) &&
                    (((n || a())[`${r}type`] = ni),
                    (n[`${r}bitmaskList`] = oe.getList(o)))
                : "function" == typeof o &&
                  (((n || a())[`${r}type`] = "Object"), (n[`${r}ctor`] = o)))),
          "default" in e && ((n || a())[`${r}default`] = e.default);
        const h = (t, i) => {
          if (t in e) {
            const s = e[t];
            typeof s === i && ((n || a())[r + t] = s);
          }
        };
        let l;
        e.editorOnly && ((n || a())[`${r}editorOnly`] = !0),
          e.__internalFlags & $e.STANDALONE
            ? (l =
                !0 === e.serializable ||
                0 != (e.__internalFlags & $e.IMPLICIT_SERIALIZABLE))
            : !1 === e.serializable && (l = !1),
          void 0 !== l && ((n || a())[`${r}serializable`] = l),
          h("formerlySerializedAs", "string");
        const c = e.range;
        c &&
          Array.isArray(c) &&
          c.length >= 2 &&
          (((n || a())[`${r}min`] = c[0]),
          (n[`${r}max`] = c[1]),
          c.length > 2 && (n[`${r}step`] = c[2])),
          h("step", "number"),
          h("userData", "object");
      }
      (hi.isArray = function (t) {
        return (t = oi(t)), Array.isArray(t);
      }),
        (hi.getDefault = oi),
        (hi.escapeForJS = function (t) {
          return JSON.stringify(t)
            .replace(/\u2028/g, "\\u2028")
            .replace(/\u2029/g, "\\u2029");
        }),
        (hi.IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/),
        (hi.getNewValueTypeCode = function (t) {
          const e = Et(t),
            i = t.constructor;
          let s = `new ${e}(`;
          for (let e = 0; e < i.__props__.length; e++)
            (s += t[i.__props__[e]]), e < i.__props__.length - 1 && (s += ",");
          return `${s})`;
        }),
        (a.Class = hi);
      const _i = Math.PI / 180,
        di = 180 / Math.PI;
      let pi = Math.random;
      const mi = t("HALF_PI", 0.5 * Math.PI),
        fi = t("TWO_PI", 2 * Math.PI),
        gi = t("EPSILON", 1e-6);
      function yi(t, e) {
        return Math.abs(t - e) <= gi * Math.max(1, Math.abs(t), Math.abs(e));
      }
      function Ti(t, e, i) {
        return (i = i || gi), Math.abs(t - e) <= i;
      }
      function Si(t, e, i) {
        if (e > i) {
          const t = e;
          (e = i), (i = t);
        }
        return t < e ? e : t > i ? i : t;
      }
      function Ei(t) {
        return t < 0 ? 0 : t > 1 ? 1 : t;
      }
      function vi(t, e, i) {
        return t + (e - t) * i;
      }
      function bi(t) {
        return t * _i;
      }
      function Ai(t) {
        return t * di;
      }
      function Ci() {
        return pi();
      }
      function Oi(t) {
        pi = t;
      }
      function Ii(t, e) {
        return Ci() * (e - t) + t;
      }
      function wi(t, e) {
        return Math.floor(Ii(t, e));
      }
      function Ri(t) {
        return (t = (9301 * t + 49297) % 233280) / 233280;
      }
      function Di(t, e, i) {
        return Ri(t) * (i - e) + e;
      }
      function xi(t, e, i) {
        return Math.floor(Di(t, e, i));
      }
      function Mi(t) {
        return m(t);
      }
      function Pi(t, e) {
        return t - Math.floor(t / e) * e;
      }
      function Ni(t, e) {
        return (t = Pi(t, 2 * e)), e - Math.abs(t - e);
      }
      function Li(t, e, i) {
        return (i - t) / (e - t);
      }
      function Bi(t) {
        return Math.abs(t.x) > Math.abs(t.y)
          ? Math.abs(t.x) > Math.abs(t.z)
            ? t.x
            : t.z
          : Math.abs(t.y) > Math.abs(t.z)
          ? t.y
          : t.z;
      }
      function Fi(t, e) {
        return Math.abs(t) > Math.abs(e) ? t : e;
      }
      function Ui(t, e) {
        e.forEach((e) => {
          Object.defineProperty(t, e, { enumerable: !0 });
        });
      }
      const ki = (function () {
          const t = new Float32Array(1),
            e = new Int32Array(t.buffer);
          return function (i) {
            t[0] = i;
            const s = e[0],
              n = (s >> 16) & 32768,
              r = 2147483647 & s;
            let a = (r - (112 << 23) + 4096) >> 13;
            return (
              (a = r < 113 << 23 ? 0 : a),
              (a = r >= 143 << 23 ? 31744 : a),
              (a = r > 255 << 23 ? 32256 : a),
              (e[0] = n | a),
              e[0]
            );
          };
        })(),
        zi = (function () {
          const t = new Float32Array(1),
            e = new Int32Array(t.buffer);
          return function (i) {
            const s = 32767 & i;
            let n = s << 13,
              r = 0;
            return (
              31744 !== n
                ? ((n += 112 << 23),
                  0 === s
                    ? (n = (1048575 & n) >> 1)
                    : 32767 === s && (n = 2147483647))
                : (n = 2139095040),
              (r = (((i >> 15) & 1) << 31) | n),
              (e[0] = r),
              t[0]
            );
          };
        })();
      function Hi(t) {
        return ki(t);
      }
      function Gi(t) {
        return zi(t);
      }
      var Vi, ji;
      class Wi extends pe {
        static clone(t) {
          return new Wi(t.x, t.y, t.z, t.w);
        }
        static copy(t, e) {
          return (t.x = e.x), (t.y = e.y), (t.z = e.z), (t.w = e.w), t;
        }
        static set(t, e, i, s, n) {
          return (t.x = e), (t.y = i), (t.z = s), (t.w = n), t;
        }
        static fromColor(t, e) {
          return (t.x = e.r), (t.y = e.g), (t.z = e.b), (t.w = e.a), t;
        }
        static angle(t, e) {
          const i = t.y * e.z - t.z * e.y,
            s = t.z * e.x - t.x * e.z,
            n = t.x * e.y - t.y * e.x,
            r = t.x * e.x + t.y * e.y + t.z * e.z;
          return Math.atan2(Math.sqrt(i * i + s * s + n * n), r);
        }
        static add(t, e, i) {
          return (
            (t.x = e.x + i.x),
            (t.y = e.y + i.y),
            (t.z = e.z + i.z),
            (t.w = e.w + i.w),
            t
          );
        }
        static subtract(t, e, i) {
          return (
            (t.x = e.x - i.x),
            (t.y = e.y - i.y),
            (t.z = e.z - i.z),
            (t.w = e.w - i.w),
            t
          );
        }
        static multiply(t, e, i) {
          return (
            (t.x = e.x * i.x),
            (t.y = e.y * i.y),
            (t.z = e.z * i.z),
            (t.w = e.w * i.w),
            t
          );
        }
        static divide(t, e, i) {
          return (
            (t.x = e.x / i.x),
            (t.y = e.y / i.y),
            (t.z = e.z / i.z),
            (t.w = e.w / i.w),
            t
          );
        }
        static ceil(t, e) {
          return (
            (t.x = Math.ceil(e.x)),
            (t.y = Math.ceil(e.y)),
            (t.z = Math.ceil(e.z)),
            (t.w = Math.ceil(e.w)),
            t
          );
        }
        static floor(t, e) {
          return (
            (t.x = Math.floor(e.x)),
            (t.y = Math.floor(e.y)),
            (t.z = Math.floor(e.z)),
            (t.w = Math.floor(e.w)),
            t
          );
        }
        static min(t, e, i) {
          return (
            (t.x = Math.min(e.x, i.x)),
            (t.y = Math.min(e.y, i.y)),
            (t.z = Math.min(e.z, i.z)),
            (t.w = Math.min(e.w, i.w)),
            t
          );
        }
        static max(t, e, i) {
          return (
            (t.x = Math.max(e.x, i.x)),
            (t.y = Math.max(e.y, i.y)),
            (t.z = Math.max(e.z, i.z)),
            (t.w = Math.max(e.w, i.w)),
            t
          );
        }
        static round(t, e) {
          return (
            (t.x = Math.round(e.x)),
            (t.y = Math.round(e.y)),
            (t.z = Math.round(e.z)),
            (t.w = Math.round(e.w)),
            t
          );
        }
        static multiplyScalar(t, e, i) {
          return (
            (t.x = e.x * i),
            (t.y = e.y * i),
            (t.z = e.z * i),
            (t.w = e.w * i),
            t
          );
        }
        static scaleAndAdd(t, e, i, s) {
          return (
            (t.x = e.x + i.x * s),
            (t.y = e.y + i.y * s),
            (t.z = e.z + i.z * s),
            (t.w = e.w + i.w * s),
            t
          );
        }
        static distance(t, e) {
          const i = e.x - t.x,
            s = e.y - t.y,
            n = e.z - t.z,
            r = e.w - t.w;
          return Math.sqrt(i * i + s * s + n * n + r * r);
        }
        static squaredDistance(t, e) {
          const i = e.x - t.x,
            s = e.y - t.y,
            n = e.z - t.z,
            r = e.w - t.w;
          return i * i + s * s + n * n + r * r;
        }
        static len(t) {
          const e = t.x,
            i = t.y,
            s = t.z,
            n = t.w;
          return Math.sqrt(e * e + i * i + s * s + n * n);
        }
        static lengthSqr(t) {
          const e = t.x,
            i = t.y,
            s = t.z,
            n = t.w;
          return e * e + i * i + s * s + n * n;
        }
        static negate(t, e) {
          return (t.x = -e.x), (t.y = -e.y), (t.z = -e.z), (t.w = -e.w), t;
        }
        static inverse(t, e) {
          return (
            (t.x = 1 / e.x),
            (t.y = 1 / e.y),
            (t.z = 1 / e.z),
            (t.w = 1 / e.w),
            t
          );
        }
        static inverseSafe(t, e) {
          const i = e.x,
            s = e.y,
            n = e.z,
            r = e.w;
          return (
            Math.abs(i) < gi ? (t.x = 0) : (t.x = 1 / i),
            Math.abs(s) < gi ? (t.y = 0) : (t.y = 1 / s),
            Math.abs(n) < gi ? (t.z = 0) : (t.z = 1 / n),
            Math.abs(r) < gi ? (t.w = 0) : (t.w = 1 / r),
            t
          );
        }
        static normalize(t, e) {
          const i = e.x,
            s = e.y,
            n = e.z,
            r = e.w;
          let a = i * i + s * s + n * n + r * r;
          return (
            a > 0
              ? ((a = 1 / Math.sqrt(a)),
                (t.x = i * a),
                (t.y = s * a),
                (t.z = n * a),
                (t.w = r * a))
              : ((t.x = 0), (t.y = 0), (t.z = 0), (t.w = 0)),
            t
          );
        }
        static dot(t, e) {
          return t.x * e.x + t.y * e.y + t.z * e.z + t.w * e.w;
        }
        static lerp(t, e, i, s) {
          return (
            (t.x = e.x + s * (i.x - e.x)),
            (t.y = e.y + s * (i.y - e.y)),
            (t.z = e.z + s * (i.z - e.z)),
            (t.w = e.w + s * (i.w - e.w)),
            t
          );
        }
        static scale(t, e, i) {
          return (
            (t.x = e.x * i),
            (t.y = e.y * i),
            (t.z = e.z * i),
            (t.w = e.w * i),
            t
          );
        }
        static random(t, e) {
          e = e || 1;
          const i = 2 * Ci() * Math.PI,
            s = 2 * Ci() - 1,
            n = Math.sqrt(1 - s * s);
          return (
            (t.x = n * Math.cos(i) * e),
            (t.y = n * Math.sin(i) * e),
            (t.z = s * e),
            (t.w = 0),
            t
          );
        }
        static transformMat4(t, e, i) {
          const s = e.x,
            n = e.y,
            r = e.z,
            a = e.w;
          return (
            (t.x = i.m00 * s + i.m04 * n + i.m08 * r + i.m12 * a),
            (t.y = i.m01 * s + i.m05 * n + i.m09 * r + i.m13 * a),
            (t.z = i.m02 * s + i.m06 * n + i.m10 * r + i.m14 * a),
            (t.w = i.m03 * s + i.m07 * n + i.m11 * r + i.m15 * a),
            t
          );
        }
        static transformAffine(t, e, i) {
          const s = e.x,
            n = e.y,
            r = e.z,
            a = e.w;
          return (
            (t.x = i.m00 * s + i.m04 * n + i.m08 * r + i.m12 * a),
            (t.y = i.m01 * s + i.m05 * n + i.m09 * r + i.m13 * a),
            (t.z = i.m02 * s + i.m06 * n + i.m10 * r + i.m14 * a),
            (t.w = e.w),
            t
          );
        }
        static transformQuat(t, e, i) {
          const { x: s, y: n, z: r } = e,
            a = i.x,
            o = i.y,
            h = i.z,
            l = i.w,
            c = l * s + o * r - h * n,
            u = l * n + h * s - a * r,
            _ = l * r + a * n - o * s,
            d = -a * s - o * n - h * r;
          return (
            (t.x = c * l + d * -a + u * -h - _ * -o),
            (t.y = u * l + d * -o + _ * -a - c * -h),
            (t.z = _ * l + d * -h + c * -o - u * -a),
            (t.w = e.w),
            t
          );
        }
        static toArray(t, e, i = 0) {
          return (
            (t[i + 0] = e.x),
            (t[i + 1] = e.y),
            (t[i + 2] = e.z),
            (t[i + 3] = e.w),
            t
          );
        }
        static fromArray(t, e, i = 0) {
          return (
            (t.x = e[i + 0]),
            (t.y = e[i + 1]),
            (t.z = e[i + 2]),
            (t.w = e[i + 3]),
            t
          );
        }
        static strictEquals(t, e) {
          return t.x === e.x && t.y === e.y && t.z === e.z && t.w === e.w;
        }
        static equals(t, e, i = gi) {
          return (
            !(
              Math.abs(t.x) === 1 / 0 ||
              Math.abs(t.y) === 1 / 0 ||
              Math.abs(t.z) === 1 / 0 ||
              Math.abs(t.w) === 1 / 0 ||
              Math.abs(e.x) === 1 / 0 ||
              Math.abs(e.y) === 1 / 0 ||
              Math.abs(e.z) === 1 / 0 ||
              Math.abs(e.w) === 1 / 0
            ) &&
            Math.abs(t.x - e.x) <=
              i * Math.max(1, Math.abs(t.x), Math.abs(e.x)) &&
            Math.abs(t.y - e.y) <=
              i * Math.max(1, Math.abs(t.y), Math.abs(e.y)) &&
            Math.abs(t.z - e.z) <=
              i * Math.max(1, Math.abs(t.z), Math.abs(e.z)) &&
            Math.abs(t.w - e.w) <= i * Math.max(1, Math.abs(t.w), Math.abs(e.w))
          );
        }
        constructor(t, e, i, s) {
          super(),
            "object" == typeof t
              ? ((this.x = t.x), (this.y = t.y), (this.z = t.z), (this.w = t.w))
              : ((this.x = t || 0),
                (this.y = e || 0),
                (this.z = i || 0),
                (this.w = s || 0));
        }
        clone() {
          return new Wi(this.x, this.y, this.z, this.w);
        }
        set(t, e, i, s) {
          return (
            "object" == typeof t
              ? ((this.x = t.x), (this.y = t.y), (this.z = t.z), (this.w = t.w))
              : ((this.x = t || 0),
                (this.y = e || 0),
                (this.z = i || 0),
                (this.w = s || 0)),
            this
          );
        }
        equals(t, e = gi) {
          return (
            Math.abs(this.x - t.x) <=
              e * Math.max(1, Math.abs(this.x), Math.abs(t.x)) &&
            Math.abs(this.y - t.y) <=
              e * Math.max(1, Math.abs(this.y), Math.abs(t.y)) &&
            Math.abs(this.z - t.z) <=
              e * Math.max(1, Math.abs(this.z), Math.abs(t.z)) &&
            Math.abs(this.w - t.w) <=
              e * Math.max(1, Math.abs(this.w), Math.abs(t.w))
          );
        }
        equals4f(t, e, i, s, n = gi) {
          return (
            Math.abs(this.x - t) <=
              n * Math.max(1, Math.abs(this.x), Math.abs(t)) &&
            Math.abs(this.y - e) <=
              n * Math.max(1, Math.abs(this.y), Math.abs(e)) &&
            Math.abs(this.z - i) <=
              n * Math.max(1, Math.abs(this.z), Math.abs(i)) &&
            Math.abs(this.w - s) <=
              n * Math.max(1, Math.abs(this.w), Math.abs(s))
          );
        }
        strictEquals(t) {
          return (
            this.x === t.x && this.y === t.y && this.z === t.z && this.w === t.w
          );
        }
        strictEquals4f(t, e, i, s) {
          return this.x === t && this.y === e && this.z === i && this.w === s;
        }
        lerp(t, e) {
          const i = this.x,
            s = this.y,
            n = this.z,
            r = this.w;
          return (
            (this.x = i + e * (t.x - i)),
            (this.y = s + e * (t.y - s)),
            (this.z = n + e * (t.z - n)),
            (this.w = r + e * (t.w - r)),
            this
          );
        }
        toString() {
          return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)}, ${this.z.toFixed(
            2
          )}, ${this.w.toFixed(2)})`;
        }
        clampf(t, e) {
          return (
            (this.x = Si(this.x, t.x, e.x)),
            (this.y = Si(this.y, t.y, e.y)),
            (this.z = Si(this.z, t.z, e.z)),
            (this.w = Si(this.w, t.w, e.w)),
            this
          );
        }
        add(t) {
          return (
            (this.x += t.x),
            (this.y += t.y),
            (this.z += t.z),
            (this.w += t.w),
            this
          );
        }
        add4f(t, e, i, s) {
          return (
            (this.x += t), (this.y += e), (this.z += i), (this.w += s), this
          );
        }
        subtract(t) {
          return (
            (this.x -= t.x),
            (this.y -= t.y),
            (this.z -= t.z),
            (this.w -= t.w),
            this
          );
        }
        subtract4f(t, e, i, s) {
          return (
            (this.x -= t), (this.y -= e), (this.z -= i), (this.w -= s), this
          );
        }
        multiplyScalar(t) {
          return (
            "object" == typeof t && z(16361),
            (this.x *= t),
            (this.y *= t),
            (this.z *= t),
            (this.w *= t),
            this
          );
        }
        multiply(t) {
          return (
            "object" != typeof t && z(16362),
            (this.x *= t.x),
            (this.y *= t.y),
            (this.z *= t.z),
            (this.w *= t.w),
            this
          );
        }
        multiply4f(t, e, i, s) {
          return (
            (this.x *= t), (this.y *= e), (this.z *= i), (this.w *= s), this
          );
        }
        divide(t) {
          return (
            (this.x /= t.x),
            (this.y /= t.y),
            (this.z /= t.z),
            (this.w /= t.w),
            this
          );
        }
        divide4f(t, e, i, s) {
          return (
            (this.x /= t), (this.y /= e), (this.z /= i), (this.w /= s), this
          );
        }
        negative() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
        }
        cross(t) {
          const { x: e, y: i, z: s } = this,
            { x: n, y: r, z: a } = t;
          return (
            (this.x = i * a - s * r),
            (this.y = s * n - e * a),
            (this.z = e * r - i * n),
            this
          );
        }
        length() {
          const t = this.x,
            e = this.y,
            i = this.z,
            s = this.w;
          return Math.sqrt(t * t + e * e + i * i + s * s);
        }
        lengthSqr() {
          const t = this.x,
            e = this.y,
            i = this.z,
            s = this.w;
          return t * t + e * e + i * i + s * s;
        }
        normalize() {
          const t = this.x,
            e = this.y,
            i = this.z,
            s = this.w;
          let n = t * t + e * e + i * i + s * s;
          return (
            n > 0 &&
              ((n = 1 / Math.sqrt(n)),
              (this.x = t * n),
              (this.y = e * n),
              (this.z = i * n),
              (this.w = s * n)),
            this
          );
        }
        scale(t) {
          return (
            (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
          );
        }
        transformMat4(t) {
          const e = this.x,
            i = this.y,
            s = this.z,
            n = this.w;
          return (
            (this.x = t.m00 * e + t.m04 * i + t.m08 * s + t.m12 * n),
            (this.y = t.m01 * e + t.m05 * i + t.m09 * s + t.m13 * n),
            (this.z = t.m02 * e + t.m06 * i + t.m10 * s + t.m14 * n),
            (this.w = t.m03 * e + t.m07 * i + t.m11 * s + t.m15 * n),
            this
          );
        }
      }
      function Xi(t, e, i, s) {
        return new Wi(t, e, i, s);
      }
      t("Vec4", Wi),
        (Vi = Wi),
        (Wi.ZERO = Object.freeze(new Vi(0, 0, 0, 0))),
        (Wi.ONE = Object.freeze(new Vi(1, 1, 1, 1))),
        (Wi.NEG_ONE = Object.freeze(new Vi(-1, -1, -1, -1))),
        (Wi.UNIT_X = Object.freeze(new Vi(1, 0, 0, 0))),
        (Wi.UNIT_Y = Object.freeze(new Vi(0, 1, 0, 0))),
        (Wi.UNIT_Z = Object.freeze(new Vi(0, 0, 1, 0))),
        (Wi.UNIT_W = Object.freeze(new Vi(0, 0, 0, 1))),
        hi.fastDefine("cc.Vec4", Wi, { x: 0, y: 0, z: 0, w: 0 }),
        (a.Vec4 = Wi),
        (a.v4 = Xi);
      class Yi extends pe {
        static zero(t) {
          return (t.x = 0), (t.y = 0), (t.z = 0), t;
        }
        static clone(t) {
          return new Yi(t.x, t.y, t.z);
        }
        static copy(t, e) {
          return (t.x = e.x), (t.y = e.y), (t.z = e.z), t;
        }
        static set(t, e, i, s) {
          return (t.x = e), (t.y = i), (t.z = s), t;
        }
        static add(t, e, i) {
          return (t.x = e.x + i.x), (t.y = e.y + i.y), (t.z = e.z + i.z), t;
        }
        static subtract(t, e, i) {
          return (t.x = e.x - i.x), (t.y = e.y - i.y), (t.z = e.z - i.z), t;
        }
        static multiply(t, e, i) {
          return (t.x = e.x * i.x), (t.y = e.y * i.y), (t.z = e.z * i.z), t;
        }
        static divide(t, e, i) {
          return (t.x = e.x / i.x), (t.y = e.y / i.y), (t.z = e.z / i.z), t;
        }
        static ceil(t, e) {
          return (
            (t.x = Math.ceil(e.x)),
            (t.y = Math.ceil(e.y)),
            (t.z = Math.ceil(e.z)),
            t
          );
        }
        static floor(t, e) {
          return (
            (t.x = Math.floor(e.x)),
            (t.y = Math.floor(e.y)),
            (t.z = Math.floor(e.z)),
            t
          );
        }
        static min(t, e, i) {
          return (
            (t.x = Math.min(e.x, i.x)),
            (t.y = Math.min(e.y, i.y)),
            (t.z = Math.min(e.z, i.z)),
            t
          );
        }
        static max(t, e, i) {
          return (
            (t.x = Math.max(e.x, i.x)),
            (t.y = Math.max(e.y, i.y)),
            (t.z = Math.max(e.z, i.z)),
            t
          );
        }
        static round(t, e) {
          return (
            (t.x = Math.round(e.x)),
            (t.y = Math.round(e.y)),
            (t.z = Math.round(e.z)),
            t
          );
        }
        static multiplyScalar(t, e, i) {
          return (t.x = e.x * i), (t.y = e.y * i), (t.z = e.z * i), t;
        }
        static scaleAndAdd(t, e, i, s) {
          return (
            (t.x = e.x + i.x * s),
            (t.y = e.y + i.y * s),
            (t.z = e.z + i.z * s),
            t
          );
        }
        static distance(t, e) {
          const i = e.x - t.x,
            s = e.y - t.y,
            n = e.z - t.z;
          return Math.sqrt(i * i + s * s + n * n);
        }
        static squaredDistance(t, e) {
          const i = e.x - t.x,
            s = e.y - t.y,
            n = e.z - t.z;
          return i * i + s * s + n * n;
        }
        static len(t) {
          const e = t.x,
            i = t.y,
            s = t.z;
          return Math.sqrt(e * e + i * i + s * s);
        }
        static lengthSqr(t) {
          const e = t.x,
            i = t.y,
            s = t.z;
          return e * e + i * i + s * s;
        }
        static negate(t, e) {
          return (t.x = -e.x), (t.y = -e.y), (t.z = -e.z), t;
        }
        static invert(t, e) {
          return (t.x = 1 / e.x), (t.y = 1 / e.y), (t.z = 1 / e.z), t;
        }
        static invertSafe(t, e) {
          const i = e.x,
            s = e.y,
            n = e.z;
          return (
            Math.abs(i) < gi ? (t.x = 0) : (t.x = 1 / i),
            Math.abs(s) < gi ? (t.y = 0) : (t.y = 1 / s),
            Math.abs(n) < gi ? (t.z = 0) : (t.z = 1 / n),
            t
          );
        }
        static normalize(t, e) {
          const i = e.x,
            s = e.y,
            n = e.z;
          let r = i * i + s * s + n * n;
          return (
            r > 0
              ? ((r = 1 / Math.sqrt(r)),
                (t.x = i * r),
                (t.y = s * r),
                (t.z = n * r))
              : ((t.x = 0), (t.y = 0), (t.z = 0)),
            t
          );
        }
        static dot(t, e) {
          return t.x * e.x + t.y * e.y + t.z * e.z;
        }
        static cross(t, e, i) {
          const { x: s, y: n, z: r } = e,
            { x: a, y: o, z: h } = i;
          return (
            (t.x = n * h - r * o),
            (t.y = r * a - s * h),
            (t.z = s * o - n * a),
            t
          );
        }
        static lerp(t, e, i, s) {
          return (
            (t.x = e.x + s * (i.x - e.x)),
            (t.y = e.y + s * (i.y - e.y)),
            (t.z = e.z + s * (i.z - e.z)),
            t
          );
        }
        static random(t, e) {
          e = e || 1;
          const i = 2 * Ci() * Math.PI,
            s = 2 * Ci() - 1,
            n = Math.sqrt(1 - s * s);
          return (
            (t.x = n * Math.cos(i) * e),
            (t.y = n * Math.sin(i) * e),
            (t.z = s * e),
            t
          );
        }
        static transformMat4(t, e, i) {
          const s = e.x,
            n = e.y,
            r = e.z;
          let a = i.m03 * s + i.m07 * n + i.m11 * r + i.m15;
          return (
            (a = a ? 1 / a : 1),
            (t.x = (i.m00 * s + i.m04 * n + i.m08 * r + i.m12) * a),
            (t.y = (i.m01 * s + i.m05 * n + i.m09 * r + i.m13) * a),
            (t.z = (i.m02 * s + i.m06 * n + i.m10 * r + i.m14) * a),
            t
          );
        }
        static transformMat4Normal(t, e, i) {
          const s = e.x,
            n = e.y,
            r = e.z;
          let a = i.m03 * s + i.m07 * n + i.m11 * r;
          return (
            (a = a ? 1 / a : 1),
            (t.x = (i.m00 * s + i.m04 * n + i.m08 * r) * a),
            (t.y = (i.m01 * s + i.m05 * n + i.m09 * r) * a),
            (t.z = (i.m02 * s + i.m06 * n + i.m10 * r) * a),
            t
          );
        }
        static transformMat3(t, e, i) {
          const s = e.x,
            n = e.y,
            r = e.z;
          return (
            (t.x = s * i.m00 + n * i.m03 + r * i.m06),
            (t.y = s * i.m01 + n * i.m04 + r * i.m07),
            (t.z = s * i.m02 + n * i.m05 + r * i.m08),
            t
          );
        }
        static transformAffine(t, e, i) {
          const s = e.x,
            n = e.y,
            r = e.z;
          return (
            (t.x = i.m00 * s + i.m04 * n + i.m08 * r + i.m12),
            (t.y = i.m01 * s + i.m05 * n + i.m09 * r + i.m13),
            (t.z = i.m02 * s + i.m06 * n + i.m10 * r + i.m14),
            t
          );
        }
        static transformQuat(t, e, i) {
          const s = i.w * e.x + i.y * e.z - i.z * e.y,
            n = i.w * e.y + i.z * e.x - i.x * e.z,
            r = i.w * e.z + i.x * e.y - i.y * e.x,
            a = -i.x * e.x - i.y * e.y - i.z * e.z;
          return (
            (t.x = s * i.w + a * -i.x + n * -i.z - r * -i.y),
            (t.y = n * i.w + a * -i.y + r * -i.x - s * -i.z),
            (t.z = r * i.w + a * -i.z + s * -i.y - n * -i.x),
            t
          );
        }
        static transformRTS(t, e, i, s, n) {
          const r = e.x * n.x,
            a = e.y * n.y,
            o = e.z * n.z,
            h = i.w * r + i.y * o - i.z * a,
            l = i.w * a + i.z * r - i.x * o,
            c = i.w * o + i.x * a - i.y * r,
            u = -i.x * r - i.y * a - i.z * o;
          return (
            (t.x = h * i.w + u * -i.x + l * -i.z - c * -i.y + s.x),
            (t.y = l * i.w + u * -i.y + c * -i.x - h * -i.z + s.y),
            (t.z = c * i.w + u * -i.z + h * -i.y - l * -i.x + s.z),
            t
          );
        }
        static transformInverseRTS(t, e, i, s, n) {
          const r = e.x - s.x,
            a = e.y - s.y,
            o = e.z - s.z,
            h = i.w * r - i.y * o + i.z * a,
            l = i.w * a - i.z * r + i.x * o,
            c = i.w * o - i.x * a + i.y * r,
            u = i.x * r + i.y * a + i.z * o;
          return (
            (t.x = (h * i.w + u * i.x + l * i.z - c * i.y) / n.x),
            (t.y = (l * i.w + u * i.y + c * i.x - h * i.z) / n.y),
            (t.z = (c * i.w + u * i.z + h * i.y - l * i.x) / n.z),
            t
          );
        }
        static rotateX(t, e, i, s) {
          const n = e.x - i.x,
            r = e.y - i.y,
            a = e.z - i.z,
            o = Math.cos(s),
            h = Math.sin(s),
            l = n,
            c = r * o - a * h,
            u = r * h + a * o;
          return (t.x = l + i.x), (t.y = c + i.y), (t.z = u + i.z), t;
        }
        static rotateY(t, e, i, s) {
          const n = e.x - i.x,
            r = e.y - i.y,
            a = e.z - i.z,
            o = Math.cos(s),
            h = Math.sin(s),
            l = a * h + n * o,
            c = r,
            u = a * o - n * h;
          return (t.x = l + i.x), (t.y = c + i.y), (t.z = u + i.z), t;
        }
        static rotateZ(t, e, i, s) {
          const n = e.x - i.x,
            r = e.y - i.y,
            a = e.z - i.z,
            o = Math.cos(s),
            h = Math.sin(s),
            l = n * o - r * h,
            c = n * h + r * o,
            u = a;
          return (t.x = l + i.x), (t.y = c + i.y), (t.z = u + i.z), t;
        }
        static rotateN(t, e, i, s, n) {
          const r = e.x - i.x,
            a = e.y - i.y,
            o = e.z - i.z,
            h = s.x,
            l = s.y,
            c = s.z,
            u = Math.cos(n),
            _ = Math.sin(n),
            d =
              r * (h * h * (1 - u) + u) +
              a * (h * l * (1 - u) - c * _) +
              o * (h * c * (1 - u) + l * _),
            p =
              r * (h * l * (1 - u) + c * _) +
              a * (l * l * (1 - u) + u) +
              o * (l * c * (1 - u) - h * _),
            m =
              r * (h * c * (1 - u) - l * _) +
              a * (l * c * (1 - u) + h * _) +
              o * (c * c * (1 - u) + u);
          return (t.x = d + i.x), (t.y = p + i.y), (t.z = m + i.z), t;
        }
        static toArray(t, e, i = 0) {
          return (t[i + 0] = e.x), (t[i + 1] = e.y), (t[i + 2] = e.z), t;
        }
        static fromArray(t, e, i = 0) {
          return (t.x = e[i + 0]), (t.y = e[i + 1]), (t.z = e[i + 2]), t;
        }
        static strictEquals(t, e) {
          return t.x === e.x && t.y === e.y && t.z === e.z;
        }
        static equals(t, e, i = gi) {
          const { x: s, y: n, z: r } = t,
            { x: a, y: o, z: h } = e;
          return (
            Math.abs(s - a) <= i * Math.max(1, Math.abs(s), Math.abs(a)) &&
            Math.abs(n - o) <= i * Math.max(1, Math.abs(n), Math.abs(o)) &&
            Math.abs(r - h) <= i * Math.max(1, Math.abs(r), Math.abs(h))
          );
        }
        static angle(t, e) {
          const i = t.x * t.x + t.y * t.y + t.z * t.z,
            s = e.x * e.x + e.y * e.y + e.z * e.z;
          if (0 === i || 0 === s) return 0;
          let n = (t.x * e.x + t.y * e.y + t.z * e.z) / Math.sqrt(i * s);
          return (n = Si(n, -1, 1)), Math.acos(n);
        }
        static projectOnPlane(t, e, i) {
          return Yi.subtract(t, e, Yi.project(t, e, i));
        }
        static project(t, e, i) {
          const s = Yi.lengthSqr(i);
          return s < 1e-6
            ? Yi.set(t, 0, 0, 0)
            : Yi.multiplyScalar(t, i, Yi.dot(e, i) / s);
        }
        static moveTowards(t, e, i, s) {
          const n = i.x - e.x,
            r = i.y - e.y,
            a = i.z - e.z,
            o = n * n + r * r + a * a;
          if (0 === o || (s >= 0 && o < s * s))
            return (t.x = i.x), (t.y = i.y), (t.z = i.z), t;
          const h = s / Math.sqrt(o);
          return (
            (t.x = e.x + n * h), (t.y = e.y + r * h), (t.z = e.z + a * h), t
          );
        }
        static generateOrthogonal(t, e) {
          const { x: i, y: s, z: n } = e,
            r = Math.abs(i),
            a = Math.abs(s),
            o = Math.abs(n);
          return (
            r < a && r < o
              ? Yi.set(t, 0, n, -s)
              : a < o
              ? Yi.set(t, n, 0, -i)
              : Yi.set(t, s, -i, 0),
            Yi.normalize(t, t)
          );
        }
        constructor(t, e, i) {
          super(),
            "object" == typeof t
              ? ((this.x = t.x), (this.y = t.y), (this.z = t.z))
              : ((this.x = t || 0), (this.y = e || 0), (this.z = i || 0));
        }
        clone() {
          return new Yi(this.x, this.y, this.z);
        }
        set(t, e, i) {
          return (
            "object" == typeof t
              ? ((this.x = t.x), (this.y = t.y), (this.z = t.z))
              : ((this.x = t || 0), (this.y = e || 0), (this.z = i || 0)),
            this
          );
        }
        equals(t, e = gi) {
          return (
            Math.abs(this.x - t.x) <= e &&
            Math.abs(this.y - t.y) <= e &&
            Math.abs(this.z - t.z) <= e
          );
        }
        equals3f(t, e, i, s = gi) {
          return (
            Math.abs(this.x - t) <= s &&
            Math.abs(this.y - e) <= s &&
            Math.abs(this.z - i) <= s
          );
        }
        strictEquals(t) {
          return this.x === t.x && this.y === t.y && this.z === t.z;
        }
        strictEquals3f(t, e, i) {
          return this.x === t && this.y === e && this.z === i;
        }
        toString() {
          return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)}, ${this.z.toFixed(
            2
          )})`;
        }
        lerp(t, e) {
          return (
            (this.x += e * (t.x - this.x)),
            (this.y += e * (t.y - this.y)),
            (this.z += e * (t.z - this.z)),
            this
          );
        }
        add(t) {
          return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
        }
        add3f(t, e, i) {
          return (this.x += t), (this.y += e), (this.z += i), this;
        }
        subtract(t) {
          return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
        }
        subtract3f(t, e, i) {
          return (this.x -= t), (this.y -= e), (this.z -= i), this;
        }
        multiplyScalar(t) {
          return (
            "object" == typeof t && z(16357),
            (this.x *= t),
            (this.y *= t),
            (this.z *= t),
            this
          );
        }
        multiply(t) {
          return (
            "object" != typeof t && z(16358),
            (this.x *= t.x),
            (this.y *= t.y),
            (this.z *= t.z),
            this
          );
        }
        multiply3f(t, e, i) {
          return (this.x *= t), (this.y *= e), (this.z *= i), this;
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
        }
        divide3f(t, e, i) {
          return (this.x /= t), (this.y /= e), (this.z /= i), this;
        }
        negative() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        clampf(t, e) {
          return (
            (this.x = Si(this.x, t.x, e.x)),
            (this.y = Si(this.y, t.y, e.y)),
            (this.z = Si(this.z, t.z, e.z)),
            this
          );
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z;
        }
        cross(t) {
          const { x: e, y: i, z: s } = this,
            { x: n, y: r, z: a } = t;
          return (
            (this.x = i * a - s * r),
            (this.y = s * n - e * a),
            (this.z = e * r - i * n),
            this
          );
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        lengthSqr() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        normalize() {
          const t = this.x,
            e = this.y,
            i = this.z;
          let s = t * t + e * e + i * i;
          return (
            s > 0 &&
              ((s = 1 / Math.sqrt(s)),
              (this.x = t * s),
              (this.y = e * s),
              (this.z = i * s)),
            this
          );
        }
        transformMat4(t) {
          const e = this.x,
            i = this.y,
            s = this.z;
          let n = t.m03 * e + t.m07 * i + t.m11 * s + t.m15;
          return (
            (n = n ? 1 / n : 1),
            (this.x = (t.m00 * e + t.m04 * i + t.m08 * s + t.m12) * n),
            (this.y = (t.m01 * e + t.m05 * i + t.m09 * s + t.m13) * n),
            (this.z = (t.m02 * e + t.m06 * i + t.m10 * s + t.m14) * n),
            this
          );
        }
        toVec2() {
          return new a.Vec2(this.x, this.y);
        }
      }
      function Ki(t, e, i) {
        return new Yi(t, e, i);
      }
      t("Vec3", Yi),
        (ji = Yi),
        (Yi.UNIT_X = Object.freeze(new ji(1, 0, 0))),
        (Yi.UNIT_Y = Object.freeze(new ji(0, 1, 0))),
        (Yi.UNIT_Z = Object.freeze(new ji(0, 0, 1))),
        (Yi.RIGHT = Object.freeze(new ji(1, 0, 0))),
        (Yi.UP = Object.freeze(new ji(0, 1, 0))),
        (Yi.FORWARD = Object.freeze(new ji(0, 0, -1))),
        (Yi.ZERO = Object.freeze(new ji(0, 0, 0))),
        (Yi.ONE = Object.freeze(new ji(1, 1, 1))),
        (Yi.NEG_ONE = Object.freeze(new ji(-1, -1, -1))),
        (Yi.slerp = (() => {
          const t = new ji(),
            e = new ji(),
            i = new ji();
          return (s, n, r, a) => {
            const o = 1e-5,
              h = ji.len(n),
              l = ji.len(r);
            if (h < o || l < o) return ji.lerp(s, n, r, a);
            const c = vi(h, l, a),
              u = ji.dot(n, r) / (h * l);
            if (u > 0.99999) return ji.lerp(s, n, r, a);
            if (u < -0.99999) {
              const r = ji.multiplyScalar(t, n, 1 / h),
                o = ji.generateOrthogonal(e, r),
                l = Math.PI * a;
              return qi(i, r, o, l), ji.multiplyScalar(s, i, c), s;
            }
            {
              const o = u,
                _ = Math.acos(o) * a,
                d = ji.multiplyScalar(t, n, 1 / h),
                p = ji.multiplyScalar(e, r, 1 / l);
              return (
                ji.scaleAndAdd(i, p, d, -o),
                ji.normalize(i, i),
                ji.multiplyScalar(i, i, Math.sin(_)),
                ji.scaleAndAdd(i, i, d, Math.cos(_)),
                ji.multiplyScalar(s, i, c),
                s
              );
            }
          };
        })()),
        (Yi.signedAngle = (() => {
          const t = new ji();
          return (e, i, s) => {
            const n = ji.angle(e, i),
              r = ji.cross(t, e, i);
            return ji.dot(r, s) < 0 ? -n : n;
          };
        })()),
        hi.fastDefine("cc.Vec3", Yi, { x: 0, y: 0, z: 0 }),
        (a.Vec3 = Yi);
      const qi = (() => {
        const t = { x: 0, y: 0, z: 0, w: 0 };
        return (e, i, s, n) => {
          const r = 0.5 * n,
            a = Math.sin(r);
          return (
            (t.x = a * s.x),
            (t.y = a * s.y),
            (t.z = a * s.z),
            (t.w = Math.cos(r)),
            Yi.transformQuat(e, i, t),
            e
          );
        };
      })();
      var $i;
      a.v3 = Ki;
      const Zi = 1 / 255;
      class Qi extends pe {
        static clone(t) {
          const e = new Qi();
          return (e.r = t.r), (e.g = t.g), (e.b = t.b), (e.a = t.a), e;
        }
        static copy(t, e) {
          return (t.r = e.r), (t.g = e.g), (t.b = e.b), (t.a = e.a), t;
        }
        static set(t, e, i, s, n) {
          return (t.r = e), (t.g = i), (t.b = s), (t.a = n), t;
        }
        static toVec4(t, e) {
          return (
            ((e = void 0 !== e ? e : new Wi()).x = t._data[0] * Zi),
            (e.y = t._data[1] * Zi),
            (e.z = t._data[2] * Zi),
            (e.w = t._data[3] * Zi),
            e
          );
        }
        static fromVec4(t, e) {
          return (
            ((e = void 0 === e ? new Qi() : e)._data[0] = t.x / Zi),
            (e._data[1] = t.y / Zi),
            (e._data[2] = t.z / Zi),
            (e._data[3] = t.w / Zi),
            e
          );
        }
        static fromHEX(t, e) {
          let i;
          return (
            "string" == typeof e
              ? (6 === (e = "#" === e[0] ? e.substring(1) : e).length
                  ? (e += "FF")
                  : 3 === e.length
                  ? (e = `${e[0] + e[0] + e[1] + e[1] + e[2] + e[2]}FF`)
                  : 4 === e.length &&
                    (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2] + e[3] + e[3]),
                (i = Number(`0x${e}`)))
              : (e < 16777216 && (e = 255 + (e << 8)), (i = e)),
            (t.r = i >>> 24),
            (t.g = (16711680 & i) >>> 16),
            (t.b = (65280 & i) >>> 8),
            (t.a = 255 & i),
            t
          );
        }
        static add(t, e, i) {
          return (
            (t.r = e.r + i.r),
            (t.g = e.g + i.g),
            (t.b = e.b + i.b),
            (t.a = e.a + i.a),
            t
          );
        }
        static subtract(t, e, i) {
          return (
            (t.r = e.r - i.r),
            (t.g = e.g - i.g),
            (t.b = e.b - i.b),
            (t.a = e.a - i.a),
            t
          );
        }
        static multiply(t, e, i) {
          return (
            (t.r = e.r * i.r),
            (t.g = e.g * i.g),
            (t.b = e.b * i.b),
            (t.a = e.a * i.a),
            t
          );
        }
        static divide(t, e, i) {
          return (
            (t.r = e.r / i.r),
            (t.g = e.g / i.g),
            (t.b = e.b / i.b),
            (t.a = e.a / i.a),
            t
          );
        }
        static scale(t, e, i) {
          return (
            (t.r = e.r * i),
            (t.g = e.g * i),
            (t.b = e.b * i),
            (t.a = e.a * i),
            t
          );
        }
        static lerp(t, e, i, s) {
          const n = e.r,
            r = e.g,
            a = e.b,
            o = e.a;
          return (
            (t.r = n + (i.r - n) * s),
            (t.g = r + (i.g - r) * s),
            (t.b = a + (i.b - a) * s),
            (t.a = o + (i.a - o) * s),
            t
          );
        }
        static toArray(t, e, i = 0) {
          const s = e instanceof Qi || e.a > 1 ? 1 / 255 : 1;
          return (
            (t[i + 0] = e.r * s),
            (t[i + 1] = e.g * s),
            (t[i + 2] = e.b * s),
            (t[i + 3] = e.a * s),
            t
          );
        }
        static fromArray(t, e, i = 0) {
          return (
            (e.r = 255 * t[i + 0]),
            (e.g = 255 * t[i + 1]),
            (e.b = 255 * t[i + 2]),
            (e.a = 255 * t[i + 3]),
            e
          );
        }
        static fromUint32(t, e) {
          return (
            (e >>>= 0),
            (t.r = 255 & e),
            (t.g = (e >> 8) & 255),
            (t.b = (e >> 16) & 255),
            (t.a = (e >> 24) & 255),
            t
          );
        }
        static toUint32(t) {
          return ((t.a << 24) | (t.b << 16) | (t.g << 8) | t.r) >>> 0;
        }
        static strictEquals(t, e) {
          return t.r === e.r && t.g === e.g && t.b === e.b && t.a === e.a;
        }
        static equals(t, e, i = gi) {
          return (
            !(
              Math.abs(t.r) === 1 / 0 ||
              Math.abs(t.g) === 1 / 0 ||
              Math.abs(t.b) === 1 / 0 ||
              Math.abs(t.a) === 1 / 0
            ) &&
            Math.abs(t.r - e.r) <=
              i * Math.max(1, Math.abs(t.r), Math.abs(e.r)) &&
            Math.abs(t.g - e.g) <=
              i * Math.max(1, Math.abs(t.g), Math.abs(e.g)) &&
            Math.abs(t.b - e.b) <=
              i * Math.max(1, Math.abs(t.b), Math.abs(e.b)) &&
            Math.abs(t.a - e.a) <= i * Math.max(1, Math.abs(t.a), Math.abs(e.a))
          );
        }
        static hex(t) {
          return (
            (((255 * t.r) << 24) |
              ((255 * t.g) << 16) |
              ((255 * t.b) << 8) |
              (255 * t.a)) >>>
            0
          );
        }
        get r() {
          return this._data[0];
        }
        set r(t) {
          this._data[0] = t;
        }
        get g() {
          return this._data[1];
        }
        set g(t) {
          this._data[1] = t;
        }
        get b() {
          return this._data[2];
        }
        set b(t) {
          this._data[2] = t;
        }
        get a() {
          return this._data[3];
        }
        set a(t) {
          this._data[3] = t;
        }
        get x() {
          return this._data[0] * Zi;
        }
        set x(t) {
          this._data[0] = 255 * t;
        }
        get y() {
          return this._data[1] * Zi;
        }
        set y(t) {
          this._data[1] = 255 * t;
        }
        get z() {
          return this._data[2] * Zi;
        }
        set z(t) {
          this._data[2] = 255 * t;
        }
        get w() {
          return this._data[3] * Zi;
        }
        set w(t) {
          this._data[3] = 255 * t;
        }
        constructor(t, e, i, s) {
          super(),
            (this._data = new Uint8ClampedArray(4)),
            "string" == typeof t
              ? this.fromHEX(t)
              : void 0 !== e
              ? this.set(t, e, i, s)
              : this.set(t);
        }
        clone() {
          const t = new Qi();
          return t._data.set(this._data), t;
        }
        equals(t) {
          const e = t;
          return (
            t &&
            this._data[0] === e.r &&
            this._data[1] === e.g &&
            this._data[2] === e.b &&
            this._data[3] === e.a
          );
        }
        lerp(t, e) {
          return Qi.lerp(this, this, t, e), this;
        }
        toString() {
          return `rgba(${this.r.toFixed()}, ${this.g.toFixed()}, ${this.b.toFixed()}, ${this.a.toFixed()})`;
        }
        toCSS(t = "rgba") {
          return "rgba" === t
            ? `rgba(${this.r},${this.g},${this.b},${(this.a * Zi).toFixed(2)})`
            : "rgb" === t
            ? `rgb(${this.r},${this.g},${this.b})`
            : `#${this.toHEX(t)}`;
        }
        fromHEX(t) {
          let e;
          return (
            "string" == typeof t
              ? (6 === (t = "#" === t[0] ? t.substring(1) : t).length
                  ? (t += "FF")
                  : 3 === t.length
                  ? (t = `${t[0] + t[0] + t[1] + t[1] + t[2] + t[2]}FF`)
                  : 4 === t.length &&
                    (t = t[0] + t[0] + t[1] + t[1] + t[2] + t[2] + t[3] + t[3]),
                (e = Number(`0x${t}`)))
              : (t < 16777216 && (t = 255 + (t << 8)), (e = t)),
            (this.r = e >>> 24),
            (this.g = (16711680 & e) >>> 16),
            (this.b = (65280 & e) >>> 8),
            (this.a = 255 & e),
            this
          );
        }
        toHEX(t = "#rrggbb") {
          const e = "0",
            i = [
              (this._data[0] < 16 ? e : "") + this._data[0].toString(16),
              (this._data[1] < 16 ? e : "") + this._data[1].toString(16),
              (this._data[2] < 16 ? e : "") + this._data[2].toString(16),
            ];
          return (
            "#rgb" === t
              ? ((i[0] = i[0][0]), (i[1] = i[1][0]), (i[2] = i[2][0]))
              : "#rrggbbaa" === t &&
                i.push(
                  (this._data[3] < 16 ? e : "") + this._data[3].toString(16)
                ),
            i.join("")
          );
        }
        toRGBValue() {
          return (this._data[2] << 16) | (this._data[1] << 8) | this._data[0];
        }
        fromHSV(t, e, i) {
          let s = 0,
            n = 0,
            r = 0;
          if (0 === e) s = n = r = i;
          else if (0 === i) s = n = r = 0;
          else {
            1 === t && (t = 0), (t *= 6);
            const a = Math.floor(t),
              o = t - a,
              h = i * (1 - e),
              l = i * (1 - e * o),
              c = i * (1 - e * (1 - o));
            switch (a) {
              default:
              case 0:
                (s = i), (n = c), (r = h);
                break;
              case 1:
                (s = l), (n = i), (r = h);
                break;
              case 2:
                (s = h), (n = i), (r = c);
                break;
              case 3:
                (s = h), (n = l), (r = i);
                break;
              case 4:
                (s = c), (n = h), (r = i);
                break;
              case 5:
                (s = i), (n = h), (r = l);
            }
          }
          return (
            (this._data[0] = 255 * s),
            (this._data[1] = 255 * n),
            (this._data[2] = 255 * r),
            this
          );
        }
        toHSV() {
          const t = this._data[0] * Zi,
            e = this._data[1] * Zi,
            i = this._data[2] * Zi,
            s = { h: 0, s: 0, v: 0 },
            n = Math.max(t, e, i),
            r = Math.min(t, e, i);
          let a = 0;
          return (
            (s.v = n),
            (s.s = n ? (n - r) / n : 0),
            s.s
              ? ((a = n - r),
                (s.h =
                  t === n
                    ? (e - i) / a
                    : e === n
                    ? 2 + (i - t) / a
                    : 4 + (t - e) / a),
                (s.h /= 6),
                s.h < 0 && (s.h += 1))
              : (s.h = 0),
            s
          );
        }
        set(t, e, i, s) {
          if ("object" == typeof t) {
            const e = t;
            var n, r, a, o;
            e._data
              ? this._data.set(e._data)
              : ((this._data[0] = null !== (n = e.r) && void 0 !== n ? n : 0),
                (this._data[1] = null !== (r = e.g) && void 0 !== r ? r : 0),
                (this._data[2] = null !== (a = e.b) && void 0 !== a ? a : 0),
                (this._data[3] = null !== (o = e.a) && void 0 !== o ? o : 255));
          } else
            (this._data[0] = null != t ? t : 0),
              (this._data[1] = null != e ? e : 0),
              (this._data[2] = null != i ? i : 0),
              (this._data[3] = null != s ? s : 255);
          return this;
        }
        multiply(t) {
          return (
            (this._data[0] *= t.r / 255),
            (this._data[1] *= t.g / 255),
            (this._data[2] *= t.b / 255),
            (this._data[3] *= t.a / 255),
            this
          );
        }
        getModifiableProperties() {
          return ["r", "g", "b", "a"];
        }
      }
      function Ji(t, e, i, s) {
        return new Qi(t, e, i, s);
      }
      var ts;
      t("Color", Qi),
        ($i = Qi),
        (Qi.WHITE = Object.freeze(new $i(255, 255, 255, 255))),
        (Qi.GRAY = Object.freeze(new $i(127, 127, 127, 255))),
        (Qi.BLACK = Object.freeze(new $i(0, 0, 0, 255))),
        (Qi.TRANSPARENT = Object.freeze(new $i(0, 0, 0, 0))),
        (Qi.RED = Object.freeze(new $i(255, 0, 0, 255))),
        (Qi.GREEN = Object.freeze(new $i(0, 255, 0, 255))),
        (Qi.BLUE = Object.freeze(new $i(0, 0, 255, 255))),
        (Qi.CYAN = Object.freeze(new $i(0, 255, 255, 255))),
        (Qi.MAGENTA = Object.freeze(new $i(255, 0, 255, 255))),
        (Qi.YELLOW = Object.freeze(new $i(255, 255, 0, 255))),
        hi.fastDefine("cc.Color", Qi, { r: 0, g: 0, b: 0, a: 255 }),
        (a.Color = Qi),
        (a.color = Ji);
      class es extends pe {
        static clone(t) {
          return new es(
            t.m00,
            t.m01,
            t.m02,
            t.m03,
            t.m04,
            t.m05,
            t.m06,
            t.m07,
            t.m08
          );
        }
        static copy(t, e) {
          return (
            (t.m00 = e.m00),
            (t.m01 = e.m01),
            (t.m02 = e.m02),
            (t.m03 = e.m03),
            (t.m04 = e.m04),
            (t.m05 = e.m05),
            (t.m06 = e.m06),
            (t.m07 = e.m07),
            (t.m08 = e.m08),
            t
          );
        }
        static set(t, e, i, s, n, r, a, o, h, l) {
          return (
            (t.m00 = e),
            (t.m01 = i),
            (t.m02 = s),
            (t.m03 = n),
            (t.m04 = r),
            (t.m05 = a),
            (t.m06 = o),
            (t.m07 = h),
            (t.m08 = l),
            t
          );
        }
        static identity(t) {
          return (
            (t.m00 = 1),
            (t.m01 = 0),
            (t.m02 = 0),
            (t.m03 = 0),
            (t.m04 = 1),
            (t.m05 = 0),
            (t.m06 = 0),
            (t.m07 = 0),
            (t.m08 = 1),
            t
          );
        }
        static transpose(t, e) {
          if (t === e) {
            const i = e.m01,
              s = e.m02,
              n = e.m05;
            (t.m01 = e.m03),
              (t.m02 = e.m06),
              (t.m03 = i),
              (t.m05 = e.m07),
              (t.m06 = s),
              (t.m07 = n);
          } else
            (t.m00 = e.m00),
              (t.m01 = e.m03),
              (t.m02 = e.m06),
              (t.m03 = e.m01),
              (t.m04 = e.m04),
              (t.m05 = e.m07),
              (t.m06 = e.m02),
              (t.m07 = e.m05),
              (t.m08 = e.m08);
          return t;
        }
        static invert(t, e) {
          const i = e.m00,
            s = e.m01,
            n = e.m02,
            r = e.m03,
            a = e.m04,
            o = e.m05,
            h = e.m06,
            l = e.m07,
            c = e.m08,
            u = c * a - o * l,
            _ = -c * r + o * h,
            d = l * r - a * h;
          let p = i * u + s * _ + n * d;
          return 0 === p
            ? ((t.m00 = 0),
              (t.m01 = 0),
              (t.m02 = 0),
              (t.m03 = 0),
              (t.m04 = 0),
              (t.m05 = 0),
              (t.m06 = 0),
              (t.m07 = 0),
              (t.m08 = 0),
              t)
            : ((p = 1 / p),
              (t.m00 = u * p),
              (t.m01 = (-c * s + n * l) * p),
              (t.m02 = (o * s - n * a) * p),
              (t.m03 = _ * p),
              (t.m04 = (c * i - n * h) * p),
              (t.m05 = (-o * i + n * r) * p),
              (t.m06 = d * p),
              (t.m07 = (-l * i + s * h) * p),
              (t.m08 = (a * i - s * r) * p),
              t);
        }
        static determinant(t) {
          const e = t.m00,
            i = t.m01,
            s = t.m02,
            n = t.m03,
            r = t.m04,
            a = t.m05,
            o = t.m06,
            h = t.m07,
            l = t.m08;
          return (
            e * (l * r - a * h) + i * (-l * n + a * o) + s * (h * n - r * o)
          );
        }
        static multiply(t, e, i) {
          const s = e.m00,
            n = e.m01,
            r = e.m02,
            a = e.m03,
            o = e.m04,
            h = e.m05,
            l = e.m06,
            c = e.m07,
            u = e.m08,
            _ = i.m00,
            d = i.m01,
            p = i.m02,
            m = i.m03,
            f = i.m04,
            g = i.m05,
            y = i.m06,
            T = i.m07,
            S = i.m08;
          return (
            (t.m00 = _ * s + d * a + p * l),
            (t.m01 = _ * n + d * o + p * c),
            (t.m02 = _ * r + d * h + p * u),
            (t.m03 = m * s + f * a + g * l),
            (t.m04 = m * n + f * o + g * c),
            (t.m05 = m * r + f * h + g * u),
            (t.m06 = y * s + T * a + S * l),
            (t.m07 = y * n + T * o + S * c),
            (t.m08 = y * r + T * h + S * u),
            t
          );
        }
        static multiplyMat4(t, e, i) {
          const s = e.m00,
            n = e.m01,
            r = e.m02,
            a = e.m03,
            o = e.m04,
            h = e.m05,
            l = e.m06,
            c = e.m07,
            u = e.m08,
            _ = i.m00,
            d = i.m01,
            p = i.m02,
            m = i.m04,
            f = i.m05,
            g = i.m06,
            y = i.m08,
            T = i.m09,
            S = i.m10;
          return (
            (t.m00 = _ * s + d * a + p * l),
            (t.m01 = _ * n + d * o + p * c),
            (t.m02 = _ * r + d * h + p * u),
            (t.m03 = m * s + f * a + g * l),
            (t.m04 = m * n + f * o + g * c),
            (t.m05 = m * r + f * h + g * u),
            (t.m06 = y * s + T * a + S * l),
            (t.m07 = y * n + T * o + S * c),
            (t.m08 = y * r + T * h + S * u),
            t
          );
        }
        static transform(t, e, i) {
          this.translate(t, e, i);
        }
        static translate(t, e, i) {
          const s = e.m00,
            n = e.m01,
            r = e.m02,
            a = e.m03,
            o = e.m04,
            h = e.m05,
            l = e.m06,
            c = e.m07,
            u = e.m08,
            _ = i.x,
            d = i.y;
          return (
            (t.m00 = s),
            (t.m01 = n),
            (t.m02 = r),
            (t.m03 = a),
            (t.m04 = o),
            (t.m05 = h),
            (t.m06 = _ * s + d * a + l),
            (t.m07 = _ * n + d * o + c),
            (t.m08 = _ * r + d * h + u),
            t
          );
        }
        static scale(t, e, i) {
          const s = i.x,
            n = i.y;
          return (
            (t.m00 = s * e.m00),
            (t.m01 = s * e.m01),
            (t.m02 = s * e.m02),
            (t.m03 = n * e.m03),
            (t.m04 = n * e.m04),
            (t.m05 = n * e.m05),
            (t.m06 = e.m06),
            (t.m07 = e.m07),
            (t.m08 = e.m08),
            t
          );
        }
        static rotate(t, e, i) {
          const s = e.m00,
            n = e.m01,
            r = e.m02,
            a = e.m03,
            o = e.m04,
            h = e.m05,
            l = e.m06,
            c = e.m07,
            u = e.m08,
            _ = Math.sin(i),
            d = Math.cos(i);
          return (
            (t.m00 = d * s + _ * a),
            (t.m01 = d * n + _ * o),
            (t.m02 = d * r + _ * h),
            (t.m03 = d * a - _ * s),
            (t.m04 = d * o - _ * n),
            (t.m05 = d * h - _ * r),
            (t.m06 = l),
            (t.m07 = c),
            (t.m08 = u),
            t
          );
        }
        static fromMat4(t, e) {
          return (
            (t.m00 = e.m00),
            (t.m01 = e.m01),
            (t.m02 = e.m02),
            (t.m03 = e.m04),
            (t.m04 = e.m05),
            (t.m05 = e.m06),
            (t.m06 = e.m08),
            (t.m07 = e.m09),
            (t.m08 = e.m10),
            t
          );
        }
        static fromViewUp(t, e, i) {
          return Yi.lengthSqr(e) < gi * gi
            ? (es.identity(t), t)
            : ((i = i || Yi.UNIT_Y),
              Yi.normalize(is, Yi.cross(is, i, e)),
              Yi.lengthSqr(is) < gi * gi
                ? (es.identity(t), t)
                : (Yi.cross(ss, e, is),
                  es.set(t, is.x, is.y, is.z, ss.x, ss.y, ss.z, e.x, e.y, e.z),
                  t));
        }
        static fromTranslation(t, e) {
          return (
            (t.m00 = 1),
            (t.m01 = 0),
            (t.m02 = 0),
            (t.m03 = 0),
            (t.m04 = 1),
            (t.m05 = 0),
            (t.m06 = e.x),
            (t.m07 = e.y),
            (t.m08 = 1),
            t
          );
        }
        static fromScaling(t, e) {
          return (
            (t.m00 = e.x),
            (t.m01 = 0),
            (t.m02 = 0),
            (t.m03 = 0),
            (t.m04 = e.y),
            (t.m05 = 0),
            (t.m06 = 0),
            (t.m07 = 0),
            (t.m08 = 1),
            t
          );
        }
        static fromRotation(t, e) {
          const i = Math.sin(e),
            s = Math.cos(e);
          return (
            (t.m00 = s),
            (t.m01 = i),
            (t.m02 = 0),
            (t.m03 = -i),
            (t.m04 = s),
            (t.m05 = 0),
            (t.m06 = 0),
            (t.m07 = 0),
            (t.m08 = 1),
            t
          );
        }
        static fromQuat(t, e) {
          const i = e.x,
            s = e.y,
            n = e.z,
            r = e.w,
            a = i + i,
            o = s + s,
            h = n + n,
            l = i * a,
            c = s * a,
            u = s * o,
            _ = n * a,
            d = n * o,
            p = n * h,
            m = r * a,
            f = r * o,
            g = r * h;
          return (
            (t.m00 = 1 - u - p),
            (t.m03 = c - g),
            (t.m06 = _ + f),
            (t.m01 = c + g),
            (t.m04 = 1 - l - p),
            (t.m07 = d - m),
            (t.m02 = _ - f),
            (t.m05 = d + m),
            (t.m08 = 1 - l - u),
            t
          );
        }
        static inverseTransposeMat4(t, e) {
          const i = e.m00,
            s = e.m01,
            n = e.m02,
            r = e.m03,
            a = e.m04,
            o = e.m05,
            h = e.m06,
            l = e.m07,
            c = e.m08,
            u = e.m09,
            _ = e.m10,
            d = e.m11,
            p = e.m12,
            m = e.m13,
            f = e.m14,
            g = e.m15,
            y = i * o - s * a,
            T = i * h - n * a,
            S = i * l - r * a,
            E = s * h - n * o,
            v = s * l - r * o,
            b = n * l - r * h,
            A = c * m - u * p,
            C = c * f - _ * p,
            O = c * g - d * p,
            I = u * f - _ * m,
            w = u * g - d * m,
            R = _ * g - d * f;
          let D = y * R - T * w + S * I + E * O - v * C + b * A;
          return D
            ? ((D = 1 / D),
              (t.m00 = (o * R - h * w + l * I) * D),
              (t.m01 = (h * O - a * R - l * C) * D),
              (t.m02 = (a * w - o * O + l * A) * D),
              (t.m03 = (n * w - s * R - r * I) * D),
              (t.m04 = (i * R - n * O + r * C) * D),
              (t.m05 = (s * O - i * w - r * A) * D),
              (t.m06 = (m * b - f * v + g * E) * D),
              (t.m07 = (f * S - p * b - g * T) * D),
              (t.m08 = (p * v - m * S + g * y) * D),
              t)
            : null;
        }
        static toArray(t, e, i = 0) {
          return (
            (t[i + 0] = e.m00),
            (t[i + 1] = e.m01),
            (t[i + 2] = e.m02),
            (t[i + 3] = e.m03),
            (t[i + 4] = e.m04),
            (t[i + 5] = e.m05),
            (t[i + 6] = e.m06),
            (t[i + 7] = e.m07),
            (t[i + 8] = e.m08),
            t
          );
        }
        static fromArray(t, e, i = 0) {
          return (
            (t.m00 = e[i + 0]),
            (t.m01 = e[i + 1]),
            (t.m02 = e[i + 2]),
            (t.m03 = e[i + 3]),
            (t.m04 = e[i + 4]),
            (t.m05 = e[i + 5]),
            (t.m06 = e[i + 6]),
            (t.m07 = e[i + 7]),
            (t.m08 = e[i + 8]),
            t
          );
        }
        static add(t, e, i) {
          return (
            (t.m00 = e.m00 + i.m00),
            (t.m01 = e.m01 + i.m01),
            (t.m02 = e.m02 + i.m02),
            (t.m03 = e.m03 + i.m03),
            (t.m04 = e.m04 + i.m04),
            (t.m05 = e.m05 + i.m05),
            (t.m06 = e.m06 + i.m06),
            (t.m07 = e.m07 + i.m07),
            (t.m08 = e.m08 + i.m08),
            t
          );
        }
        static subtract(t, e, i) {
          return (
            (t.m00 = e.m00 - i.m00),
            (t.m01 = e.m01 - i.m01),
            (t.m02 = e.m02 - i.m02),
            (t.m03 = e.m03 - i.m03),
            (t.m04 = e.m04 - i.m04),
            (t.m05 = e.m05 - i.m05),
            (t.m06 = e.m06 - i.m06),
            (t.m07 = e.m07 - i.m07),
            (t.m08 = e.m08 - i.m08),
            t
          );
        }
        static multiplyScalar(t, e, i) {
          return (
            (t.m00 = e.m00 * i),
            (t.m01 = e.m01 * i),
            (t.m02 = e.m02 * i),
            (t.m03 = e.m03 * i),
            (t.m04 = e.m04 * i),
            (t.m05 = e.m05 * i),
            (t.m06 = e.m06 * i),
            (t.m07 = e.m07 * i),
            (t.m08 = e.m08 * i),
            t
          );
        }
        static multiplyScalarAndAdd(t, e, i, s) {
          return (
            (t.m00 = i.m00 * s + e.m00),
            (t.m01 = i.m01 * s + e.m01),
            (t.m02 = i.m02 * s + e.m02),
            (t.m03 = i.m03 * s + e.m03),
            (t.m04 = i.m04 * s + e.m04),
            (t.m05 = i.m05 * s + e.m05),
            (t.m06 = i.m06 * s + e.m06),
            (t.m07 = i.m07 * s + e.m07),
            (t.m08 = i.m08 * s + e.m08),
            t
          );
        }
        static strictEquals(t, e) {
          return (
            t.m00 === e.m00 &&
            t.m01 === e.m01 &&
            t.m02 === e.m02 &&
            t.m03 === e.m03 &&
            t.m04 === e.m04 &&
            t.m05 === e.m05 &&
            t.m06 === e.m06 &&
            t.m07 === e.m07 &&
            t.m08 === e.m08
          );
        }
        static equals(t, e, i = gi) {
          return (
            Math.abs(t.m00 - e.m00) <=
              i * Math.max(1, Math.abs(t.m00), Math.abs(e.m00)) &&
            Math.abs(t.m01 - e.m01) <=
              i * Math.max(1, Math.abs(t.m01), Math.abs(e.m01)) &&
            Math.abs(t.m02 - e.m02) <=
              i * Math.max(1, Math.abs(t.m02), Math.abs(e.m02)) &&
            Math.abs(t.m03 - e.m03) <=
              i * Math.max(1, Math.abs(t.m03), Math.abs(e.m03)) &&
            Math.abs(t.m04 - e.m04) <=
              i * Math.max(1, Math.abs(t.m04), Math.abs(e.m04)) &&
            Math.abs(t.m05 - e.m05) <=
              i * Math.max(1, Math.abs(t.m05), Math.abs(e.m05)) &&
            Math.abs(t.m06 - e.m06) <=
              i * Math.max(1, Math.abs(t.m06), Math.abs(e.m06)) &&
            Math.abs(t.m07 - e.m07) <=
              i * Math.max(1, Math.abs(t.m07), Math.abs(e.m07)) &&
            Math.abs(t.m08 - e.m08) <=
              i * Math.max(1, Math.abs(t.m08), Math.abs(e.m08))
          );
        }
        static toEuler(t, e) {
          const i = t.m00,
            s = t.m01;
          t.m02;
          const n = t.m03,
            r = t.m04;
          t.m05;
          const a = t.m06,
            o = t.m07,
            h = t.m08;
          return o < 0.999
            ? o > -0.999
              ? ((e.x = Math.asin(-o)),
                (e.y = Math.atan2(a, h)),
                (e.z = Math.atan2(s, r)),
                !0)
              : ((e.x = mi), (e.y = Math.atan2(n, i)), (e.z = 0), !1)
            : ((e.x = -mi), (e.y = Math.atan2(-n, i)), (e.z = 0), !1);
        }
        constructor(
          t = 1,
          e = 0,
          i = 0,
          s = 0,
          n = 1,
          r = 0,
          a = 0,
          o = 0,
          h = 1
        ) {
          super(),
            "object" == typeof t
              ? ((this.m00 = t.m00),
                (this.m01 = t.m01),
                (this.m02 = t.m02),
                (this.m03 = t.m03),
                (this.m04 = t.m04),
                (this.m05 = t.m05),
                (this.m06 = t.m06),
                (this.m07 = t.m07),
                (this.m08 = t.m08))
              : ((this.m00 = t),
                (this.m01 = e),
                (this.m02 = i),
                (this.m03 = s),
                (this.m04 = n),
                (this.m05 = r),
                (this.m06 = a),
                (this.m07 = o),
                (this.m08 = h));
        }
        clone() {
          const t = this;
          return new es(
            t.m00,
            t.m01,
            t.m02,
            t.m03,
            t.m04,
            t.m05,
            t.m06,
            t.m07,
            t.m08
          );
        }
        set(t = 1, e = 0, i = 0, s = 0, n = 1, r = 0, a = 0, o = 0, h = 1) {
          return (
            "object" == typeof t
              ? ((this.m00 = t.m00),
                (this.m01 = t.m01),
                (this.m02 = t.m02),
                (this.m03 = t.m03),
                (this.m04 = t.m04),
                (this.m05 = t.m05),
                (this.m06 = t.m06),
                (this.m07 = t.m07),
                (this.m08 = t.m08))
              : ((this.m00 = t),
                (this.m01 = e),
                (this.m02 = i),
                (this.m03 = s),
                (this.m04 = n),
                (this.m05 = r),
                (this.m06 = a),
                (this.m07 = o),
                (this.m08 = h)),
            this
          );
        }
        equals(t, e = gi) {
          return (
            Math.abs(this.m00 - t.m00) <=
              e * Math.max(1, Math.abs(this.m00), Math.abs(t.m00)) &&
            Math.abs(this.m01 - t.m01) <=
              e * Math.max(1, Math.abs(this.m01), Math.abs(t.m01)) &&
            Math.abs(this.m02 - t.m02) <=
              e * Math.max(1, Math.abs(this.m02), Math.abs(t.m02)) &&
            Math.abs(this.m03 - t.m03) <=
              e * Math.max(1, Math.abs(this.m03), Math.abs(t.m03)) &&
            Math.abs(this.m04 - t.m04) <=
              e * Math.max(1, Math.abs(this.m04), Math.abs(t.m04)) &&
            Math.abs(this.m05 - t.m05) <=
              e * Math.max(1, Math.abs(this.m05), Math.abs(t.m05)) &&
            Math.abs(this.m06 - t.m06) <=
              e * Math.max(1, Math.abs(this.m06), Math.abs(t.m06)) &&
            Math.abs(this.m07 - t.m07) <=
              e * Math.max(1, Math.abs(this.m07), Math.abs(t.m07)) &&
            Math.abs(this.m08 - t.m08) <=
              e * Math.max(1, Math.abs(this.m08), Math.abs(t.m08))
          );
        }
        strictEquals(t) {
          return (
            this.m00 === t.m00 &&
            this.m01 === t.m01 &&
            this.m02 === t.m02 &&
            this.m03 === t.m03 &&
            this.m04 === t.m04 &&
            this.m05 === t.m05 &&
            this.m06 === t.m06 &&
            this.m07 === t.m07 &&
            this.m08 === t.m08
          );
        }
        toString() {
          const t = this;
          return `[\n${t.m00}, ${t.m01}, ${t.m02},\n${t.m03},\n${t.m04}, ${t.m05},\n${t.m06}, ${t.m07},\n${t.m08}\n]`;
        }
        identity() {
          return (
            (this.m00 = 1),
            (this.m01 = 0),
            (this.m02 = 0),
            (this.m03 = 0),
            (this.m04 = 1),
            (this.m05 = 0),
            (this.m06 = 0),
            (this.m07 = 0),
            (this.m08 = 1),
            this
          );
        }
        transpose() {
          const t = this.m01,
            e = this.m02,
            i = this.m05;
          return (
            (this.m01 = this.m03),
            (this.m02 = this.m06),
            (this.m03 = t),
            (this.m05 = this.m07),
            (this.m06 = e),
            (this.m07 = i),
            this
          );
        }
        invert() {
          const t = this.m00,
            e = this.m01,
            i = this.m02,
            s = this.m03,
            n = this.m04,
            r = this.m05,
            a = this.m06,
            o = this.m07,
            h = this.m08,
            l = h * n - r * o,
            c = -h * s + r * a,
            u = o * s - n * a;
          let _ = t * l + e * c + i * u;
          return 0 === _
            ? (this.set(0, 0, 0, 0, 0, 0, 0, 0, 0), this)
            : ((_ = 1 / _),
              (this.m00 = l * _),
              (this.m01 = (-h * e + i * o) * _),
              (this.m02 = (r * e - i * n) * _),
              (this.m03 = c * _),
              (this.m04 = (h * t - i * a) * _),
              (this.m05 = (-r * t + i * s) * _),
              (this.m06 = u * _),
              (this.m07 = (-o * t + e * a) * _),
              (this.m08 = (n * t - e * s) * _),
              this);
        }
        determinant() {
          const t = this.m00,
            e = this.m01,
            i = this.m02,
            s = this.m03,
            n = this.m04,
            r = this.m05,
            a = this.m06,
            o = this.m07,
            h = this.m08;
          return (
            t * (h * n - r * o) + e * (-h * s + r * a) + i * (o * s - n * a)
          );
        }
        add(t) {
          return (
            (this.m00 += t.m00),
            (this.m01 += t.m01),
            (this.m02 += t.m02),
            (this.m03 += t.m03),
            (this.m04 += t.m04),
            (this.m05 += t.m05),
            (this.m06 += t.m06),
            (this.m07 += t.m07),
            (this.m08 += t.m08),
            this
          );
        }
        subtract(t) {
          return (
            (this.m00 -= t.m00),
            (this.m01 -= t.m01),
            (this.m02 -= t.m02),
            (this.m03 -= t.m03),
            (this.m04 -= t.m04),
            (this.m05 -= t.m05),
            (this.m06 -= t.m06),
            (this.m07 -= t.m07),
            (this.m08 -= t.m08),
            this
          );
        }
        multiply(t) {
          const e = this.m00,
            i = this.m01,
            s = this.m02,
            n = this.m03,
            r = this.m04,
            a = this.m05,
            o = this.m06,
            h = this.m07,
            l = this.m08,
            c = t.m00,
            u = t.m01,
            _ = t.m02,
            d = t.m03,
            p = t.m04,
            m = t.m05,
            f = t.m06,
            g = t.m07,
            y = t.m08;
          return (
            (this.m00 = c * e + u * n + _ * o),
            (this.m01 = c * i + u * r + _ * h),
            (this.m02 = c * s + u * a + _ * l),
            (this.m03 = d * e + p * n + m * o),
            (this.m04 = d * i + p * r + m * h),
            (this.m05 = d * s + p * a + m * l),
            (this.m06 = f * e + g * n + y * o),
            (this.m07 = f * i + g * r + y * h),
            (this.m08 = f * s + g * a + y * l),
            this
          );
        }
        multiplyScalar(t) {
          return (
            (this.m00 *= t),
            (this.m01 *= t),
            (this.m02 *= t),
            (this.m03 *= t),
            (this.m04 *= t),
            (this.m05 *= t),
            (this.m06 *= t),
            (this.m07 *= t),
            (this.m08 *= t),
            this
          );
        }
        scale(t) {
          const e = t.x,
            i = t.y;
          return (
            (this.m00 *= e),
            (this.m01 *= e),
            (this.m02 *= e),
            (this.m03 *= i),
            (this.m04 *= i),
            (this.m05 *= i),
            this
          );
        }
        rotate(t) {
          const e = this.m00,
            i = this.m01,
            s = this.m02,
            n = this.m03,
            r = this.m04,
            a = this.m05,
            o = this.m06,
            h = this.m07,
            l = this.m08,
            c = Math.sin(t),
            u = Math.cos(t);
          return (
            (this.m00 = u * e + c * n),
            (this.m01 = u * i + c * r),
            (this.m02 = u * s + c * a),
            (this.m03 = u * n - c * e),
            (this.m04 = u * r - c * i),
            (this.m05 = u * a - c * s),
            (this.m06 = o),
            (this.m07 = h),
            (this.m08 = l),
            this
          );
        }
        fromQuat(t) {
          const e = t.x,
            i = t.y,
            s = t.z,
            n = t.w,
            r = e + e,
            a = i + i,
            o = s + s,
            h = e * r,
            l = i * r,
            c = i * a,
            u = s * r,
            _ = s * a,
            d = s * o,
            p = n * r,
            m = n * a,
            f = n * o;
          return (
            (this.m00 = 1 - c - d),
            (this.m03 = l - f),
            (this.m06 = u + m),
            (this.m01 = l + f),
            (this.m04 = 1 - h - d),
            (this.m07 = _ - p),
            (this.m02 = u - m),
            (this.m05 = _ + p),
            (this.m08 = 1 - h - c),
            this
          );
        }
      }
      t("Mat3", es), (ts = es), (es.IDENTITY = Object.freeze(new ts()));
      const is = new Yi(),
        ss = new Yi();
      var rs;
      hi.fastDefine("cc.Mat3", es, {
        m00: 1,
        m01: 0,
        m02: 0,
        m03: 0,
        m04: 1,
        m05: 0,
        m06: 0,
        m07: 0,
        m08: 1,
      }),
        (a.Mat3 = es);
      class as extends pe {
        static clone(t) {
          return new as(t.x, t.y, t.z, t.w);
        }
        static copy(t, e) {
          return (t.x = e.x), (t.y = e.y), (t.z = e.z), (t.w = e.w), t;
        }
        static set(t, e, i, s, n) {
          return (t.x = e), (t.y = i), (t.z = s), (t.w = n), t;
        }
        static identity(t) {
          return (t.x = 0), (t.y = 0), (t.z = 0), (t.w = 1), t;
        }
        static rotationTo(t, e, i) {
          const s = Yi.dot(e, i);
          return s < -0.999999
            ? (Yi.cross(ls, Yi.UNIT_X, e),
              ls.length() < 1e-6 && Yi.cross(ls, Yi.UNIT_Y, e),
              Yi.normalize(ls, ls),
              as.fromAxisAngle(t, ls, Math.PI),
              t)
            : s > 0.999999
            ? ((t.x = 0), (t.y = 0), (t.z = 0), (t.w = 1), t)
            : (Yi.cross(ls, e, i),
              (t.x = ls.x),
              (t.y = ls.y),
              (t.z = ls.z),
              (t.w = 1 + s),
              as.normalize(t, t));
        }
        static getAxisAngle(t, e) {
          const i = 2 * Math.acos(e.w),
            s = Math.sin(i / 2);
          return (
            0 !== s
              ? ((t.x = e.x / s), (t.y = e.y / s), (t.z = e.z / s))
              : ((t.x = 1), (t.y = 0), (t.z = 0)),
            i
          );
        }
        static multiply(t, e, i) {
          const s = e.x * i.w + e.w * i.x + e.y * i.z - e.z * i.y,
            n = e.y * i.w + e.w * i.y + e.z * i.x - e.x * i.z,
            r = e.z * i.w + e.w * i.z + e.x * i.y - e.y * i.x,
            a = e.w * i.w - e.x * i.x - e.y * i.y - e.z * i.z;
          return (t.x = s), (t.y = n), (t.z = r), (t.w = a), t;
        }
        static multiplyScalar(t, e, i) {
          return (
            (t.x = e.x * i),
            (t.y = e.y * i),
            (t.z = e.z * i),
            (t.w = e.w * i),
            t
          );
        }
        static scaleAndAdd(t, e, i, s) {
          return (
            (t.x = e.x + i.x * s),
            (t.y = e.y + i.y * s),
            (t.z = e.z + i.z * s),
            (t.w = e.w + i.w * s),
            t
          );
        }
        static rotateX(t, e, i) {
          i *= 0.5;
          const s = Math.sin(i),
            n = Math.cos(i),
            { x: r, y: a, z: o, w: h } = e;
          return (
            (t.x = r * n + h * s),
            (t.y = a * n + o * s),
            (t.z = o * n - a * s),
            (t.w = h * n - r * s),
            t
          );
        }
        static rotateY(t, e, i) {
          i *= 0.5;
          const s = Math.sin(i),
            n = Math.cos(i),
            { x: r, y: a, z: o, w: h } = e;
          return (
            (t.x = r * n - o * s),
            (t.y = a * n + h * s),
            (t.z = o * n + r * s),
            (t.w = h * n - a * s),
            t
          );
        }
        static rotateZ(t, e, i) {
          i *= 0.5;
          const s = Math.sin(i),
            n = Math.cos(i),
            { x: r, y: a, z: o, w: h } = e;
          return (
            (t.x = r * n + a * s),
            (t.y = a * n - r * s),
            (t.z = o * n + h * s),
            (t.w = h * n - o * s),
            t
          );
        }
        static rotateAround(t, e, i, s) {
          return (
            as.invert(os, e),
            Yi.transformQuat(ls, i, os),
            as.fromAxisAngle(os, ls, s),
            as.multiply(t, e, os),
            t
          );
        }
        static rotateAroundLocal(t, e, i, s) {
          return as.fromAxisAngle(os, i, s), as.multiply(t, e, os), t;
        }
        static calculateW(t, e) {
          return (
            (t.x = e.x),
            (t.y = e.y),
            (t.z = e.z),
            (t.w = Math.sqrt(Math.abs(1 - e.x * e.x - e.y * e.y - e.z * e.z))),
            t
          );
        }
        static dot(t, e) {
          return t.x * e.x + t.y * e.y + t.z * e.z + t.w * e.w;
        }
        static lerp(t, e, i, s) {
          return (
            (t.x = e.x + s * (i.x - e.x)),
            (t.y = e.y + s * (i.y - e.y)),
            (t.z = e.z + s * (i.z - e.z)),
            (t.w = e.w + s * (i.w - e.w)),
            t
          );
        }
        static slerp(t, e, i, s) {
          let n = 0,
            r = 0,
            a = i.x,
            o = i.y,
            h = i.z,
            l = i.w,
            c = e.x * i.x + e.y * i.y + e.z * i.z + e.w * i.w;
          if (
            (c < 0 && ((c = -c), (a = -a), (o = -o), (h = -h), (l = -l)),
            1 - c > 1e-6)
          ) {
            const t = Math.acos(c),
              e = Math.sin(t);
            (n = Math.sin((1 - s) * t) / e), (r = Math.sin(s * t) / e);
          } else (n = 1 - s), (r = s);
          return (
            (t.x = n * e.x + r * a),
            (t.y = n * e.y + r * o),
            (t.z = n * e.z + r * h),
            (t.w = n * e.w + r * l),
            t
          );
        }
        static sqlerp(t, e, i, s, n, r) {
          return (
            as.slerp(os, e, n, r),
            as.slerp(hs, i, s, r),
            as.slerp(t, os, hs, 2 * r * (1 - r)),
            t
          );
        }
        static invert(t, e) {
          const i = e.x * e.x + e.y * e.y + e.z * e.z + e.w * e.w,
            s = i ? 1 / i : 0;
          return (
            (t.x = -e.x * s),
            (t.y = -e.y * s),
            (t.z = -e.z * s),
            (t.w = e.w * s),
            t
          );
        }
        static conjugate(t, e) {
          return (t.x = -e.x), (t.y = -e.y), (t.z = -e.z), (t.w = e.w), t;
        }
        static len(t) {
          return Math.sqrt(t.x * t.x + t.y * t.y + t.z * t.z + t.w * t.w);
        }
        static lengthSqr(t) {
          return t.x * t.x + t.y * t.y + t.z * t.z + t.w * t.w;
        }
        static normalize(t, e) {
          let i = e.x * e.x + e.y * e.y + e.z * e.z + e.w * e.w;
          return (
            i > 0
              ? ((i = 1 / Math.sqrt(i)),
                (t.x = e.x * i),
                (t.y = e.y * i),
                (t.z = e.z * i),
                (t.w = e.w * i))
              : ((t.x = 0), (t.y = 0), (t.z = 0), (t.w = 0)),
            t
          );
        }
        static fromAxes(t, e, i, s) {
          return (
            es.set(cs, e.x, e.y, e.z, i.x, i.y, i.z, s.x, s.y, s.z),
            as.normalize(t, as.fromMat3(t, cs))
          );
        }
        static fromViewUp(t, e, i) {
          return es.fromViewUp(cs, e, i), as.normalize(t, as.fromMat3(t, cs));
        }
        static fromAxisAngle(t, e, i) {
          i *= 0.5;
          const s = Math.sin(i);
          return (
            (t.x = s * e.x),
            (t.y = s * e.y),
            (t.z = s * e.z),
            (t.w = Math.cos(i)),
            t
          );
        }
        static fromMat3(t, e) {
          const {
              m00: i,
              m01: s,
              m02: n,
              m03: r,
              m04: a,
              m05: o,
              m06: h,
              m07: l,
              m08: c,
            } = e,
            u = i - a - c,
            _ = a - i - c,
            d = c - i - a;
          let p = 0,
            m = i + a + c;
          u > m && ((m = u), (p = 1)),
            _ > m && ((m = _), (p = 2)),
            d > m && ((m = d), (p = 3));
          const f = 0.5 * Math.sqrt(m + 1),
            g = 0.25 / f;
          switch (p) {
            case 0:
              (t.w = f),
                (t.x = (o - l) * g),
                (t.y = (h - n) * g),
                (t.z = (s - r) * g);
              break;
            case 1:
              (t.w = (o - l) * g),
                (t.x = f),
                (t.y = (s + r) * g),
                (t.z = (h + n) * g);
              break;
            case 2:
              (t.w = (h - n) * g),
                (t.x = (s + r) * g),
                (t.y = f),
                (t.z = (o + l) * g);
              break;
            case 3:
              (t.w = (s - r) * g),
                (t.x = (h + n) * g),
                (t.y = (o + l) * g),
                (t.z = f);
              break;
            default:
              (t.w = 1), (t.x = 0), (t.y = 0), (t.z = 0);
          }
          return t;
        }
        static fromEuler(t, e, i, s) {
          (e *= us), (i *= us), (s *= us);
          const n = Math.sin(e),
            r = Math.cos(e),
            a = Math.sin(i),
            o = Math.cos(i),
            h = Math.sin(s),
            l = Math.cos(s);
          return (
            (t.x = n * o * l + r * a * h),
            (t.y = r * a * l + n * o * h),
            (t.z = r * o * h - n * a * l),
            (t.w = r * o * l - n * a * h),
            t
          );
        }
        static fromAngleZ(t, e) {
          return (
            (e *= us),
            (t.x = t.y = 0),
            (t.z = Math.sin(e)),
            (t.w = Math.cos(e)),
            t
          );
        }
        static toAxisX(t, e) {
          const i = 2 * e.y,
            s = 2 * e.z;
          return (
            (t.x = 1 - i * e.y - s * e.z),
            (t.y = i * e.x + s * e.w),
            (t.z = s * e.x - i * e.w),
            t
          );
        }
        static toAxisY(t, e) {
          const i = 2 * e.x,
            s = 2 * e.y,
            n = 2 * e.z;
          return (
            (t.x = s * e.x - n * e.w),
            (t.y = 1 - i * e.x - n * e.z),
            (t.z = n * e.y + i * e.w),
            t
          );
        }
        static toAxisZ(t, e) {
          const i = 2 * e.x,
            s = 2 * e.y,
            n = 2 * e.z;
          return (
            (t.x = n * e.x + s * e.w),
            (t.y = n * e.y - i * e.w),
            (t.z = 1 - i * e.x - s * e.y),
            t
          );
        }
        static toEuler(t, e, i) {
          const { x: s, y: n, z: r, w: a } = e;
          let o = 0,
            h = 0,
            l = 0;
          const c = s * n + r * a;
          if (c > 0.499999) (o = 0), (h = Ai(2 * Math.atan2(s, a))), (l = 90);
          else if (c < -0.499999)
            (o = 0), (h = -Ai(2 * Math.atan2(s, a))), (l = -90);
          else {
            const t = s * s,
              e = n * n,
              u = r * r;
            (o = Ai(Math.atan2(2 * s * a - 2 * n * r, 1 - 2 * t - 2 * u))),
              (h = Ai(Math.atan2(2 * n * a - 2 * s * r, 1 - 2 * e - 2 * u))),
              (l = Ai(Math.asin(2 * c))),
              i &&
                ((o = -180 * Math.sign(o + 1e-6) + o),
                (h = -180 * Math.sign(h + 1e-6) + h),
                (l = 180 * Math.sign(l + 1e-6) - l));
          }
          return (t.x = o), (t.y = h), (t.z = l), t;
        }
        static toEulerInYXZOrder(t, e) {
          es.fromQuat(cs, e),
            es.toEuler(cs, t),
            (t.x = Ai(t.x)),
            (t.y = Ai(t.y)),
            (t.z = Ai(t.z));
        }
        static toArray(t, e, i = 0) {
          return (
            (t[i + 0] = e.x),
            (t[i + 1] = e.y),
            (t[i + 2] = e.z),
            (t[i + 3] = e.w),
            t
          );
        }
        static fromArray(t, e, i = 0) {
          return (
            (t.x = e[i + 0]),
            (t.y = e[i + 1]),
            (t.z = e[i + 2]),
            (t.w = e[i + 3]),
            t
          );
        }
        static strictEquals(t, e) {
          return t.x === e.x && t.y === e.y && t.z === e.z && t.w === e.w;
        }
        static equals(t, e, i = gi) {
          return (
            Math.abs(t.x - e.x) <=
              i * Math.max(1, Math.abs(t.x), Math.abs(e.x)) &&
            Math.abs(t.y - e.y) <=
              i * Math.max(1, Math.abs(t.y), Math.abs(e.y)) &&
            Math.abs(t.z - e.z) <=
              i * Math.max(1, Math.abs(t.z), Math.abs(e.z)) &&
            Math.abs(t.w - e.w) <= i * Math.max(1, Math.abs(t.w), Math.abs(e.w))
          );
        }
        static angle(t, e) {
          const i = Math.min(Math.abs(as.dot(t, e)), 1);
          return 2 * Math.acos(i);
        }
        static rotateTowards(t, e, i, s) {
          const n = as.angle(e, i);
          if (0 === n)
            return (t.x = i.x), (t.y = i.y), (t.z = i.z), (t.w = i.w), t;
          const r = Math.min(s / Ai(n), 1);
          return as.slerp(t, e, i, r);
        }
        constructor(t, e, i, s) {
          super(),
            "object" == typeof t
              ? ((this.x = t.x), (this.y = t.y), (this.z = t.z), (this.w = t.w))
              : ((this.x = t || 0),
                (this.y = e || 0),
                (this.z = i || 0),
                (this.w = null != s ? s : 1));
        }
        clone() {
          return new as(this.x, this.y, this.z, this.w);
        }
        set(t, e, i, s) {
          return (
            "object" == typeof t
              ? ((this.x = t.x), (this.y = t.y), (this.z = t.z), (this.w = t.w))
              : ((this.x = t || 0),
                (this.y = e || 0),
                (this.z = i || 0),
                (this.w = null != s ? s : 1)),
            this
          );
        }
        equals(t, e = gi) {
          return (
            Math.abs(this.x - t.x) <=
              e * Math.max(1, Math.abs(this.x), Math.abs(t.x)) &&
            Math.abs(this.y - t.y) <=
              e * Math.max(1, Math.abs(this.y), Math.abs(t.y)) &&
            Math.abs(this.z - t.z) <=
              e * Math.max(1, Math.abs(this.z), Math.abs(t.z)) &&
            Math.abs(this.w - t.w) <=
              e * Math.max(1, Math.abs(this.w), Math.abs(t.w))
          );
        }
        strictEquals(t) {
          return (
            t &&
            this.x === t.x &&
            this.y === t.y &&
            this.z === t.z &&
            this.w === t.w
          );
        }
        getEulerAngles(t) {
          return as.toEuler(t, this);
        }
        lerp(t, e) {
          return (
            (this.x += e * (t.x - this.x)),
            (this.y += e * (t.y - this.y)),
            (this.z += e * (t.z - this.z)),
            (this.w += e * (t.w - this.w)),
            this
          );
        }
        slerp(t, e) {
          return as.slerp(this, this, t, e);
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        lengthSqr() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
      }
      t("Quat", as), (rs = as), (as.IDENTITY = Object.freeze(new rs()));
      const os = new as(),
        hs = new as(),
        ls = new Yi(),
        cs = new es(),
        us = (0.5 * Math.PI) / 180;
      function _s(t = 0, e = 0, i = 0, s = 1) {
        return new as(t, e, i, s);
      }
      var ds;
      hi.fastDefine("cc.Quat", as, { x: 0, y: 0, z: 0, w: 1 }),
        (a.Quat = as),
        (a.quat = _s);
      const ps = t(
        "preTransforms",
        Object.freeze([
          Object.freeze([1, 0, 0, 1]),
          Object.freeze([0, 1, -1, 0]),
          Object.freeze([-1, 0, 0, -1]),
          Object.freeze([0, -1, 1, 0]),
        ])
      );
      class ms extends pe {
        static clone(t) {
          return new ms(
            t.m00,
            t.m01,
            t.m02,
            t.m03,
            t.m04,
            t.m05,
            t.m06,
            t.m07,
            t.m08,
            t.m09,
            t.m10,
            t.m11,
            t.m12,
            t.m13,
            t.m14,
            t.m15
          );
        }
        static copy(t, e) {
          return (
            (t.m00 = e.m00),
            (t.m01 = e.m01),
            (t.m02 = e.m02),
            (t.m03 = e.m03),
            (t.m04 = e.m04),
            (t.m05 = e.m05),
            (t.m06 = e.m06),
            (t.m07 = e.m07),
            (t.m08 = e.m08),
            (t.m09 = e.m09),
            (t.m10 = e.m10),
            (t.m11 = e.m11),
            (t.m12 = e.m12),
            (t.m13 = e.m13),
            (t.m14 = e.m14),
            (t.m15 = e.m15),
            t
          );
        }
        static set(t, e, i, s, n, r, a, o, h, l, c, u, _, d, p, m, f) {
          return (
            (t.m00 = e),
            (t.m01 = i),
            (t.m02 = s),
            (t.m03 = n),
            (t.m04 = r),
            (t.m05 = a),
            (t.m06 = o),
            (t.m07 = h),
            (t.m08 = l),
            (t.m09 = c),
            (t.m10 = u),
            (t.m11 = _),
            (t.m12 = d),
            (t.m13 = p),
            (t.m14 = m),
            (t.m15 = f),
            t
          );
        }
        static identity(t) {
          return (
            (t.m00 = 1),
            (t.m01 = 0),
            (t.m02 = 0),
            (t.m03 = 0),
            (t.m04 = 0),
            (t.m05 = 1),
            (t.m06 = 0),
            (t.m07 = 0),
            (t.m08 = 0),
            (t.m09 = 0),
            (t.m10 = 1),
            (t.m11 = 0),
            (t.m12 = 0),
            (t.m13 = 0),
            (t.m14 = 0),
            (t.m15 = 1),
            t
          );
        }
        static transpose(t, e) {
          if (t === e) {
            const i = e.m01,
              s = e.m02,
              n = e.m03,
              r = e.m06,
              a = e.m07,
              o = e.m11;
            (t.m01 = e.m04),
              (t.m02 = e.m08),
              (t.m03 = e.m12),
              (t.m04 = i),
              (t.m06 = e.m09),
              (t.m07 = e.m13),
              (t.m08 = s),
              (t.m09 = r),
              (t.m11 = e.m14),
              (t.m12 = n),
              (t.m13 = a),
              (t.m14 = o);
          } else
            (t.m00 = e.m00),
              (t.m01 = e.m04),
              (t.m02 = e.m08),
              (t.m03 = e.m12),
              (t.m04 = e.m01),
              (t.m05 = e.m05),
              (t.m06 = e.m09),
              (t.m07 = e.m13),
              (t.m08 = e.m02),
              (t.m09 = e.m06),
              (t.m10 = e.m10),
              (t.m11 = e.m14),
              (t.m12 = e.m03),
              (t.m13 = e.m07),
              (t.m14 = e.m11),
              (t.m15 = e.m15);
          return t;
        }
        static invert(t, e) {
          const i = e.m00,
            s = e.m01,
            n = e.m02,
            r = e.m03,
            a = e.m04,
            o = e.m05,
            h = e.m06,
            l = e.m07,
            c = e.m08,
            u = e.m09,
            _ = e.m10,
            d = e.m11,
            p = e.m12,
            m = e.m13,
            f = e.m14,
            g = e.m15,
            y = i * o - s * a,
            T = i * h - n * a,
            S = i * l - r * a,
            E = s * h - n * o,
            v = s * l - r * o,
            b = n * l - r * h,
            A = c * m - u * p,
            C = c * f - _ * p,
            O = c * g - d * p,
            I = u * f - _ * m,
            w = u * g - d * m,
            R = _ * g - d * f;
          let D = y * R - T * w + S * I + E * O - v * C + b * A;
          return 0 === D
            ? ((t.m00 = 0),
              (t.m01 = 0),
              (t.m02 = 0),
              (t.m03 = 0),
              (t.m04 = 0),
              (t.m05 = 0),
              (t.m06 = 0),
              (t.m07 = 0),
              (t.m08 = 0),
              (t.m09 = 0),
              (t.m10 = 0),
              (t.m11 = 0),
              (t.m12 = 0),
              (t.m13 = 0),
              (t.m14 = 0),
              (t.m15 = 0),
              t)
            : ((D = 1 / D),
              (t.m00 = (o * R - h * w + l * I) * D),
              (t.m01 = (n * w - s * R - r * I) * D),
              (t.m02 = (m * b - f * v + g * E) * D),
              (t.m03 = (_ * v - u * b - d * E) * D),
              (t.m04 = (h * O - a * R - l * C) * D),
              (t.m05 = (i * R - n * O + r * C) * D),
              (t.m06 = (f * S - p * b - g * T) * D),
              (t.m07 = (c * b - _ * S + d * T) * D),
              (t.m08 = (a * w - o * O + l * A) * D),
              (t.m09 = (s * O - i * w - r * A) * D),
              (t.m10 = (p * v - m * S + g * y) * D),
              (t.m11 = (u * S - c * v - d * y) * D),
              (t.m12 = (o * C - a * I - h * A) * D),
              (t.m13 = (i * I - s * C + n * A) * D),
              (t.m14 = (m * T - p * E - f * y) * D),
              (t.m15 = (c * E - u * T + _ * y) * D),
              t);
        }
        static determinant(t) {
          const e = t.m00,
            i = t.m01,
            s = t.m02,
            n = t.m03,
            r = t.m04,
            a = t.m05,
            o = t.m06,
            h = t.m07,
            l = t.m08,
            c = t.m09,
            u = t.m10,
            _ = t.m11,
            d = t.m12,
            p = t.m13,
            m = t.m14,
            f = t.m15;
          return (
            (e * a - i * r) * (u * f - _ * m) -
            (e * o - s * r) * (c * f - _ * p) +
            (e * h - n * r) * (c * m - u * p) +
            (i * o - s * a) * (l * f - _ * d) -
            (i * h - n * a) * (l * m - u * d) +
            (s * h - n * o) * (l * p - c * d)
          );
        }
        static multiply(t, e, i) {
          const s = e.m00,
            n = e.m01,
            r = e.m02,
            a = e.m03,
            o = e.m04,
            h = e.m05,
            l = e.m06,
            c = e.m07,
            u = e.m08,
            _ = e.m09,
            d = e.m10,
            p = e.m11,
            m = e.m12,
            f = e.m13,
            g = e.m14,
            y = e.m15;
          let T = i.m00,
            S = i.m01,
            E = i.m02,
            v = i.m03;
          return (
            (t.m00 = T * s + S * o + E * u + v * m),
            (t.m01 = T * n + S * h + E * _ + v * f),
            (t.m02 = T * r + S * l + E * d + v * g),
            (t.m03 = T * a + S * c + E * p + v * y),
            (T = i.m04),
            (S = i.m05),
            (E = i.m06),
            (v = i.m07),
            (t.m04 = T * s + S * o + E * u + v * m),
            (t.m05 = T * n + S * h + E * _ + v * f),
            (t.m06 = T * r + S * l + E * d + v * g),
            (t.m07 = T * a + S * c + E * p + v * y),
            (T = i.m08),
            (S = i.m09),
            (E = i.m10),
            (v = i.m11),
            (t.m08 = T * s + S * o + E * u + v * m),
            (t.m09 = T * n + S * h + E * _ + v * f),
            (t.m10 = T * r + S * l + E * d + v * g),
            (t.m11 = T * a + S * c + E * p + v * y),
            (T = i.m12),
            (S = i.m13),
            (E = i.m14),
            (v = i.m15),
            (t.m12 = T * s + S * o + E * u + v * m),
            (t.m13 = T * n + S * h + E * _ + v * f),
            (t.m14 = T * r + S * l + E * d + v * g),
            (t.m15 = T * a + S * c + E * p + v * y),
            t
          );
        }
        static transform(t, e, i) {
          const s = i.x,
            n = i.y,
            r = i.z;
          if (e === t)
            (t.m12 = e.m00 * s + e.m04 * n + e.m08 * r + e.m12),
              (t.m13 = e.m01 * s + e.m05 * n + e.m09 * r + e.m13),
              (t.m14 = e.m02 * s + e.m06 * n + e.m10 * r + e.m14),
              (t.m15 = e.m03 * s + e.m07 * n + e.m11 * r + e.m15);
          else {
            const i = e.m00,
              a = e.m01,
              o = e.m02,
              h = e.m03,
              l = e.m04,
              c = e.m05,
              u = e.m06,
              _ = e.m07,
              d = e.m08,
              p = e.m09,
              m = e.m10,
              f = e.m11;
            (t.m00 = i),
              (t.m01 = a),
              (t.m02 = o),
              (t.m03 = h),
              (t.m04 = l),
              (t.m05 = c),
              (t.m06 = u),
              (t.m07 = _),
              (t.m08 = d),
              (t.m09 = p),
              (t.m10 = m),
              (t.m11 = f),
              (t.m12 = i * s + l * n + d * r + e.m12),
              (t.m13 = a * s + c * n + p * r + e.m13),
              (t.m14 = o * s + u * n + m * r + e.m14),
              (t.m15 = h * s + _ * n + f * r + e.m15);
          }
          return t;
        }
        static translate(t, e, i) {
          return (
            e === t
              ? ((t.m12 += i.x), (t.m13 += i.y), (t.m14 += i.z))
              : ((t.m00 = e.m00),
                (t.m01 = e.m01),
                (t.m02 = e.m02),
                (t.m03 = e.m03),
                (t.m04 = e.m04),
                (t.m05 = e.m05),
                (t.m06 = e.m06),
                (t.m07 = e.m07),
                (t.m08 = e.m08),
                (t.m09 = e.m09),
                (t.m10 = e.m10),
                (t.m11 = e.m11),
                (t.m12 = e.m12 + i.x),
                (t.m13 = e.m13 + i.y),
                (t.m14 = e.m14 + i.z),
                (t.m15 = e.m15)),
            t
          );
        }
        static scale(t, e, i) {
          const s = i.x,
            n = i.y,
            r = i.z;
          return (
            (t.m00 = e.m00 * s),
            (t.m01 = e.m01 * s),
            (t.m02 = e.m02 * s),
            (t.m03 = e.m03 * s),
            (t.m04 = e.m04 * n),
            (t.m05 = e.m05 * n),
            (t.m06 = e.m06 * n),
            (t.m07 = e.m07 * n),
            (t.m08 = e.m08 * r),
            (t.m09 = e.m09 * r),
            (t.m10 = e.m10 * r),
            (t.m11 = e.m11 * r),
            (t.m12 = e.m12),
            (t.m13 = e.m13),
            (t.m14 = e.m14),
            (t.m15 = e.m15),
            t
          );
        }
        static rotate(t, e, i, s) {
          let n = s.x,
            r = s.y,
            a = s.z,
            o = Math.sqrt(n * n + r * r + a * a);
          if (Math.abs(o) < gi) return null;
          (o = 1 / o), (n *= o), (r *= o), (a *= o);
          const h = Math.sin(i),
            l = Math.cos(i),
            c = 1 - l,
            u = e.m00,
            _ = e.m01,
            d = e.m02,
            p = e.m03,
            m = e.m04,
            f = e.m05,
            g = e.m06,
            y = e.m07,
            T = e.m08,
            S = e.m09,
            E = e.m10,
            v = e.m11,
            b = n * n * c + l,
            A = r * n * c + a * h,
            C = a * n * c - r * h,
            O = n * r * c - a * h,
            I = r * r * c + l,
            w = a * r * c + n * h,
            R = n * a * c + r * h,
            D = r * a * c - n * h,
            x = a * a * c + l;
          return (
            (t.m00 = u * b + m * A + T * C),
            (t.m01 = _ * b + f * A + S * C),
            (t.m02 = d * b + g * A + E * C),
            (t.m03 = p * b + y * A + v * C),
            (t.m04 = u * O + m * I + T * w),
            (t.m05 = _ * O + f * I + S * w),
            (t.m06 = d * O + g * I + E * w),
            (t.m07 = p * O + y * I + v * w),
            (t.m08 = u * R + m * D + T * x),
            (t.m09 = _ * R + f * D + S * x),
            (t.m10 = d * R + g * D + E * x),
            (t.m11 = p * R + y * D + v * x),
            e !== t &&
              ((t.m12 = e.m12),
              (t.m13 = e.m13),
              (t.m14 = e.m14),
              (t.m15 = e.m15)),
            t
          );
        }
        static rotateX(t, e, i) {
          const s = Math.sin(i),
            n = Math.cos(i),
            r = e.m04,
            a = e.m05,
            o = e.m06,
            h = e.m07,
            l = e.m08,
            c = e.m09,
            u = e.m10,
            _ = e.m11;
          return (
            e !== t &&
              ((t.m00 = e.m00),
              (t.m01 = e.m01),
              (t.m02 = e.m02),
              (t.m03 = e.m03),
              (t.m12 = e.m12),
              (t.m13 = e.m13),
              (t.m14 = e.m14),
              (t.m15 = e.m15)),
            (t.m04 = r * n + l * s),
            (t.m05 = a * n + c * s),
            (t.m06 = o * n + u * s),
            (t.m07 = h * n + _ * s),
            (t.m08 = l * n - r * s),
            (t.m09 = c * n - a * s),
            (t.m10 = u * n - o * s),
            (t.m11 = _ * n - h * s),
            t
          );
        }
        static rotateY(t, e, i) {
          const s = Math.sin(i),
            n = Math.cos(i),
            r = e.m00,
            a = e.m01,
            o = e.m02,
            h = e.m03,
            l = e.m08,
            c = e.m09,
            u = e.m10,
            _ = e.m11;
          return (
            e !== t &&
              ((t.m04 = e.m04),
              (t.m05 = e.m05),
              (t.m06 = e.m06),
              (t.m07 = e.m07),
              (t.m12 = e.m12),
              (t.m13 = e.m13),
              (t.m14 = e.m14),
              (t.m15 = e.m15)),
            (t.m00 = r * n - l * s),
            (t.m01 = a * n - c * s),
            (t.m02 = o * n - u * s),
            (t.m03 = h * n - _ * s),
            (t.m08 = r * s + l * n),
            (t.m09 = a * s + c * n),
            (t.m10 = o * s + u * n),
            (t.m11 = h * s + _ * n),
            t
          );
        }
        static rotateZ(t, e, i) {
          const s = Math.sin(i),
            n = Math.cos(i),
            r = e.m00,
            a = e.m01,
            o = e.m02,
            h = e.m03,
            l = e.m04,
            c = e.m05,
            u = e.m06,
            _ = e.m07;
          return (
            e !== t &&
              ((t.m08 = e.m08),
              (t.m09 = e.m09),
              (t.m10 = e.m10),
              (t.m11 = e.m11),
              (t.m12 = e.m12),
              (t.m13 = e.m13),
              (t.m14 = e.m14),
              (t.m15 = e.m15)),
            (t.m00 = r * n + l * s),
            (t.m01 = a * n + c * s),
            (t.m02 = o * n + u * s),
            (t.m03 = h * n + _ * s),
            (t.m04 = l * n - r * s),
            (t.m05 = c * n - a * s),
            (t.m06 = u * n - o * s),
            (t.m07 = _ * n - h * s),
            t
          );
        }
        static fromTranslation(t, e) {
          return (
            (t.m00 = 1),
            (t.m01 = 0),
            (t.m02 = 0),
            (t.m03 = 0),
            (t.m04 = 0),
            (t.m05 = 1),
            (t.m06 = 0),
            (t.m07 = 0),
            (t.m08 = 0),
            (t.m09 = 0),
            (t.m10 = 1),
            (t.m11 = 0),
            (t.m12 = e.x),
            (t.m13 = e.y),
            (t.m14 = e.z),
            (t.m15 = 1),
            t
          );
        }
        static fromScaling(t, e) {
          return (
            (t.m00 = e.x),
            (t.m01 = 0),
            (t.m02 = 0),
            (t.m03 = 0),
            (t.m04 = 0),
            (t.m05 = e.y),
            (t.m06 = 0),
            (t.m07 = 0),
            (t.m08 = 0),
            (t.m09 = 0),
            (t.m10 = e.z),
            (t.m11 = 0),
            (t.m12 = 0),
            (t.m13 = 0),
            (t.m14 = 0),
            (t.m15 = 1),
            t
          );
        }
        static fromRotation(t, e, i) {
          let s = i.x,
            n = i.y,
            r = i.z,
            a = Math.sqrt(s * s + n * n + r * r);
          if (Math.abs(a) < gi) return null;
          (a = 1 / a), (s *= a), (n *= a), (r *= a);
          const o = Math.sin(e),
            h = Math.cos(e),
            l = 1 - h;
          return (
            (t.m00 = s * s * l + h),
            (t.m01 = n * s * l + r * o),
            (t.m02 = r * s * l - n * o),
            (t.m03 = 0),
            (t.m04 = s * n * l - r * o),
            (t.m05 = n * n * l + h),
            (t.m06 = r * n * l + s * o),
            (t.m07 = 0),
            (t.m08 = s * r * l + n * o),
            (t.m09 = n * r * l - s * o),
            (t.m10 = r * r * l + h),
            (t.m11 = 0),
            (t.m12 = 0),
            (t.m13 = 0),
            (t.m14 = 0),
            (t.m15 = 1),
            t
          );
        }
        static fromXRotation(t, e) {
          const i = Math.sin(e),
            s = Math.cos(e);
          return (
            (t.m00 = 1),
            (t.m01 = 0),
            (t.m02 = 0),
            (t.m03 = 0),
            (t.m04 = 0),
            (t.m05 = s),
            (t.m06 = i),
            (t.m07 = 0),
            (t.m08 = 0),
            (t.m09 = -i),
            (t.m10 = s),
            (t.m11 = 0),
            (t.m12 = 0),
            (t.m13 = 0),
            (t.m14 = 0),
            (t.m15 = 1),
            t
          );
        }
        static fromYRotation(t, e) {
          const i = Math.sin(e),
            s = Math.cos(e);
          return (
            (t.m00 = s),
            (t.m01 = 0),
            (t.m02 = -i),
            (t.m03 = 0),
            (t.m04 = 0),
            (t.m05 = 1),
            (t.m06 = 0),
            (t.m07 = 0),
            (t.m08 = i),
            (t.m09 = 0),
            (t.m10 = s),
            (t.m11 = 0),
            (t.m12 = 0),
            (t.m13 = 0),
            (t.m14 = 0),
            (t.m15 = 1),
            t
          );
        }
        static fromZRotation(t, e) {
          const i = Math.sin(e),
            s = Math.cos(e);
          return (
            (t.m00 = s),
            (t.m01 = i),
            (t.m02 = 0),
            (t.m03 = 0),
            (t.m04 = -i),
            (t.m05 = s),
            (t.m06 = 0),
            (t.m07 = 0),
            (t.m08 = 0),
            (t.m09 = 0),
            (t.m10 = 1),
            (t.m11 = 0),
            (t.m12 = 0),
            (t.m13 = 0),
            (t.m14 = 0),
            (t.m15 = 1),
            t
          );
        }
        static fromRT(t, e, i) {
          const s = e.x,
            n = e.y,
            r = e.z,
            a = e.w,
            o = s + s,
            h = n + n,
            l = r + r,
            c = s * o,
            u = s * h,
            _ = s * l,
            d = n * h,
            p = n * l,
            m = r * l,
            f = a * o,
            g = a * h,
            y = a * l;
          return (
            (t.m00 = 1 - (d + m)),
            (t.m01 = u + y),
            (t.m02 = _ - g),
            (t.m03 = 0),
            (t.m04 = u - y),
            (t.m05 = 1 - (c + m)),
            (t.m06 = p + f),
            (t.m07 = 0),
            (t.m08 = _ + g),
            (t.m09 = p - f),
            (t.m10 = 1 - (c + d)),
            (t.m11 = 0),
            (t.m12 = i.x),
            (t.m13 = i.y),
            (t.m14 = i.z),
            (t.m15 = 1),
            t
          );
        }
        static getTranslation(t, e) {
          return (t.x = e.m12), (t.y = e.m13), (t.z = e.m14), t;
        }
        static getScaling(t, e) {
          const i = (gs.m00 = e.m00),
            s = (gs.m01 = e.m01),
            n = (gs.m02 = e.m02),
            r = (gs.m03 = e.m04),
            a = (gs.m04 = e.m05),
            o = (gs.m05 = e.m06),
            h = (gs.m06 = e.m08),
            l = (gs.m07 = e.m09),
            c = (gs.m08 = e.m10);
          return (
            (t.x = Math.sqrt(i * i + s * s + n * n)),
            (t.y = Math.sqrt(r * r + a * a + o * o)),
            (t.z = Math.sqrt(h * h + l * l + c * c)),
            es.determinant(gs) < 0 && (t.x *= -1),
            t
          );
        }
        static getRotation(t, e) {
          const i = e.m00 + e.m05 + e.m10;
          let s = 0;
          return (
            i > 0
              ? ((s = 2 * Math.sqrt(i + 1)),
                (t.w = 0.25 * s),
                (t.x = (e.m06 - e.m09) / s),
                (t.y = (e.m08 - e.m02) / s),
                (t.z = (e.m01 - e.m04) / s))
              : e.m00 > e.m05 && e.m00 > e.m10
              ? ((s = 2 * Math.sqrt(1 + e.m00 - e.m05 - e.m10)),
                (t.w = (e.m06 - e.m09) / s),
                (t.x = 0.25 * s),
                (t.y = (e.m01 + e.m04) / s),
                (t.z = (e.m08 + e.m02) / s))
              : e.m05 > e.m10
              ? ((s = 2 * Math.sqrt(1 + e.m05 - e.m00 - e.m10)),
                (t.w = (e.m08 - e.m02) / s),
                (t.x = (e.m01 + e.m04) / s),
                (t.y = 0.25 * s),
                (t.z = (e.m06 + e.m09) / s))
              : ((s = 2 * Math.sqrt(1 + e.m10 - e.m00 - e.m05)),
                (t.w = (e.m01 - e.m04) / s),
                (t.x = (e.m08 + e.m02) / s),
                (t.y = (e.m06 + e.m09) / s),
                (t.z = 0.25 * s)),
            t
          );
        }
        static toRTS(t, e, i, s) {
          ms.toSRT(t, e, i, s);
        }
        static toSRT(t, e, i, s) {
          i && Yi.set(i, t.m12, t.m13, t.m14);
          const n = Yi.set(fs, t.m00, t.m01, t.m02).length(),
            r = Yi.set(fs, t.m04, t.m05, t.m06).length(),
            a = Yi.set(fs, t.m08, t.m09, t.m10).length();
          if (
            (s && ((s.x = n), (s.y = r), (s.z = a)),
            0 === n || 0 === r || 0 === a)
          )
            return void (e && as.identity(e));
          (gs.m00 = t.m00 / n),
            (gs.m01 = t.m01 / n),
            (gs.m02 = t.m02 / n),
            (gs.m03 = t.m04 / r),
            (gs.m04 = t.m05 / r),
            (gs.m05 = t.m06 / r),
            (gs.m06 = t.m08 / a),
            (gs.m07 = t.m09 / a),
            (gs.m08 = t.m10 / a);
          const o = es.determinant(gs);
          s && o < 0 && (s.x *= -1),
            e &&
              (o < 0 && ((gs.m00 *= -1), (gs.m01 *= -1), (gs.m02 *= -1)),
              as.fromMat3(e, gs));
        }
        static toEuler(t, e) {
          return (
            es.set(
              gs,
              t.m00,
              t.m01,
              t.m02,
              t.m04,
              t.m05,
              t.m06,
              t.m08,
              t.m09,
              t.m10
            ),
            es.toEuler(gs, e)
          );
        }
        static fromRTS(t, e, i, s) {
          return ms.fromSRT(t, e, i, s);
        }
        static fromSRT(t, e, i, s) {
          const n = e.x,
            r = e.y,
            a = e.z,
            o = e.w,
            h = n + n,
            l = r + r,
            c = a + a,
            u = n * h,
            _ = n * l,
            d = n * c,
            p = r * l,
            m = r * c,
            f = a * c,
            g = o * h,
            y = o * l,
            T = o * c,
            S = s.x,
            E = s.y,
            v = s.z;
          return (
            (t.m00 = (1 - (p + f)) * S),
            (t.m01 = (_ + T) * S),
            (t.m02 = (d - y) * S),
            (t.m03 = 0),
            (t.m04 = (_ - T) * E),
            (t.m05 = (1 - (u + f)) * E),
            (t.m06 = (m + g) * E),
            (t.m07 = 0),
            (t.m08 = (d + y) * v),
            (t.m09 = (m - g) * v),
            (t.m10 = (1 - (u + p)) * v),
            (t.m11 = 0),
            (t.m12 = i.x),
            (t.m13 = i.y),
            (t.m14 = i.z),
            (t.m15 = 1),
            t
          );
        }
        static fromRTSOrigin(t, e, i, s, n) {
          const r = e.x,
            a = e.y,
            o = e.z,
            h = e.w,
            l = r + r,
            c = a + a,
            u = o + o,
            _ = r * l,
            d = r * c,
            p = r * u,
            m = a * c,
            f = a * u,
            g = o * u,
            y = h * l,
            T = h * c,
            S = h * u,
            E = s.x,
            v = s.y,
            b = s.z,
            A = n.x,
            C = n.y,
            O = n.z;
          return (
            (t.m00 = (1 - (m + g)) * E),
            (t.m01 = (d + S) * E),
            (t.m02 = (p - T) * E),
            (t.m03 = 0),
            (t.m04 = (d - S) * v),
            (t.m05 = (1 - (_ + g)) * v),
            (t.m06 = (f + y) * v),
            (t.m07 = 0),
            (t.m08 = (p + T) * b),
            (t.m09 = (f - y) * b),
            (t.m10 = (1 - (_ + m)) * b),
            (t.m11 = 0),
            (t.m12 = i.x + A - (t.m00 * A + t.m04 * C + t.m08 * O)),
            (t.m13 = i.y + C - (t.m01 * A + t.m05 * C + t.m09 * O)),
            (t.m14 = i.z + O - (t.m02 * A + t.m06 * C + t.m10 * O)),
            (t.m15 = 1),
            t
          );
        }
        static fromSRTOrigin(t, e, i, s, n) {
          const r = e.x,
            a = e.y,
            o = e.z,
            h = e.w,
            l = r + r,
            c = a + a,
            u = o + o,
            _ = r * l,
            d = r * c,
            p = r * u,
            m = a * c,
            f = a * u,
            g = o * u,
            y = h * l,
            T = h * c,
            S = h * u,
            E = s.x,
            v = s.y,
            b = s.z,
            A = n.x,
            C = n.y,
            O = n.z;
          return (
            (t.m00 = (1 - (m + g)) * E),
            (t.m01 = (d + S) * E),
            (t.m02 = (p - T) * E),
            (t.m03 = 0),
            (t.m04 = (d - S) * v),
            (t.m05 = (1 - (_ + g)) * v),
            (t.m06 = (f + y) * v),
            (t.m07 = 0),
            (t.m08 = (p + T) * b),
            (t.m09 = (f - y) * b),
            (t.m10 = (1 - (_ + m)) * b),
            (t.m11 = 0),
            (t.m12 = i.x + A - (t.m00 * A + t.m04 * C + t.m08 * O)),
            (t.m13 = i.y + C - (t.m01 * A + t.m05 * C + t.m09 * O)),
            (t.m14 = i.z + O - (t.m02 * A + t.m06 * C + t.m10 * O)),
            (t.m15 = 1),
            t
          );
        }
        static fromQuat(t, e) {
          const i = e.x,
            s = e.y,
            n = e.z,
            r = e.w,
            a = i + i,
            o = s + s,
            h = n + n,
            l = i * a,
            c = s * a,
            u = s * o,
            _ = n * a,
            d = n * o,
            p = n * h,
            m = r * a,
            f = r * o,
            g = r * h;
          return (
            (t.m00 = 1 - u - p),
            (t.m01 = c + g),
            (t.m02 = _ - f),
            (t.m03 = 0),
            (t.m04 = c - g),
            (t.m05 = 1 - l - p),
            (t.m06 = d + m),
            (t.m07 = 0),
            (t.m08 = _ + f),
            (t.m09 = d - m),
            (t.m10 = 1 - l - u),
            (t.m11 = 0),
            (t.m12 = 0),
            (t.m13 = 0),
            (t.m14 = 0),
            (t.m15 = 1),
            t
          );
        }
        static frustum(t, e, i, s, n, r, a) {
          const o = 1 / (i - e),
            h = 1 / (n - s),
            l = 1 / (r - a);
          return (
            (t.m00 = 2 * r * o),
            (t.m01 = 0),
            (t.m02 = 0),
            (t.m03 = 0),
            (t.m04 = 0),
            (t.m05 = 2 * r * h),
            (t.m06 = 0),
            (t.m07 = 0),
            (t.m08 = (i + e) * o),
            (t.m09 = (n + s) * h),
            (t.m10 = (a + r) * l),
            (t.m11 = -1),
            (t.m12 = 0),
            (t.m13 = 0),
            (t.m14 = a * r * 2 * l),
            (t.m15 = 0),
            t
          );
        }
        static perspective(t, e, i, s, n, r = !0, a = -1, o = 1, h = 0) {
          const l = 1 / Math.tan(e / 2),
            c = 1 / (s - n),
            u = r ? l / i : l,
            _ = (r ? l : l * i) * o,
            d = ps[h];
          return (
            (t.m00 = u * d[0]),
            (t.m01 = u * d[1]),
            (t.m02 = 0),
            (t.m03 = 0),
            (t.m04 = _ * d[2]),
            (t.m05 = _ * d[3]),
            (t.m06 = 0),
            (t.m07 = 0),
            (t.m08 = 0),
            (t.m09 = 0),
            (t.m10 = (n - a * s) * c),
            (t.m11 = -1),
            (t.m12 = 0),
            (t.m13 = 0),
            (t.m14 = n * s * c * (1 - a)),
            (t.m15 = 0),
            t
          );
        }
        static ortho(t, e, i, s, n, r, a, o = -1, h = 1, l = 0) {
          const c = 1 / (e - i),
            u = (1 / (s - n)) * h,
            _ = 1 / (r - a),
            d = -2 * c,
            p = -2 * u,
            m = (e + i) * c,
            f = (n + s) * u,
            g = ps[l];
          return (
            (t.m00 = d * g[0]),
            (t.m01 = d * g[1]),
            (t.m02 = 0),
            (t.m03 = 0),
            (t.m04 = p * g[2]),
            (t.m05 = p * g[3]),
            (t.m06 = 0),
            (t.m07 = 0),
            (t.m08 = 0),
            (t.m09 = 0),
            (t.m10 = _ * (1 - o)),
            (t.m11 = 0),
            (t.m12 = m * g[0] + f * g[2]),
            (t.m13 = m * g[1] + f * g[3]),
            (t.m14 = (r - o * a) * _),
            (t.m15 = 1),
            t
          );
        }
        static lookAt(t, e, i, s) {
          const n = e.x,
            r = e.y,
            a = e.z,
            o = s.x,
            h = s.y,
            l = s.z;
          let c = n - i.x,
            u = r - i.y,
            _ = a - i.z,
            d = 1 / Math.sqrt(c * c + u * u + _ * _);
          (c *= d), (u *= d), (_ *= d);
          let p = h * _ - l * u,
            m = l * c - o * _,
            f = o * u - h * c;
          (d = 1 / Math.sqrt(p * p + m * m + f * f)),
            (p *= d),
            (m *= d),
            (f *= d);
          const g = u * f - _ * m,
            y = _ * p - c * f,
            T = c * m - u * p;
          return (
            (t.m00 = p),
            (t.m01 = g),
            (t.m02 = c),
            (t.m03 = 0),
            (t.m04 = m),
            (t.m05 = y),
            (t.m06 = u),
            (t.m07 = 0),
            (t.m08 = f),
            (t.m09 = T),
            (t.m10 = _),
            (t.m11 = 0),
            (t.m12 = -(p * n + m * r + f * a)),
            (t.m13 = -(g * n + y * r + T * a)),
            (t.m14 = -(c * n + u * r + _ * a)),
            (t.m15 = 1),
            t
          );
        }
        static inverseTranspose(t, e) {
          const i = e.m00,
            s = e.m01,
            n = e.m02,
            r = e.m03,
            a = e.m04,
            o = e.m05,
            h = e.m06,
            l = e.m07,
            c = e.m08,
            u = e.m09,
            _ = e.m10,
            d = e.m11,
            p = e.m12,
            m = e.m13,
            f = e.m14,
            g = e.m15,
            y = i * o - s * a,
            T = i * h - n * a,
            S = i * l - r * a,
            E = s * h - n * o,
            v = s * l - r * o,
            b = n * l - r * h,
            A = c * m - u * p,
            C = c * f - _ * p,
            O = c * g - d * p,
            I = u * f - _ * m,
            w = u * g - d * m,
            R = _ * g - d * f;
          let D = y * R - T * w + S * I + E * O - v * C + b * A;
          return D
            ? ((D = 1 / D),
              (t.m00 = (o * R - h * w + l * I) * D),
              (t.m01 = (h * O - a * R - l * C) * D),
              (t.m02 = (a * w - o * O + l * A) * D),
              (t.m03 = 0),
              (t.m04 = (n * w - s * R - r * I) * D),
              (t.m05 = (i * R - n * O + r * C) * D),
              (t.m06 = (s * O - i * w - r * A) * D),
              (t.m07 = 0),
              (t.m08 = (m * b - f * v + g * E) * D),
              (t.m09 = (f * S - p * b - g * T) * D),
              (t.m10 = (p * v - m * S + g * y) * D),
              (t.m11 = 0),
              (t.m12 = 0),
              (t.m13 = 0),
              (t.m14 = 0),
              (t.m15 = 1),
              t)
            : null;
        }
        static toArray(t, e, i = 0) {
          return (
            (t[i + 0] = e.m00),
            (t[i + 1] = e.m01),
            (t[i + 2] = e.m02),
            (t[i + 3] = e.m03),
            (t[i + 4] = e.m04),
            (t[i + 5] = e.m05),
            (t[i + 6] = e.m06),
            (t[i + 7] = e.m07),
            (t[i + 8] = e.m08),
            (t[i + 9] = e.m09),
            (t[i + 10] = e.m10),
            (t[i + 11] = e.m11),
            (t[i + 12] = e.m12),
            (t[i + 13] = e.m13),
            (t[i + 14] = e.m14),
            (t[i + 15] = e.m15),
            t
          );
        }
        static fromArray(t, e, i = 0) {
          return (
            (t.m00 = e[i + 0]),
            (t.m01 = e[i + 1]),
            (t.m02 = e[i + 2]),
            (t.m03 = e[i + 3]),
            (t.m04 = e[i + 4]),
            (t.m05 = e[i + 5]),
            (t.m06 = e[i + 6]),
            (t.m07 = e[i + 7]),
            (t.m08 = e[i + 8]),
            (t.m09 = e[i + 9]),
            (t.m10 = e[i + 10]),
            (t.m11 = e[i + 11]),
            (t.m12 = e[i + 12]),
            (t.m13 = e[i + 13]),
            (t.m14 = e[i + 14]),
            (t.m15 = e[i + 15]),
            t
          );
        }
        static add(t, e, i) {
          return (
            (t.m00 = e.m00 + i.m00),
            (t.m01 = e.m01 + i.m01),
            (t.m02 = e.m02 + i.m02),
            (t.m03 = e.m03 + i.m03),
            (t.m04 = e.m04 + i.m04),
            (t.m05 = e.m05 + i.m05),
            (t.m06 = e.m06 + i.m06),
            (t.m07 = e.m07 + i.m07),
            (t.m08 = e.m08 + i.m08),
            (t.m09 = e.m09 + i.m09),
            (t.m10 = e.m10 + i.m10),
            (t.m11 = e.m11 + i.m11),
            (t.m12 = e.m12 + i.m12),
            (t.m13 = e.m13 + i.m13),
            (t.m14 = e.m14 + i.m14),
            (t.m15 = e.m15 + i.m15),
            t
          );
        }
        static subtract(t, e, i) {
          return (
            (t.m00 = e.m00 - i.m00),
            (t.m01 = e.m01 - i.m01),
            (t.m02 = e.m02 - i.m02),
            (t.m03 = e.m03 - i.m03),
            (t.m04 = e.m04 - i.m04),
            (t.m05 = e.m05 - i.m05),
            (t.m06 = e.m06 - i.m06),
            (t.m07 = e.m07 - i.m07),
            (t.m08 = e.m08 - i.m08),
            (t.m09 = e.m09 - i.m09),
            (t.m10 = e.m10 - i.m10),
            (t.m11 = e.m11 - i.m11),
            (t.m12 = e.m12 - i.m12),
            (t.m13 = e.m13 - i.m13),
            (t.m14 = e.m14 - i.m14),
            (t.m15 = e.m15 - i.m15),
            t
          );
        }
        static multiplyScalar(t, e, i) {
          return (
            (t.m00 = e.m00 * i),
            (t.m01 = e.m01 * i),
            (t.m02 = e.m02 * i),
            (t.m03 = e.m03 * i),
            (t.m04 = e.m04 * i),
            (t.m05 = e.m05 * i),
            (t.m06 = e.m06 * i),
            (t.m07 = e.m07 * i),
            (t.m08 = e.m08 * i),
            (t.m09 = e.m09 * i),
            (t.m10 = e.m10 * i),
            (t.m11 = e.m11 * i),
            (t.m12 = e.m12 * i),
            (t.m13 = e.m13 * i),
            (t.m14 = e.m14 * i),
            (t.m15 = e.m15 * i),
            t
          );
        }
        static multiplyScalarAndAdd(t, e, i, s) {
          return (
            (t.m00 = e.m00 + i.m00 * s),
            (t.m01 = e.m01 + i.m01 * s),
            (t.m02 = e.m02 + i.m02 * s),
            (t.m03 = e.m03 + i.m03 * s),
            (t.m04 = e.m04 + i.m04 * s),
            (t.m05 = e.m05 + i.m05 * s),
            (t.m06 = e.m06 + i.m06 * s),
            (t.m07 = e.m07 + i.m07 * s),
            (t.m08 = e.m08 + i.m08 * s),
            (t.m09 = e.m09 + i.m09 * s),
            (t.m10 = e.m10 + i.m10 * s),
            (t.m11 = e.m11 + i.m11 * s),
            (t.m12 = e.m12 + i.m12 * s),
            (t.m13 = e.m13 + i.m13 * s),
            (t.m14 = e.m14 + i.m14 * s),
            (t.m15 = e.m15 + i.m15 * s),
            t
          );
        }
        static strictEquals(t, e) {
          return (
            t.m00 === e.m00 &&
            t.m01 === e.m01 &&
            t.m02 === e.m02 &&
            t.m03 === e.m03 &&
            t.m04 === e.m04 &&
            t.m05 === e.m05 &&
            t.m06 === e.m06 &&
            t.m07 === e.m07 &&
            t.m08 === e.m08 &&
            t.m09 === e.m09 &&
            t.m10 === e.m10 &&
            t.m11 === e.m11 &&
            t.m12 === e.m12 &&
            t.m13 === e.m13 &&
            t.m14 === e.m14 &&
            t.m15 === e.m15
          );
        }
        static equals(t, e, i = gi) {
          return (
            Math.abs(t.m00 - e.m00) <=
              i * Math.max(1, Math.abs(t.m00), Math.abs(e.m00)) &&
            Math.abs(t.m01 - e.m01) <=
              i * Math.max(1, Math.abs(t.m01), Math.abs(e.m01)) &&
            Math.abs(t.m02 - e.m02) <=
              i * Math.max(1, Math.abs(t.m02), Math.abs(e.m02)) &&
            Math.abs(t.m03 - e.m03) <=
              i * Math.max(1, Math.abs(t.m03), Math.abs(e.m03)) &&
            Math.abs(t.m04 - e.m04) <=
              i * Math.max(1, Math.abs(t.m04), Math.abs(e.m04)) &&
            Math.abs(t.m05 - e.m05) <=
              i * Math.max(1, Math.abs(t.m05), Math.abs(e.m05)) &&
            Math.abs(t.m06 - e.m06) <=
              i * Math.max(1, Math.abs(t.m06), Math.abs(e.m06)) &&
            Math.abs(t.m07 - e.m07) <=
              i * Math.max(1, Math.abs(t.m07), Math.abs(e.m07)) &&
            Math.abs(t.m08 - e.m08) <=
              i * Math.max(1, Math.abs(t.m08), Math.abs(e.m08)) &&
            Math.abs(t.m09 - e.m09) <=
              i * Math.max(1, Math.abs(t.m09), Math.abs(e.m09)) &&
            Math.abs(t.m10 - e.m10) <=
              i * Math.max(1, Math.abs(t.m10), Math.abs(e.m10)) &&
            Math.abs(t.m11 - e.m11) <=
              i * Math.max(1, Math.abs(t.m11), Math.abs(e.m11)) &&
            Math.abs(t.m12 - e.m12) <=
              i * Math.max(1, Math.abs(t.m12), Math.abs(e.m12)) &&
            Math.abs(t.m13 - e.m13) <=
              i * Math.max(1, Math.abs(t.m13), Math.abs(e.m13)) &&
            Math.abs(t.m14 - e.m14) <=
              i * Math.max(1, Math.abs(t.m14), Math.abs(e.m14)) &&
            Math.abs(t.m15 - e.m15) <=
              i * Math.max(1, Math.abs(t.m15), Math.abs(e.m15))
          );
        }
        constructor(
          t = 1,
          e = 0,
          i = 0,
          s = 0,
          n = 0,
          r = 1,
          a = 0,
          o = 0,
          h = 0,
          l = 0,
          c = 1,
          u = 0,
          _ = 0,
          d = 0,
          p = 0,
          m = 1
        ) {
          super(),
            "object" == typeof t
              ? ((this.m00 = t.m00),
                (this.m01 = t.m01),
                (this.m02 = t.m02),
                (this.m03 = t.m03),
                (this.m04 = t.m04),
                (this.m05 = t.m05),
                (this.m06 = t.m06),
                (this.m07 = t.m07),
                (this.m08 = t.m08),
                (this.m09 = t.m09),
                (this.m10 = t.m10),
                (this.m11 = t.m11),
                (this.m12 = t.m12),
                (this.m13 = t.m13),
                (this.m14 = t.m14),
                (this.m15 = t.m15))
              : ((this.m00 = t),
                (this.m01 = e),
                (this.m02 = i),
                (this.m03 = s),
                (this.m04 = n),
                (this.m05 = r),
                (this.m06 = a),
                (this.m07 = o),
                (this.m08 = h),
                (this.m09 = l),
                (this.m10 = c),
                (this.m11 = u),
                (this.m12 = _),
                (this.m13 = d),
                (this.m14 = p),
                (this.m15 = m));
        }
        clone() {
          return new ms(
            this.m00,
            this.m01,
            this.m02,
            this.m03,
            this.m04,
            this.m05,
            this.m06,
            this.m07,
            this.m08,
            this.m09,
            this.m10,
            this.m11,
            this.m12,
            this.m13,
            this.m14,
            this.m15
          );
        }
        set(
          t = 1,
          e = 0,
          i = 0,
          s = 0,
          n = 0,
          r = 1,
          a = 0,
          o = 0,
          h = 0,
          l = 0,
          c = 1,
          u = 0,
          _ = 0,
          d = 0,
          p = 0,
          m = 1
        ) {
          return (
            "object" == typeof t
              ? ((this.m01 = t.m01),
                (this.m02 = t.m02),
                (this.m03 = t.m03),
                (this.m04 = t.m04),
                (this.m05 = t.m05),
                (this.m06 = t.m06),
                (this.m07 = t.m07),
                (this.m08 = t.m08),
                (this.m09 = t.m09),
                (this.m10 = t.m10),
                (this.m11 = t.m11),
                (this.m12 = t.m12),
                (this.m13 = t.m13),
                (this.m14 = t.m14),
                (this.m15 = t.m15),
                (this.m00 = t.m00))
              : ((this.m01 = e),
                (this.m02 = i),
                (this.m03 = s),
                (this.m04 = n),
                (this.m05 = r),
                (this.m06 = a),
                (this.m07 = o),
                (this.m08 = h),
                (this.m09 = l),
                (this.m10 = c),
                (this.m11 = u),
                (this.m12 = _),
                (this.m13 = d),
                (this.m14 = p),
                (this.m15 = m),
                (this.m00 = t)),
            this
          );
        }
        equals(t, e = gi) {
          return (
            !(
              Math.abs(this.m00) === 1 / 0 ||
              Math.abs(this.m01) === 1 / 0 ||
              Math.abs(this.m02) === 1 / 0 ||
              Math.abs(this.m03) === 1 / 0 ||
              Math.abs(this.m04) === 1 / 0 ||
              Math.abs(this.m05) === 1 / 0 ||
              Math.abs(this.m06) === 1 / 0 ||
              Math.abs(this.m07) === 1 / 0 ||
              Math.abs(this.m08) === 1 / 0 ||
              Math.abs(this.m09) === 1 / 0 ||
              Math.abs(this.m10) === 1 / 0 ||
              Math.abs(this.m11) === 1 / 0 ||
              Math.abs(this.m12) === 1 / 0 ||
              Math.abs(this.m13) === 1 / 0 ||
              Math.abs(this.m14) === 1 / 0 ||
              Math.abs(this.m15) === 1 / 0
            ) &&
            Math.abs(this.m00 - t.m00) <=
              e * Math.max(1, Math.abs(this.m00), Math.abs(t.m00)) &&
            Math.abs(this.m01 - t.m01) <=
              e * Math.max(1, Math.abs(this.m01), Math.abs(t.m01)) &&
            Math.abs(this.m02 - t.m02) <=
              e * Math.max(1, Math.abs(this.m02), Math.abs(t.m02)) &&
            Math.abs(this.m03 - t.m03) <=
              e * Math.max(1, Math.abs(this.m03), Math.abs(t.m03)) &&
            Math.abs(this.m04 - t.m04) <=
              e * Math.max(1, Math.abs(this.m04), Math.abs(t.m04)) &&
            Math.abs(this.m05 - t.m05) <=
              e * Math.max(1, Math.abs(this.m05), Math.abs(t.m05)) &&
            Math.abs(this.m06 - t.m06) <=
              e * Math.max(1, Math.abs(this.m06), Math.abs(t.m06)) &&
            Math.abs(this.m07 - t.m07) <=
              e * Math.max(1, Math.abs(this.m07), Math.abs(t.m07)) &&
            Math.abs(this.m08 - t.m08) <=
              e * Math.max(1, Math.abs(this.m08), Math.abs(t.m08)) &&
            Math.abs(this.m09 - t.m09) <=
              e * Math.max(1, Math.abs(this.m09), Math.abs(t.m09)) &&
            Math.abs(this.m10 - t.m10) <=
              e * Math.max(1, Math.abs(this.m10), Math.abs(t.m10)) &&
            Math.abs(this.m11 - t.m11) <=
              e * Math.max(1, Math.abs(this.m11), Math.abs(t.m11)) &&
            Math.abs(this.m12 - t.m12) <=
              e * Math.max(1, Math.abs(this.m12), Math.abs(t.m12)) &&
            Math.abs(this.m13 - t.m13) <=
              e * Math.max(1, Math.abs(this.m13), Math.abs(t.m13)) &&
            Math.abs(this.m14 - t.m14) <=
              e * Math.max(1, Math.abs(this.m14), Math.abs(t.m14)) &&
            Math.abs(this.m15 - t.m15) <=
              e * Math.max(1, Math.abs(this.m15), Math.abs(t.m15))
          );
        }
        strictEquals(t) {
          return (
            this.m00 === t.m00 &&
            this.m01 === t.m01 &&
            this.m02 === t.m02 &&
            this.m03 === t.m03 &&
            this.m04 === t.m04 &&
            this.m05 === t.m05 &&
            this.m06 === t.m06 &&
            this.m07 === t.m07 &&
            this.m08 === t.m08 &&
            this.m09 === t.m09 &&
            this.m10 === t.m10 &&
            this.m11 === t.m11 &&
            this.m12 === t.m12 &&
            this.m13 === t.m13 &&
            this.m14 === t.m14 &&
            this.m15 === t.m15
          );
        }
        toString() {
          return `[\n${this.m00}, ${this.m01}, ${this.m02}, ${this.m03},\n${this.m04}, ${this.m05}, ${this.m06}, ${this.m07},\n${this.m08}, ${this.m09}, ${this.m10}, ${this.m11},\n${this.m12}, ${this.m13}, ${this.m14}, ${this.m15}\n]`;
        }
        identity() {
          return (
            (this.m00 = 1),
            (this.m01 = 0),
            (this.m02 = 0),
            (this.m03 = 0),
            (this.m04 = 0),
            (this.m05 = 1),
            (this.m06 = 0),
            (this.m07 = 0),
            (this.m08 = 0),
            (this.m09 = 0),
            (this.m10 = 1),
            (this.m11 = 0),
            (this.m12 = 0),
            (this.m13 = 0),
            (this.m14 = 0),
            (this.m15 = 1),
            this
          );
        }
        zero() {
          return (
            (this.m00 = 0),
            (this.m01 = 0),
            (this.m02 = 0),
            (this.m03 = 0),
            (this.m04 = 0),
            (this.m05 = 0),
            (this.m06 = 0),
            (this.m07 = 0),
            (this.m08 = 0),
            (this.m09 = 0),
            (this.m10 = 0),
            (this.m11 = 0),
            (this.m12 = 0),
            (this.m13 = 0),
            (this.m14 = 0),
            (this.m15 = 0),
            this
          );
        }
        transpose() {
          const t = this.m01,
            e = this.m02,
            i = this.m03,
            s = this.m06,
            n = this.m07,
            r = this.m11;
          return (
            (this.m01 = this.m04),
            (this.m02 = this.m08),
            (this.m03 = this.m12),
            (this.m04 = t),
            (this.m06 = this.m09),
            (this.m07 = this.m13),
            (this.m08 = e),
            (this.m09 = s),
            (this.m11 = this.m14),
            (this.m12 = i),
            (this.m13 = n),
            (this.m14 = r),
            this
          );
        }
        invert() {
          const t = this.m00,
            e = this.m01,
            i = this.m02,
            s = this.m03,
            n = this.m04,
            r = this.m05,
            a = this.m06,
            o = this.m07,
            h = this.m08,
            l = this.m09,
            c = this.m10,
            u = this.m11,
            _ = this.m12,
            d = this.m13,
            p = this.m14,
            m = this.m15,
            f = t * r - e * n,
            g = t * a - i * n,
            y = t * o - s * n,
            T = e * a - i * r,
            S = e * o - s * r,
            E = i * o - s * a,
            v = h * d - l * _,
            b = h * p - c * _,
            A = h * m - u * _,
            C = l * p - c * d,
            O = l * m - u * d,
            I = c * m - u * p;
          let w = f * I - g * O + y * C + T * A - S * b + E * v;
          return 0 === w
            ? (this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), this)
            : ((w = 1 / w),
              (this.m00 = (r * I - a * O + o * C) * w),
              (this.m01 = (i * O - e * I - s * C) * w),
              (this.m02 = (d * E - p * S + m * T) * w),
              (this.m03 = (c * S - l * E - u * T) * w),
              (this.m04 = (a * A - n * I - o * b) * w),
              (this.m05 = (t * I - i * A + s * b) * w),
              (this.m06 = (p * y - _ * E - m * g) * w),
              (this.m07 = (h * E - c * y + u * g) * w),
              (this.m08 = (n * O - r * A + o * v) * w),
              (this.m09 = (e * A - t * O - s * v) * w),
              (this.m10 = (_ * S - d * y + m * f) * w),
              (this.m11 = (l * y - h * S - u * f) * w),
              (this.m12 = (r * b - n * C - a * v) * w),
              (this.m13 = (t * C - e * b + i * v) * w),
              (this.m14 = (d * g - _ * T - p * f) * w),
              (this.m15 = (h * T - l * g + c * f) * w),
              this);
        }
        determinant() {
          const t = this.m00,
            e = this.m01,
            i = this.m02,
            s = this.m03,
            n = this.m04,
            r = this.m05,
            a = this.m06,
            o = this.m07,
            h = this.m08,
            l = this.m09,
            c = this.m10,
            u = this.m11,
            _ = this.m12,
            d = this.m13,
            p = this.m14,
            m = this.m15;
          return (
            (t * r - e * n) * (c * m - u * p) -
            (t * a - i * n) * (l * m - u * d) +
            (t * o - s * n) * (l * p - c * d) +
            (e * a - i * r) * (h * m - u * _) -
            (e * o - s * r) * (h * p - c * _) +
            (i * o - s * a) * (h * d - l * _)
          );
        }
        add(t) {
          return (
            (this.m00 += t.m00),
            (this.m01 += t.m01),
            (this.m02 += t.m02),
            (this.m03 += t.m03),
            (this.m04 += t.m04),
            (this.m05 += t.m05),
            (this.m06 += t.m06),
            (this.m07 += t.m07),
            (this.m08 += t.m08),
            (this.m09 += t.m09),
            (this.m10 += t.m10),
            (this.m11 += t.m11),
            (this.m12 += t.m12),
            (this.m13 += t.m13),
            (this.m14 += t.m14),
            (this.m15 += t.m15),
            this
          );
        }
        subtract(t) {
          return (
            (this.m00 -= t.m00),
            (this.m01 -= t.m01),
            (this.m02 -= t.m02),
            (this.m03 -= t.m03),
            (this.m04 -= t.m04),
            (this.m05 -= t.m05),
            (this.m06 -= t.m06),
            (this.m07 -= t.m07),
            (this.m08 -= t.m08),
            (this.m09 -= t.m09),
            (this.m10 -= t.m10),
            (this.m11 -= t.m11),
            (this.m12 -= t.m12),
            (this.m13 -= t.m13),
            (this.m14 -= t.m14),
            (this.m15 -= t.m15),
            this
          );
        }
        multiply(t) {
          const e = this.m00,
            i = this.m01,
            s = this.m02,
            n = this.m03,
            r = this.m04,
            a = this.m05,
            o = this.m06,
            h = this.m07,
            l = this.m08,
            c = this.m09,
            u = this.m10,
            _ = this.m11,
            d = this.m12,
            p = this.m13,
            m = this.m14,
            f = this.m15;
          let g = t.m00,
            y = t.m01,
            T = t.m02,
            S = t.m03;
          return (
            (this.m00 = g * e + y * r + T * l + S * d),
            (this.m01 = g * i + y * a + T * c + S * p),
            (this.m02 = g * s + y * o + T * u + S * m),
            (this.m03 = g * n + y * h + T * _ + S * f),
            (g = t.m04),
            (y = t.m05),
            (T = t.m06),
            (S = t.m07),
            (this.m04 = g * e + y * r + T * l + S * d),
            (this.m05 = g * i + y * a + T * c + S * p),
            (this.m06 = g * s + y * o + T * u + S * m),
            (this.m07 = g * n + y * h + T * _ + S * f),
            (g = t.m08),
            (y = t.m09),
            (T = t.m10),
            (S = t.m11),
            (this.m08 = g * e + y * r + T * l + S * d),
            (this.m09 = g * i + y * a + T * c + S * p),
            (this.m10 = g * s + y * o + T * u + S * m),
            (this.m11 = g * n + y * h + T * _ + S * f),
            (g = t.m12),
            (y = t.m13),
            (T = t.m14),
            (S = t.m15),
            (this.m12 = g * e + y * r + T * l + S * d),
            (this.m13 = g * i + y * a + T * c + S * p),
            (this.m14 = g * s + y * o + T * u + S * m),
            (this.m15 = g * n + y * h + T * _ + S * f),
            this
          );
        }
        multiplyScalar(t) {
          return (
            (this.m00 *= t),
            (this.m01 *= t),
            (this.m02 *= t),
            (this.m03 *= t),
            (this.m04 *= t),
            (this.m05 *= t),
            (this.m06 *= t),
            (this.m07 *= t),
            (this.m08 *= t),
            (this.m09 *= t),
            (this.m10 *= t),
            (this.m11 *= t),
            (this.m12 *= t),
            (this.m13 *= t),
            (this.m14 *= t),
            (this.m15 *= t),
            this
          );
        }
        translate(t) {
          return (this.m12 += t.x), (this.m13 += t.y), (this.m14 += t.z), this;
        }
        transform(t) {
          const { x: e, y: i, z: s } = t,
            n = this.m00,
            r = this.m01,
            a = this.m02,
            o = this.m03,
            h = this.m04,
            l = this.m05,
            c = this.m06,
            u = this.m07,
            _ = this.m08,
            d = this.m09,
            p = this.m10,
            m = this.m11;
          return (
            (this.m12 = n * e + h * i + _ * s + this.m12),
            (this.m13 = r * e + l * i + d * s + this.m13),
            (this.m14 = a * e + c * i + p * s + this.m14),
            (this.m15 = o * e + u * i + m * s + this.m15),
            this
          );
        }
        scale(t) {
          const e = t.x,
            i = t.y,
            s = t.z;
          return (
            (this.m00 *= e),
            (this.m01 *= e),
            (this.m02 *= e),
            (this.m03 *= e),
            (this.m04 *= i),
            (this.m05 *= i),
            (this.m06 *= i),
            (this.m07 *= i),
            (this.m08 *= s),
            (this.m09 *= s),
            (this.m10 *= s),
            (this.m11 *= s),
            this
          );
        }
        rotate(t, e) {
          let i = e.x,
            s = e.y,
            n = e.z,
            r = Math.sqrt(i * i + s * s + n * n);
          if (Math.abs(r) < gi) return null;
          (r = 1 / r), (i *= r), (s *= r), (n *= r);
          const a = Math.sin(t),
            o = Math.cos(t),
            h = 1 - o,
            l = this.m00,
            c = this.m01,
            u = this.m02,
            _ = this.m03,
            d = this.m04,
            p = this.m05,
            m = this.m06,
            f = this.m07,
            g = this.m08,
            y = this.m09,
            T = this.m10,
            S = this.m11,
            E = i * i * h + o,
            v = s * i * h + n * a,
            b = n * i * h - s * a,
            A = i * s * h - n * a,
            C = s * s * h + o,
            O = n * s * h + i * a,
            I = i * n * h + s * a,
            w = s * n * h - i * a,
            R = n * n * h + o;
          return (
            (this.m00 = l * E + d * v + g * b),
            (this.m01 = c * E + p * v + y * b),
            (this.m02 = u * E + m * v + T * b),
            (this.m03 = _ * E + f * v + S * b),
            (this.m04 = l * A + d * C + g * O),
            (this.m05 = c * A + p * C + y * O),
            (this.m06 = u * A + m * C + T * O),
            (this.m07 = _ * A + f * C + S * O),
            (this.m08 = l * I + d * w + g * R),
            (this.m09 = c * I + p * w + y * R),
            (this.m10 = u * I + m * w + T * R),
            (this.m11 = _ * I + f * w + S * R),
            this
          );
        }
        getTranslation(t) {
          return (t.x = this.m12), (t.y = this.m13), (t.z = this.m14), t;
        }
        getScale(t) {
          const e = (gs.m00 = this.m00),
            i = (gs.m01 = this.m01),
            s = (gs.m02 = this.m02),
            n = (gs.m03 = this.m04),
            r = (gs.m04 = this.m05),
            a = (gs.m05 = this.m06),
            o = (gs.m06 = this.m08),
            h = (gs.m07 = this.m09),
            l = (gs.m08 = this.m10);
          return (
            (t.x = Math.sqrt(e * e + i * i + s * s)),
            (t.y = Math.sqrt(n * n + r * r + a * a)),
            (t.z = Math.sqrt(o * o + h * h + l * l)),
            es.determinant(gs) < 0 && (t.x *= -1),
            t
          );
        }
        getRotation(t) {
          const e = Yi.set(fs, this.m00, this.m01, this.m02).length(),
            i = Yi.set(fs, this.m04, this.m05, this.m06).length(),
            s = Yi.set(fs, this.m08, this.m09, this.m10).length();
          return (
            (gs.m00 = this.m00 / e),
            (gs.m01 = this.m01 / e),
            (gs.m02 = this.m02 / e),
            (gs.m03 = this.m04 / i),
            (gs.m04 = this.m05 / i),
            (gs.m05 = this.m06 / i),
            (gs.m06 = this.m08 / s),
            (gs.m07 = this.m09 / s),
            (gs.m08 = this.m10 / s),
            es.determinant(gs) < 0 &&
              ((gs.m00 *= -1), (gs.m01 *= -1), (gs.m02 *= -1)),
            as.fromMat3(t, gs)
          );
        }
        fromRTS(t, e, i) {
          const s = t.x,
            n = t.y,
            r = t.z,
            a = t.w,
            o = s + s,
            h = n + n,
            l = r + r,
            c = s * o,
            u = s * h,
            _ = s * l,
            d = n * h,
            p = n * l,
            m = r * l,
            f = a * o,
            g = a * h,
            y = a * l,
            T = i.x,
            S = i.y,
            E = i.z;
          return (
            (this.m00 = (1 - (d + m)) * T),
            (this.m01 = (u + y) * T),
            (this.m02 = (_ - g) * T),
            (this.m03 = 0),
            (this.m04 = (u - y) * S),
            (this.m05 = (1 - (c + m)) * S),
            (this.m06 = (p + f) * S),
            (this.m07 = 0),
            (this.m08 = (_ + g) * E),
            (this.m09 = (p - f) * E),
            (this.m10 = (1 - (c + d)) * E),
            (this.m11 = 0),
            (this.m12 = e.x),
            (this.m13 = e.y),
            (this.m14 = e.z),
            (this.m15 = 1),
            this
          );
        }
        fromSRT(t, e, i) {
          const s = t.x,
            n = t.y,
            r = t.z,
            a = t.w,
            o = s + s,
            h = n + n,
            l = r + r,
            c = s * o,
            u = s * h,
            _ = s * l,
            d = n * h,
            p = n * l,
            m = r * l,
            f = a * o,
            g = a * h,
            y = a * l,
            T = i.x,
            S = i.y,
            E = i.z;
          return (
            (this.m00 = (1 - (d + m)) * T),
            (this.m01 = (u + y) * T),
            (this.m02 = (_ - g) * T),
            (this.m03 = 0),
            (this.m04 = (u - y) * S),
            (this.m05 = (1 - (c + m)) * S),
            (this.m06 = (p + f) * S),
            (this.m07 = 0),
            (this.m08 = (_ + g) * E),
            (this.m09 = (p - f) * E),
            (this.m10 = (1 - (c + d)) * E),
            (this.m11 = 0),
            (this.m12 = e.x),
            (this.m13 = e.y),
            (this.m14 = e.z),
            (this.m15 = 1),
            this
          );
        }
        fromQuat(t) {
          const e = t.x,
            i = t.y,
            s = t.z,
            n = t.w,
            r = e + e,
            a = i + i,
            o = s + s,
            h = e * r,
            l = i * r,
            c = i * a,
            u = s * r,
            _ = s * a,
            d = s * o,
            p = n * r,
            m = n * a,
            f = n * o;
          return (
            (this.m00 = 1 - c - d),
            (this.m01 = l + f),
            (this.m02 = u - m),
            (this.m03 = 0),
            (this.m04 = l - f),
            (this.m05 = 1 - h - d),
            (this.m06 = _ + p),
            (this.m07 = 0),
            (this.m08 = u + m),
            (this.m09 = _ - p),
            (this.m10 = 1 - h - c),
            (this.m11 = 0),
            (this.m12 = 0),
            (this.m13 = 0),
            (this.m14 = 0),
            (this.m15 = 1),
            this
          );
        }
      }
      t("Mat4", ms), (ds = ms), (ms.IDENTITY = Object.freeze(new ds()));
      const fs = new Yi(),
        gs = new es();
      function ys(t, e, i, s, n, r, a, o, h, l, c, u, _, d, p, m) {
        return new ms(t, e, i, s, n, r, a, o, h, l, c, u, _, d, p, m);
      }
      var Ts;
      hi.fastDefine("cc.Mat4", ms, {
        m00: 1,
        m01: 0,
        m02: 0,
        m03: 0,
        m04: 0,
        m05: 1,
        m06: 0,
        m07: 0,
        m08: 0,
        m09: 0,
        m10: 1,
        m11: 0,
        m12: 0,
        m13: 0,
        m14: 0,
        m15: 1,
      }),
        (a.Mat4 = ms),
        (a.mat4 = ys);
      class Ss extends pe {
        static clone(t) {
          return new Ss(t.x, t.y);
        }
        static copy(t, e) {
          return (t.x = e.x), (t.y = e.y), t;
        }
        static set(t, e, i) {
          return (t.x = e), (t.y = i), t;
        }
        static add(t, e, i) {
          return (t.x = e.x + i.x), (t.y = e.y + i.y), t;
        }
        static subtract(t, e, i) {
          return (t.x = e.x - i.x), (t.y = e.y - i.y), t;
        }
        static multiply(t, e, i) {
          return (t.x = e.x * i.x), (t.y = e.y * i.y), t;
        }
        static divide(t, e, i) {
          return (t.x = e.x / i.x), (t.y = e.y / i.y), t;
        }
        static ceil(t, e) {
          return (t.x = Math.ceil(e.x)), (t.y = Math.ceil(e.y)), t;
        }
        static floor(t, e) {
          return (t.x = Math.floor(e.x)), (t.y = Math.floor(e.y)), t;
        }
        static min(t, e, i) {
          return (t.x = Math.min(e.x, i.x)), (t.y = Math.min(e.y, i.y)), t;
        }
        static max(t, e, i) {
          return (t.x = Math.max(e.x, i.x)), (t.y = Math.max(e.y, i.y)), t;
        }
        static round(t, e) {
          return (t.x = Math.round(e.x)), (t.y = Math.round(e.y)), t;
        }
        static multiplyScalar(t, e, i) {
          return (t.x = e.x * i), (t.y = e.y * i), t;
        }
        static scaleAndAdd(t, e, i, s) {
          return (t.x = e.x + i.x * s), (t.y = e.y + i.y * s), t;
        }
        static distance(t, e) {
          const i = e.x - t.x,
            s = e.y - t.y;
          return Math.sqrt(i * i + s * s);
        }
        static squaredDistance(t, e) {
          const i = e.x - t.x,
            s = e.y - t.y;
          return i * i + s * s;
        }
        static len(t) {
          const e = t.x,
            i = t.y;
          return Math.sqrt(e * e + i * i);
        }
        static lengthSqr(t) {
          const e = t.x,
            i = t.y;
          return e * e + i * i;
        }
        static negate(t, e) {
          return (t.x = -e.x), (t.y = -e.y), t;
        }
        static inverse(t, e) {
          return (t.x = 1 / e.x), (t.y = 1 / e.y), t;
        }
        static inverseSafe(t, e) {
          const i = e.x,
            s = e.y;
          return (
            Math.abs(i) < gi ? (t.x = 0) : (t.x = 1 / i),
            Math.abs(s) < gi ? (t.y = 0) : (t.y = 1 / s),
            t
          );
        }
        static normalize(t, e) {
          const i = e.x,
            s = e.y;
          let n = i * i + s * s;
          return (
            n > 0
              ? ((n = 1 / Math.sqrt(n)), (t.x = i * n), (t.y = s * n))
              : ((t.x = 0), (t.y = 0)),
            t
          );
        }
        static dot(t, e) {
          return t.x * e.x + t.y * e.y;
        }
        static cross(t, e, i) {
          return t instanceof Yi
            ? ((t.x = t.y = 0), (t.z = e.x * i.y - e.y * i.x), t)
            : t.x * e.y - t.y * e.x;
        }
        static lerp(t, e, i, s) {
          const n = e.x,
            r = e.y;
          return (t.x = n + s * (i.x - n)), (t.y = r + s * (i.y - r)), t;
        }
        static random(t, e) {
          e = e || 1;
          const i = 2 * Ci() * Math.PI;
          return (t.x = Math.cos(i) * e), (t.y = Math.sin(i) * e), t;
        }
        static transformMat3(t, e, i) {
          const s = e.x,
            n = e.y;
          return (
            (t.x = i.m00 * s + i.m03 * n + i.m06),
            (t.y = i.m01 * s + i.m04 * n + i.m07),
            t
          );
        }
        static transformMat4(t, e, i) {
          const s = e.x,
            n = e.y;
          return (
            (t.x = i.m00 * s + i.m04 * n + i.m12),
            (t.y = i.m01 * s + i.m05 * n + i.m13),
            t
          );
        }
        static str(t) {
          return `Vec2(${t.x}, ${t.y})`;
        }
        static toArray(t, e, i = 0) {
          return (t[i + 0] = e.x), (t[i + 1] = e.y), t;
        }
        static fromArray(t, e, i = 0) {
          return (t.x = e[i + 0]), (t.y = e[i + 1]), t;
        }
        static strictEquals(t, e) {
          return t.x === e.x && t.y === e.y;
        }
        static equals(t, e, i = gi) {
          return (
            Math.abs(t.x - e.x) <=
              i * Math.max(1, Math.abs(t.x), Math.abs(e.x)) &&
            Math.abs(t.y - e.y) <= i * Math.max(1, Math.abs(t.y), Math.abs(e.y))
          );
        }
        static angle(t, e) {
          const i = t.x * t.x + t.y * t.y,
            s = e.x * e.x + e.y * e.y;
          if (0 === i || 0 === s) return 0;
          let n = (t.x * e.x + t.y * e.y) / Math.sqrt(i * s);
          return (n = Si(n, -1, 1)), Math.acos(n);
        }
        constructor(t, e) {
          super(),
            "object" == typeof t
              ? ((this.x = t.x), (this.y = t.y))
              : ((this.x = t || 0), (this.y = e || 0));
        }
        clone() {
          return new Ss(this.x, this.y);
        }
        set(t, e) {
          return (
            "object" == typeof t
              ? ((this.x = t.x), (this.y = t.y))
              : ((this.x = t || 0), (this.y = e || 0)),
            this
          );
        }
        equals(t, e = gi) {
          return (
            Math.abs(this.x - t.x) <=
              e * Math.max(1, Math.abs(this.x), Math.abs(t.x)) &&
            Math.abs(this.y - t.y) <=
              e * Math.max(1, Math.abs(this.y), Math.abs(t.y))
          );
        }
        equals2f(t, e, i = gi) {
          return (
            Math.abs(this.x - t) <=
              i * Math.max(1, Math.abs(this.x), Math.abs(t)) &&
            Math.abs(this.y - e) <=
              i * Math.max(1, Math.abs(this.y), Math.abs(e))
          );
        }
        strictEquals(t) {
          return t && this.x === t.x && this.y === t.y;
        }
        strictEquals2f(t, e) {
          return this.x === t && this.y === e;
        }
        toString() {
          return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`;
        }
        lerp(t, e) {
          const i = this.x,
            s = this.y;
          return (
            (this.x = i + e * (t.x - i)), (this.y = s + e * (t.y - s)), this
          );
        }
        clampf(t, e) {
          return (
            (this.x = Si(this.x, t.x, e.x)),
            (this.y = Si(this.y, t.y, e.y)),
            this
          );
        }
        add(t) {
          return (this.x += t.x), (this.y += t.y), this;
        }
        add2f(t, e) {
          return (this.x += t), (this.y += e), this;
        }
        subtract(t) {
          return (this.x -= t.x), (this.y -= t.y), this;
        }
        subtract2f(t, e) {
          return (this.x -= t), (this.y -= e), this;
        }
        multiplyScalar(t) {
          return (
            "object" == typeof t && z(16359), (this.x *= t), (this.y *= t), this
          );
        }
        multiply(t) {
          return (
            "object" != typeof t && z(16360),
            (this.x *= t.x),
            (this.y *= t.y),
            this
          );
        }
        multiply2f(t, e) {
          return (this.x *= t), (this.y *= e), this;
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), this;
        }
        divide2f(t, e) {
          return (this.x /= t), (this.y /= e), this;
        }
        negative() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y;
        }
        cross(t) {
          return this.x * t.y - this.y * t.x;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        lengthSqr() {
          return this.x * this.x + this.y * this.y;
        }
        normalize() {
          const t = this.x,
            e = this.y;
          let i = t * t + e * e;
          return (
            i > 0 && ((i = 1 / Math.sqrt(i)), (this.x *= i), (this.y *= i)),
            this
          );
        }
        angle(t) {
          const e = this.lengthSqr(),
            i = t.lengthSqr();
          if (0 === e || 0 === i) return 0;
          let s = this.dot(t) / Math.sqrt(e * i);
          return (s = Si(s, -1, 1)), Math.acos(s);
        }
        signAngle(t) {
          const e = this.cross(t),
            i = this.dot(t);
          return Math.atan2(e, i);
        }
        rotate(t) {
          const e = this.x,
            i = this.y,
            s = Math.sin(t),
            n = Math.cos(t);
          return (this.x = n * e - s * i), (this.y = s * e + n * i), this;
        }
        project(t) {
          const e = this.dot(t) / t.dot(t);
          return (this.x = t.x * e), (this.y = t.y * e), this;
        }
        transformMat4(t) {
          const e = this.x,
            i = this.y;
          return (
            (this.x = t.m00 * e + t.m04 * i + t.m12),
            (this.y = t.m01 * e + t.m05 * i + t.m13),
            this
          );
        }
        toVec3() {
          return new Yi(this.x, this.y, 0);
        }
      }
      function Es(t, e) {
        return new Ss(t, e);
      }
      t("Vec2", Ss),
        (Ts = Ss),
        (Ss.ZERO = Object.freeze(new Ts(0, 0))),
        (Ss.ONE = Object.freeze(new Ts(1, 1))),
        (Ss.NEG_ONE = Object.freeze(new Ts(-1, -1))),
        (Ss.UNIT_X = Object.freeze(new Ts(1, 0))),
        (Ss.UNIT_Y = Object.freeze(new Ts(0, 1))),
        hi.fastDefine("cc.Vec2", Ss, { x: 0, y: 0 }),
        (a.Vec2 = Ss),
        (a.v2 = Es),
        $(Ss, "Vec2", [
          { name: "sub", newName: "subtract", target: Ss, targetName: "Vec2" },
          { name: "mul", newName: "multiply", target: Ss, targetName: "Vec2" },
          { name: "div", newName: "divide", target: Ss, targetName: "Vec2" },
          { name: "dist", newName: "distance", target: Ss, targetName: "Vec2" },
          {
            name: "sqrDist",
            newName: "squaredDistance",
            target: Ss,
            targetName: "Vec2",
          },
          { name: "mag", newName: "len", target: Ss, targetName: "Vec2" },
          {
            name: "sqrMag",
            newName: "lengthSqr",
            target: Ss,
            targetName: "Vec2",
          },
          {
            name: "scale",
            newName: "multiplyScalar",
            target: Ss,
            targetName: "Vec2",
          },
          {
            name: "exactEquals",
            newName: "strictEquals",
            target: Ss,
            targetName: "Vec2",
          },
        ]),
        $(Ss.prototype, "Vec2", [
          {
            name: "mag",
            newName: "length",
            target: Ss.prototype,
            targetName: "Vec2",
          },
          {
            name: "magSqr",
            newName: "lengthSqr",
            target: Ss.prototype,
            targetName: "Vec2",
          },
          {
            name: "scale",
            newName: "multiplyScalar",
            target: Ss.prototype,
            targetName: "Vec2",
          },
          {
            name: "exactEquals",
            newName: "strictEquals",
            target: Ss.prototype,
            targetName: "Vec2",
          },
        ]),
        $(Yi, "Vec3", [
          { name: "sub", newName: "subtract", target: Yi, targetName: "Vec3" },
          { name: "mul", newName: "multiply", target: Yi, targetName: "Vec3" },
          { name: "div", newName: "divide", target: Yi, targetName: "Vec3" },
          { name: "dist", newName: "distance", target: Yi, targetName: "Vec3" },
          {
            name: "sqrDist",
            newName: "squaredDistance",
            target: Yi,
            targetName: "Vec3",
          },
          { name: "mag", newName: "len", target: Yi, targetName: "Vec3" },
          {
            name: "sqrMag",
            newName: "lengthSqr",
            target: Yi,
            targetName: "Vec3",
          },
          {
            name: "scale",
            newName: "multiplyScalar",
            target: Yi,
            targetName: "Vec3",
          },
          {
            name: "exactEquals",
            newName: "strictEquals",
            target: Yi,
            targetName: "Vec3",
          },
        ]),
        $(Yi.prototype, "Vec3", [
          {
            name: "mag",
            newName: "length",
            target: Yi.prototype,
            targetName: "Vec3",
          },
          {
            name: "magSqr",
            newName: "lengthSqr",
            target: Yi.prototype,
            targetName: "Vec3",
          },
          {
            name: "scale",
            newName: "multiplyScalar",
            target: Yi.prototype,
            targetName: "Vec3",
          },
          {
            name: "exactEquals",
            newName: "strictEquals",
            target: Yi.prototype,
            targetName: "Vec3",
          },
        ]),
        $(Wi, "Vec4", [
          { name: "sub", newName: "subtract", target: Wi, targetName: "Vec4" },
          { name: "mul", newName: "multiply", target: Wi, targetName: "Vec4" },
          { name: "div", newName: "divide", target: Wi, targetName: "Vec4" },
          { name: "dist", newName: "distance", target: Wi, targetName: "Vec4" },
          {
            name: "sqrDist",
            newName: "squaredDistance",
            target: Wi,
            targetName: "Vec4",
          },
          { name: "mag", newName: "len", target: Wi, targetName: "Vec4" },
          {
            name: "sqrMag",
            newName: "lengthSqr",
            target: Wi,
            targetName: "Vec4",
          },
          {
            name: "scale",
            newName: "multiplyScalar",
            target: Wi,
            targetName: "Vec4",
          },
          {
            name: "exactEquals",
            newName: "strictEquals",
            target: Wi,
            targetName: "Vec4",
          },
        ]),
        $(Wi.prototype, "Vec4", [
          {
            name: "mag",
            newName: "length",
            target: Wi.prototype,
            targetName: "Vec4",
          },
          {
            name: "magSqr",
            newName: "lengthSqr",
            target: Wi.prototype,
            targetName: "Vec4",
          },
          {
            name: "scale",
            newName: "multiplyScalar",
            target: Wi.prototype,
            targetName: "Vec4",
          },
          {
            name: "exactEquals",
            newName: "strictEquals",
            target: Wi.prototype,
            targetName: "Vec4",
          },
        ]),
        $(as, "Quat", [
          { name: "mag", newName: "len", target: as, targetName: "Quat" },
          { name: "mul", newName: "multiply", target: as, targetName: "Quat" },
          {
            name: "sqrMag",
            newName: "lengthSqr",
            target: as,
            targetName: "Quat",
          },
          {
            name: "scale",
            newName: "multiplyScalar",
            target: as,
            targetName: "Quat",
          },
          {
            name: "exactEquals",
            newName: "strictEquals",
            target: as,
            targetName: "Quat",
          },
        ]),
        $(as.prototype, "Quat", [
          {
            name: "scale",
            newName: "multiplyScalar",
            target: as.prototype,
            targetName: "Quat",
          },
          {
            name: "exactEquals",
            newName: "strictEquals",
            target: as.prototype,
            targetName: "Quat",
          },
        ]),
        $(Qi, "Color", [
          { name: "sub", newName: "subtract", target: Qi, targetName: "Color" },
          { name: "mul", newName: "multiply", target: Qi, targetName: "Color" },
          { name: "div", newName: "divide", target: Qi, targetName: "Color" },
          {
            name: "exactEquals",
            newName: "strictEquals",
            target: Qi,
            targetName: "Color",
          },
          {
            name: "fromHex",
            newName: "fromHEX",
            customFunction(...t) {
              const e = t[1].toString(16);
              return a.Color.fromHEX(t[0], e);
            },
          },
        ]),
        $(es, "Mat3", [
          { name: "sub", newName: "subtract", target: es, targetName: "Mat3" },
          { name: "mul", newName: "multiply", target: es, targetName: "Mat3" },
          {
            name: "exactEquals",
            newName: "strictEquals",
            target: es,
            targetName: "Mat3",
          },
          {
            name: "transfrom",
            newName: "transform",
            target: es,
            targetName: "Mat3",
          },
        ]),
        $(es.prototype, "Mat3", [
          {
            name: "sub",
            newName: "subtract",
            target: es.prototype,
            targetName: "Mat3",
          },
          {
            name: "mul",
            newName: "multiply",
            target: es.prototype,
            targetName: "Mat3",
          },
          {
            name: "mulScalar",
            newName: "multiplyScalar",
            target: es.prototype,
            targetName: "Mat3",
          },
          {
            name: "exactEquals",
            newName: "strictEquals",
            target: es.prototype,
            targetName: "Mat3",
          },
        ]),
        $(ms, "Mat4", [
          { name: "sub", newName: "subtract", target: ms, targetName: "Mat4" },
          { name: "mul", newName: "multiply", target: ms, targetName: "Mat4" },
          {
            name: "exactEquals",
            newName: "strictEquals",
            target: ms,
            targetName: "Mat4",
          },
        ]),
        $(ms.prototype, "Mat4", [
          {
            name: "sub",
            newName: "subtract",
            target: ms.prototype,
            targetName: "Mat4",
          },
          {
            name: "mul",
            newName: "multiply",
            target: ms.prototype,
            targetName: "Mat4",
          },
          {
            name: "mulScalar",
            newName: "multiplyScalar",
            target: ms.prototype,
            targetName: "Mat4",
          },
          {
            name: "exactEquals",
            newName: "strictEquals",
            target: ms.prototype,
            targetName: "Mat4",
          },
        ]);
      const vs = (t, e, i) => {
        Object.defineProperty(t, e, {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._data()[i];
          },
          set(t) {
            this._data()[i] = t;
          },
        });
      };
      let bs;
      function As(t, e, i) {
        (t._data = function () {
          return (
            this.__data ||
              (this.__data = new Float32Array(this.underlyingData())),
            this.__data
          );
        }),
          Object.setPrototypeOf(t, e),
          Object.defineProperty(t, "type", {
            configurable: !0,
            enumerable: !0,
            writable: !1,
            value: i,
          });
      }
      function Cs(t, e) {
        for (const i of ["__cid__", "__classname__"])
          Object.defineProperty(t.prototype, i, {
            value: e.prototype[i],
            writable: !1,
            enumerable: !1,
            configurable: !0,
          });
        for (const i of ["__attrs__", "__props__", "__values__"]) t[i] = e[i];
      }
      !(function (t) {
        (t[(t.VEC2 = 0)] = "VEC2"),
          (t[(t.VEC3 = 1)] = "VEC3"),
          (t[(t.VEC4 = 2)] = "VEC4"),
          (t[(t.QUATERNION = 3)] = "QUATERNION"),
          (t[(t.MAT3 = 4)] = "MAT3"),
          (t[(t.MAT4 = 5)] = "MAT4"),
          (t[(t.SIZE = 6)] = "SIZE"),
          (t[(t.RECT = 7)] = "RECT"),
          (t[(t.COLOR = 8)] = "COLOR");
      })(bs || (bs = {})),
        As(jsb.Mat4.prototype, ms.prototype, bs.MAT4);
      for (let t = 0; t < 16; t++) {
        const e = `0${t}`;
        vs(jsb.Mat4.prototype, `m${e.substring(e.length - 2)}`, t);
      }
      for (let t = 0; t < 9; t++) {
        const e = `0${t}`;
        vs(jsb.Mat3.prototype, `m${e.substring(e.length - 2)}`, t);
      }
      As(jsb.Mat3.prototype, es.prototype, bs.MAT3),
        vs(jsb.Vec2.prototype, "x", 0),
        vs(jsb.Vec2.prototype, "y", 1),
        As(jsb.Vec2.prototype, Ss.prototype, bs.VEC2),
        vs(jsb.Vec3.prototype, "x", 0),
        vs(jsb.Vec3.prototype, "y", 1),
        vs(jsb.Vec3.prototype, "z", 2),
        As(jsb.Vec3.prototype, Yi.prototype, bs.VEC3),
        vs(jsb.Vec4.prototype, "x", 0),
        vs(jsb.Vec4.prototype, "y", 1),
        vs(jsb.Vec4.prototype, "z", 2),
        vs(jsb.Vec4.prototype, "w", 3),
        As(jsb.Vec4.prototype, Wi.prototype, bs.VEC4),
        vs(jsb.Quat.prototype, "x", 0),
        vs(jsb.Quat.prototype, "y", 1),
        vs(jsb.Quat.prototype, "z", 2),
        vs(jsb.Quat.prototype, "w", 3),
        As(jsb.Quat.prototype, as.prototype, bs.QUATERNION),
        Object.setPrototypeOf(jsb.Color.prototype, Qi.prototype),
        Object.defineProperty(jsb.Color.prototype, "type", {
          configurable: !0,
          enumerable: !0,
          writable: !1,
          value: bs.COLOR,
        }),
        Cs(jsb.Vec4, Wi),
        Cs(jsb.Vec3, Yi),
        Cs(jsb.Vec2, Ss),
        Cs(jsb.Mat4, ms),
        Cs(jsb.Mat3, es),
        Cs(jsb.Color, Qi),
        Cs(jsb.Quat, as);
      class Os {
        static identity() {
          return new Os();
        }
        static clone(t) {
          return new Os(t.a, t.b, t.c, t.d, t.tx, t.ty);
        }
        static concat(t, e, i) {
          const s = e.a,
            n = e.b,
            r = e.c,
            a = e.d,
            o = e.tx,
            h = e.ty;
          (t.a = s * i.a + n * i.c),
            (t.b = s * i.b + n * i.d),
            (t.c = r * i.a + a * i.c),
            (t.d = r * i.b + a * i.d),
            (t.tx = o * i.a + h * i.c + i.tx),
            (t.ty = o * i.b + h * i.d + i.ty);
        }
        static invert(t, e) {
          const i = 1 / (e.a * e.d - e.b * e.c);
          (t.a = i * e.d),
            (t.b = -i * e.b),
            (t.c = -i * e.c),
            (t.d = i * e.a),
            (t.tx = i * (e.c * e.ty - e.d * e.tx)),
            (t.ty = i * (e.b * e.tx - e.a * e.ty));
        }
        static fromMat4(t, e) {
          (t.a = e.m00),
            (t.b = e.m01),
            (t.c = e.m04),
            (t.d = e.m05),
            (t.tx = e.m12),
            (t.ty = e.m13);
        }
        static transformVec2(t, e, i, s) {
          let n, r;
          s ? ((n = e), (r = i)) : ((s = i), (n = e.x), (r = e.y)),
            (t.x = s.a * n + s.c * r + s.tx),
            (t.y = s.b * n + s.d * r + s.ty);
        }
        static transformSize(t, e, i) {
          (t.width = i.a * e.width + i.c * e.height),
            (t.height = i.b * e.width + i.d * e.height);
        }
        static transformRect(t, e, i) {
          const s = e.x + e.width,
            n = e.y + e.height,
            r = i.a * e.x + i.c * e.y + i.tx,
            a = i.b * e.x + i.d * e.y + i.ty,
            o = i.a * s + i.c * e.y + i.tx,
            h = i.b * s + i.d * e.y + i.ty,
            l = i.a * e.x + i.c * n + i.tx,
            c = i.b * e.x + i.d * n + i.ty,
            u = i.a * s + i.c * n + i.tx,
            _ = i.b * s + i.d * n + i.ty,
            d = Math.min(r, o, l, u),
            p = Math.max(r, o, l, u),
            m = Math.min(a, h, c, _),
            f = Math.max(a, h, c, _);
          (t.x = d), (t.y = m), (t.width = p - d), (t.height = f - m);
        }
        static transformObb(t, e, i, s, n, r, a = !0) {
          const o = r.a * n.x + r.c * n.y + r.tx,
            h = r.b * n.x + r.d * n.y + r.ty,
            l = r.a * n.width,
            c = r.b * n.width,
            u = r.c * n.height,
            _ = r.d * n.height;
          a
            ? ((e.x = o),
              (e.y = h),
              (i.x = l + o),
              (i.y = c + h),
              (t.x = u + o),
              (t.y = _ + h),
              (s.x = l + u + o),
              (s.y = c + _ + h))
            : ((t.x = o),
              (t.y = h),
              (s.x = l + o),
              (s.y = c + h),
              (e.x = u + o),
              (e.y = _ + h),
              (i.x = l + u + o),
              (i.y = c + _ + h));
        }
        constructor(t = 1, e = 0, i = 0, s = 1, n = 0, r = 0) {
          (this.a = t),
            (this.b = e),
            (this.c = i),
            (this.d = s),
            (this.tx = n),
            (this.ty = r);
        }
      }
      var Is;
      t("AffineTransform", Os), (a.AffineTransform = Os);
      class ws extends pe {
        static lerp(t, e, i, s) {
          return (
            (t.width = e.width + (i.width - e.width) * s),
            (t.height = e.height + (i.height - e.height) * s),
            t
          );
        }
        static equals(t, e) {
          return t.width === e.width && t.height === e.height;
        }
        set x(t) {
          this.width = t;
        }
        get x() {
          return this.width;
        }
        set y(t) {
          this.height = t;
        }
        get y() {
          return this.height;
        }
        constructor(t, e) {
          super(),
            "object" == typeof t
              ? ((this.width = t.width), (this.height = t.height))
              : ((this.width = t || 0), (this.height = e || 0));
        }
        clone() {
          return new ws(this.width, this.height);
        }
        set(t, e) {
          return (
            "object" == typeof t
              ? ((this.height = t.height), (this.width = t.width))
              : ((this.width = t || 0), (this.height = e || 0)),
            this
          );
        }
        equals(t) {
          return this.width === t.width && this.height === t.height;
        }
        lerp(t, e) {
          return (
            (this.width += (t.width - this.width) * e),
            (this.height += (t.height - this.height) * e),
            this
          );
        }
        toString() {
          return `(${this.width.toFixed(2)}, ${this.height.toFixed(2)})`;
        }
      }
      function Rs(t = 0, e = 0) {
        return new ws(t, e);
      }
      t("Size", ws),
        (Is = ws),
        (ws.ZERO = Object.freeze(new Is(0, 0))),
        (ws.ONE = Object.freeze(new Is(1, 1))),
        hi.fastDefine("cc.Size", ws, { width: 0, height: 0 }),
        (a.size = Rs),
        (a.Size = ws);
      class Ds extends pe {
        static fromMinMax(t, e, i) {
          const s = Math.min(e.x, i.x),
            n = Math.min(e.y, i.y),
            r = Math.max(e.x, i.x),
            a = Math.max(e.y, i.y);
          return (t.x = s), (t.y = n), (t.width = r - s), (t.height = a - n), t;
        }
        static lerp(t, e, i, s) {
          const n = e.x,
            r = e.y,
            a = e.width,
            o = e.height;
          return (
            (t.x = n + (i.x - n) * s),
            (t.y = r + (i.y - r) * s),
            (t.width = a + (i.width - a) * s),
            (t.height = o + (i.height - o) * s),
            t
          );
        }
        static intersection(t, e, i) {
          const s = e.x,
            n = e.y,
            r = e.x + e.width,
            a = e.y + e.height,
            o = i.x,
            h = i.y,
            l = i.x + i.width,
            c = i.y + i.height;
          return (
            (t.x = Math.max(s, o)),
            (t.y = Math.max(n, h)),
            (t.width = Math.min(r, l) - t.x),
            (t.height = Math.min(a, c) - t.y),
            t
          );
        }
        static union(t, e, i) {
          const s = e.x,
            n = e.y,
            r = e.width,
            a = e.height,
            o = i.x,
            h = i.y,
            l = i.width,
            c = i.height;
          return (
            (t.x = Math.min(s, o)),
            (t.y = Math.min(n, h)),
            (t.width = Math.max(s + r, o + l) - t.x),
            (t.height = Math.max(n + a, h + c) - t.y),
            t
          );
        }
        static equals(t, e) {
          return (
            t.x === e.x &&
            t.y === e.y &&
            t.width === e.width &&
            t.height === e.height
          );
        }
        get xMin() {
          return this.x;
        }
        set xMin(t) {
          (this.width += this.x - t), (this.x = t);
        }
        get yMin() {
          return this.y;
        }
        set yMin(t) {
          (this.height += this.y - t), (this.y = t);
        }
        get xMax() {
          return this.x + this.width;
        }
        set xMax(t) {
          this.width = t - this.x;
        }
        get yMax() {
          return this.y + this.height;
        }
        set yMax(t) {
          this.height = t - this.y;
        }
        get center() {
          return new Ss(this.x + 0.5 * this.width, this.y + 0.5 * this.height);
        }
        set center(t) {
          (this.x = t.x - 0.5 * this.width), (this.y = t.y - 0.5 * this.height);
        }
        get origin() {
          return new Ss(this.x, this.y);
        }
        set origin(t) {
          (this.x = t.x), (this.y = t.y);
        }
        get size() {
          return new ws(this.width, this.height);
        }
        set size(t) {
          (this.width = t.width), (this.height = t.height);
        }
        set z(t) {
          this.width = t;
        }
        get z() {
          return this.width;
        }
        set w(t) {
          this.height = t;
        }
        get w() {
          return this.height;
        }
        constructor(t, e, i, s) {
          super(),
            "object" == typeof t
              ? ((this.x = t.x),
                (this.y = t.y),
                (this.width = t.width),
                (this.height = t.height))
              : ((this.x = t || 0),
                (this.y = e || 0),
                (this.width = i || 0),
                (this.height = s || 0));
        }
        clone() {
          return new Ds(this.x, this.y, this.width, this.height);
        }
        set(t, e, i, s) {
          return (
            "object" == typeof t
              ? ((this.x = t.x),
                (this.y = t.y),
                (this.width = t.width),
                (this.height = t.height))
              : ((this.x = t || 0),
                (this.y = e || 0),
                (this.width = i || 0),
                (this.height = s || 0)),
            this
          );
        }
        equals(t) {
          return (
            this.x === t.x &&
            this.y === t.y &&
            this.width === t.width &&
            this.height === t.height
          );
        }
        lerp(t, e) {
          const i = this.x,
            s = this.y,
            n = this.width,
            r = this.height;
          return (
            (this.x = i + (t.x - i) * e),
            (this.y = s + (t.y - s) * e),
            (this.width = n + (t.width - n) * e),
            (this.height = r + (t.height - r) * e),
            this
          );
        }
        toString() {
          return `(${this.x.toFixed(2)}, ${this.y.toFixed(
            2
          )}, ${this.width.toFixed(2)}, ${this.height.toFixed(2)})`;
        }
        intersects(t) {
          const e = this.x + this.width,
            i = this.y + this.height,
            s = t.x + t.width,
            n = t.y + t.height;
          return !(e < t.x || s < this.x || i < t.y || n < this.y);
        }
        contains(t) {
          return (
            this.x <= t.x &&
            this.x + this.width >= t.x &&
            this.y <= t.y &&
            this.y + this.height >= t.y
          );
        }
        containsRect(t) {
          return (
            this.x <= t.x &&
            this.x + this.width >= t.x + t.width &&
            this.y <= t.y &&
            this.y + this.height >= t.y + t.height
          );
        }
        transformMat4(t) {
          const e = this.x,
            i = this.y,
            s = e + this.width,
            n = i + this.height,
            r = t.m00 * e + t.m04 * i + t.m12,
            a = t.m01 * e + t.m05 * i + t.m13,
            o = t.m00 * s + t.m04 * i + t.m12,
            h = t.m01 * s + t.m05 * i + t.m13,
            l = t.m00 * e + t.m04 * n + t.m12,
            c = t.m01 * e + t.m05 * n + t.m13,
            u = t.m00 * s + t.m04 * n + t.m12,
            _ = t.m01 * s + t.m05 * n + t.m13,
            d = Math.min(r, o, l, u),
            p = Math.max(r, o, l, u),
            m = Math.min(a, h, c, _),
            f = Math.max(a, h, c, _);
          return (
            (this.x = d),
            (this.y = m),
            (this.width = p - d),
            (this.height = f - m),
            this
          );
        }
        transformMat4ToPoints(t, e, i, s, n) {
          const r = this.x,
            a = this.y,
            o = r + this.width,
            h = a + this.height;
          (e.x = t.m00 * r + t.m04 * a + t.m12),
            (e.y = t.m01 * r + t.m05 * a + t.m13),
            (n.x = t.m00 * o + t.m04 * a + t.m12),
            (n.y = t.m01 * o + t.m05 * a + t.m13),
            (i.x = t.m00 * r + t.m04 * h + t.m12),
            (i.y = t.m01 * r + t.m05 * h + t.m13),
            (s.x = t.m00 * o + t.m04 * h + t.m12),
            (s.y = t.m01 * o + t.m05 * h + t.m13);
        }
      }
      function xs(t = 0, e = 0, i = 0, s = 0) {
        return new Ds(t, e, i, s);
      }
      t("Rect", Ds),
        hi.fastDefine("cc.Rect", Ds, { x: 0, y: 0, width: 0, height: 0 }),
        (a.Rect = Ds),
        (a.rect = xs);
      const Ms = t("MATH_FLOAT_ARRAY", Float32Array);
      class Ps extends pe {
        static createFloatArray(t) {
          return new Ms(t);
        }
        get array() {
          return this._array;
        }
      }
      t("MathBase", Ps);
      var Ns = Object.freeze({
        __proto__: null,
        bits: g,
        Vec2: Ss,
        v2: Es,
        Vec3: Yi,
        v3: Ki,
        Vec4: Wi,
        v4: Xi,
        Quat: as,
        quat: _s,
        Mat3: es,
        Mat4: ms,
        mat4: ys,
        AffineTransform: Os,
        Size: ws,
        size: Rs,
        Rect: Ds,
        rect: xs,
        Color: Qi,
        color: Ji,
        preTransforms: ps,
        HALF_PI: mi,
        TWO_PI: fi,
        EPSILON: gi,
        equals: yi,
        approx: Ti,
        clamp: Si,
        clamp01: Ei,
        lerp: vi,
        toRadian: bi,
        toDegree: Ai,
        random: Ci,
        setRandGenerator: Oi,
        randomRange: Ii,
        randomRangeInt: wi,
        pseudoRandom: Ri,
        pseudoRandomRange: Di,
        pseudoRandomRangeInt: xi,
        nextPow2: Mi,
        repeat: Pi,
        pingPong: Ni,
        inverseLerp: Li,
        absMaxComponent: Bi,
        absMax: Fi,
        enumerableProps: Ui,
        floatToHalf: Hi,
        halfToFloat: Gi,
        MATH_FLOAT_ARRAY: Ms,
        MathBase: Ps,
      });
      t("math", Ns);
      const Ls = new Yi(),
        Bs = new Yi(),
        Fs = new Yi(),
        Us = new Yi(),
        ks = new Yi(),
        zs = new Yi(),
        Hs = new Array(3),
        Gs = new Array(3);
      function Vs(t, e) {
        return Yi.dot(e.n, t) - e.d;
      }
      function js(t, e, i) {
        return (
          Yi.copy(t, e),
          Yi.subtract(ks, i.center, i.halfExtents),
          Yi.add(zs, i.center, i.halfExtents),
          (t.x = t.x < ks.x ? ks.x : t.x),
          (t.y = t.y < ks.y ? ks.y : t.y),
          (t.z = t.z < ks.z ? ks.z : t.z),
          (t.x = t.x > zs.x ? zs.x : t.x),
          (t.y = t.y > zs.y ? zs.y : t.y),
          (t.z = t.z > zs.z ? zs.z : t.z),
          t
        );
      }
      function Ws(t, e, i) {
        Yi.set(Ls, i.orientation.m00, i.orientation.m01, i.orientation.m02),
          Yi.set(Bs, i.orientation.m03, i.orientation.m04, i.orientation.m05),
          Yi.set(Fs, i.orientation.m06, i.orientation.m07, i.orientation.m08),
          (Hs[0] = Ls),
          (Hs[1] = Bs),
          (Hs[2] = Fs),
          (Gs[0] = i.halfExtents.x),
          (Gs[1] = i.halfExtents.y),
          (Gs[2] = i.halfExtents.z),
          Yi.subtract(Us, e, i.center),
          Yi.set(t, i.center.x, i.center.y, i.center.z);
        for (let e = 0; e < 3; e++) {
          let i = Yi.dot(Us, Hs[e]);
          i > Gs[e] && (i = Gs[e]),
            i < -Gs[e] && (i = -Gs[e]),
            (t.x += i * Hs[e].x),
            (t.y += i * Hs[e].y),
            (t.z += i * Hs[e].z);
        }
        return t;
      }
      var Xs = Object.freeze({
          __proto__: null,
          point_plane: Vs,
          pt_point_plane: function (t, e, i) {
            const s = Vs(e, i);
            return Yi.subtract(t, e, Yi.multiplyScalar(t, i.n, s));
          },
          pt_point_aabb: js,
          pt_point_obb: Ws,
          pt_point_line: function (t, e, i, s) {
            Yi.subtract(Ls, i, s);
            const n = Ls.clone(),
              r = Yi.lengthSqr(n);
            if (0 === r) Yi.copy(t, i);
            else {
              Yi.subtract(Ls, e, i);
              const a = Yi.dot(Ls, n) / r;
              a < 0
                ? Yi.copy(t, i)
                : a > 1
                ? Yi.copy(t, s)
                : Yi.scaleAndAdd(t, i, n, a);
            }
          },
        }),
        Ys = {
          SHAPE_RAY: 1,
          SHAPE_LINE: 2,
          SHAPE_SPHERE: 4,
          SHAPE_AABB: 8,
          SHAPE_OBB: 16,
          SHAPE_PLANE: 32,
          SHAPE_TRIANGLE: 64,
          SHAPE_FRUSTUM: 128,
          SHAPE_FRUSTUM_ACCURATE: 256,
          SHAPE_CAPSULE: 512,
          SHAPE_SPLINE: 1024,
        };
      class Ks {
        static create(t, e, i, s, n, r) {
          return new Ks(t, e, i, s, n, r);
        }
        static clone(t) {
          return new Ks(t.s.x, t.s.y, t.s.z, t.e.x, t.e.y, t.e.z);
        }
        static copy(t, e) {
          return Yi.copy(t.s, e.s), Yi.copy(t.e, e.e), t;
        }
        static fromPoints(t, e, i) {
          return Yi.copy(t.s, e), Yi.copy(t.e, i), t;
        }
        static set(t, e, i, s, n, r, a) {
          return (
            (t.s.x = e),
            (t.s.y = i),
            (t.s.z = s),
            (t.e.x = n),
            (t.e.y = r),
            (t.e.z = a),
            t
          );
        }
        static len(t) {
          return Yi.distance(t.s, t.e);
        }
        get type() {
          return this._type;
        }
        constructor(t = 0, e = 0, i = 0, s = 0, n = 0, r = -1) {
          (this.s = void 0),
            (this.e = void 0),
            (this._type = void 0),
            (this._type = Ys.SHAPE_LINE),
            (this.s = new Yi(t, e, i)),
            (this.e = new Yi(s, n, r));
        }
        length() {
          return Yi.distance(this.s, this.e);
        }
      }
      class qs {
        static create(t = 0, e = 0, i = 0, s = 0, n = 0, r = 1) {
          return new qs(t, e, i, s, n, r);
        }
        static clone(t) {
          return new qs(t.o.x, t.o.y, t.o.z, t.d.x, t.d.y, t.d.z);
        }
        static copy(t, e) {
          return Yi.copy(t.o, e.o), Yi.copy(t.d, e.d), t;
        }
        static fromPoints(t, e, i) {
          return Yi.copy(t.o, e), Yi.normalize(t.d, Yi.subtract(t.d, i, e)), t;
        }
        static set(t, e, i, s, n, r, a) {
          return (
            (t.o.x = e),
            (t.o.y = i),
            (t.o.z = s),
            (t.d.x = n),
            (t.d.y = r),
            (t.d.z = a),
            t
          );
        }
        get type() {
          return this._type;
        }
        constructor(t = 0, e = 0, i = 0, s = 0, n = 0, r = -1) {
          (this._type = Ys.SHAPE_RAY),
            (this.o = new Yi(t, e, i)),
            (this.d = new Yi(s, n, r));
        }
        computeHit(t, e) {
          Yi.normalize(t, this.d), Yi.scaleAndAdd(t, this.o, t, e);
        }
      }
      const $s = new Yi(),
        Zs = new Yi(),
        Qs = new Yi(),
        Js = new Yi();
      function tn(t) {
        return Math.max(Math.max(t.x, t.y), t.z);
      }
      class en {
        static create(t, e, i, s) {
          return new en(t, e, i, s);
        }
        static clone(t) {
          return new en(t.center.x, t.center.y, t.center.z, t.radius);
        }
        static copy(t, e) {
          return Yi.copy(t.center, e.center), (t.radius = e.radius), t;
        }
        static fromPoints(t, e, i) {
          return (
            Yi.multiplyScalar(t.center, Yi.add($s, e, i), 0.5),
            (t.radius = 0.5 * Yi.subtract($s, i, e).length()),
            t
          );
        }
        static set(t, e, i, s, n) {
          return (
            (t.center.x = e),
            (t.center.y = i),
            (t.center.z = s),
            (t.radius = n),
            t
          );
        }
        get center() {
          return this._center;
        }
        set center(t) {
          this._center = t;
        }
        get radius() {
          return this._radius;
        }
        set radius(t) {
          this._radius = t;
        }
        get type() {
          return this._type;
        }
        constructor(t = 0, e = 0, i = 0, s = 1) {
          (this._type = Ys.SHAPE_SPHERE),
            (this._center = new Yi(t, e, i)),
            (this._radius = s);
        }
        destroy() {}
        clone() {
          return en.clone(this);
        }
        copy(t) {
          return en.copy(this, t);
        }
        getBoundary(t, e) {
          Yi.set(
            t,
            this.center.x - this.radius,
            this.center.y - this.radius,
            this.center.z - this.radius
          ),
            Yi.set(
              e,
              this.center.x + this.radius,
              this.center.y + this.radius,
              this.center.z + this.radius
            );
        }
        transform(t, e, i, s, n) {
          Yi.transformMat4(n.center, this.center, t),
            (n.radius = this.radius * tn(s));
        }
        translateAndRotate(t, e, i) {
          Yi.transformMat4(i.center, this.center, t);
        }
        setScale(t, e) {
          e.radius = this.radius * tn(t);
        }
        mergePoint(t) {
          this.radius < 0 && (this.center.set(t), (this.radius = 0)),
            Yi.subtract(Zs, t, this.center);
          const e = Zs.length();
          if (e > this.radius) {
            const t = 0.5 * (e - this.radius);
            (this.radius += t),
              Yi.multiplyScalar(Zs, Zs, t / e),
              Yi.add(this.center, this.center, Zs);
          }
        }
        mergePoints(t) {
          const e = t.length;
          if (!(e < 1)) {
            this.radius = -1;
            for (let i = 0; i < e; i++) this.mergePoint(t[i]);
          }
        }
        mergeAABB(t) {
          t.getBoundary(Qs, Js), this.mergePoint(Qs), this.mergePoint(Js);
        }
      }
      const sn = function (t, e) {
          const i = Yi.dot(t.d, e.n);
          if (Math.abs(i) < Number.EPSILON) return 0;
          const s = -Vs(t.o, e) / i;
          return s < 0 ? 0 : s;
        },
        nn = (function () {
          const t = new Yi(0, 0, 0),
            e = new Yi(0, 0, 0),
            i = new Yi(0, 0, 0),
            s = new Yi(0, 0, 0),
            n = new Yi(0, 0, 0);
          return function (r, a, o) {
            Yi.subtract(t, a.b, a.a),
              Yi.subtract(e, a.c, a.a),
              Yi.cross(i, r.d, e);
            const h = Yi.dot(t, i);
            if (h < Number.EPSILON && (!o || h > -Number.EPSILON)) return 0;
            const l = 1 / h;
            Yi.subtract(s, r.o, a.a);
            const c = Yi.dot(s, i) * l;
            if (c < 0 || c > 1) return 0;
            Yi.cross(n, s, t);
            const u = Yi.dot(r.d, n) * l;
            if (u < 0 || c + u > 1) return 0;
            const _ = Yi.dot(e, n) * l;
            return _ < 0 ? 0 : _;
          };
        })(),
        rn = (function () {
          const t = new Yi(0, 0, 0);
          return function (e, i) {
            const s = i.radius,
              n = i.center,
              r = e.o,
              a = e.d,
              o = s * s;
            Yi.subtract(t, n, r);
            const h = t.lengthSqr(),
              l = Yi.dot(t, a),
              c = o - (h - l * l);
            if (c < 0) return 0;
            const u = Math.sqrt(c),
              _ = h < o ? l + u : l - u;
            return _ < 0 ? 0 : _;
          };
        })(),
        an = (function () {
          const t = new Yi(),
            e = new Yi();
          return function (i, s) {
            return (
              Yi.subtract(t, s.center, s.halfExtents),
              Yi.add(e, s.center, s.halfExtents),
              (function (t, e, i) {
                const s = t.o,
                  n = t.d,
                  r = 1 / n.x,
                  a = 1 / n.y,
                  o = 1 / n.z,
                  h = (e.x - s.x) * r,
                  l = (i.x - s.x) * r,
                  c = (e.y - s.y) * a,
                  u = (i.y - s.y) * a,
                  _ = (e.z - s.z) * o,
                  d = (i.z - s.z) * o,
                  p = Math.max(
                    Math.max(Math.min(h, l), Math.min(c, u)),
                    Math.min(_, d)
                  ),
                  m = Math.min(
                    Math.min(Math.max(h, l), Math.max(c, u)),
                    Math.max(_, d)
                  );
                return m < 0 || p > m ? 0 : p > 0 ? p : m;
              })(i, t, e)
            );
          };
        })(),
        on = (function () {
          let t = new Yi(),
            e = new Yi(),
            i = new Yi();
          const s = new Yi(),
            n = new Yi(),
            r = new Yi(),
            a = new Yi(),
            o = new Array(3),
            h = new Array(3),
            l = new Array(3),
            c = new Array(6);
          return function (u, _) {
            (o[0] = _.halfExtents.x),
              (o[1] = _.halfExtents.y),
              (o[2] = _.halfExtents.z),
              (t = _.center),
              (e = u.o),
              (i = u.d),
              Yi.set(
                s,
                _.orientation.m00,
                _.orientation.m01,
                _.orientation.m02
              ),
              Yi.set(
                n,
                _.orientation.m03,
                _.orientation.m04,
                _.orientation.m05
              ),
              Yi.set(
                r,
                _.orientation.m06,
                _.orientation.m07,
                _.orientation.m08
              ),
              Yi.subtract(a, t, e),
              (h[0] = Yi.dot(s, i)),
              (h[1] = Yi.dot(n, i)),
              (h[2] = Yi.dot(r, i)),
              (l[0] = Yi.dot(s, a)),
              (l[1] = Yi.dot(n, a)),
              (l[2] = Yi.dot(r, a));
            for (let t = 0; t < 3; ++t) {
              if (0 === h[t]) {
                if (-l[t] - o[t] > 0 || -l[t] + o[t] < 0) return 0;
                h[t] = 1e-7;
              }
              (c[2 * t + 0] = (l[t] + o[t]) / h[t]),
                (c[2 * t + 1] = (l[t] - o[t]) / h[t]);
            }
            const d = Math.max(
                Math.max(Math.min(c[0], c[1]), Math.min(c[2], c[3])),
                Math.min(c[4], c[5])
              ),
              p = Math.min(
                Math.min(Math.max(c[0], c[1]), Math.max(c[2], c[3])),
                Math.max(c[4], c[5])
              );
            return p < 0 || d > p ? 0 : d > 0 ? d : p;
          };
        })(),
        hn = (function () {
          const t = new Yi(),
            e = new Yi(),
            i = new Yi(),
            s = new Yi(),
            n = new Yi(),
            r = new Yi(),
            a = new Yi(),
            o = new en();
          return function (h, l) {
            const c = l.ellipseCenter0,
              u = l.ellipseCenter1,
              _ = Yi.subtract(e, u, c);
            if (_.length() < gi)
              return (
                (o.radius = l.radius),
                o.center.set(l.ellipseCenter0),
                Bn.raySphere(h, o)
              );
            const d = h.o,
              p = Yi.subtract(i, d, c),
              m = Yi.normalize(t, h.d),
              f = Yi.cross(s, m, _),
              g = f.lengthSqr();
            if (0 === g) {
              o.radius = l.radius;
              const t = Yi.subtract(n, u, d);
              return (
                p.lengthSqr() < t.lengthSqr()
                  ? o.center.set(c)
                  : o.center.set(u),
                Bn.raySphere(h, o)
              );
            }
            const y = Yi.cross(n, p, _),
              T = _.lengthSqr(),
              S = 2 * Yi.dot(f, y),
              E = l.radius * l.radius,
              v = S * S - 4 * g * (y.lengthSqr() - E * T);
            if (v < 0) return 0;
            const b = (-S - Math.sqrt(v)) / (2 * g);
            if (b < 0) {
              o.radius = l.radius;
              const t = Yi.subtract(r, u, d);
              return (
                p.lengthSqr() < t.lengthSqr()
                  ? o.center.set(l.ellipseCenter0)
                  : o.center.set(l.ellipseCenter1),
                Bn.raySphere(h, o)
              );
            }
            {
              const t = Yi.scaleAndAdd(r, h.o, m, b),
                e = Yi.subtract(a, t, c),
                i = Yi.dot(e, _) / T;
              return i >= 0 && i <= 1
                ? b
                : i < 0
                ? ((o.radius = l.radius),
                  o.center.set(l.ellipseCenter0),
                  Bn.raySphere(h, o))
                : i > 1
                ? ((o.radius = l.radius),
                  o.center.set(l.ellipseCenter1),
                  Bn.raySphere(h, o))
                : 0;
            }
          };
        })(),
        ln = (function () {
          const t = new Yi(0, 0, 0);
          return function (e, i) {
            Yi.subtract(t, e.e, e.s);
            const s = -Vs(e.s, i) / Yi.dot(t, i.n);
            return s < 0 || s > 1 ? 0 : s;
          };
        })(),
        cn = (function () {
          const t = new Yi(0, 0, 0),
            e = new Yi(0, 0, 0),
            i = new Yi(0, 0, 0),
            s = new Yi(0, 0, 0),
            n = new Yi(0, 0, 0),
            r = new Yi(0, 0, 0);
          return function (a, o, h) {
            Yi.subtract(t, o.b, o.a),
              Yi.subtract(e, o.c, o.a),
              Yi.subtract(i, a.s, a.e),
              Yi.cross(n, t, e);
            const l = Yi.dot(i, n);
            if (l <= 0) return 0;
            Yi.subtract(s, a.s, o.a);
            const c = Yi.dot(s, n);
            if (c < 0 || c > l) return 0;
            Yi.cross(r, i, s);
            let u = Yi.dot(e, r);
            if (u < 0 || u > l) return 0;
            let _ = -Yi.dot(t, r);
            if (_ < 0 || u + _ > l) return 0;
            if (h) {
              const t = 1 / l;
              (u *= t), (_ *= t);
              const e = 1 - u - _;
              Yi.set(
                h,
                o.a.x * e + o.b.x * u + o.c.x * _,
                o.a.y * e + o.b.y * u + o.c.y * _,
                o.a.z * e + o.b.z * u + o.c.z * _
              );
            }
            return 1;
          };
        })(),
        un = new qs();
      function _n(t, e) {
        un.o.set(t.s), Yi.subtract(un.d, t.e, t.s), un.d.normalize();
        const i = an(un, e);
        return i <= t.length() ? i : 0;
      }
      function dn(t, e) {
        un.o.set(t.s), Yi.subtract(un.d, t.e, t.s), un.d.normalize();
        const i = on(un, e);
        return i <= t.length() ? i : 0;
      }
      function pn(t, e) {
        un.o.set(t.s), Yi.subtract(un.d, t.e, t.s), un.d.normalize();
        const i = rn(un, e);
        return i <= t.length() ? i : 0;
      }
      const mn = (function () {
        const t = new Yi(),
          e = new Yi(),
          i = new Yi(),
          s = new Yi();
        return function (n, r) {
          return (
            Yi.subtract(t, n.center, n.halfExtents),
            Yi.add(e, n.center, n.halfExtents),
            Yi.subtract(i, r.center, r.halfExtents),
            Yi.add(s, r.center, r.halfExtents),
            t.x <= s.x &&
              e.x >= i.x &&
              t.y <= s.y &&
              e.y >= i.y &&
              t.z <= s.z &&
              e.z >= i.z
          );
        };
      })();
      function fn(t, e, i, s, n, r) {
        Yi.set(
          r[0],
          t.x + i.x * e.x + s.x * e.y + n.x * e.z,
          t.y + i.y * e.x + s.y * e.y + n.y * e.z,
          t.z + i.z * e.x + s.z * e.y + n.z * e.z
        ),
          Yi.set(
            r[1],
            t.x - i.x * e.x + s.x * e.y + n.x * e.z,
            t.y - i.y * e.x + s.y * e.y + n.y * e.z,
            t.z - i.z * e.x + s.z * e.y + n.z * e.z
          ),
          Yi.set(
            r[2],
            t.x + i.x * e.x - s.x * e.y + n.x * e.z,
            t.y + i.y * e.x - s.y * e.y + n.y * e.z,
            t.z + i.z * e.x - s.z * e.y + n.z * e.z
          ),
          Yi.set(
            r[3],
            t.x + i.x * e.x + s.x * e.y - n.x * e.z,
            t.y + i.y * e.x + s.y * e.y - n.y * e.z,
            t.z + i.z * e.x + s.z * e.y - n.z * e.z
          ),
          Yi.set(
            r[4],
            t.x - i.x * e.x - s.x * e.y - n.x * e.z,
            t.y - i.y * e.x - s.y * e.y - n.y * e.z,
            t.z - i.z * e.x - s.z * e.y - n.z * e.z
          ),
          Yi.set(
            r[5],
            t.x + i.x * e.x - s.x * e.y - n.x * e.z,
            t.y + i.y * e.x - s.y * e.y - n.y * e.z,
            t.z + i.z * e.x - s.z * e.y - n.z * e.z
          ),
          Yi.set(
            r[6],
            t.x - i.x * e.x + s.x * e.y - n.x * e.z,
            t.y - i.y * e.x + s.y * e.y - n.y * e.z,
            t.z - i.z * e.x + s.z * e.y - n.z * e.z
          ),
          Yi.set(
            r[7],
            t.x - i.x * e.x - s.x * e.y + n.x * e.z,
            t.y - i.y * e.x - s.y * e.y + n.y * e.z,
            t.z - i.z * e.x - s.z * e.y + n.z * e.z
          );
      }
      function gn(t, e) {
        let i = Yi.dot(e, t[0]),
          s = i;
        for (let n = 1; n < 8; ++n) {
          const r = Yi.dot(e, t[n]);
          (i = r < i ? r : i), (s = r > s ? r : s);
        }
        return [i, s];
      }
      const yn = (function () {
          const t = new Array(15);
          for (let e = 0; e < 15; e++) t[e] = new Yi(0, 0, 0);
          const e = new Array(8),
            i = new Array(8);
          for (let t = 0; t < 8; t++)
            (e[t] = new Yi(0, 0, 0)), (i[t] = new Yi(0, 0, 0));
          const s = new Yi(),
            n = new Yi();
          return function (r, a) {
            Yi.set(t[0], 1, 0, 0),
              Yi.set(t[1], 0, 1, 0),
              Yi.set(t[2], 0, 0, 1),
              Yi.set(
                t[3],
                a.orientation.m00,
                a.orientation.m01,
                a.orientation.m02
              ),
              Yi.set(
                t[4],
                a.orientation.m03,
                a.orientation.m04,
                a.orientation.m05
              ),
              Yi.set(
                t[5],
                a.orientation.m06,
                a.orientation.m07,
                a.orientation.m08
              );
            for (let e = 0; e < 3; ++e)
              Yi.cross(t[6 + 3 * e], t[e], t[3]),
                Yi.cross(t[7 + 3 * e], t[e], t[4]),
                Yi.cross(t[7 + 3 * e], t[e], t[5]);
            Yi.subtract(s, r.center, r.halfExtents),
              Yi.add(n, r.center, r.halfExtents),
              (function (t, e, i) {
                Yi.set(i[0], t.x, e.y, e.z),
                  Yi.set(i[1], t.x, e.y, t.z),
                  Yi.set(i[2], t.x, t.y, e.z),
                  Yi.set(i[3], t.x, t.y, t.z),
                  Yi.set(i[4], e.x, e.y, e.z),
                  Yi.set(i[5], e.x, e.y, t.z),
                  Yi.set(i[6], e.x, t.y, e.z),
                  Yi.set(i[7], e.x, t.y, t.z);
              })(s, n, e),
              fn(a.center, a.halfExtents, t[3], t[4], t[5], i);
            for (let s = 0; s < 15; ++s) {
              const n = gn(e, t[s]),
                r = gn(i, t[s]);
              if (r[0] > n[1] || n[0] > r[1]) return 0;
            }
            return 1;
          };
        })(),
        Tn = function (t, e) {
          const i =
              t.halfExtents.x * Math.abs(e.n.x) +
              t.halfExtents.y * Math.abs(e.n.y) +
              t.halfExtents.z * Math.abs(e.n.z),
            s = Yi.dot(e.n, t.center);
          return s + i < e.d ? -1 : s - i > e.d ? 0 : 1;
        },
        Sn = function (t, e) {
          for (let i = 0; i < e.planes.length; i++)
            if (-1 === Tn(t, e.planes[i])) return 0;
          return 1;
        },
        En = (function () {
          const t = new Array(8);
          let e = 0,
            i = 0;
          for (let e = 0; e < t.length; e++) t[e] = new Yi(0, 0, 0);
          return function (s, n) {
            let r = 0,
              a = !1;
            for (let t = 0; t < n.planes.length; t++) {
              if (((r = Tn(s, n.planes[t])), -1 === r)) return 0;
              1 === r && (a = !0);
            }
            if (!a) return 1;
            for (let e = 0; e < n.vertices.length; e++)
              Yi.subtract(t[e], n.vertices[e], s.center);
            (e = 0), (i = 0);
            for (let r = 0; r < n.vertices.length; r++)
              t[r].x > s.halfExtents.x ? e++ : t[r].x < -s.halfExtents.x && i++;
            if (e === n.vertices.length || i === n.vertices.length) return 0;
            (e = 0), (i = 0);
            for (let r = 0; r < n.vertices.length; r++)
              t[r].y > s.halfExtents.y ? e++ : t[r].y < -s.halfExtents.y && i++;
            if (e === n.vertices.length || i === n.vertices.length) return 0;
            (e = 0), (i = 0);
            for (let r = 0; r < n.vertices.length; r++)
              t[r].z > s.halfExtents.z ? e++ : t[r].z < -s.halfExtents.z && i++;
            return e === n.vertices.length || i === n.vertices.length ? 0 : 1;
          };
        })(),
        vn = (function () {
          const t = new Yi(0, 0, 0),
            e = new es();
          return function (i, s) {
            return (
              Yi.subtract(t, s, i.center),
              Yi.transformMat3(t, t, es.transpose(e, i.orientation)),
              (n = t),
              (r = i.halfExtents),
              Math.abs(n.x) < r.x && Math.abs(n.y) < r.y && Math.abs(n.z) < r.z
            );
            var n, r;
          };
        })(),
        bn = (function () {
          const t = function (t, e, i, s) {
            return Math.abs(t.x * e + t.y * i + t.z * s);
          };
          return function (e, i) {
            const s =
                e.halfExtents.x *
                  t(
                    i.n,
                    e.orientation.m00,
                    e.orientation.m01,
                    e.orientation.m02
                  ) +
                e.halfExtents.y *
                  t(
                    i.n,
                    e.orientation.m03,
                    e.orientation.m04,
                    e.orientation.m05
                  ) +
                e.halfExtents.z *
                  t(
                    i.n,
                    e.orientation.m06,
                    e.orientation.m07,
                    e.orientation.m08
                  ),
              n = Yi.dot(i.n, e.center);
            return n + s < i.d ? -1 : n - s > i.d ? 0 : 1;
          };
        })(),
        An = function (t, e) {
          for (let i = 0; i < e.planes.length; i++)
            if (-1 === bn(t, e.planes[i])) return 0;
          return 1;
        },
        Cn = (function () {
          const t = new Array(8);
          let e = 0,
            i = 0,
            s = 0;
          for (let e = 0; e < t.length; e++) t[e] = new Yi(0, 0, 0);
          const n = function (t, e, i, s) {
            return t.x * e + t.y * i + t.z * s;
          };
          return function (r, a) {
            let o = 0,
              h = !1;
            for (let t = 0; t < a.planes.length; t++) {
              if (((o = bn(r, a.planes[t])), -1 === o)) return 0;
              1 === o && (h = !0);
            }
            if (!h) return 1;
            for (let e = 0; e < a.vertices.length; e++)
              Yi.subtract(t[e], a.vertices[e], r.center);
            (i = 0), (s = 0);
            for (let o = 0; o < a.vertices.length; o++)
              (e = n(
                t[o],
                r.orientation.m00,
                r.orientation.m01,
                r.orientation.m02
              )),
                e > r.halfExtents.x ? i++ : e < -r.halfExtents.x && s++;
            if (i === a.vertices.length || s === a.vertices.length) return 0;
            (i = 0), (s = 0);
            for (let o = 0; o < a.vertices.length; o++)
              (e = n(
                t[o],
                r.orientation.m03,
                r.orientation.m04,
                r.orientation.m05
              )),
                e > r.halfExtents.y ? i++ : e < -r.halfExtents.y && s++;
            if (i === a.vertices.length || s === a.vertices.length) return 0;
            (i = 0), (s = 0);
            for (let o = 0; o < a.vertices.length; o++)
              (e = n(
                t[o],
                r.orientation.m06,
                r.orientation.m07,
                r.orientation.m08
              )),
                e > r.halfExtents.z ? i++ : e < -r.halfExtents.z && s++;
            return i === a.vertices.length || s === a.vertices.length ? 0 : 1;
          };
        })(),
        On = (function () {
          const t = new Array(15);
          for (let e = 0; e < 15; e++) t[e] = new Yi(0, 0, 0);
          const e = new Array(8),
            i = new Array(8);
          for (let t = 0; t < 8; t++)
            (e[t] = new Yi(0, 0, 0)), (i[t] = new Yi(0, 0, 0));
          return function (s, n) {
            Yi.set(
              t[0],
              s.orientation.m00,
              s.orientation.m01,
              s.orientation.m02
            ),
              Yi.set(
                t[1],
                s.orientation.m03,
                s.orientation.m04,
                s.orientation.m05
              ),
              Yi.set(
                t[2],
                s.orientation.m06,
                s.orientation.m07,
                s.orientation.m08
              ),
              Yi.set(
                t[3],
                n.orientation.m00,
                n.orientation.m01,
                n.orientation.m02
              ),
              Yi.set(
                t[4],
                n.orientation.m03,
                n.orientation.m04,
                n.orientation.m05
              ),
              Yi.set(
                t[5],
                n.orientation.m06,
                n.orientation.m07,
                n.orientation.m08
              );
            for (let e = 0; e < 3; ++e)
              Yi.cross(t[6 + 3 * e], t[e], t[3]),
                Yi.cross(t[7 + 3 * e], t[e], t[4]),
                Yi.cross(t[8 + 3 * e], t[e], t[5]);
            fn(s.center, s.halfExtents, t[0], t[1], t[2], e),
              fn(n.center, n.halfExtents, t[3], t[4], t[5], i);
            for (let s = 0; s < 15; ++s) {
              const n = gn(e, t[s]),
                r = gn(i, t[s]);
              if (r[0] > n[1] || n[0] > r[1]) return 0;
            }
            return 1;
          };
        })(),
        In = (function () {
          const t = new en(),
            e = new Yi(),
            i = new Yi(),
            s = new Yi(),
            n = new Array(8);
          for (let t = 0; t < 8; t++) n[t] = new Yi();
          const r = new Array(8);
          for (let t = 0; t < 8; t++) r[t] = new Yi();
          return function (a, o) {
            if (0 === Yi.squaredDistance(o.ellipseCenter0, o.ellipseCenter1))
              return (
                (t.radius = o.radius),
                t.center.set(o.ellipseCenter0),
                Bn.sphereOBB(t, a)
              );
            {
              (e.x = a.orientation.m00),
                (e.y = a.orientation.m01),
                (e.z = a.orientation.m02),
                (i.x = a.orientation.m03),
                (i.y = a.orientation.m04),
                (i.z = a.orientation.m05),
                (s.x = a.orientation.m06),
                (s.y = a.orientation.m07),
                (s.z = a.orientation.m08),
                fn(a.center, a.halfExtents, e, i, s, n);
              const t = r,
                h = Yi.copy(t[0], e),
                l = Yi.copy(t[1], i),
                c = Yi.copy(t[2], s);
              Yi.subtract(t[3], o.center, a.center).normalize();
              const u = Yi.subtract(t[4], o.ellipseCenter0, o.ellipseCenter1);
              u.normalize(),
                Yi.cross(t[5], h, u),
                Yi.cross(t[6], l, u),
                Yi.cross(t[7], c, u);
              for (let e = 0; e < 8; ++e) {
                const i = gn(n, t[e]),
                  s = Yi.dot(t[e], o.ellipseCenter0),
                  r = Yi.dot(t[e], o.ellipseCenter1),
                  a = Math.max(s, r),
                  h = Math.min(s, r) - o.radius,
                  l = a + o.radius;
                if (h > i[1] || i[0] > l) return 0;
              }
              return 1;
            }
          };
        })(),
        wn = function (t, e) {
          const i = Yi.dot(e.n, t.center),
            s = t.radius * e.n.length();
          return i + s < e.d ? -1 : i - s > e.d ? 0 : 1;
        },
        Rn = function (t, e) {
          for (let i = 0; i < e.planes.length; i++)
            if (-1 === wn(t, e.planes[i])) return 0;
          return 1;
        },
        Dn = (function () {
          const t = new Yi(0, 0, 0),
            e = [1, -1, 1, -1, 1, -1];
          return function (i, s) {
            for (let n = 0; n < 6; n++) {
              const r = s.planes[n],
                a = i.radius,
                o = i.center,
                h = r.n,
                l = r.d,
                c = Yi.dot(h, o);
              if (c + a < l) return 0;
              if (!(c - a > l)) {
                Yi.add(t, o, Yi.multiplyScalar(t, h, a));
                for (let i = 0; i < 6; i++) {
                  if (i === n || i === n + e[n]) continue;
                  const r = s.planes[i];
                  if (Yi.dot(r.n, t) < r.d) return 0;
                }
              }
            }
            return 1;
          };
        })(),
        xn = function (t, e) {
          const i = t.radius + e.radius;
          return Yi.squaredDistance(t.center, e.center) < i * i;
        },
        Mn = (function () {
          const t = new Yi();
          return function (e, i) {
            return (
              js(t, e.center, i),
              Yi.squaredDistance(e.center, t) < e.radius * e.radius
            );
          };
        })(),
        Pn = (function () {
          const t = new Yi();
          return function (e, i) {
            return (
              Ws(t, e.center, i),
              Yi.squaredDistance(e.center, t) < e.radius * e.radius
            );
          };
        })(),
        Nn = (function () {
          const t = new Yi(),
            e = new Yi();
          return function (i, s) {
            const n = i.radius + s.radius,
              r = n * n,
              a = Yi.squaredDistance(s.ellipseCenter0, s.ellipseCenter1);
            if (0 === a) return Yi.squaredDistance(i.center, s.center) < r;
            {
              Yi.subtract(t, i.center, s.ellipseCenter0),
                Yi.subtract(e, s.ellipseCenter1, s.ellipseCenter0);
              const n = Yi.dot(t, e) / a;
              return n < 0
                ? Yi.squaredDistance(i.center, s.ellipseCenter0) < r
                : n > 1
                ? Yi.squaredDistance(i.center, s.ellipseCenter1) < r
                : (Yi.scaleAndAdd(t, s.ellipseCenter0, e, n),
                  Yi.squaredDistance(i.center, t) < r);
            }
          };
        })(),
        Ln = (function () {
          const t = new Yi(),
            e = new Yi(),
            i = new Yi(),
            s = new Yi(),
            n = new Yi(),
            r = new Yi();
          return function (a, o) {
            const h = Yi.subtract(t, a.ellipseCenter1, a.ellipseCenter0),
              l = Yi.subtract(e, o.ellipseCenter1, o.ellipseCenter0),
              c = Yi.subtract(i, a.ellipseCenter0, o.ellipseCenter0),
              u = Yi.dot(h, h),
              _ = Yi.dot(h, l),
              d = Yi.dot(l, l),
              p = Yi.dot(h, c),
              m = Yi.dot(l, c),
              f = u * d - _ * _;
            let g,
              y,
              T = f,
              S = f;
            f < gi
              ? ((g = 0), (T = 1), (y = m), (S = d))
              : ((g = _ * m - d * p),
                (y = u * m - _ * p),
                g < 0
                  ? ((g = 0), (y = m), (S = d))
                  : g > T && ((g = T), (y = m + _), (S = d))),
              y < 0
                ? ((y = 0),
                  -p < 0 ? (g = 0) : -p > u ? (g = T) : ((g = -p), (T = u)))
                : y > S &&
                  ((y = S),
                  -p + _ < 0
                    ? (g = 0)
                    : -p + _ > u
                    ? (g = T)
                    : ((g = -p + _), (T = u)));
            const E = Math.abs(g) < gi ? 0 : g / T,
              v = Math.abs(y) < gi ? 0 : y / S,
              b = s;
            b.set(c),
              b.add(Yi.multiplyScalar(n, h, E)),
              b.subtract(Yi.multiplyScalar(r, l, v));
            const A = a.radius + o.radius;
            return b.lengthSqr() < A * A;
          };
        })(),
        Bn = {
          raySphere: rn,
          rayAABB: an,
          rayOBB: on,
          rayPlane: sn,
          rayTriangle: nn,
          rayCapsule: hn,
          raySubMesh: null,
          rayMesh: null,
          rayModel: null,
          lineSphere: pn,
          lineAABB: _n,
          lineOBB: dn,
          linePlane: ln,
          lineTriangle: cn,
          sphereWithSphere: xn,
          sphereAABB: Mn,
          sphereOBB: Pn,
          spherePlane: wn,
          sphereFrustum: Rn,
          sphereFrustumAccurate: Dn,
          sphereCapsule: Nn,
          aabbWithAABB: mn,
          aabbWithOBB: yn,
          aabbPlane: Tn,
          aabbFrustum: Sn,
          aabbFrustumAccurate: En,
          obbWithOBB: On,
          obbPlane: bn,
          obbFrustum: An,
          obbFrustumAccurate: Cn,
          obbPoint: vn,
          obbCapsule: In,
          aabbFrustumCompletelyInside: function (t, e) {
            for (let i = 0; i < e.planes.length; i++)
              if (0 !== Tn(t, e.planes[i])) return 0;
            return 1;
          },
          capsuleWithCapsule: Ln,
          resolve(t, e, i = null) {
            const s = t._type,
              n = e._type,
              r = this[s | n];
            return s < n ? r(t, e, i) : r(e, t, i);
          },
        };
      (Bn[Ys.SHAPE_RAY | Ys.SHAPE_SPHERE] = rn),
        (Bn[Ys.SHAPE_RAY | Ys.SHAPE_AABB] = an),
        (Bn[Ys.SHAPE_RAY | Ys.SHAPE_OBB] = on),
        (Bn[Ys.SHAPE_RAY | Ys.SHAPE_PLANE] = sn),
        (Bn[Ys.SHAPE_RAY | Ys.SHAPE_TRIANGLE] = nn),
        (Bn[Ys.SHAPE_RAY | Ys.SHAPE_CAPSULE] = hn),
        (Bn[Ys.SHAPE_LINE | Ys.SHAPE_SPHERE] = pn),
        (Bn[Ys.SHAPE_LINE | Ys.SHAPE_AABB] = _n),
        (Bn[Ys.SHAPE_LINE | Ys.SHAPE_OBB] = dn),
        (Bn[Ys.SHAPE_LINE | Ys.SHAPE_PLANE] = ln),
        (Bn[Ys.SHAPE_LINE | Ys.SHAPE_TRIANGLE] = cn),
        (Bn[Ys.SHAPE_SPHERE] = xn),
        (Bn[Ys.SHAPE_SPHERE | Ys.SHAPE_AABB] = Mn),
        (Bn[Ys.SHAPE_SPHERE | Ys.SHAPE_OBB] = Pn),
        (Bn[Ys.SHAPE_SPHERE | Ys.SHAPE_PLANE] = wn),
        (Bn[Ys.SHAPE_SPHERE | Ys.SHAPE_FRUSTUM] = Rn),
        (Bn[Ys.SHAPE_SPHERE | Ys.SHAPE_FRUSTUM_ACCURATE] = Dn),
        (Bn[Ys.SHAPE_SPHERE | Ys.SHAPE_CAPSULE] = Nn),
        (Bn[Ys.SHAPE_AABB] = mn),
        (Bn[Ys.SHAPE_AABB | Ys.SHAPE_OBB] = yn),
        (Bn[Ys.SHAPE_AABB | Ys.SHAPE_PLANE] = Tn),
        (Bn[Ys.SHAPE_AABB | Ys.SHAPE_FRUSTUM] = Sn),
        (Bn[Ys.SHAPE_AABB | Ys.SHAPE_FRUSTUM_ACCURATE] = En),
        (Bn[Ys.SHAPE_OBB] = On),
        (Bn[Ys.SHAPE_OBB | Ys.SHAPE_PLANE] = bn),
        (Bn[Ys.SHAPE_OBB | Ys.SHAPE_FRUSTUM] = An),
        (Bn[Ys.SHAPE_OBB | Ys.SHAPE_FRUSTUM_ACCURATE] = Cn),
        (Bn[Ys.SHAPE_OBB | Ys.SHAPE_CAPSULE] = In),
        (Bn[Ys.SHAPE_CAPSULE] = Ln),
        $(Ks.prototype, "line", [
          { name: "mag", newName: "len" },
          { name: "magnitude", newName: "len" },
        ]),
        Z(Bn, "intersect", [{ name: "line_quad" }]);
      const Fn = new Yi(0, 0, 0),
        Un = new Yi(0, 0, 0),
        kn = a.mat4(),
        zn = a.v4();
      class Hn {
        static create(t, e, i, s) {
          return new Hn(t, e, i, s);
        }
        static clone(t) {
          return new Hn(t.n.x, t.n.y, t.n.z, t.d);
        }
        static copy(t, e) {
          return Yi.copy(t.n, e.n), (t.d = e.d), t;
        }
        static fromPoints(t, e, i, s) {
          return (
            Yi.subtract(Fn, i, e),
            Yi.subtract(Un, s, e),
            Yi.normalize(t.n, Yi.cross(t.n, Fn, Un)),
            (t.d = Yi.dot(t.n, e)),
            t
          );
        }
        static set(t, e, i, s, n) {
          return (t.n.x = e), (t.n.y = i), (t.n.z = s), (t.d = n), t;
        }
        static fromNormalAndPoint(t, e, i) {
          return Yi.copy(t.n, e), (t.d = Yi.dot(e, i)), t;
        }
        static normalize(t, e) {
          const i = e.n.length();
          return Yi.normalize(t.n, e.n), i > 0 && (t.d = e.d / i), t;
        }
        get type() {
          return this._type;
        }
        set x(t) {
          this.n.x = t;
        }
        get x() {
          return this.n.x;
        }
        set y(t) {
          this.n.y = t;
        }
        get y() {
          return this.n.y;
        }
        set z(t) {
          this.n.z = t;
        }
        get z() {
          return this.n.z;
        }
        set w(t) {
          this.d = t;
        }
        get w() {
          return this.d;
        }
        constructor(t = 0, e = 1, i = 0, s = 0) {
          (this._type = Ys.SHAPE_PLANE),
            (this.n = new Yi(t, e, i)),
            (this.d = s);
        }
        transform(t) {
          ms.invert(kn, t),
            ms.transpose(kn, kn),
            Wi.set(zn, this.n.x, this.n.y, this.n.z, -this.d),
            Wi.transformMat4(zn, zn, kn),
            Yi.set(this.n, zn.x, zn.y, zn.z),
            (this.d = -zn.w);
        }
      }
      class Gn {
        static create(
          t = 1,
          e = 0,
          i = 0,
          s = 0,
          n = 0,
          r = 0,
          a = 0,
          o = 0,
          h = 1
        ) {
          return new Gn(t, e, i, s, n, r, a, o, h);
        }
        static clone(t) {
          return new Gn(
            t.a.x,
            t.a.y,
            t.a.z,
            t.b.x,
            t.b.y,
            t.b.z,
            t.c.x,
            t.c.y,
            t.c.z
          );
        }
        static copy(t, e) {
          return Yi.copy(t.a, e.a), Yi.copy(t.b, e.b), Yi.copy(t.c, e.c), t;
        }
        static fromPoints(t, e, i, s) {
          return Yi.copy(t.a, e), Yi.copy(t.b, i), Yi.copy(t.c, s), t;
        }
        static set(t, e, i, s, n, r, a, o, h, l) {
          return (
            (t.a.x = e),
            (t.a.y = i),
            (t.a.z = s),
            (t.b.x = n),
            (t.b.y = r),
            (t.b.z = a),
            (t.c.x = o),
            (t.c.y = h),
            (t.c.z = l),
            t
          );
        }
        get type() {
          return this._type;
        }
        constructor(
          t = 0,
          e = 0,
          i = 0,
          s = 1,
          n = 0,
          r = 0,
          a = 0,
          o = 1,
          h = 0
        ) {
          (this._type = Ys.SHAPE_TRIANGLE),
            (this.a = new Yi(t, e, i)),
            (this.b = new Yi(s, n, r)),
            (this.c = new Yi(a, o, h));
        }
      }
      rt({
        replaceProperty: { since: "3.6.0", removed: !1 },
        removeProperty: { since: "3.6.0", removed: !1 },
        markAsWarning: { since: "3.6.0", removed: !1 },
        setDefaultLogTimes: { since: "3.6.0", removed: !1 },
      });
      class Vn {
        constructor() {
          (this._poolHandle = -1), jn.addContainer(this);
        }
        destroy() {
          jn.removeContainer(this);
        }
      }
      const jn = new (class {
        constructor() {
          (this._pools = []),
            (this._lastShrinkPassed = 0),
            (this.shrinkTimeSpan = 5);
        }
        addContainer(t) {
          -1 === t._poolHandle &&
            ((t._poolHandle = this._pools.length), this._pools.push(t));
        }
        removeContainer(t) {
          -1 !== t._poolHandle &&
            ((this._pools[this._pools.length - 1]._poolHandle = t._poolHandle),
            Jt(this._pools, t._poolHandle),
            (t._poolHandle = -1));
        }
        tryShrink() {
          for (let t = 0; t < this._pools.length; t++)
            this._pools[t].tryShrink();
        }
        update(t) {
          (this._lastShrinkPassed += t),
            this._lastShrinkPassed > this.shrinkTimeSpan &&
              (this.tryShrink(),
              (this._lastShrinkPassed -= this.shrinkTimeSpan));
        }
      })();
      class Wn extends Vn {
        constructor(t, e, i, s) {
          super(),
            (this._freePool = []),
            (this._ctor = t),
            (this._dtor = i || null),
            (this._elementsPerBatch = Math.max(e, 1)),
            (this._shrinkThreshold = s ? u(s, 1) : this._elementsPerBatch),
            (this._nextAvail = this._elementsPerBatch - 1);
          for (let e = 0; e < this._elementsPerBatch; ++e)
            this._freePool.push(t());
        }
        alloc() {
          if (this._nextAvail < 0) {
            this._freePool.length = this._elementsPerBatch;
            for (let t = 0; t < this._elementsPerBatch; t++)
              this._freePool[t] = this._ctor();
            this._nextAvail = this._elementsPerBatch - 1;
          }
          return this._freePool[this._nextAvail--];
        }
        free(t) {
          this._freePool[++this._nextAvail] = t;
        }
        freeArray(t) {
          (this._freePool.length = this._nextAvail + 1),
            Array.prototype.push.apply(this._freePool, t),
            (this._nextAvail += t.length);
        }
        tryShrink() {
          const t = this._nextAvail + 1;
          if (t <= this._shrinkThreshold) return;
          let e = 0;
          if (
            ((e =
              t >> 1 >= this._shrinkThreshold
                ? t >> 1
                : Math.floor((t - this._shrinkThreshold + 1) / 2)),
            this._dtor)
          )
            for (let t = this._nextAvail - e + 1; t <= this._nextAvail; ++t)
              this._dtor(this._freePool[t]);
          (this._nextAvail -= e), (this._freePool.length = this._nextAvail + 1);
        }
        destroy() {
          const t = arguments.length > 0 ? arguments[0] : null;
          t && z(14100);
          const e = t || this._dtor;
          if (e)
            for (let t = 0; t <= this._nextAvail; t++) e(this._freePool[t]);
          (this._freePool.length = 0), (this._nextAvail = -1), super.destroy();
        }
      }
      t("Pool", Wn);
      class Xn extends Vn {
        constructor(t, e, i) {
          super(),
            (this._count = 0),
            (this._fn = t),
            (this._dtor = i || null),
            (this._data = new Array(e)),
            (this._initSize = e);
          for (let i = 0; i < e; ++i) this._data[i] = t();
        }
        get length() {
          return this._count;
        }
        get data() {
          return this._data;
        }
        reset() {
          this._count = 0;
        }
        resize(t) {
          if (t > this._data.length)
            for (let e = this._data.length; e < t; ++e)
              this._data[e] = this._fn();
        }
        add() {
          return (
            this._count >= this._data.length &&
              this.resize(this._data.length << 1),
            this._data[this._count++]
          );
        }
        destroy() {
          if (this._dtor)
            for (let t = 0; t < this._data.length; t++)
              this._dtor(this._data[t]);
          (this._data.length = 0), (this._count = 0), super.destroy();
        }
        tryShrink() {
          if (this._data.length >> 2 > this._count) {
            const t = Math.max(this._initSize, this._data.length >> 1);
            if (this._dtor)
              for (let e = t; e < this._data.length; e++)
                this._dtor(this._data[e]);
            this._data.length = t;
          }
        }
        removeAt(t) {
          if (t >= this._count) return;
          const e = this._count - 1,
            i = this._data[t];
          (this._data[t] = this._data[e]),
            (this._data[e] = i),
            (this._count -= 1);
        }
      }
      t("RecyclePool", Xn);
      class Yn extends Vn {
        constructor(t, e) {
          super(),
            (this.length = 0),
            (this._initSize = 0),
            (this.array = new Array(t)),
            (this._initSize = t),
            (this._compareFn = e);
        }
        push(t) {
          this.array[this.length++] = t;
        }
        pop() {
          return this.array[--this.length];
        }
        get(t) {
          return this.array[t];
        }
        clear() {
          this.length = 0;
        }
        destroy() {
          (this.length = 0), (this.array.length = 0), super.destroy();
        }
        tryShrink() {
          this.array.length >> 2 > this.length &&
            (this.array.length = Math.max(
              this._initSize,
              this.array.length >> 1
            ));
        }
        sort() {
          (this.array.length = this.length), this.array.sort(this._compareFn);
        }
        concat(t) {
          for (let e = 0; e < t.length; ++e) this.array[this.length++] = t[e];
        }
        fastRemove(t) {
          if (t >= this.length || t < 0) return;
          const e = --this.length;
          this.array[t] = this.array[e];
        }
        indexOf(t) {
          for (let e = 0, i = this.length; e < i; ++e)
            if (this.array[e] === t) return e;
          return -1;
        }
      }
      t("CachedArray", Yn),
        t(
          "memop",
          Object.freeze({
            __proto__: null,
            Pool: Wn,
            RecyclePool: Xn,
            CachedArray: Yn,
          })
        );
      const Kn = t("editorExtrasTag", "__editorExtras__"),
        qn = [];
      class $n {
        static _deferredDestroy() {
          const t = qn.length;
          for (let e = 0; e < t; ++e) {
            const t = qn[e];
            1 & t._objFlags || t._destroyImmediate();
          }
          t === qn.length ? (qn.length = 0) : qn.splice(0, t);
        }
        constructor(t = "") {
          (this._objFlags = 0), (this._name = t);
        }
        get name() {
          return this._name;
        }
        set name(t) {
          this._name = t;
        }
        set hideFlags(t) {
          const e = t & $n.Flags.AllHideMasks;
          this._objFlags = (this._objFlags & ~$n.Flags.AllHideMasks) | e;
        }
        get hideFlags() {
          return this._objFlags & $n.Flags.AllHideMasks;
        }
        get isValid() {
          return !(1 & this._objFlags);
        }
        destroy() {
          return 1 & this._objFlags
            ? (z(5e3), !1)
            : !(
                4 & this._objFlags ||
                ((this._objFlags |= 4), qn.push(this), this._destroy(), 0)
              );
        }
        _destruct() {
          const t = this.constructor;
          let e;
          Object.prototype.hasOwnProperty.call(t, "__destruct__")
            ? (e = t.__destruct__)
            : ((e = (function (t, e) {
                const i = t instanceof a.Node || t instanceof a.Component,
                  s = i ? "_id" : null;
                let n;
                const r = {};
                for (n in t)
                  if (t.hasOwnProperty(n)) {
                    if (n === s) continue;
                    switch (typeof t[n]) {
                      case "string":
                        r[n] = "";
                        break;
                      case "object":
                      case "function":
                        r[n] = null;
                    }
                  }
                if (hi._isCCClass(e)) {
                  const t = a.Class.Attr.getClassAttrs(e),
                    s = e.__props__;
                  for (let e = 0; e < s.length; e++) {
                    n = s[e];
                    const a = `${n}`;
                    if (a in t) {
                      if (i && "_id" === n) continue;
                      switch (typeof t[a]) {
                        case "string":
                          r[n] = "";
                          break;
                        case "object":
                        case "function":
                          r[n] = null;
                          break;
                        case "undefined":
                          r[n] = void 0;
                      }
                    }
                  }
                }
                {
                  let t = "";
                  for (n in r) {
                    let e;
                    e = hi.IDENTIFIER_RE.test(n)
                      ? `o.${n}=`
                      : `o[${hi.escapeForJS(n)}]=`;
                    let i = r[n];
                    "" === i && (i = '""'), (t += `${e + i};\n`);
                  }
                  return Function("o", t);
                }
              })(this, t)),
              ft(t, "__destruct__", e, !0)),
            e(this);
        }
        _destroyImmediate() {
          var t;
          1 & this._objFlags
            ? G(5e3)
            : (null === (t = this._onPreDestroy) ||
                void 0 === t ||
                t.call(this),
              this.destruct && this.destruct(),
              this._destruct(),
              (this._objFlags |= 1));
        }
      }
      function Zn(t) {
        return t instanceof $n;
      }
      function Qn(t, e) {
        return "object" == typeof t
          ? !(!t || t._objFlags & (e ? 5 : 1))
          : void 0 !== t;
      }
      t("CCObject", $n),
        ($n.prototype._deserialize = null),
        hi.fastDefine("cc.Object", $n, { _name: "", _objFlags: 0 }),
        ft($n, "Flags", {
          Destroyed: 1,
          DontSave: 8,
          EditorOnly: 16,
          Dirty: 32,
          DontDestroy: 64,
          PersistentMask: -4192741,
          Destroying: 128,
          Deactivating: 256,
          LockedInEditor: 512,
          HideInHierarchy: 1024,
          AllHideMasks: 1560,
          IsPreloadStarted: 8192,
          IsOnLoadStarted: 32768,
          IsOnLoadCalled: 16384,
          IsOnEnableCalled: 2048,
          IsStartCalled: 65536,
          IsEditorOnEnableCalled: 4096,
          IsPositionLocked: 1 << 21,
          IsRotationLocked: 1 << 17,
          IsScaleLocked: 1 << 18,
          IsAnchorLocked: 1 << 19,
          IsSizeLocked: 1 << 20,
        }),
        (a.isValid = Qn),
        Dt($n, jsb.CCObject, ["prototype", "length", "name"]),
        Dt($n.prototype, jsb.CCObject.prototype, [
          "constructor",
          "name",
          "hideFlags",
          "isValid",
        ]),
        t("CCObject", ($n = jsb.CCObject)),
        (a.Object = $n);
      const Jn = Jt;
      function tr() {}
      class er {
        constructor() {
          (this.callback = tr), (this.target = void 0), (this.once = !1);
        }
        set(t, e, i) {
          (this.callback = t || tr), (this.target = e), (this.once = !!i);
        }
        reset() {
          (this.target = void 0), (this.callback = tr), (this.once = !1);
        }
        check() {
          return !(Zn(this.target) && !Qn(this.target, !0));
        }
      }
      const ir = new Wn(() => new er(), 32);
      class sr {
        constructor() {
          (this.callbackInfos = []),
            (this.isInvoking = !1),
            (this.containCanceled = !1);
        }
        removeByCallback(t) {
          for (let e = 0; e < this.callbackInfos.length; ++e) {
            const i = this.callbackInfos[e];
            i &&
              i.callback === t &&
              (i.reset(), ir.free(i), Jn(this.callbackInfos, e), --e);
          }
        }
        removeByTarget(t) {
          for (let e = 0; e < this.callbackInfos.length; ++e) {
            const i = this.callbackInfos[e];
            i &&
              i.target === t &&
              (i.reset(), ir.free(i), Jn(this.callbackInfos, e), --e);
          }
        }
        cancel(t) {
          const e = this.callbackInfos[t];
          e &&
            (e.reset(),
            this.isInvoking
              ? (this.callbackInfos[t] = null)
              : Jn(this.callbackInfos, t),
            ir.free(e)),
            (this.containCanceled = !0);
        }
        cancelAll() {
          for (let t = 0; t < this.callbackInfos.length; t++) {
            const e = this.callbackInfos[t];
            e && (e.reset(), ir.free(e), (this.callbackInfos[t] = null));
          }
          this.containCanceled = !0;
        }
        purgeCanceled() {
          for (let t = this.callbackInfos.length - 1; t >= 0; --t)
            this.callbackInfos[t] || Jn(this.callbackInfos, t);
          this.containCanceled = !1;
        }
        clear() {
          this.cancelAll(),
            (this.callbackInfos.length = 0),
            (this.isInvoking = !1),
            (this.containCanceled = !1);
        }
      }
      const rr = new Wn(() => new sr(), 16);
      class ar {
        constructor() {
          (this._callbackTable = St(!0)), (this._offCallback = void 0);
        }
        on(t, e, i, s) {
          if (!this.hasEventListener(t, e, i)) {
            let n = this._callbackTable[t];
            n || (n = this._callbackTable[t] = rr.alloc());
            const r = ir.alloc();
            r.set(e, i, s), n.callbackInfos.push(r);
          }
          return e;
        }
        hasEventListener(t, e, i) {
          const s = this._callbackTable && this._callbackTable[t];
          if (!s) return !1;
          const n = s.callbackInfos;
          if (!e) {
            if (s.isInvoking) {
              for (let t = 0; t < n.length; ++t) if (n[t]) return !0;
              return !1;
            }
            return n.length > 0;
          }
          for (let t = 0; t < n.length; ++t) {
            const s = n[t];
            if (s && s.check() && s.callback === e && s.target === i) return !0;
          }
          return !1;
        }
        removeAll(t) {
          const e = typeof t;
          if ("string" === e || "number" === e) {
            const e = this._callbackTable && this._callbackTable[t];
            e &&
              (e.isInvoking
                ? e.cancelAll()
                : (e.clear(), rr.free(e), delete this._callbackTable[t]));
          } else if (t)
            for (const e in this._callbackTable) {
              const i = this._callbackTable[e];
              if (i.isInvoking) {
                const e = i.callbackInfos;
                for (let s = 0; s < e.length; ++s) {
                  const n = e[s];
                  n && n.target === t && i.cancel(s);
                }
              } else i.removeByTarget(t);
            }
        }
        off(t, e, i) {
          var s;
          const n = this._callbackTable && this._callbackTable[t];
          if (n) {
            const s = n.callbackInfos;
            if (e)
              for (let t = 0; t < s.length; ++t) {
                const r = s[t];
                if (r && r.callback === e && r.target === i) {
                  n.cancel(t);
                  break;
                }
              }
            else this.removeAll(t);
          }
          null === (s = this._offCallback) || void 0 === s || s.call(this);
        }
        emit(t, e, i, s, n, r) {
          const a = this._callbackTable && this._callbackTable[t];
          if (a) {
            const o = !a.isInvoking;
            a.isInvoking = !0;
            const h = a.callbackInfos;
            for (let a = 0, o = h.length; a < o; ++a) {
              const o = h[a];
              if (o) {
                const a = o.callback,
                  h = o.target;
                o.once && this.off(t, a, h),
                  o.check()
                    ? h
                      ? a.call(h, e, i, s, n, r)
                      : a(e, i, s, n, r)
                    : this.off(t, a, h);
              }
            }
            o && ((a.isInvoking = !1), a.containCanceled && a.purgeCanceled());
          }
        }
        clear() {
          for (const t in this._callbackTable) {
            const e = this._callbackTable[t];
            e && (e.clear(), rr.free(e), delete this._callbackTable[t]);
          }
        }
        _registerOffCallback(t) {
          this._offCallback = t;
        }
      }
      function or(t) {
        class e extends t {
          constructor(...t) {
            super(...t), (this._callbackTable = St(!0));
          }
          once(t, e, i) {
            return this.on(t, e, i, !0);
          }
          targetOff(t) {
            this.removeAll(t);
          }
        }
        const i = ar.prototype,
          s = Object.getOwnPropertyNames(i).concat(
            Object.getOwnPropertySymbols(i)
          );
        for (let t = 0; t < s.length; ++t) {
          const n = s[t];
          if (!(n in e.prototype)) {
            const t = Object.getOwnPropertyDescriptor(i, n);
            t && Object.defineProperty(e.prototype, n, t);
          }
        }
        return e;
      }
      t("CallbacksInvoker", ar);
      const hr = t("EventTarget", or(class {}));
      a.EventTarget = hr;
      class lr {
        constructor() {
          this._delegates = [];
        }
        add(t) {
          this._delegates.includes(t) || this._delegates.push(t);
        }
        hasListener(t) {
          return this._delegates.includes(t);
        }
        remove(t) {
          ee(this._delegates, t);
        }
        dispatch(...t) {
          return Promise.all(
            this._delegates.map((t) => t(...arguments)).filter(Boolean)
          );
        }
      }
      let cr, ur, _r, dr, pr, mr;
      t("AsyncDelegate", lr),
        (function (t) {
          (t.UNKNOWN = "unknown"),
            (t.WECHAT = "wechat"),
            (t.ANDROID = "androidbrowser"),
            (t.IE = "ie"),
            (t.EDGE = "edge"),
            (t.QQ = "qqbrowser"),
            (t.MOBILE_QQ = "mqqbrowser"),
            (t.UC = "ucbrowser"),
            (t.UCBS = "ucbs"),
            (t.BROWSER_360 = "360browser"),
            (t.BAIDU_APP = "baiduboxapp"),
            (t.BAIDU = "baidubrowser"),
            (t.MAXTHON = "maxthon"),
            (t.OPERA = "opera"),
            (t.OUPENG = "oupeng"),
            (t.MIUI = "miuibrowser"),
            (t.FIREFOX = "firefox"),
            (t.SAFARI = "safari"),
            (t.CHROME = "chrome"),
            (t.LIEBAO = "liebao"),
            (t.QZONE = "qzone"),
            (t.SOUGOU = "sogou"),
            (t.HUAWEI = "huawei");
        })(cr || (cr = {})),
        (function (t) {
          (t.UNKNOWN = "unknown"),
            (t.ENGLISH = "en"),
            (t.CHINESE = "zh"),
            (t.FRENCH = "fr"),
            (t.ITALIAN = "it"),
            (t.GERMAN = "de"),
            (t.SPANISH = "es"),
            (t.DUTCH = "du"),
            (t.RUSSIAN = "ru"),
            (t.KOREAN = "ko"),
            (t.JAPANESE = "ja"),
            (t.HUNGARIAN = "hu"),
            (t.PORTUGUESE = "pt"),
            (t.ARABIC = "ar"),
            (t.NORWEGIAN = "no"),
            (t.POLISH = "pl"),
            (t.TURKISH = "tr"),
            (t.UKRAINIAN = "uk"),
            (t.ROMANIAN = "ro"),
            (t.BULGARIAN = "bg"),
            (t.HINDI = "hi"),
            (t.THAI = "th"),
            (t.VIETNAMESE = "vi"),
            (t.FINNISH = "fi"),
            (t.INDONESIAN = "id");
        })(ur || (ur = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.LAN = 1)] = "LAN"),
            (t[(t.WWAN = 2)] = "WWAN");
        })(_r || (_r = {})),
        (function (t) {
          (t.UNKNOWN = "Unknown"),
            (t.IOS = "iOS"),
            (t.ANDROID = "Android"),
            (t.WINDOWS = "Windows"),
            (t.LINUX = "Linux"),
            (t.OSX = "OS X"),
            (t.OHOS = "OHOS"),
            (t.OPENHARMONY = "OpenHarmony");
        })(dr || (dr = {})),
        (function (t) {
          (t.UNKNOWN = "UNKNOWN"),
            (t.EDITOR_PAGE = "EDITOR_PAGE"),
            (t.EDITOR_CORE = "EDITOR_CORE"),
            (t.MOBILE_BROWSER = "MOBILE_BROWSER"),
            (t.DESKTOP_BROWSER = "DESKTOP_BROWSER"),
            (t.WIN32 = "WIN32"),
            (t.ANDROID = "ANDROID"),
            (t.IOS = "IOS"),
            (t.MACOS = "MACOS"),
            (t.OHOS = "OHOS"),
            (t.OPENHARMONY = "OPENHARMONY"),
            (t.WECHAT_GAME = "WECHAT_GAME"),
            (t.WECHAT_MINI_PROGRAM = "WECHAT_MINI_PROGRAM"),
            (t.BAIDU_MINI_GAME = "BAIDU_MINI_GAME"),
            (t.XIAOMI_QUICK_GAME = "XIAOMI_QUICK_GAME"),
            (t.ALIPAY_MINI_GAME = "ALIPAY_MINI_GAME"),
            (t.TAOBAO_CREATIVE_APP = "TAOBAO_CREATIVE_APP"),
            (t.TAOBAO_MINI_GAME = "TAOBAO_MINI_GAME"),
            (t.BYTEDANCE_MINI_GAME = "BYTEDANCE_MINI_GAME"),
            (t.OPPO_MINI_GAME = "OPPO_MINI_GAME"),
            (t.VIVO_MINI_GAME = "VIVO_MINI_GAME"),
            (t.HUAWEI_QUICK_GAME = "HUAWEI_QUICK_GAME"),
            (t.COCOSPLAY = "COCOSPLAY"),
            (t.LINKSURE_MINI_GAME = "LINKSURE_MINI_GAME"),
            (t.QTT_MINI_GAME = "QTT_MINI_GAME");
        })(pr || (pr = {})),
        (function (t) {
          (t.WEBP = "WEBP"),
            (t.IMAGE_BITMAP = "IMAGE_BITMAP"),
            (t.WEB_VIEW = "WEB_VIEW"),
            (t.VIDEO_PLAYER = "VIDEO_PLAYER"),
            (t.SAFE_AREA = "SAFE_AREA"),
            (t.HPE = "HPE"),
            (t.INPUT_TOUCH = "INPUT_TOUCH"),
            (t.EVENT_KEYBOARD = "EVENT_KEYBOARD"),
            (t.EVENT_MOUSE = "EVENT_MOUSE"),
            (t.EVENT_TOUCH = "EVENT_TOUCH"),
            (t.EVENT_ACCELEROMETER = "EVENT_ACCELEROMETER"),
            (t.EVENT_GAMEPAD = "EVENT_GAMEPAD"),
            (t.EVENT_HANDLE = "EVENT_HANDLE"),
            (t.EVENT_HMD = "EVENT_HMD"),
            (t.EVENT_HANDHELD = "EVENT_HANDHELD"),
            (t.WASM = "WASM");
        })(mr || (mr = {}));
      const fr = { 0: _r.NONE, 1: _r.LAN, 2: _r.WWAN },
        gr = {
          0: pr.WIN32,
          2: pr.MACOS,
          3: pr.ANDROID,
          4: pr.IOS,
          5: pr.IOS,
          6: pr.OHOS,
          7: pr.OPENHARMONY,
        },
        yr = new (class extends hr {
          get networkType() {
            return fr[jsb.device.getNetworkType()];
          }
          constructor() {
            super(),
              (this._initPromise = []),
              (this.isNative = !0),
              (this.isBrowser = !1),
              (this.platform = gr[__getPlatform()]),
              (this.isMobile =
                this.platform === pr.ANDROID ||
                this.platform === pr.IOS ||
                this.platform === pr.OHOS ||
                this.platform === pr.OPENHARMONY),
              (this.isLittleEndian = (() => {
                const t = new ArrayBuffer(2);
                return (
                  new DataView(t).setInt16(0, 256, !0),
                  256 === new Int16Array(t)[0]
                );
              })());
            const t = __getCurrentLanguageCode();
            (this.nativeLanguage = t ? t.toLowerCase() : ur.UNKNOWN),
              (this.language = __getCurrentLanguage()),
              (this.os = __getOS()),
              (this.osVersion = __getOSVersion()),
              (this.osMainVersion = parseInt(this.osVersion)),
              (this.browserType = cr.UNKNOWN),
              (this.browserVersion = ""),
              (this.isXR = "undefined" != typeof xr && void 0 !== xr.XrEntry);
            const e = "function" == typeof __supportHPE && __supportHPE();
            (this._featureMap = {
              [mr.WEBP]: !0,
              [mr.IMAGE_BITMAP]: !1,
              [mr.WEB_VIEW]: this.isMobile,
              [mr.VIDEO_PLAYER]: this.isMobile,
              [mr.SAFE_AREA]: this.isMobile,
              [mr.HPE]: e,
              [mr.INPUT_TOUCH]: this.isMobile,
              [mr.EVENT_KEYBOARD]: !0,
              [mr.EVENT_MOUSE]: e || !this.isMobile,
              [mr.EVENT_TOUCH]: !0,
              [mr.EVENT_ACCELEROMETER]: this.isMobile,
              [mr.EVENT_GAMEPAD]: !0,
              [mr.EVENT_HANDLE]: this.isXR,
              [mr.EVENT_HMD]: this.isXR,
              [mr.EVENT_HANDHELD]:
                "undefined" != typeof xr && void 0 !== xr.ARModule,
              [mr.WASM]: !0,
            }),
              this._registerEvent();
          }
          _registerEvent() {
            (jsb.onPause = () => {
              this.emit("hide");
            }),
              (jsb.onResume = () => {
                this.emit("show");
              }),
              (jsb.onClose = () => {
                this.emit("close");
              }),
              (jsb.onWindowWillClose = (t) => {
                this.emit("onWindowWillClose", t);
              });
          }
          _setFeature(t, e) {
            return (this._featureMap[t] = e);
          }
          init() {
            return Promise.all(this._initPromise);
          }
          hasFeature(t) {
            return this._featureMap[t];
          }
          getBatteryLevel() {
            return jsb.device.getBatteryLevel();
          }
          triggerGC() {
            jsb.garbageCollect();
          }
          openURL(t) {
            jsb.openURL(t);
          }
          now() {
            return Date.now ? Date.now() : +new Date();
          }
          restartJSVM() {
            __restartVM();
          }
          close() {
            __close();
          }
          exit() {
            __exit();
          }
        })(),
        Tr = /(\.[^\.\/\?\\]*)(\?.*)?$/,
        Sr = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/,
        Er = /[^\.\/]+\/\.\.\//;
      function vr(...t) {
        let e = "";
        for (const i of t)
          e = (e + ("" === e ? "" : "/") + i).replace(/(\/|\\\\)$/, "");
        return e;
      }
      function br(t) {
        const e = Tr.exec(t);
        return e ? e[1] : "";
      }
      function Ar(t) {
        if (t) {
          const e = t.lastIndexOf(".");
          if (-1 !== e) return t.substring(0, e);
        }
        return t;
      }
      function Cr(t, e) {
        const i = t.indexOf("?");
        i > 0 && (t = t.substring(0, i));
        const s = /(\/|\\)([^\/\\]+)$/g.exec(t.replace(/(\/|\\)$/, ""));
        if (!s) return t;
        const n = s[2];
        return e &&
          t.substring(t.length - e.length).toLowerCase() === e.toLowerCase()
          ? n.substring(0, n.length - e.length)
          : n;
      }
      function Or(t) {
        const e = Sr.exec(t);
        return e ? e[2] : "";
      }
      function Ir(t, e) {
        e = e || "";
        let i = t.indexOf("?"),
          s = "";
        return (
          i > 0 && ((s = t.substring(i)), (t = t.substring(0, i))),
          (i = t.lastIndexOf(".")),
          i < 0 ? t + e + s : t.substring(0, i) + e + s
        );
      }
      function wr(t, e, i) {
        if (0 === e.indexOf(".")) return Ir(t, e);
        let s = t.indexOf("?"),
          n = "";
        const r = i ? br(t) : "";
        return (
          s > 0 && ((n = t.substring(s)), (t = t.substring(0, s))),
          (s = t.lastIndexOf("/")),
          (s = s <= 0 ? 0 : s + 1),
          t.substring(0, s) + e + r + n
        );
      }
      function Rr(t) {
        let e = (t = String(t));
        do {
          (e = t), (t = t.replace(Er, ""));
        } while (e.length !== t.length);
        return t;
      }
      function Dr(t) {
        return t.replace(/[\/\\]$/, "");
      }
      function Mr() {
        return yr.os === dr.WINDOWS ? "\\" : "/";
      }
      t(
        "path",
        Object.freeze({
          __proto__: null,
          join: vr,
          extname: br,
          mainFileName: Ar,
          basename: Cr,
          dirname: Or,
          changeExtname: Ir,
          changeBasename: wr,
          _normalize: Rr,
          stripSep: Dr,
          getSeperator: Mr,
        })
      );
      const Pr = new Yi();
      function Nr(t, e, i, s) {
        s || (s = new Yi()), t.convertToUINode(e, i, s);
        const n = i.position;
        return s.add(n), s;
      }
      function Lr(t, e, i) {
        return (
          i || (i = new Yi()),
          t.worldToScreen(e, i),
          (i.x /= a.view.getScaleX()),
          (i.y /= a.view.getScaleY()),
          i
        );
      }
      const Br = t("convertUtils", {
        WorldNode3DToLocalNodeUI: Nr,
        WorldNode3DToWorldNodeUI: Lr,
      });
      (a.pipelineUtils = Br),
        $(a.pipelineUtils, "cc.pipelineUtils", [
          {
            name: "WorldNode3DToLocalNodeUI",
            newName: "convertToUINode",
            targetName: "cc.Camera.prototype",
            customFunction(...t) {
              const e = t[0],
                i = t[3] || Pr;
              return (
                e.convertToUINode(t[1], t[2], i),
                i.add(t[2].position),
                t[3] || i.clone()
              );
            },
          },
        ]);
      const Fr = {
          0: ye.PORTRAIT,
          "-90": ye.LANDSCAPE_LEFT,
          90: ye.LANDSCAPE_RIGHT,
          180: ye.PORTRAIT_UPSIDE_DOWN,
        },
        Ur = new (class extends hr {
          get supportFullScreen() {
            return !1;
          }
          get isFullScreen() {
            return !1;
          }
          get devicePixelRatio() {
            return jsb.device.getDevicePixelRatio() || 1;
          }
          get windowSize() {
            const t = this.devicePixelRatio,
              e = jsb.window.innerWidth,
              i = jsb.window.innerHeight,
              s = Math.round(e),
              n = Math.round(i);
            return new ws(s * t, n * t);
          }
          set windowSize(t) {
            w("Setting window size is not supported yet.");
          }
          get resolution() {
            const t = this.windowSize,
              e = this.resolutionScale;
            return new ws(t.width * e, t.height * e);
          }
          get resolutionScale() {
            return this._resolutionScale;
          }
          set resolutionScale(t) {
            var e;
            t !== this._resolutionScale &&
              ((this._resolutionScale = t),
              null === (e = this._cbToUpdateFrameBuffer) ||
                void 0 === e ||
                e.call(this));
          }
          get orientation() {
            return Fr[jsb.device.getDeviceOrientation()];
          }
          set orientation(t) {
            z(1221);
          }
          get safeAreaEdge() {
            const t = jsb.device.getSafeAreaEdge(),
              e = this.devicePixelRatio;
            return {
              top: t.x * e,
              bottom: t.z * e,
              left: t.y * e,
              right: t.w * e,
            };
          }
          get isProportionalToFrame() {
            return this._isProportionalToFrame;
          }
          set isProportionalToFrame(t) {}
          constructor() {
            super(),
              (this.isFrameRotated = !1),
              (this.handleResizeEvent = !0),
              (this._enabledCssRotate = !0),
              (this._cbToUpdateFrameBuffer = void 0),
              (this._resolutionScale = 1),
              (this._isProportionalToFrame = !1),
              this._registerEvent();
          }
          init(t, e) {
            (this._cbToUpdateFrameBuffer = e), this._cbToUpdateFrameBuffer();
          }
          requestFullScreen() {
            return Promise.reject(
              new Error(
                "request fullscreen has not been supported yet on this platform."
              )
            );
          }
          exitFullScreen() {
            return Promise.reject(
              new Error(
                "exit fullscreen has not been supported yet on this platform."
              )
            );
          }
          _registerEvent() {
            (jsb.onResize = (t) => {
              0 !== t.width &&
                0 !== t.height &&
                (window.resize(
                  t.width / this.devicePixelRatio,
                  t.height / this.devicePixelRatio
                ),
                this.emit("window-resize", t.width, t.height, t.windowId));
            }),
              (jsb.onOrientationChanged = () => {
                this.emit("orientation-change", this.orientation);
              });
          }
          get enabledCssRotate() {
            return this._enabledCssRotate;
          }
          set enabledCssRotate(t) {
            this._enabledCssRotate = !!t;
          }
        })(),
        kr = t(
          "screen",
          new (class {
            init() {
              var t, e;
              const i =
                  null ===
                    (t = ge.querySettings(
                      fe.Category.SCREEN,
                      "exactFitScreen"
                    )) ||
                  void 0 === t ||
                  t,
                s =
                  null !==
                    (e = ge.querySettings(fe.Category.SCREEN, "orientation")) &&
                  void 0 !== e
                    ? e
                    : "auto",
                n = 3 === ge.querySettings(fe.Category.RENDERING, "renderMode");
              Ur.init(
                { exactFitScreen: i, configOrientation: s, isHeadlessMode: n },
                () => {
                  var t;
                  const e = a.director;
                  null !== (t = e.root) && void 0 !== t && t.pipeline
                    ? (e.root.pipeline.shadingScale = Ur.resolutionScale)
                    : z(1220);
                }
              );
            }
            get devicePixelRatio() {
              return Ur.devicePixelRatio;
            }
            get windowSize() {
              return Ur.windowSize;
            }
            set windowSize(t) {
              Ur.windowSize = t;
            }
            get enabledCssRotate() {
              return Ur.enabledCssRotate;
            }
            set enabledCssRotate(t) {
              Ur.enabledCssRotate = !!t;
            }
            get resolution() {
              return Ur.resolution;
            }
            get supportsFullScreen() {
              return Ur.supportFullScreen;
            }
            fullScreen() {
              return Ur.isFullScreen;
            }
            requestFullScreen(t, e, i) {
              return (
                arguments.length > 0 &&
                  z(
                    1400,
                    "screen.requestFullScreen(element, onFullScreenChange?, onFullScreenError?)",
                    "screen.requestFullScreen(): Promise"
                  ),
                Ur.requestFullScreen()
                  .then(() => {
                    null == e || e.call(document);
                  })
                  .catch((t) => {
                    R(t), null == i || i.call(document);
                  })
              );
            }
            exitFullScreen() {
              return Ur.exitFullScreen();
            }
            autoFullScreen(t, e) {
              var i;
              null === (i = this.requestFullScreen(t, e)) ||
                void 0 === i ||
                i.catch((t) => {
                  w(t);
                });
            }
            disableAutoFullScreen(t) {}
            on(t, e, i) {
              Ur.on(t, e, i);
            }
            once(t, e, i) {
              Ur.once(t, e, i);
            }
            off(t, e, i) {
              Ur.off(t, e, i);
            }
          })()
        );
      a.screen = kr;
      const zr = t("sys", {
        Feature: mr,
        hasFeature: (t) => yr.hasFeature(t),
        NetworkType: _r,
        Language: ur,
        OS: dr,
        Platform: pr,
        BrowserType: cr,
        isNative: yr.isNative,
        isBrowser: yr.isBrowser,
        isMobile: yr.isMobile,
        isLittleEndian: yr.isLittleEndian,
        platform: yr.platform,
        language: yr.language,
        languageCode: yr.nativeLanguage,
        os: yr.os,
        osVersion: yr.osVersion,
        osMainVersion: yr.osMainVersion,
        browserType: yr.browserType,
        browserVersion: yr.browserVersion,
        isXR: yr.isXR,
        windowPixelResolution: kr.windowSize,
        capabilities: {
          canvas: !0,
          opengl: !0,
          webp: yr.hasFeature(mr.WEBP),
          imageBitmap: yr.hasFeature(mr.IMAGE_BITMAP),
          touches: yr.hasFeature(mr.INPUT_TOUCH),
          mouse: yr.hasFeature(mr.EVENT_MOUSE),
          keyboard: yr.hasFeature(mr.EVENT_KEYBOARD),
          accelerometer: yr.hasFeature(mr.EVENT_ACCELEROMETER),
        },
        localStorage: {},
        getNetworkType: () => yr.networkType,
        getBatteryLevel: () => yr.getBatteryLevel(),
        garbageCollect() {
          yr.triggerGC();
        },
        isObjectValid: (t) => null != t,
        __isWebIOS14OrIPadOS14Env: !1,
        dump() {
          let t = "";
          (t += `isMobile : ${this.isMobile}\r\n`),
            (t += `language : ${this.language}\r\n`),
            (t += `browserType : ${this.browserType}\r\n`),
            (t += `browserVersion : ${this.browserVersion}\r\n`),
            (t += `supports webp: ${zr.hasFeature(mr.WEBP)}\r\n`),
            (t += `supports bitmap: ${zr.hasFeature(mr.IMAGE_BITMAP)}\r\n`),
            (t += `supports touches: ${zr.hasFeature(mr.INPUT_TOUCH)}\r\n`),
            (t += `supports mouse: ${zr.hasFeature(mr.EVENT_MOUSE)}\r\n`),
            (t += `supports keyboard: ${zr.hasFeature(mr.EVENT_KEYBOARD)}\r\n`),
            (t += `supports accelerometer: ${zr.hasFeature(
              mr.EVENT_ACCELEROMETER
            )}\r\n`),
            (t += `os : ${this.os}\r\n`),
            (t += `osVersion : ${this.osVersion}\r\n`),
            (t += `platform : ${this.platform}\r\n`),
            (t += `Using ${
              a.game.renderType === a.game.RENDER_TYPE_WEBGL
                ? "WEBGL"
                : "CANVAS"
            } renderer.\r\n`),
            I(t);
        },
        openURL(t) {
          yr.openURL(t);
        },
        init() {
          return Promise.resolve()
            .then(() => yr.init())
            .then(() => {
              try {
                let t = (zr.localStorage = window.localStorage);
                t.setItem("storage", ""), t.removeItem("storage"), (t = null);
              } catch (t) {
                const e = function () {
                  z(5200);
                };
                this.localStorage = {
                  getItem: e,
                  setItem: e,
                  clear: e,
                  removeItem: e,
                  key: e,
                  length: 0,
                };
              }
              this.__isWebIOS14OrIPadOS14Env =
                (zr.os === dr.IOS || zr.os === dr.OSX) &&
                yr.isBrowser &&
                /(OS 14)|(Version\/14)/.test(window.navigator.userAgent);
            });
        },
        now: () => yr.now(),
        restartVM() {
          yr.restartJSVM();
        },
        getSafeAreaRect(t = !0) {
          const e = a.view,
            i = Ur.safeAreaEdge;
          t &&
            (Ur.orientation === Te.ORIENTATION_PORTRAIT
              ? i.top < i.bottom
                ? (i.top = i.bottom)
                : (i.bottom = i.top)
              : i.left < i.right
              ? (i.left = i.right)
              : (i.right = i.left));
          const s = Ur.windowSize,
            n = new Ss(i.left, i.bottom),
            r = new Ss(s.width - i.right, s.height - i.top);
          e._convertToUISpace(n), e._convertToUISpace(r);
          const o = n.x,
            h = n.y,
            l = r.x - n.x,
            c = r.y - n.y;
          return new Ds(o, h, l, c);
        },
      });
      (a.sys = zr),
        Q(a, "cc", [
          {
            name: "winSize",
            suggest: "please use view.getVisibleSize() instead.",
          },
        ]),
        Q(zr, "sys", [
          {
            name: "capabilities",
            suggest: "please use sys.hasFeature() method instead.",
          },
        ]),
        $(
          zr,
          "sys",
          [
            "UNKNOWN",
            "ENGLISH",
            "CHINESE",
            "FRENCH",
            "ITALIAN",
            "GERMAN",
            "SPANISH",
            "DUTCH",
            "RUSSIAN",
            "KOREAN",
            "JAPANESE",
            "HUNGARIAN",
            "PORTUGUESE",
            "ARABIC",
            "NORWEGIAN",
            "POLISH",
            "TURKISH",
            "UKRAINIAN",
            "ROMANIAN",
            "BULGARIAN",
            "THAI",
            "VIETNAMESE",
            "FINNISH",
            "INDONESIAN",
          ].map((t) => ({
            name: `LANGUAGE_${t}`,
            newName: t,
            target: zr.Language,
            targetName: "sys.Language",
          }))
        ),
        $(
          zr,
          "sys",
          ["UNKNOWN", "IOS", "ANDROID", "WINDOWS", "LINUX", "OSX"].map((t) => ({
            name: `OS_${t}`,
            newName: t,
            target: zr.OS,
            targetName: "sys.OS",
          }))
        ),
        $(
          zr,
          "sys",
          [
            "UNKNOWN",
            "WECHAT",
            "ANDROID",
            "IE",
            "EDGE",
            "QQ",
            "MOBILE_QQ",
            "UC",
            "UCBS",
            "BAIDU_APP",
            "BAIDU",
            "MAXTHON",
            "OPERA",
            "OUPENG",
            "MIUI",
            "FIREFOX",
            "SAFARI",
            "CHROME",
            "LIEBAO",
            "QZONE",
            "SOUGOU",
            "HUAWEI",
          ].map((t) => ({
            name: `BROWSER_TYPE_${t}`,
            newName: t,
            target: zr.BrowserType,
            targetName: "sys.BrowserType",
          }))
        ),
        $(zr, "sys", [
          {
            name: "BROWSER_TYPE_360",
            newName: "BROWSER_360",
            target: zr.BrowserType,
            targetName: "sys.BrowserType",
          },
        ]),
        $(
          zr,
          "sys",
          [
            "UNKNOWN",
            "EDITOR_PAGE",
            "EDITOR_CORE",
            "MOBILE_BROWSER",
            "DESKTOP_BROWSER",
            "WIN32",
            "MACOS",
            "IOS",
            "ANDROID",
            "OHOS",
            "WECHAT_GAME",
            "BAIDU_MINI_GAME",
            "XIAOMI_QUICK_GAME",
            "ALIPAY_MINI_GAME",
            "BYTEDANCE_MINI_GAME",
            "OPPO_MINI_GAME",
            "VIVO_MINI_GAME",
            "HUAWEI_QUICK_GAME",
            "COCOSPLAY",
            "LINKSURE_MINI_GAME",
            "QTT_MINI_GAME",
          ].map((t) => ({
            name: t,
            target: zr.Platform,
            targetName: "sys.Platform",
          }))
        ),
        $(zr, "sys", [
          {
            name: "IPHONE",
            newName: "IOS",
            target: zr.Platform,
            targetName: "sys.Platform",
          },
          {
            name: "IPAD",
            newName: "IOS",
            target: zr.Platform,
            targetName: "sys.Platform",
          },
        ]),
        Z(
          zr,
          "sys",
          [
            "LINUX",
            "BLACKBERRY",
            "NACL",
            "EMSCRIPTEN",
            "TIZEN",
            "WINRT",
            "WP8",
            "QQ_PLAY",
            "FB_PLAYABLE_ADS",
          ].map((t) => ({ name: t }))
        ),
        $(zr, "sys", [
          {
            name: "windowPixelResolution",
            target: kr,
            targetName: "screen",
            newName: "windowSize",
          },
        ]),
        Q(kr, "screen", [
          {
            name: "autoFullScreen",
            suggest: "please use screen.requestFullScreen() instead.",
          },
          { name: "disableAutoFullScreen" },
        ]);
      const Hr = t("visibleRect", {
        topLeft: a.v2(0, 0),
        topRight: a.v2(0, 0),
        top: a.v2(0, 0),
        bottomLeft: a.v2(0, 0),
        bottomRight: a.v2(0, 0),
        bottom: a.v2(0, 0),
        center: a.v2(0, 0),
        left: a.v2(0, 0),
        right: a.v2(0, 0),
        width: 0,
        height: 0,
        init(t) {
          const e = (this.width = t.width),
            i = (this.height = t.height),
            s = t.x,
            n = t.y,
            r = n + i,
            a = s + e;
          (this.topLeft.x = s),
            (this.topLeft.y = r),
            (this.topRight.x = a),
            (this.topRight.y = r),
            (this.top.x = s + e / 2),
            (this.top.y = r),
            (this.bottomLeft.x = s),
            (this.bottomLeft.y = n),
            (this.bottomRight.x = a),
            (this.bottomRight.y = n),
            (this.bottom.x = s + e / 2),
            (this.bottom.y = n),
            (this.center.x = s + e / 2),
            (this.center.y = n + i / 2),
            (this.left.x = s),
            (this.left.y = n + i / 2),
            (this.right.x = a),
            (this.right.y = n + i / 2);
        },
        setVisibleRect: function (t, e) {
          (t.topLeft = a.v2(0, 0)),
            (t.topRight = a.v2(0, 0)),
            (t.top = a.v2(0, 0)),
            (t.bottomLeft = a.v2(0, 0)),
            (t.bottomRight = a.v2(0, 0)),
            (t.bottom = a.v2(0, 0)),
            (t.center = a.v2(0, 0)),
            (t.left = a.v2(0, 0)),
            (t.right = a.v2(0, 0)),
            (t.width = 0),
            (t.height = 0);
          var i = (t.width = e.width),
            s = (t.height = e.height),
            n = e.x,
            r = e.y,
            o = r + s,
            h = n + i;
          (t.topLeft.x = n),
            (t.topLeft.y = o),
            (t.topRight.x = h),
            (t.topRight.y = o),
            (t.top.x = n + i / 2),
            (t.top.y = o),
            (t.bottomLeft.x = n),
            (t.bottomLeft.y = r),
            (t.bottomRight.x = h),
            (t.bottomRight.y = r),
            (t.bottom.x = n + i / 2),
            (t.bottom.y = r),
            (t.center.x = n + i / 2),
            (t.center.y = r + s / 2),
            (t.left.x = n),
            (t.left.y = r + s / 2),
            (t.right.x = h),
            (t.right.y = r + s / 2);
        },
        copyVisibleRect: function (t, e) {
          null != t &&
            null != e &&
            ((t.topLeft = a.v2(0, 0)),
            (t.topRight = a.v2(0, 0)),
            (t.top = a.v2(0, 0)),
            (t.bottomLeft = a.v2(0, 0)),
            (t.bottomRight = a.v2(0, 0)),
            (t.bottom = a.v2(0, 0)),
            (t.center = a.v2(0, 0)),
            (t.left = a.v2(0, 0)),
            (t.right = a.v2(0, 0)),
            (t.width = 0),
            (t.height = 0),
            (t.topLeft.x = e.topLeft.x),
            (t.topLeft.y = e.topLeft.y),
            (t.topRight.x = e.topRight.x),
            (t.topRight.y = e.topRight.y),
            (t.top.x = e.top.x),
            (t.top.y = e.top.y),
            (t.bottomLeft.x = e.bottomLeft.x),
            (t.bottomLeft.y = e.bottomLeft.y),
            (t.bottomRight.x = e.bottomRight.x),
            (t.bottomRight.y = e.bottomRight.y),
            (t.bottom.x = e.bottom.x),
            (t.bottom.y = e.bottom.y),
            (t.center.x = e.center.x),
            (t.center.y = e.center.y),
            (t.left.x = e.left.x),
            (t.left.y = e.left.y),
            (t.right.x = e.right.x),
            (t.right.y = e.right.y),
            (t.width = e.width),
            (t.height = e.height));
        },
      });
      a.visibleRect = Hr;
      const Gr = new Yi(),
        Vr = new Yi(),
        jr = new Yi(),
        Wr = new Yi(),
        Xr = new es(),
        Yr = (t, e, i) => {
          (Xr.m00 = Math.abs(i.m00)),
            (Xr.m01 = Math.abs(i.m01)),
            (Xr.m02 = Math.abs(i.m02)),
            (Xr.m03 = Math.abs(i.m04)),
            (Xr.m04 = Math.abs(i.m05)),
            (Xr.m05 = Math.abs(i.m06)),
            (Xr.m06 = Math.abs(i.m08)),
            (Xr.m07 = Math.abs(i.m09)),
            (Xr.m08 = Math.abs(i.m10)),
            Yi.transformMat3(t, e, Xr);
        };
      class Kr {
        static create(t, e, i, s, n, r) {
          return new Kr(t, e, i, s, n, r);
        }
        static clone(t) {
          return new Kr(
            t.center.x,
            t.center.y,
            t.center.z,
            t.halfExtents.x,
            t.halfExtents.y,
            t.halfExtents.z
          );
        }
        static copy(t, e) {
          return (
            Yi.copy(t.center, e.center),
            Yi.copy(t.halfExtents, e.halfExtents),
            t
          );
        }
        static fromPoints(t, e, i) {
          return (
            Yi.add(Gr, i, e),
            Yi.subtract(Vr, i, e),
            Yi.multiplyScalar(t.center, Gr, 0.5),
            Yi.multiplyScalar(t.halfExtents, Vr, 0.5),
            t
          );
        }
        static set(t, e, i, s, n, r, a) {
          return t.center.set(e, i, s), t.halfExtents.set(n, r, a), t;
        }
        static merge(t, e, i) {
          return (
            Yi.subtract(Gr, e.center, e.halfExtents),
            Yi.subtract(Vr, i.center, i.halfExtents),
            Yi.add(jr, e.center, e.halfExtents),
            Yi.add(Wr, i.center, i.halfExtents),
            Yi.max(Wr, jr, Wr),
            Yi.min(jr, Gr, Vr),
            Kr.fromPoints(t, jr, Wr)
          );
        }
        static toBoundingSphere(t, e) {
          return t.center.set(e.center), (t.radius = e.halfExtents.length()), t;
        }
        static transform(t, e, i) {
          return (
            Yi.transformMat4(t.center, e.center, i),
            Yr(t.halfExtents, e.halfExtents, i),
            t
          );
        }
        get type() {
          return this._type;
        }
        constructor(t = 0, e = 0, i = 0, s = 1, n = 1, r = 1) {
          (this.center = void 0),
            (this.halfExtents = void 0),
            (this._type = void 0),
            (this._type = Ys.SHAPE_AABB),
            (this.center = new Yi(t, e, i)),
            (this.halfExtents = new Yi(s, n, r));
        }
        getBoundary(t, e) {
          Yi.subtract(t, this.center, this.halfExtents),
            Yi.add(e, this.center, this.halfExtents);
        }
        transform(t, e, i, s, n) {
          Yi.transformMat4(n.center, this.center, t),
            Yr(n.halfExtents, this.halfExtents, t);
        }
        clone() {
          const t = this.center,
            e = this.halfExtents;
          return new Kr(t.x, t.y, t.z, e.x, e.y, e.z);
        }
        copy(t) {
          return (
            Yi.copy(this.center, t.center),
            Yi.copy(this.halfExtents, t.halfExtents),
            this
          );
        }
        mergePoint(t) {
          this.getBoundary(Gr, Vr),
            t.x < Gr.x && (Gr.x = t.x),
            t.y < Gr.y && (Gr.y = t.y),
            t.z < Gr.z && (Gr.z = t.z),
            t.x > Vr.x && (Vr.x = t.x),
            t.y > Vr.y && (Vr.y = t.y),
            t.z > Vr.z && (Vr.z = t.z),
            Yi.add(jr, Gr, Vr),
            this.center.set(Yi.multiplyScalar(jr, jr, 0.5)),
            this.halfExtents.set(Vr.x - jr.x, Vr.y - jr.y, Vr.z - jr.z);
        }
        mergePoints(t) {
          if (!(t.length < 1))
            for (let e = 0; e < t.length; e++) this.mergePoint(t[e]);
        }
        mergeFrustum(t) {
          this.mergePoints(t.vertices);
        }
      }
      class qr {
        get type() {
          return this._type;
        }
        constructor(t = 0.5, e = 0.5, i = 1) {
          (this._type = void 0),
            (this.radius = void 0),
            (this.halfHeight = void 0),
            (this.axis = void 0),
            (this.center = void 0),
            (this.rotation = void 0),
            (this.ellipseCenter0 = void 0),
            (this.ellipseCenter1 = void 0),
            (this._type = Ys.SHAPE_CAPSULE),
            (this.radius = t),
            (this.halfHeight = e),
            (this.axis = i),
            (this.center = new Yi()),
            (this.rotation = new as()),
            (this.ellipseCenter0 = new Yi(0, e, 0)),
            (this.ellipseCenter1 = new Yi(0, -e, 0)),
            this.updateCache();
        }
        transform(t, e, i, s, n) {
          const r = s,
            a = Bi(r);
          n.radius = this.radius * Math.abs(a);
          let o = (this.halfHeight + this.radius) * Math.abs(r.y) - n.radius;
          o < 0 && (o = 0),
            (n.halfHeight = o),
            Yi.transformMat4(n.center, this.center, t),
            as.multiply(n.rotation, this.rotation, i),
            n.updateCache();
        }
        updateCache() {
          this.updateLocalCenter(),
            Yi.transformQuat(
              this.ellipseCenter0,
              this.ellipseCenter0,
              this.rotation
            ),
            Yi.transformQuat(
              this.ellipseCenter1,
              this.ellipseCenter1,
              this.rotation
            ),
            this.ellipseCenter0.add(this.center),
            this.ellipseCenter1.add(this.center);
        }
        updateLocalCenter() {
          const t = this.halfHeight;
          switch (this.axis) {
            case 0:
              this.ellipseCenter0.set(t, 0, 0),
                this.ellipseCenter1.set(-t, 0, 0);
              break;
            case 1:
              this.ellipseCenter0.set(0, t, 0),
                this.ellipseCenter1.set(0, -t, 0);
              break;
            case 2:
              this.ellipseCenter0.set(0, 0, t),
                this.ellipseCenter1.set(0, 0, -t);
          }
        }
      }
      const $r = new Array(8);
      ($r[0] = new Yi(1, 1, 1)),
        ($r[1] = new Yi(-1, 1, 1)),
        ($r[2] = new Yi(-1, -1, 1)),
        ($r[3] = new Yi(1, -1, 1)),
        ($r[4] = new Yi(1, 1, -1)),
        ($r[5] = new Yi(-1, 1, -1)),
        ($r[6] = new Yi(-1, -1, -1)),
        ($r[7] = new Yi(1, -1, -1));
      const Zr = new Yi(),
        Qr = new Yi(),
        Jr = new Yi();
      class ta {
        static createOrthographic(t, e, i, s, n, r) {
          const a = e / 2,
            o = i / 2;
          Yi.set(Jr, a, o, -s),
            Yi.transformMat4(t.vertices[0], Jr, r),
            Yi.set(Jr, -a, o, -s),
            Yi.transformMat4(t.vertices[1], Jr, r),
            Yi.set(Jr, -a, -o, -s),
            Yi.transformMat4(t.vertices[2], Jr, r),
            Yi.set(Jr, a, -o, -s),
            Yi.transformMat4(t.vertices[3], Jr, r),
            Yi.set(Jr, a, o, -n),
            Yi.transformMat4(t.vertices[4], Jr, r),
            Yi.set(Jr, -a, o, -n),
            Yi.transformMat4(t.vertices[5], Jr, r),
            Yi.set(Jr, -a, -o, -n),
            Yi.transformMat4(t.vertices[6], Jr, r),
            Yi.set(Jr, a, -o, -n),
            Yi.transformMat4(t.vertices[7], Jr, r),
            t.updatePlanes();
        }
        static createOrtho(t, e, i, s, n, r) {
          return ta.createOrthographic(t, e, i, s, n, r);
        }
        static createPerspective(t, e, i, s, n, r) {
          const a = Math.tan(0.5 * i),
            o = a * e;
          Zr.set(s * o, s * a, s), Qr.set(n * o, n * a, n);
          const h = t.vertices;
          Jr.set(Zr.x, Zr.y, -Zr.z),
            Yi.transformMat4(h[0], Jr, r),
            Jr.set(-Zr.x, Zr.y, -Zr.z),
            Yi.transformMat4(h[1], Jr, r),
            Jr.set(-Zr.x, -Zr.y, -Zr.z),
            Yi.transformMat4(h[2], Jr, r),
            Jr.set(Zr.x, -Zr.y, -Zr.z),
            Yi.transformMat4(h[3], Jr, r),
            Jr.set(Qr.x, Qr.y, -Qr.z),
            Yi.transformMat4(h[4], Jr, r),
            Jr.set(-Qr.x, Qr.y, -Qr.z),
            Yi.transformMat4(h[5], Jr, r),
            Jr.set(-Qr.x, -Qr.y, -Qr.z),
            Yi.transformMat4(h[6], Jr, r),
            Jr.set(Qr.x, -Qr.y, -Qr.z),
            Yi.transformMat4(h[7], Jr, r),
            t.updatePlanes();
        }
        static createFromAABB(t, e) {
          const i = new Yi(),
            s = new Yi();
          return (
            Yi.subtract(i, e.center, e.halfExtents),
            Yi.add(s, e.center, e.halfExtents),
            t.vertices[0].set(s.x, s.y, -i.z),
            t.vertices[1].set(i.x, s.y, -i.z),
            t.vertices[2].set(i.x, i.y, -i.z),
            t.vertices[3].set(s.x, i.y, -i.z),
            t.vertices[4].set(s.x, s.y, -s.z),
            t.vertices[5].set(i.x, s.y, -s.z),
            t.vertices[6].set(i.x, i.y, -s.z),
            t.vertices[7].set(s.x, i.y, -s.z),
            t.updatePlanes(),
            t
          );
        }
        split(t, e, i, s, n) {
          return ta.createPerspective(this, i, s, t, e, n);
        }
        static create() {
          return new ta();
        }
        static clone(t) {
          return ta.copy(new ta(), t);
        }
        static copy(t, e) {
          t._type = e.type;
          for (let i = 0; i < 6; ++i) Hn.copy(t.planes[i], e.planes[i]);
          for (let i = 0; i < 8; ++i) Yi.copy(t.vertices[i], e.vertices[i]);
          return t;
        }
        set accurate(t) {
          this._type = t ? Ys.SHAPE_FRUSTUM_ACCURATE : Ys.SHAPE_FRUSTUM;
        }
        get type() {
          return this._type;
        }
        constructor() {
          (this.planes = void 0),
            (this.vertices = void 0),
            (this._type = void 0),
            (this._type = Ys.SHAPE_FRUSTUM),
            (this.planes = new Array(6));
          for (let t = 0; t < 6; ++t) this.planes[t] = Hn.create(0, 0, 0, 0);
          this.vertices = new Array(8);
          for (let t = 0; t < 8; ++t) this.vertices[t] = new Yi();
        }
        update(t, e) {
          Yi.set(this.planes[0].n, t.m03 + t.m00, t.m07 + t.m04, t.m11 + t.m08),
            (this.planes[0].d = -(t.m15 + t.m12)),
            Yi.set(
              this.planes[1].n,
              t.m03 - t.m00,
              t.m07 - t.m04,
              t.m11 - t.m08
            ),
            (this.planes[1].d = -(t.m15 - t.m12)),
            Yi.set(
              this.planes[2].n,
              t.m03 + t.m01,
              t.m07 + t.m05,
              t.m11 + t.m09
            ),
            (this.planes[2].d = -(t.m15 + t.m13)),
            Yi.set(
              this.planes[3].n,
              t.m03 - t.m01,
              t.m07 - t.m05,
              t.m11 - t.m09
            ),
            (this.planes[3].d = -(t.m15 - t.m13)),
            Yi.set(
              this.planes[4].n,
              t.m03 + t.m02,
              t.m07 + t.m06,
              t.m11 + t.m10
            ),
            (this.planes[4].d = -(t.m15 + t.m14)),
            Yi.set(
              this.planes[5].n,
              t.m03 - t.m02,
              t.m07 - t.m06,
              t.m11 - t.m10
            ),
            (this.planes[5].d = -(t.m15 - t.m14));
          for (let t = 0; t < 6; t++) {
            const e = this.planes[t],
              i = 1 / e.n.length();
            Yi.multiplyScalar(e.n, e.n, i), (e.d *= i);
          }
          for (let t = 0; t < 8; t++)
            Yi.transformMat4(this.vertices[t], $r[t], e);
        }
        transform(t) {
          for (let e = 0; e < 8; e++)
            Yi.transformMat4(this.vertices[e], this.vertices[e], t);
          this.updatePlanes();
        }
        zero() {
          for (let t = 0; t < 8; t++) this.vertices[t].set(0, 0, 0);
          for (let t = 0; t < 6; t++) Hn.set(this.planes[t], 0, 0, 0, 0);
        }
        updatePlanes() {
          Hn.fromPoints(
            this.planes[0],
            this.vertices[1],
            this.vertices[6],
            this.vertices[5]
          ),
            Hn.fromPoints(
              this.planes[1],
              this.vertices[3],
              this.vertices[4],
              this.vertices[7]
            ),
            Hn.fromPoints(
              this.planes[2],
              this.vertices[6],
              this.vertices[3],
              this.vertices[7]
            ),
            Hn.fromPoints(
              this.planes[3],
              this.vertices[0],
              this.vertices[5],
              this.vertices[4]
            ),
            Hn.fromPoints(
              this.planes[4],
              this.vertices[2],
              this.vertices[0],
              this.vertices[3]
            ),
            Hn.fromPoints(
              this.planes[5],
              this.vertices[7],
              this.vertices[5],
              this.vertices[6]
            );
        }
      }
      function ea(t, e) {
        const i = Object.getOwnPropertyDescriptor(t.prototype, e),
          s = `_$cache_${e}`,
          n = `_$_${e}`;
        Object.defineProperty(t.prototype, n, i),
          Object.defineProperty(t.prototype, e, {
            get() {
              return void 0 === this[s] && (this[s] = this[n]), this[s];
            },
            set(t) {
              this[n] = t;
            },
            configurable: !0,
            enumerable: !0,
          });
      }
      function ia(t) {
        t.prototype._arraybuffer = function () {
          return (
            this.__data || (this.__data = this.underlyingData()), this.__data
          );
        };
      }
      const sa = (t, e) => {
          const i = t.__nativeFields__[e],
            s = `_$_${e}`;
          D(4 === i.fieldSize, `field ${e} size ${i.fieldSize}`),
            Object.defineProperty(t.prototype, i.fieldName, {
              configurable: !0,
              enumerable: !0,
              get() {
                return (
                  void 0 === this[s] &&
                    (this[s] = new Float32Array(
                      this._arraybuffer(),
                      i.fieldOffset,
                      1
                    )),
                  this[s][0]
                );
              },
              set(t) {
                void 0 === this[s] &&
                  (this[s] = new Float32Array(
                    this._arraybuffer(),
                    i.fieldOffset,
                    1
                  )),
                  (this[s][0] = t);
              },
            });
        },
        na = (t, e) => {
          const i = t.__nativeFields__[e];
          i || console.error(`attr ${e} not defined in class ${t.toString()}`);
          const s = `_$_${e}`;
          D(4 === i.fieldSize, `field ${e} size ${i.fieldSize}`),
            Object.defineProperty(t.prototype, i.fieldName, {
              configurable: !0,
              enumerable: !0,
              get() {
                return (
                  void 0 === this[s] &&
                    (this[s] = new Int32Array(
                      this._arraybuffer(),
                      i.fieldOffset,
                      1
                    )),
                  this[s][0]
                );
              },
              set(t) {
                void 0 === this[s] &&
                  (this[s] = new Int32Array(
                    this._arraybuffer(),
                    i.fieldOffset,
                    1
                  )),
                  (this[s][0] = t);
              },
            });
        };
      {
        ea(ns.Line, "s"),
          ea(ns.Line, "e"),
          Object.setPrototypeOf(ns.Line.prototype, Ks.prototype),
          ia(ns.Plane),
          ea(ns.Plane, "n"),
          sa(ns.Plane, "d"),
          Object.setPrototypeOf(ns.Plane.prototype, Hn.prototype),
          ia(ns.Ray),
          ea(ns.Ray, "o"),
          ea(ns.Ray, "d"),
          Object.setPrototypeOf(ns.Ray.prototype, qs.prototype),
          ia(ns.Triangle),
          ea(ns.Triangle, "a"),
          ea(ns.Triangle, "b"),
          ea(ns.Triangle, "c"),
          Object.setPrototypeOf(ns.Triangle.prototype, Gn.prototype),
          ia(ns.Sphere),
          ea(ns.Sphere, "_center"),
          sa(ns.Sphere, "_radius"),
          Object.setPrototypeOf(ns.Sphere.prototype, en.prototype),
          ia(ns.AABB),
          ea(ns.AABB, "center"),
          ea(ns.AABB, "halfExtents"),
          Object.setPrototypeOf(ns.AABB.prototype, Kr.prototype),
          ia(ns.Capsule),
          sa(ns.Capsule, "radius"),
          sa(ns.Capsule, "halfHeight"),
          na(ns.Capsule, "axis"),
          ea(ns.Capsule, "center"),
          ea(ns.Capsule, "rotation"),
          ea(ns.Capsule, "ellipseCenter0"),
          ea(ns.Capsule, "ellipseCenter1"),
          Object.setPrototypeOf(ns.Capsule.prototype, qr.prototype),
          ea(ns.Frustum, "vertices"),
          ea(ns.Frustum, "planes"),
          Object.setPrototypeOf(ns.Frustum.prototype, ta.prototype);
        const t = Object.getOwnPropertyDescriptor(
          ns.ShapeBase.prototype,
          "_type"
        );
        for (const e of [
          ns.Line,
          ns.Plane,
          ns.Ray,
          ns.Triangle,
          ns.Sphere,
          ns.AABB,
          ns.Capsule,
          ns.Frustum,
        ])
          Object.defineProperty(e.prototype, "_type", t);
      }
      const ra = new Yi(),
        aa = new Yi(),
        oa = new es();
      class ha {
        static create(t, e, i, s, n, r, a, o, h, l, c, u, _, d, p) {
          return new ha(t, e, i, s, n, r, a, o, h, l, c, u, _, d, p);
        }
        static clone(t) {
          return new ha(
            t.center.x,
            t.center.y,
            t.center.z,
            t.halfExtents.x,
            t.halfExtents.y,
            t.halfExtents.z,
            t.orientation.m00,
            t.orientation.m01,
            t.orientation.m02,
            t.orientation.m03,
            t.orientation.m04,
            t.orientation.m05,
            t.orientation.m06,
            t.orientation.m07,
            t.orientation.m08
          );
        }
        static copy(t, e) {
          return (
            Yi.copy(t.center, e.center),
            Yi.copy(t.halfExtents, e.halfExtents),
            es.copy(t.orientation, e.orientation),
            t
          );
        }
        static fromPoints(t, e, i) {
          return (
            Yi.multiplyScalar(t.center, Yi.add(ra, e, i), 0.5),
            Yi.multiplyScalar(t.halfExtents, Yi.subtract(aa, i, e), 0.5),
            es.identity(t.orientation),
            t
          );
        }
        static set(t, e, i, s, n, r, a, o, h, l, c, u, _, d, p, m) {
          return (
            Yi.set(t.center, e, i, s),
            Yi.set(t.halfExtents, n, r, a),
            es.set(t.orientation, o, h, l, c, u, _, d, p, m),
            t
          );
        }
        get type() {
          return this._type;
        }
        constructor(
          t = 0,
          e = 0,
          i = 0,
          s = 1,
          n = 1,
          r = 1,
          a = 1,
          o = 0,
          h = 0,
          l = 0,
          c = 1,
          u = 0,
          _ = 0,
          d = 0,
          p = 1
        ) {
          (this.center = void 0),
            (this.halfExtents = void 0),
            (this.orientation = void 0),
            (this._type = void 0),
            (this._type = Ys.SHAPE_OBB),
            (this.center = new Yi(t, e, i)),
            (this.halfExtents = new Yi(s, n, r)),
            (this.orientation = new es(a, o, h, l, c, u, _, d, p));
        }
        getBoundary(t, e) {
          var i, s, n;
          (i = ra),
            (s = this.halfExtents),
            (n = this.orientation),
            (oa.m00 = Math.abs(n.m00)),
            (oa.m01 = Math.abs(n.m01)),
            (oa.m02 = Math.abs(n.m02)),
            (oa.m03 = Math.abs(n.m03)),
            (oa.m04 = Math.abs(n.m04)),
            (oa.m05 = Math.abs(n.m05)),
            (oa.m06 = Math.abs(n.m06)),
            (oa.m07 = Math.abs(n.m07)),
            (oa.m08 = Math.abs(n.m08)),
            Yi.transformMat3(i, s, oa),
            Yi.subtract(t, this.center, ra),
            Yi.add(e, this.center, ra);
        }
        transform(t, e, i, s, n) {
          Yi.transformMat4(n.center, this.center, t),
            es.fromQuat(n.orientation, i),
            Yi.multiply(n.halfExtents, this.halfExtents, s);
        }
        translateAndRotate(t, e, i) {
          Yi.transformMat4(i.center, this.center, t),
            es.fromQuat(i.orientation, e);
        }
        setScale(t, e) {
          Yi.multiply(e.halfExtents, this.halfExtents, t);
        }
      }
      function la(t, e, i = 1e-6) {
        let s = 0,
          n = t.length - 1,
          r = n >>> 1;
        for (; s <= n; r = (s + n) >>> 1) {
          const a = t[r];
          if (a > e + i) n = r - 1;
          else {
            if (!(a < e - i)) return r;
            s = r + 1;
          }
        }
        return ~s;
      }
      let ca, ua, _a, da;
      ca = Symbol.iterator;
      class pa {
        constructor() {
          (this._times = []), (this._values = []);
        }
        get keyFramesCount() {
          return this._times.length;
        }
        get rangeMin() {
          return this._times[0];
        }
        get rangeMax() {
          return this._times[this._values.length - 1];
        }
        [ca]() {
          let t = 0;
          return {
            next: () => {
              if (t >= this._times.length) return { done: !0, value: void 0 };
              {
                const e = [this._times[t], this._values[t]];
                return ++t, { done: !1, value: e };
              }
            },
          };
        }
        keyframes() {
          return this;
        }
        times() {
          return this._times;
        }
        values() {
          return this._values;
        }
        getKeyframeTime(t) {
          return this._times[t];
        }
        getKeyframeValue(t) {
          return this._values[t];
        }
        addKeyFrame(t, e) {
          return this._insertNewKeyframe(t, e);
        }
        removeKeyframe(t) {
          this._times.splice(t, 1), this._values.splice(t, 1);
        }
        indexOfKeyframe(t) {
          return la(this._times, t);
        }
        updateTime(t, e) {
          const i = this._values[t];
          this.removeKeyframe(t), this._insertNewKeyframe(e, i);
        }
        assignSorted(t, e) {
          if (void 0 !== e) this.setKeyframes(t.slice(), e.slice());
          else {
            const e = Array.from(t);
            this.setKeyframes(
              e.map(([t]) => t),
              e.map(([, t]) => t)
            );
          }
        }
        clear() {
          (this._times.length = 0), (this._values.length = 0);
        }
        searchKeyframe(t) {
          return la(this._times, t);
        }
        setKeyframes(t, e) {
          t.length,
            e.length,
            (function (t) {
              t.every(
                (t, e, i) => 0 === e || t > i[e - 1] || Ti(t, i[e - 1], 1e-6)
              );
            })(t),
            (this._times = t),
            (this._values = e);
        }
        _insertNewKeyframe(t, e) {
          const i = this._times,
            s = this._values,
            n = i.length,
            r = la(i, t);
          if (r >= 0) return r;
          const a = ~r;
          return (
            0 === a
              ? (i.unshift(t), s.unshift(e))
              : a === n
              ? (i.push(t), s.push(e))
              : (i.splice(a - 1, 0, t), s.splice(a - 1, 0, e)),
            a
          );
        }
      }
      function ma(t) {
        return t > -1e-9 && t < 1e-9;
      }
      function fa(t, e, i, s) {
        return i
          .slice()
          .reverse()
          .reduce(function (i, s) {
            return s(t, e, i) || i;
          }, s);
      }
      hi.fastDefine("cc.KeyframeCurve", pa, { _times: [], _values: [] }),
        t("RealInterpolationMode", ua),
        (function (t) {
          (t[(t.LINEAR = 0)] = "LINEAR"),
            (t[(t.CONSTANT = 1)] = "CONSTANT"),
            (t[(t.CUBIC = 2)] = "CUBIC");
        })(ua || t("RealInterpolationMode", (ua = {}))),
        t("ExtrapolationMode", _a),
        (function (t) {
          (t[(t.LINEAR = 0)] = "LINEAR"),
            (t[(t.CLAMP = 1)] = "CLAMP"),
            (t[(t.LOOP = 2)] = "LOOP"),
            (t[(t.PING_PONG = 3)] = "PING_PONG");
        })(_a || t("ExtrapolationMode", (_a = {}))),
        t("TangentWeightMode", da),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.LEFT = 1)] = "LEFT"),
            (t[(t.RIGHT = 2)] = "RIGHT"),
            (t[(t.BOTH = 3)] = "BOTH");
        })(da || t("TangentWeightMode", (da = {})));
      const ga = () => {},
        ya = () => ga,
        Ta = Sa(() => {});
      function Sa(t) {
        return function (e) {
          return "function" == typeof e
            ? t(e)
            : function (i) {
                return t(i, e);
              };
        };
      }
      function Ea(t) {
        return (e) => (i) => {
          !(function (t, e, i) {
            const s = ba(t);
            if (s) {
              const t = Aa(s, "proto");
              Aa(t, "editor")[e] = i;
            }
          })(i, t, e);
        };
      }
      const va = "__ccclassCache__";
      function ba(t) {
        return Aa(t, va);
      }
      function Aa(t, e) {
        return t[e] || (t[e] = {});
      }
      const Ca = Sa((t, e) => {
          let i = Nt(t);
          i === Object && (i = null);
          const s = { name: e, extends: i, ctor: t },
            n = t[va];
          if (n) {
            const e = n.proto;
            e && Mt(s, e), (t[va] = void 0);
          }
          return hi(s);
        }),
        Oa = Ea("requireComponent"),
        Ia = Ea("executionOrder"),
        wa = Ta;
      function Ra(t, e, i) {
        let s = null;
        function n(t, e, i) {
          !(function (t, e, i, s, n, r) {
            let a;
            const o = r && "function" != typeof r && (r.get || r.set);
            n && (a = qe(n, o));
            const h = Mt(e, a || n || {});
            o
              ? (r.get && (h.get = r.get), r.set && (h.set = r.set))
              : Ma(t, h, i, s, r);
          })(
            (function (t) {
              return ba(t.constructor);
            })(t),
            (function (t, e) {
              var i, s;
              const n = Aa(ba(t.constructor), "proto"),
                r = Aa(n, "properties");
              return null !== (s = r[(i = e)]) && void 0 !== s
                ? s
                : (r[i] = {});
            })(t, e),
            t.constructor,
            e,
            s,
            i
          );
        }
        return void 0 === t
          ? Ra({ type: void 0 })
          : void 0 === e
          ? ((s = t), n)
          : void n(t, e, i);
      }
      function Da(t) {
        let e;
        try {
          e = t();
        } catch (e) {
          return t;
        }
        return "object" != typeof e || null === e ? e : t;
      }
      function xa(t, e, i) {
        var s, n;
        const r = ba(t.constructor),
          a = Aa(r, "proto"),
          o = Aa(a, "properties"),
          h = null !== (n = o[(s = e)]) && void 0 !== n ? n : (o[s] = {});
        return (
          (h.__internalFlags |= $e.STANDALONE),
          i && "function" != typeof i && (i.get || i.set)
            ? (i.get && (h.get = i.get), i.set && (h.set = i.set))
            : Ma(r, h, t.constructor, e, i),
          h
        );
      }
      function Ma(t, e, i, s, n) {
        if (void 0 !== n)
          "function" == typeof n
            ? (e.default = Da(n))
            : null === n || (n.initializer && (e.default = Da(n.initializer)));
        else {
          const n =
            t.default ||
            (t.default = (function (t) {
              let e;
              try {
                e = new t();
              } catch (t) {
                return {};
              }
              return e;
            })(i));
          n.hasOwnProperty(s) && (e.default = n[s]);
        }
      }
      const Pa = Symbol("cc:SerializationMetadata"),
        Na = t("serializable", (t, e, i) => {
          Fa(xa(t, e, i));
        });
      function La(t) {
        return (e, i, s) => {
          const n = xa(e, i, s);
          (n.formerlySerializedAs = t), Fa(n);
        };
      }
      const Ba = (t, e, i) => {
        const s = xa(t, e, i);
        (s.editorOnly = !0), Fa(s);
      };
      function Fa(t) {
        t.__internalFlags |= $e.IMPLICIT_SERIALIZABLE;
      }
      const Ua = ga,
        ka = Ta,
        za = ya,
        Ha = Ta,
        Ga = ya,
        Va = ya,
        ja = ya,
        Wa = t("editable", ga),
        Xa = t("visible", ya),
        Ya = ga,
        Ka = t("displayName", ya),
        qa = t("tooltip", ya),
        $a = t("range", ya),
        Za = ya,
        Qa = t("rangeStep", ya),
        Ja = t("slide", ga),
        to = t("displayOrder", ya),
        eo = t("disallowAnimation", ga),
        io = ao(ke),
        so = ao(ze),
        no = ao(He),
        ro = ao(Ge);
      function ao(t) {
        return Ra({ type: t });
      }
      const oo = t("override", (t, e, i) => {
        xa(t, e, i).override = !0;
      });
      const ho = t("EditorExtendable", class {});
      var lo,
        co,
        uo,
        _o,
        po,
        mo,
        fo,
        go = Object.freeze({
          __proto__: null,
          uniquelyReferenced: Ua,
          ccclass: Ca,
          property: Ra,
          requireComponent: Oa,
          executionOrder: Ia,
          disallowMultiple: wa,
          executeInEditMode: ka,
          menu: za,
          playOnFocus: Ha,
          inspector: Ga,
          icon: Va,
          help: ja,
          type: ao,
          integer: io,
          float: so,
          boolean: no,
          string: ro,
          editable: Wa,
          tooltip: qa,
          visible: Xa,
          displayName: Ka,
          displayOrder: to,
          range: $a,
          rangeStep: Qa,
          slide: Ja,
          disallowAnimation: eo,
          override: oo,
          formerlySerializedAs: La,
          serializable: Na,
        });
      let yo, To;
      function So(t, e) {
        return (e << 3) + t;
      }
      function Eo(t) {
        return bo[t];
      }
      function vo(t) {
        switch (t) {
          case yo.Uint8:
            return Uint8Array;
          case yo.Uint16:
            return Uint16Array;
          case yo.Uint32:
            return Uint32Array;
          case yo.Int8:
            return Int8Array;
          case yo.Int16:
            return Int16Array;
          case yo.Int32:
            return Int32Array;
          case yo.Float32:
            return Float32Array;
          case yo.Float64:
            return Float64Array;
        }
      }
      t("_decorator", go),
        (function (t) {
          (t[(t.Uint8 = 0)] = "Uint8"),
            (t[(t.Uint16 = 1)] = "Uint16"),
            (t[(t.Uint32 = 2)] = "Uint32"),
            (t[(t.Int8 = 3)] = "Int8"),
            (t[(t.Int16 = 4)] = "Int16"),
            (t[(t.Int32 = 5)] = "Int32"),
            (t[(t.Float32 = 6)] = "Float32"),
            (t[(t.Float64 = 7)] = "Float64");
        })(yo || (yo = {})),
        (function (t) {
          (t[(t.Scalar = 0)] = "Scalar"),
            (t[(t.Vec2 = 1)] = "Vec2"),
            (t[(t.Vec3 = 2)] = "Vec3"),
            (t[(t.Vec4 = 3)] = "Vec4"),
            (t[(t.Quat = 4)] = "Quat"),
            (t[(t.Mat4 = 5)] = "Mat4");
        })(To || (To = {})),
        t(
          "CompactValueTypeArray",
          Ca("cc.CompactValueTypeArray")(
            (((fo = class t {
              constructor() {
                (this._byteOffset = uo && uo()),
                  (this._unitCount = _o && _o()),
                  (this._unitElement = po && po()),
                  (this._length = mo && mo());
              }
              static lengthFor(t, e, i) {
                return Eo(e).requiredUnits * t.length * vo(i).BYTES_PER_ELEMENT;
              }
              static compress(e, i, s, n, r, a) {
                const o = Eo(i),
                  h = vo(s),
                  l = o.requiredUnits * e.length,
                  c = new h(n, r, l);
                for (let t = 0; t < e.length; ++t) o.compress(c, t, e[t]);
                const u = new t();
                return (
                  (u._unitElement = So(s, i)),
                  (u._byteOffset = a),
                  (u._unitCount = l),
                  (u._length = e.length),
                  u
                );
              }
              decompress(t) {
                const { storageUnit: e, elementType: i } = {
                  storageUnit: 7 & (s = this._unitElement),
                  elementType: s >> 3,
                };
                var s;
                const n = Eo(i),
                  r = new (vo(e))(t, this._byteOffset, this._unitCount),
                  a = new Array(this._length);
                for (let t = 0; t < this._length; ++t)
                  a[t] = n.decompress(r, t);
                return a;
              }
            }).StorageUnit = yo),
            (fo.ElementType = To),
            (uo = fa((co = fo).prototype, "_byteOffset", [Na], function () {
              return 0;
            })),
            (_o = fa(co.prototype, "_unitCount", [Na], function () {
              return 0;
            })),
            (po = fa(co.prototype, "_unitElement", [Na], function () {
              return So(yo.Uint8, To.Scalar);
            })),
            (mo = fa(co.prototype, "_length", [Na], function () {
              return 0;
            })),
            (lo = co))
          ) || lo
        );
      const bo = {
          [To.Scalar]: {
            requiredUnits: 1,
            compress(t, e, i) {
              t[e] = i;
            },
            decompress: (t, e) => t[e],
          },
          [To.Vec2]: {
            requiredUnits: 2,
            compress(t, e, i) {
              (t[2 * e] = i.x), (t[2 * e + 1] = i.y);
            },
            decompress: (t, e) => new Yi(t[2 * e], t[2 * e + 1]),
          },
          [To.Vec3]: {
            requiredUnits: 3,
            compress(t, e, i) {
              (t[3 * e] = i.x), (t[3 * e + 1] = i.y), (t[3 * e + 2] = i.z);
            },
            decompress: (t, e) => new Yi(t[3 * e], t[3 * e + 1], t[3 * e + 2]),
          },
          [To.Vec4]: {
            requiredUnits: 4,
            compress(t, e, i) {
              (t[4 * e] = i.x),
                (t[4 * e + 1] = i.y),
                (t[4 * e + 2] = i.z),
                (t[4 * e + 3] = i.w);
            },
            decompress: (t, e) =>
              new Wi(t[4 * e], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]),
          },
          [To.Quat]: {
            requiredUnits: 4,
            compress(t, e, i) {
              (t[4 * e] = i.x),
                (t[4 * e + 1] = i.y),
                (t[4 * e + 2] = i.z),
                (t[4 * e + 3] = i.w);
            },
            decompress: (t, e) =>
              new as(t[4 * e], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]),
          },
          [To.Mat4]: {
            requiredUnits: 16,
            compress(t, e, i) {
              ms.toArray(t, i, 16 * e);
            },
            decompress: (t, e) => ms.fromArray(new ms(), t, 16 * e),
          },
        },
        Ao = t("serializeTag", Symbol("[[Serialize]]")),
        Co = t("deserializeTag", Symbol("[[Deserialize]]"));
      function Oo() {
        return 0;
      }
      function Io(t) {
        return t;
      }
      function wo(t) {
        return t * t;
      }
      function Ro(t) {
        return t * (2 - t);
      }
      function Do(t) {
        return (t *= 2) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1);
      }
      function xo(t) {
        return t * t * t;
      }
      function Mo(t) {
        return --t * t * t + 1;
      }
      function Po(t) {
        return (t *= 2) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2);
      }
      function No(t) {
        return t * t * t * t;
      }
      function Lo(t) {
        return 1 - --t * t * t * t;
      }
      function Bo(t) {
        return (t *= 2) < 1
          ? 0.5 * t * t * t * t
          : -0.5 * ((t -= 2) * t * t * t - 2);
      }
      function Fo(t) {
        return t * t * t * t * t;
      }
      function Uo(t) {
        return --t * t * t * t * t + 1;
      }
      function ko(t) {
        return (t *= 2) < 1
          ? 0.5 * t * t * t * t * t
          : 0.5 * ((t -= 2) * t * t * t * t + 2);
      }
      function zo(t) {
        return 1 === t ? 1 : 1 - Math.cos((t * Math.PI) / 2);
      }
      function Ho(t) {
        return Math.sin((t * Math.PI) / 2);
      }
      function Go(t) {
        return 0.5 * (1 - Math.cos(Math.PI * t));
      }
      function Vo(t) {
        return 0 === t ? 0 : 1024 ** (t - 1);
      }
      function jo(t) {
        return 1 === t ? 1 : 1 - 2 ** (-10 * t);
      }
      function Wo(t) {
        return 0 === t
          ? 0
          : 1 === t
          ? 1
          : (t *= 2) < 1
          ? 0.5 * 1024 ** (t - 1)
          : 0.5 * (2 - 2 ** (-10 * (t - 1)));
      }
      function Xo(t) {
        return 1 - Math.sqrt(1 - t * t);
      }
      function Yo(t) {
        return Math.sqrt(1 - --t * t);
      }
      function Ko(t) {
        return (t *= 2) < 1
          ? -0.5 * (Math.sqrt(1 - t * t) - 1)
          : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
      }
      function qo(t) {
        let e,
          i = 0.1;
        return 0 === t
          ? 0
          : 1 === t
          ? 1
          : (!i || i < 1
              ? ((i = 1), (e = 0.1))
              : (e = (0.4 * Math.asin(1 / i)) / (2 * Math.PI)),
            -i *
              2 ** (10 * (t -= 1)) *
              Math.sin((2 * (t - e) * Math.PI) / 0.4));
      }
      function $o(t) {
        let e,
          i = 0.1;
        return 0 === t
          ? 0
          : 1 === t
          ? 1
          : (!i || i < 1
              ? ((i = 1), (e = 0.1))
              : (e = (0.4 * Math.asin(1 / i)) / (2 * Math.PI)),
            i * 2 ** (-10 * t) * Math.sin((2 * (t - e) * Math.PI) / 0.4) + 1);
      }
      function Zo(t) {
        let e,
          i = 0.1;
        return 0 === t
          ? 0
          : 1 === t
          ? 1
          : (!i || i < 1
              ? ((i = 1), (e = 0.1))
              : (e = (0.4 * Math.asin(1 / i)) / (2 * Math.PI)),
            (t *= 2) < 1
              ? i *
                2 ** (10 * (t -= 1)) *
                Math.sin((2 * (t - e) * Math.PI) / 0.4) *
                -0.5
              : i *
                  2 ** (-10 * (t -= 1)) *
                  Math.sin((2 * (t - e) * Math.PI) / 0.4) *
                  0.5 +
                1);
      }
      function Qo(t) {
        if (1 === t) return 1;
        const e = 1.70158;
        return t * t * ((e + 1) * t - e);
      }
      function Jo(t) {
        if (0 === t) return 0;
        const e = 1.70158;
        return --t * t * ((e + 1) * t + e) + 1;
      }
      function th(t) {
        const e = 2.5949095;
        return (t *= 2) < 1
          ? t * t * ((e + 1) * t - e) * 0.5
          : 0.5 * ((t -= 2) * t * ((e + 1) * t + e) + 2);
      }
      function eh(t) {
        return 1 - ih(1 - t);
      }
      function ih(t) {
        return t < 1 / 2.75
          ? 7.5625 * t * t
          : t < 2 / 2.75
          ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75
          : t < 2.5 / 2.75
          ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375
          : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
      }
      function sh(t) {
        return t < 0.5 ? 0.5 * eh(2 * t) : 0.5 * ih(2 * t - 1) + 0.5;
      }
      function nh(t) {
        return t <= 0 ? 0 : t >= 1 ? 1 : t * t * (3 - 2 * t);
      }
      function rh(t) {
        return t <= 0 ? 0 : t >= 1 ? 1 : t * t * t * (t * (6 * t - 15) + 10);
      }
      a._decorator = go;
      const ah = fh(wo, Ro),
        oh = fh(xo, Mo),
        hh = fh(No, Lo),
        lh = fh(Fo, Uo),
        ch = fh(zo, Ho),
        uh = fh(Vo, jo),
        _h = fh(Xo, Yo),
        dh = fh(qo, $o),
        ph = fh(Qo, Jo),
        mh = fh(eh, ih);
      function fh(t, e) {
        return (i) => (i < 0.5 ? e(2 * i) / 2 : t(2 * i - 1) / 2 + 0.5);
      }
      var gh = Object.freeze({
        __proto__: null,
        constant: Oo,
        linear: Io,
        quadIn: wo,
        quadOut: Ro,
        quadInOut: Do,
        cubicIn: xo,
        cubicOut: Mo,
        cubicInOut: Po,
        quartIn: No,
        quartOut: Lo,
        quartInOut: Bo,
        quintIn: Fo,
        quintOut: Uo,
        quintInOut: ko,
        sineIn: zo,
        sineOut: Ho,
        sineInOut: Go,
        expoIn: Vo,
        expoOut: jo,
        expoInOut: Wo,
        circIn: Xo,
        circOut: Yo,
        circInOut: Ko,
        elasticIn: qo,
        elasticOut: $o,
        elasticInOut: Zo,
        backIn: Qo,
        backOut: Jo,
        backInOut: th,
        bounceIn: eh,
        bounceOut: ih,
        bounceInOut: sh,
        smooth: nh,
        fade: rh,
        quadOutIn: ah,
        cubicOutIn: oh,
        quartOutIn: hh,
        quintOutIn: lh,
        sineOutIn: ch,
        expoOutIn: uh,
        circOutIn: _h,
        elasticOutIn: dh,
        backOutIn: ph,
        bounceOutIn: mh,
      });
      let yh;
      t("easing", gh),
        t("EasingMethod", yh),
        (function (t) {
          (t[(t.LINEAR = 0)] = "LINEAR"),
            (t[(t.CONSTANT = 1)] = "CONSTANT"),
            (t[(t.QUAD_IN = 2)] = "QUAD_IN"),
            (t[(t.QUAD_OUT = 3)] = "QUAD_OUT"),
            (t[(t.QUAD_IN_OUT = 4)] = "QUAD_IN_OUT"),
            (t[(t.QUAD_OUT_IN = 5)] = "QUAD_OUT_IN"),
            (t[(t.CUBIC_IN = 6)] = "CUBIC_IN"),
            (t[(t.CUBIC_OUT = 7)] = "CUBIC_OUT"),
            (t[(t.CUBIC_IN_OUT = 8)] = "CUBIC_IN_OUT"),
            (t[(t.CUBIC_OUT_IN = 9)] = "CUBIC_OUT_IN"),
            (t[(t.QUART_IN = 10)] = "QUART_IN"),
            (t[(t.QUART_OUT = 11)] = "QUART_OUT"),
            (t[(t.QUART_IN_OUT = 12)] = "QUART_IN_OUT"),
            (t[(t.QUART_OUT_IN = 13)] = "QUART_OUT_IN"),
            (t[(t.QUINT_IN = 14)] = "QUINT_IN"),
            (t[(t.QUINT_OUT = 15)] = "QUINT_OUT"),
            (t[(t.QUINT_IN_OUT = 16)] = "QUINT_IN_OUT"),
            (t[(t.QUINT_OUT_IN = 17)] = "QUINT_OUT_IN"),
            (t[(t.SINE_IN = 18)] = "SINE_IN"),
            (t[(t.SINE_OUT = 19)] = "SINE_OUT"),
            (t[(t.SINE_IN_OUT = 20)] = "SINE_IN_OUT"),
            (t[(t.SINE_OUT_IN = 21)] = "SINE_OUT_IN"),
            (t[(t.EXPO_IN = 22)] = "EXPO_IN"),
            (t[(t.EXPO_OUT = 23)] = "EXPO_OUT"),
            (t[(t.EXPO_IN_OUT = 24)] = "EXPO_IN_OUT"),
            (t[(t.EXPO_OUT_IN = 25)] = "EXPO_OUT_IN"),
            (t[(t.CIRC_IN = 26)] = "CIRC_IN"),
            (t[(t.CIRC_OUT = 27)] = "CIRC_OUT"),
            (t[(t.CIRC_IN_OUT = 28)] = "CIRC_IN_OUT"),
            (t[(t.CIRC_OUT_IN = 29)] = "CIRC_OUT_IN"),
            (t[(t.ELASTIC_IN = 30)] = "ELASTIC_IN"),
            (t[(t.ELASTIC_OUT = 31)] = "ELASTIC_OUT"),
            (t[(t.ELASTIC_IN_OUT = 32)] = "ELASTIC_IN_OUT"),
            (t[(t.ELASTIC_OUT_IN = 33)] = "ELASTIC_OUT_IN"),
            (t[(t.BACK_IN = 34)] = "BACK_IN"),
            (t[(t.BACK_OUT = 35)] = "BACK_OUT"),
            (t[(t.BACK_IN_OUT = 36)] = "BACK_IN_OUT"),
            (t[(t.BACK_OUT_IN = 37)] = "BACK_OUT_IN"),
            (t[(t.BOUNCE_IN = 38)] = "BOUNCE_IN"),
            (t[(t.BOUNCE_OUT = 39)] = "BOUNCE_OUT"),
            (t[(t.BOUNCE_IN_OUT = 40)] = "BOUNCE_IN_OUT"),
            (t[(t.BOUNCE_OUT_IN = 41)] = "BOUNCE_OUT_IN"),
            (t[(t.SMOOTH = 42)] = "SMOOTH"),
            (t[(t.FADE = 43)] = "FADE");
        })(yh || t("EasingMethod", (yh = {})));
      const Th = {
        [yh.CONSTANT]: Oo,
        [yh.LINEAR]: Io,
        [yh.QUAD_IN]: wo,
        [yh.QUAD_OUT]: Ro,
        [yh.QUAD_IN_OUT]: Do,
        [yh.QUAD_OUT_IN]: ah,
        [yh.CUBIC_IN]: xo,
        [yh.CUBIC_OUT]: Mo,
        [yh.CUBIC_IN_OUT]: Po,
        [yh.CUBIC_OUT_IN]: oh,
        [yh.QUART_IN]: No,
        [yh.QUART_OUT]: Lo,
        [yh.QUART_IN_OUT]: Bo,
        [yh.QUART_OUT_IN]: hh,
        [yh.QUINT_IN]: Fo,
        [yh.QUINT_OUT]: Uo,
        [yh.QUINT_IN_OUT]: ko,
        [yh.QUINT_OUT_IN]: lh,
        [yh.SINE_IN]: zo,
        [yh.SINE_OUT]: Ho,
        [yh.SINE_IN_OUT]: Go,
        [yh.SINE_OUT_IN]: ch,
        [yh.EXPO_IN]: Vo,
        [yh.EXPO_OUT]: jo,
        [yh.EXPO_IN_OUT]: Wo,
        [yh.EXPO_OUT_IN]: uh,
        [yh.CIRC_IN]: Xo,
        [yh.CIRC_OUT]: Yo,
        [yh.CIRC_IN_OUT]: Ko,
        [yh.CIRC_OUT_IN]: _h,
        [yh.ELASTIC_IN]: qo,
        [yh.ELASTIC_OUT]: $o,
        [yh.ELASTIC_IN_OUT]: Zo,
        [yh.ELASTIC_OUT_IN]: dh,
        [yh.BACK_IN]: Qo,
        [yh.BACK_OUT]: Jo,
        [yh.BACK_IN_OUT]: th,
        [yh.BACK_OUT_IN]: ph,
        [yh.BOUNCE_IN]: eh,
        [yh.BOUNCE_OUT]: ih,
        [yh.BOUNCE_IN_OUT]: sh,
        [yh.BOUNCE_OUT_IN]: mh,
        [yh.SMOOTH]: nh,
        [yh.FADE]: rh,
      };
      function Sh(t) {
        return Th[t];
      }
      d(255), d(65280);
      const Eh = (ua.LINEAR << 0) | (da.NONE << 8) | (yh.LINEAR << 16);
      class vh extends ho {
        constructor() {
          super(),
            (this.value = 0),
            (this.rightTangent = 0),
            (this.rightTangentWeight = 0),
            (this.leftTangent = 0),
            (this.leftTangentWeight = 0),
            (this._flags = Eh);
        }
        get interpolationMode() {
          return (255 & this._flags) >> 0;
        }
        set interpolationMode(t) {
          (this._flags &= -256), (this._flags |= t << 0);
        }
        get tangentWeightMode() {
          return (65280 & this._flags) >> 8;
        }
        set tangentWeightMode(t) {
          (this._flags &= -65281), (this._flags |= t << 8);
        }
        get easingMethod() {
          return (16711680 & this._flags) >> 16;
        }
        set easingMethod(t) {
          (this._flags &= -16711681), (this._flags |= t << 16);
        }
      }
      var bh, Ah, Ch, Oh;
      function Ih(t) {
        const e = new vh();
        if ("number" == typeof t) e.value = t;
        else {
          const {
            interpolationMode: i,
            tangentWeightMode: s,
            value: n,
            rightTangent: r,
            rightTangentWeight: a,
            leftTangent: o,
            leftTangentWeight: h,
            easingMethod: l,
            [Kn]: c,
          } = t;
          (e.value = null != n ? n : e.value),
            (e.rightTangent = null != r ? r : e.rightTangent),
            (e.rightTangentWeight = null != a ? a : e.rightTangentWeight),
            (e.leftTangent = null != o ? o : e.leftTangent),
            (e.leftTangentWeight = null != h ? h : e.leftTangentWeight),
            (e.interpolationMode = null != i ? i : e.interpolationMode),
            (e.tangentWeightMode = null != s ? s : e.tangentWeightMode),
            (e.easingMethod = null != l ? l : e.easingMethod),
            c && (e[Kn] = c);
        }
        return e;
      }
      hi.fastDefine("cc.RealKeyframeValue", vh, {
        interpolationMode: ua.LINEAR,
        tangentWeightMode: da.NONE,
        value: 0,
        rightTangent: 0,
        rightTangentWeight: 0,
        leftTangent: 0,
        leftTangentWeight: 0,
        easingMethod: yh.LINEAR,
        [Kn]: void 0,
      }),
        hi.Attr.setClassAttr(vh, Kn, "editorOnly", !0),
        (((bh = vh),
        null !== (Ch = (Ah = bh)[Pa]) && void 0 !== Ch
          ? Ch
          : (Ah[Pa] = {})).uniquelyReferenced = !0);
      class wh extends pa {
        constructor() {
          super(),
            (this.preExtrapolation = _a.CLAMP),
            (this.postExtrapolation = _a.CLAMP);
        }
        evaluate(t) {
          const { _times: e, _values: i } = this,
            s = e.length;
          if (0 === s) return 0;
          const n = e[0],
            r = e[s - 1];
          if (t < n) {
            const { preExtrapolation: a } = this,
              o = i[0];
            if (a === _a.CLAMP || s < 2) return o.value;
            switch (a) {
              case _a.LINEAR:
                return Vh(n, i[0].value, e[1], i[1].value, t);
              case _a.LOOP:
                t = Hh(t, n, r);
                break;
              case _a.PING_PONG:
                t = Gh(t, n, r);
                break;
              default:
                return o.value;
            }
          } else if (t > r) {
            const { postExtrapolation: a } = this,
              o = i[s - 1];
            if (a === _a.CLAMP || s < 2) return o.value;
            switch (a) {
              case _a.LINEAR:
                return Vh(r, o.value, e[s - 2], i[s - 2].value, t);
              case _a.LOOP:
                t = Hh(t, n, r);
                break;
              case _a.PING_PONG:
                t = Gh(t, n, r);
                break;
              default:
                return o.value;
            }
          }
          const a = la(e, t);
          if (a >= 0) return i[a].value;
          const o = ~a,
            h = o - 1,
            l = e[h],
            c = i[h],
            u = e[o];
          return (function (t, e, i, s, n) {
            const r = i - t;
            switch (e.interpolationMode) {
              default:
              case ua.CONSTANT:
                return e.value;
              case ua.LINEAR: {
                const t =
                  e.easingMethod === yh.LINEAR ? n : Sh(e.easingMethod)(n);
                return vi(e.value, s.value, t);
              }
              case ua.CUBIC: {
                const a = 1 / 3,
                  { rightTangent: o, rightTangentWeight: h } = e,
                  l = 0 != (e.tangentWeightMode & da.RIGHT),
                  { leftTangent: c, leftTangentWeight: u } = s,
                  _ = 0 != (s.tangentWeightMode & da.LEFT);
                if (l || _) {
                  let d = 0;
                  if (l) d = h;
                  else {
                    const t = r,
                      e = r * o;
                    d = Math.sqrt(t * t + e * e) * a;
                  }
                  const p = Math.atan(o),
                    m = Math.cos(p) * d + t,
                    f = Math.sin(p) * d + e.value;
                  let g = 0;
                  if (_) g = u;
                  else {
                    const t = r,
                      e = r * c;
                    g = Math.sqrt(t * t + e * e) * a;
                  }
                  const y = Math.atan(c),
                    T = (m - t) / r,
                    S = (-Math.cos(y) * g + i - t) / r,
                    E = f,
                    v = -Math.sin(y) * g + s.value,
                    b = [0, 0, 0],
                    A = (function (t, e, i, s, n) {
                      const r = i / s,
                        a = e / s,
                        o = r * r,
                        h = (1 / 3) * ((-1 / 3) * o + a),
                        l = 0.5 * ((2 / 27) * r * o - (1 / 3) * r * a + t / s),
                        c = h * h * h,
                        u = l * l + c;
                      let _ = 0;
                      if (ma(u)) {
                        if (ma(l)) return (n[0] = 0), 1;
                        {
                          const t = Math.cbrt(-l);
                          return (n[0] = 2 * t), (n[1] = -t), 2;
                        }
                      }
                      if (u < 0) {
                        const t = (1 / 3) * Math.acos(-l / Math.sqrt(-c)),
                          e = 2 * Math.sqrt(-h);
                        (n[0] = e * Math.cos(t)),
                          (n[1] = -e * Math.cos(t + Math.PI / 3)),
                          (n[2] = -e * Math.cos(t - Math.PI / 3)),
                          (_ = 3);
                      } else {
                        const t = Math.sqrt(u),
                          e = Math.cbrt(t - l),
                          i = -Math.cbrt(t + l);
                        (n[0] = e + i), (_ = 1);
                      }
                      const d = (1 / 3) * r;
                      for (let t = 0; t < _; ++t) n[t] -= d;
                      return _;
                    })(0 - n, 3 * T, 3 * S - 6 * T, 3 * (T - S) + 1, b),
                    C = (function (t, e, i) {
                      let s = i;
                      if (1 === e) s = t[0];
                      else {
                        s = -1 / 0;
                        for (let i = 0; i < e; ++i) {
                          const e = t[i];
                          e >= 0 && e <= 1 && e > s && (s = e);
                        }
                        s === -1 / 0 && (s = 0);
                      }
                      return s;
                    })(b, A, n);
                  return jh(e.value, E, v, s.value, C);
                }
                {
                  const t = e.value + a * o * r,
                    i = s.value - a * c * r;
                  return jh(e.value, t, i, s.value, n);
                }
              }
            }
          })(l, c, u, i[o], (t - l) / (u - l));
        }
        addKeyFrame(t, e) {
          return super.addKeyFrame(t, Ih(e));
        }
        assignSorted(t, e) {
          if (void 0 !== e)
            this.setKeyframes(
              t.slice(),
              e.map((t) => Ih(t))
            );
          else {
            const e = Array.from(t);
            this.setKeyframes(
              e.map(([t]) => t),
              e.map(([, t]) => Ih(t))
            );
          }
        }
        isConstant(t) {
          if (this._values.length <= 1) return !0;
          const e = this._values[0].value;
          return this._values.every((i) => Ti(i.value, e, t));
        }
        [Ao](t, e) {
          if (!e.toCCON) return void t.writeThis();
          const { _times: i, _values: s } = this,
            n = i.length,
            r = new DataView(
              new ArrayBuffer(0 + Rh + Rh + Dh + xh * n + Uh * n)
            );
          let a = 0;
          r.setUint8(a, this.preExtrapolation),
            (a += Rh),
            r.setUint8(a, this.postExtrapolation),
            (a += Rh),
            r.setUint32(a, n, !0),
            (a += Dh),
            i.forEach((t, e) => r.setFloat32(a + xh * e, t, !0)),
            (a += xh * n);
          for (const t of s) a = kh(r, t, a);
          const o = new Uint8Array(r.buffer, 0, a);
          t.writeProperty("bytes", o);
          const h = s.map((t) => t[Kn]);
          h.some((t) => void 0 !== t) &&
            t.writeProperty("keyframeValueEditorExtras", h);
        }
        [Co](t, e) {
          if (!e.fromCCON) return void t.readThis();
          const i = t.readProperty("bytes"),
            s = new DataView(i.buffer, i.byteOffset, i.byteLength);
          let n = 0;
          (this.preExtrapolation = s.getUint8(n)),
            (n += Rh),
            (this.postExtrapolation = s.getUint8(n)),
            (n += Rh);
          const r = s.getUint32(n, !0);
          n += Dh;
          const a = Array.from({ length: r }, (t, e) =>
            s.getFloat32(n + xh * e, !0)
          );
          n += xh * r;
          const o = new Array(r);
          for (let t = 0; t < r; ++t) {
            const e = Ih({});
            (n = zh(s, e, n)), (o[t] = e);
          }
          i.byteLength;
          const h = t.readProperty("keyframeValueEditorExtras");
          h && (h.length, h.forEach((t, e) => (o[e][Kn] = t))),
            (this._times = a),
            (this._values = o);
        }
      }
      t("RealCurve", wh),
        hi.fastDefine("cc.RealCurve", wh, {
          _times: [],
          _values: [],
          preExtrapolation: _a.CLAMP,
          postExtrapolation: _a.CLAMP,
        }),
        (function (t) {
          (t[(t.VALUE = 1)] = "VALUE"),
            (t[(t.INTERPOLATION_MODE = 2)] = "INTERPOLATION_MODE"),
            (t[(t.TANGENT_WEIGHT_MODE = 4)] = "TANGENT_WEIGHT_MODE"),
            (t[(t.LEFT_TANGENT = 8)] = "LEFT_TANGENT"),
            (t[(t.LEFT_TANGENT_WEIGHT = 16)] = "LEFT_TANGENT_WEIGHT"),
            (t[(t.RIGHT_TANGENT = 32)] = "RIGHT_TANGENT"),
            (t[(t.RIGHT_TANGENT_WEIGHT = 64)] = "RIGHT_TANGENT_WEIGHT");
        })(Oh || (Oh = {}));
      const Rh = 1,
        Dh = 4,
        xh = 4,
        {
          interpolationMode: Mh,
          tangentWeightMode: Ph,
          leftTangent: Nh,
          leftTangentWeight: Lh,
          rightTangent: Bh,
          rightTangentWeight: Fh,
        } = Ih({}),
        Uh = 26;
      function kh(t, e, i) {
        let s = 0,
          n = i;
        const r = n;
        n += 4;
        const {
          value: a,
          interpolationMode: o,
          tangentWeightMode: h,
          rightTangent: l,
          rightTangentWeight: c,
          leftTangent: u,
          leftTangentWeight: _,
          easingMethod: d,
        } = e;
        return (
          t.setFloat32(n, a, !0),
          (n += 4),
          o !== Mh &&
            ((s |= Oh.INTERPOLATION_MODE), t.setUint8(n, o), (n += 1)),
          h !== Ph &&
            ((s |= Oh.TANGENT_WEIGHT_MODE), t.setUint8(n, h), (n += 1)),
          u !== Nh &&
            ((s |= Oh.LEFT_TANGENT), t.setFloat32(n, u, !0), (n += 4)),
          _ !== Lh &&
            ((s |= Oh.LEFT_TANGENT_WEIGHT), t.setFloat32(n, _, !0), (n += 4)),
          l !== Bh &&
            ((s |= Oh.RIGHT_TANGENT), t.setFloat32(n, l, !0), (n += 4)),
          c !== Fh &&
            ((s |= Oh.RIGHT_TANGENT_WEIGHT), t.setFloat32(n, c, !0), (n += 4)),
          (s |= d << 8),
          t.setUint32(r, s, !0),
          n
        );
      }
      function zh(t, e, i) {
        let s = i;
        const n = t.getUint32(s, !0);
        (s += 4),
          (e.value = t.getFloat32(s, !0)),
          (s += 4),
          n & Oh.INTERPOLATION_MODE &&
            ((e.interpolationMode = t.getUint8(s)), (s += 1)),
          n & Oh.TANGENT_WEIGHT_MODE &&
            ((e.tangentWeightMode = t.getUint8(s)), (s += 1)),
          n & Oh.LEFT_TANGENT &&
            ((e.leftTangent = t.getFloat32(s, !0)), (s += 4)),
          n & Oh.LEFT_TANGENT_WEIGHT &&
            ((e.leftTangentWeight = t.getFloat32(s, !0)), (s += 4)),
          n & Oh.RIGHT_TANGENT &&
            ((e.rightTangent = t.getFloat32(s, !0)), (s += 4)),
          n & Oh.RIGHT_TANGENT_WEIGHT &&
            ((e.rightTangentWeight = t.getFloat32(s, !0)), (s += 4));
        const r = (65280 & n) >> 8;
        return (e.easingMethod = r), s;
      }
      function Hh(t, e, i) {
        return e + Pi(t - e, i - e);
      }
      function Gh(t, e, i) {
        return e + Ni(t - e, i - e);
      }
      function Vh(t, e, i, s, n) {
        return e + ((s - e) / (i - t)) * (n - t);
      }
      function jh(t, e, i, s, n) {
        const r = 1 - n;
        return (
          r * r * r * t + 3 * r * r * n * e + 3 * r * n * n * i + n * n * n * s
        );
      }
      function Wh(t, e, i, s, n) {
        const r = 1 - n;
        return r * (r * (t + (3 * e - t) * n) + 3 * i * n * n) + s * n * n * n;
      }
      a.bezier = Wh;
      const Xh = Math.cos,
        Yh = Math.acos,
        Kh = Math.max,
        qh = 2 * Math.PI,
        $h = Math.sqrt;
      function Zh(t) {
        return t < 0 ? -Math.pow(-t, 1 / 3) : Math.pow(t, 1 / 3);
      }
      function Qh(t, e) {
        const i = (function (t, e) {
            const i = e - 0,
              s = e - t[0],
              n = 3 * i,
              r = 3 * s,
              a = 3 * (e - t[2]),
              o = 1 / (-i + r - a + (e - 1)),
              h = 1 / 3,
              l = (n - 6 * s + a) * o,
              c = l * h,
              u = (-n + r) * o,
              _ = (3 * u - l * l) * h,
              d = _ * h,
              p = (2 * l * l * l - 9 * l * u + i * o * 27) / 27,
              m = p / 2,
              f = m * m + d * d * d;
            let g, y, T, S, E;
            if (f < 0) {
              const t = -_ * h,
                e = $h(t * t * t),
                i = -p / (2 * e),
                s = Yh(i < -1 ? -1 : i > 1 ? 1 : i),
                n = 2 * Zh(e);
              return (
                (T = n * Xh(s * h) - c),
                (S = n * Xh((s + qh) * h) - c),
                (E = n * Xh((s + 2 * qh) * h) - c),
                T >= 0 && T <= 1
                  ? S >= 0 && S <= 1
                    ? E >= 0 && E <= 1
                      ? Kh(T, S, E)
                      : Kh(T, S)
                    : E >= 0 && E <= 1
                    ? Kh(T, E)
                    : T
                  : S >= 0 && S <= 1
                  ? E >= 0 && E <= 1
                    ? Kh(S, E)
                    : S
                  : E
              );
            }
            if (0 === f)
              return (
                (g = m < 0 ? Zh(-m) : -Zh(m)),
                (T = 2 * g - c),
                (S = -g - c),
                T >= 0 && T <= 1 ? (S >= 0 && S <= 1 ? Kh(T, S) : T) : S
              );
            {
              const t = $h(f);
              return (g = Zh(-m + t)), (y = Zh(m + t)), (T = g - y - c), T;
            }
          })(t, e),
          s = t[1];
        return ((1 - i) * (s + (t[3] - s) * i) * 3 + i * i) * i;
      }
      var Jh, tl, el, il, sl, nl, rl, al, ol;
      let hl;
      (a.bezierByTime = Qh),
        t("QuatInterpolationMode", hl),
        (function (t) {
          (t[(t.SLERP = 0)] = "SLERP"), (t[(t.CONSTANT = 1)] = "CONSTANT");
        })(hl || t("QuatInterpolationMode", (hl = {})));
      let ll =
        Ca("cc.QuatKeyframeValue")(
          (Jh =
            Ua(
              ((tl = class {
                constructor({
                  value: t,
                  interpolationMode: e,
                  easingMethod: i,
                } = {}) {
                  (this.interpolationMode = el && el()),
                    (this.value = il && il()),
                    (this.easingMethod = sl && sl()),
                    (this.value = t ? as.clone(t) : this.value),
                    (this.interpolationMode =
                      null != e ? e : this.interpolationMode),
                    (this.easingMethod = null != i ? i : this.easingMethod);
                }
              }),
              (el = fa(tl.prototype, "interpolationMode", [Na], function () {
                return hl.SLERP;
              })),
              (il = fa(tl.prototype, "value", [Na], function () {
                return as.clone(as.IDENTITY);
              })),
              (sl = fa(tl.prototype, "easingMethod", [Na], function () {
                return yh.LINEAR;
              })),
              (Jh = tl))
            ) || Jh)
        ) || Jh;
      function cl(t) {
        return new ll(t);
      }
      let ul = t(
        "QuatCurve",
        Ca("cc.QuatCurve")(
          ((rl = class extends pa {
            constructor() {
              super(),
                (this.preExtrapolation = al && al()),
                (this.postExtrapolation = ol && ol());
            }
            evaluate(t, e) {
              var i;
              (null !== (i = e) && void 0 !== i) || (e = new as());
              const {
                  _times: s,
                  _values: n,
                  postExtrapolation: r,
                  preExtrapolation: a,
                } = this,
                o = s.length;
              if (0 === o) return e;
              const h = s[0],
                l = s[o - 1];
              if (t < h) {
                const i = n[0];
                switch (a) {
                  case _a.LOOP:
                    t = h + Pi(t - h, l - h);
                    break;
                  case _a.PING_PONG:
                    t = h + Ni(t - h, l - h);
                    break;
                  case _a.CLAMP:
                  default:
                    return as.copy(e, i.value);
                }
              } else if (t > l) {
                const i = n[o - 1];
                switch (r) {
                  case _a.LOOP:
                    t = h + Pi(t - h, l - h);
                    break;
                  case _a.PING_PONG:
                    t = h + Ni(t - h, l - h);
                    break;
                  case _a.CLAMP:
                  default:
                    return as.copy(e, i.value);
                }
              }
              const c = la(s, t);
              if (c >= 0) return as.copy(e, n[c].value);
              const u = ~c,
                _ = u - 1,
                d = s[_],
                p = n[_],
                m = s[u],
                f = n[u],
                g = (t - d) / (m - d);
              switch (p.interpolationMode) {
                default:
                case hl.CONSTANT:
                  return as.copy(e, p.value);
                case hl.SLERP: {
                  const { easingMethod: t } = p,
                    i =
                      t === yh.LINEAR
                        ? g
                        : Array.isArray(t)
                        ? Qh(t, g)
                        : Sh(t)(g);
                  return as.slerp(e, p.value, f.value, i);
                }
              }
            }
            addKeyFrame(t, e) {
              const i = new ll(e);
              return super.addKeyFrame(t, i);
            }
            assignSorted(t, e) {
              if (void 0 !== e)
                this.setKeyframes(
                  t.slice(),
                  e.map((t) => cl(t))
                );
              else {
                const e = Array.from(t);
                this.setKeyframes(
                  e.map(([t]) => t),
                  e.map(([, t]) => cl(t))
                );
              }
            }
            [Ao](t, e) {
              if (!e.toCCON) return void t.writeThis();
              const { _times: i, _values: s } = this;
              let n = !0;
              s.forEach((t, e, [i]) => {
                n && t.interpolationMode !== i.interpolationMode && (n = !1);
              });
              const r = i.length,
                a = gl * (n ? 1 : r),
                o = s.reduce(
                  (t, { easingMethod: e }) =>
                    t + (Array.isArray(e) ? yl + 4 * Sl : yl),
                  0
                );
              let h = 0;
              h += dl + pl + ml * r + 4 * fl * r + o + a + 0;
              const l = new DataView(new ArrayBuffer(h));
              let c = 0,
                u = 0;
              n && (u |= _l.INTERPOLATION_MODE),
                l.setUint32(c, u, !0),
                (c += dl),
                l.setUint32(c, r, !0),
                (c += pl),
                i.forEach((t, e) => l.setFloat32(c + ml * e, t, !0)),
                (c += ml * r),
                s.forEach(({ value: { x: t, y: e, z: i, w: s } }, n) => {
                  const r = c + 4 * fl * n;
                  l.setFloat32(r + 0 * fl, t, !0),
                    l.setFloat32(r + 1 * fl, e, !0),
                    l.setFloat32(r + 2 * fl, i, !0),
                    l.setFloat32(r + 3 * fl, s, !0);
                }),
                (c += 4 * fl * r),
                s.forEach(({ easingMethod: t }) => {
                  Array.isArray(t)
                    ? (l.setUint8(c, Tl),
                      ++c,
                      l.setFloat32(c + 0 * Sl, t[0], !0),
                      l.setFloat32(c + 1 * Sl, t[1], !0),
                      l.setFloat32(c + 2 * Sl, t[2], !0),
                      l.setFloat32(c + 3 * Sl, t[3], !0),
                      (c += 4 * Sl))
                    : (l.setUint8(c, t), ++c);
                });
              const _ = c;
              c += a;
              let d = _;
              s.forEach(({ interpolationMode: t }) => {
                l.setUint8(d, t), n || (d += gl);
              });
              const p = new Uint8Array(l.buffer);
              t.writeProperty("bytes", p);
            }
            [Co](t, e) {
              if (!e.fromCCON) return void t.readThis();
              const i = t.readProperty("bytes"),
                s = new DataView(i.buffer, i.byteOffset, i.byteLength);
              let n = 0;
              const r = s.getUint32(n, !0);
              n += dl;
              const a = r & _l.INTERPOLATION_MODE,
                o = s.getUint32(n, !0);
              n += pl;
              const h = Array.from({ length: o }, (t, e) =>
                s.getFloat32(n + ml * e, !0)
              );
              n += ml * o;
              const l = n;
              n += 4 * fl * o;
              const c = Array.from({ length: o }, (t, e) => {
                const i = l + 4 * fl * e,
                  r = s.getFloat32(i + 0 * fl, !0),
                  a = s.getFloat32(i + 1 * fl, !0),
                  o = s.getFloat32(i + 2 * fl, !0),
                  h = s.getFloat32(i + 3 * fl, !0),
                  c = s.getUint8(n);
                ++n;
                const u = cl({ value: { x: r, y: a, z: o, w: h } });
                return (
                  c !== Tl
                    ? (u.easingMethod = c)
                    : ((u.easingMethod = [
                        s.getFloat32(n + 0 * Sl, !0),
                        s.getFloat32(n + 1 * Sl, !0),
                        s.getFloat32(n + 2 * Sl, !0),
                        s.getFloat32(n + 3 * Sl, !0),
                      ]),
                      (n += 4 * Sl)),
                  u
                );
              });
              if (a) {
                const t = s.getUint8(n);
                ++n;
                for (let e = 0; e < o; ++e) c[e].interpolationMode = t;
              } else {
                for (let t = 0; t < o; ++t) {
                  const e = s.getUint8(n + t);
                  c[t].interpolationMode = e;
                }
                n += o;
              }
              (this._times = h), (this._values = c);
            }
          }),
          (al = fa(rl.prototype, "preExtrapolation", [Na], function () {
            return _a.CLAMP;
          })),
          (ol = fa(rl.prototype, "postExtrapolation", [Na], function () {
            return _a.CLAMP;
          })),
          (nl = rl))
        ) || nl
      );
      var _l;
      !(function (t) {
        t[(t.INTERPOLATION_MODE = 1)] = "INTERPOLATION_MODE";
      })(_l || (_l = {}));
      const dl = 1,
        pl = 4,
        ml = 4,
        fl = 4,
        gl = 1,
        yl = 1,
        Tl = 255,
        Sl = 4;
      var El;
      let vl = t(
        "ObjectCurve",
        Ca("cc.ObjectCurve")(
          (El = class extends pa {
            evaluate(t) {
              const e = this.searchKeyframe(t);
              if (e >= 0) return this._values[e];
              const i = Si(~e - 1, 0, this._values.length - 1);
              return this._values[i];
            }
          })
        ) || El
      );
      const bl = ce({ Blend: 0, Fixed: 1 });
      class Al {
        constructor() {
          (this.color = Qi.WHITE.clone()), (this.time = 0);
        }
      }
      t("ColorKey", Al),
        hi.fastDefine("cc.ColorKey", Al, { color: Qi.WHITE.clone(), time: 0 }),
        hi.Attr.setClassAttr(Al, "color", "visible", !0),
        hi.Attr.setClassAttr(Al, "time", "visible", !0);
      class Cl {
        constructor() {
          (this.alpha = 1), (this.time = 0);
        }
      }
      t("AlphaKey", Cl),
        hi.fastDefine("cc.AlphaKey", Cl, { alpha: 1, time: 0 }),
        hi.Attr.setClassAttr(Cl, "alpha", "visible", !0),
        hi.Attr.setClassAttr(Cl, "time", "visible", !0);
      class Ol {
        constructor() {
          (this.colorKeys = []), (this.alphaKeys = []), (this.mode = bl.Blend);
        }
        setKeys(t, e) {
          (this.colorKeys = t), (this.alphaKeys = e);
        }
        sortKeys() {
          this.colorKeys.length > 1 &&
            this.colorKeys.sort((t, e) => t.time - e.time),
            this.alphaKeys.length > 1 &&
              this.alphaKeys.sort((t, e) => t.time - e.time);
        }
        evaluate(t) {
          return this.evaluateFast(new Qi(), t);
        }
        evaluateFast(t, e) {
          return this.getRGB(t, e), (t.a = this.getAlpha(e)), t;
        }
        randomColor() {
          return this.getRandomColor(new Qi());
        }
        getRandomColor(t) {
          const e = this.colorKeys[Math.trunc(Ci() * this.colorKeys.length)],
            i = this.alphaKeys[Math.trunc(Ci() * this.alphaKeys.length)];
          return t.set(e.color), (t.a = i.alpha), t;
        }
        getRGB(t, e) {
          const i = this.colorKeys,
            s = i.length;
          if (s > 1) {
            e = Pi(e, 1 + gi);
            for (let n = 1; n < s; ++n) {
              const s = i[n - 1].time,
                r = i[n].time;
              if (e >= s && e < r) {
                if (this.mode === bl.Fixed) return Qi.copy(t, i[n].color), t;
                const a = (e - s) / (r - s);
                return Qi.lerp(t, i[n - 1].color, i[n].color, a), t;
              }
            }
            const n = s - 1;
            Ti(e, i[n].time, gi)
              ? Qi.copy(t, i[n].color)
              : e < i[0].time
              ? Qi.lerp(t, Qi.BLACK, i[0].color, e / i[0].time)
              : e > i[n].time &&
                Qi.lerp(
                  t,
                  i[n].color,
                  Qi.BLACK,
                  (e - i[n].time) / (1 - i[n].time)
                );
          } else 1 === s ? Qi.copy(t, i[0].color) : Qi.copy(t, Qi.WHITE);
          return t;
        }
        getAlpha(t) {
          const e = this.alphaKeys,
            i = e.length;
          if (i > 1) {
            t = Pi(t, 1 + gi);
            for (let s = 1; s < i; ++s) {
              const i = e[s - 1].time,
                n = e[s].time;
              if (t >= i && t < n) {
                if (this.mode === bl.Fixed) return e[s].alpha;
                const r = (t - i) / (n - i);
                return vi(e[s - 1].alpha, e[s].alpha, r);
              }
            }
            const s = i - 1;
            return Ti(t, e[s].time, gi)
              ? e[s].alpha
              : t < e[0].time
              ? vi(0, e[0].alpha, t / e[0].time)
              : t > e[s].time
              ? vi(e[s].alpha, 0, (t - e[s].time) / (1 - e[s].time))
              : 255;
          }
          return 1 === i ? e[0].alpha : 255;
        }
      }
      t("Gradient", Ol),
        (Ol.Mode = bl),
        hi.fastDefine("cc.Gradient", Ol, {
          colorKeys: [],
          alphaKeys: [],
          mode: bl.Blend,
        }),
        hi.Attr.setClassAttr(Ol, "colorKeys", "visible", !0),
        hi.Attr.setClassAttr(Ol, "alphaKeys", "visible", !0),
        hi.Attr.setClassAttr(Ol, "mode", "visible", !0);
      class Il {
        constructor() {
          (this.time = 0),
            (this.value = 0),
            (this.inTangent = 0),
            (this.outTangent = 0);
        }
      }
      hi.fastDefine("cc.Keyframe", Il, {
        time: 0,
        value: 0,
        inTangent: 0,
        outTangent: 0,
      });
      class wl {
        constructor() {
          (this.index = void 0),
            (this.time = void 0),
            (this.endTime = void 0),
            (this.coefficient = void 0),
            (this.index = -1),
            (this.time = 0),
            (this.endTime = 0),
            (this.coefficient = new Float32Array(4));
        }
        evaluate(t) {
          return Rl(t - this.time, this.coefficient);
        }
      }
      function Rl(t, e) {
        return t * (t * (t * e[0] + e[1]) + e[2]) + e[3];
      }
      class Dl {
        get _internalCurve() {
          return this._curve;
        }
        get keyFrames() {
          return Array.from(this._curve.keyframes()).map(([t, e]) => {
            const i = new Il();
            return (
              (i.time = t),
              (i.value = e.value),
              (i.inTangent = e.leftTangent),
              (i.outTangent = e.rightTangent),
              i
            );
          });
        }
        set keyFrames(t) {
          this._curve.assignSorted(
            t.map((t) => [
              t.time,
              {
                interpolationMode: ua.CUBIC,
                value: t.value,
                leftTangent: t.inTangent,
                rightTangent: t.outTangent,
              },
            ])
          );
        }
        get preWrapMode() {
          return Nl(this._curve.preExtrapolation);
        }
        set preWrapMode(t) {
          this._curve.preExtrapolation = Pl(t);
        }
        get postWrapMode() {
          return Nl(this._curve.postExtrapolation);
        }
        set postWrapMode(t) {
          this._curve.postExtrapolation = Pl(t);
        }
        constructor(t = null) {
          if (
            ((this._curve = void 0), (this.cachedKey = void 0), t instanceof wh)
          )
            this._curve = t;
          else {
            const e = new wh();
            (this._curve = e),
              (e.preExtrapolation = _a.LOOP),
              (e.postExtrapolation = _a.CLAMP),
              t
                ? e.assignSorted(
                    t.map((t) => [
                      t.time,
                      {
                        interpolationMode: ua.CUBIC,
                        value: t.value,
                        leftTangent: t.inTangent,
                        rightTangent: t.outTangent,
                      },
                    ])
                  )
                : e.assignSorted([
                    [0, { interpolationMode: ua.CUBIC, value: 1 }],
                    [1, { interpolationMode: ua.CUBIC, value: 1 }],
                  ]);
          }
          this.cachedKey = new wl();
        }
        addKey(t) {
          t
            ? this._curve.addKeyFrame(t.time, {
                interpolationMode: ua.CUBIC,
                value: t.value,
                leftTangent: t.inTangent,
                rightTangent: t.outTangent,
              })
            : this._curve.clear();
        }
        evaluate_slow(t) {
          return this._curve.evaluate(t);
        }
        evaluate(t) {
          const { cachedKey: e, _curve: i } = this,
            s = i.keyFramesCount - 1;
          let n = t;
          const r = t < 0 ? i.preExtrapolation : i.postExtrapolation,
            a = i.getKeyframeTime(0),
            o = i.getKeyframeTime(s);
          switch (r) {
            case _a.LOOP:
              n = Pi(t - a, o - a) + a;
              break;
            case _a.PING_PONG:
              n = Ni(t - a, o - a) + a;
              break;
            case _a.CLAMP:
            default:
              n = Si(t, a, o);
          }
          if (n >= e.time && n < e.endTime) return e.evaluate(n);
          const h = this.findIndex(e, n),
            l = Math.min(h + 1, s);
          return this.calcOptimizedKey(e, h, l), e.evaluate(n);
        }
        calcOptimizedKey(t, e, i) {
          const s = this._curve.getKeyframeTime(e),
            n = this._curve.getKeyframeTime(i),
            { value: r, leftTangent: a } = this._curve.getKeyframeValue(e),
            { value: o, rightTangent: h } = this._curve.getKeyframeValue(i);
          (t.index = e), (t.time = s), (t.endTime = n);
          const l = n - s,
            c = o - r,
            u = 1 / (l * l),
            _ = a * l,
            d = h * l;
          (t.coefficient[0] = ((_ + d - c - c) * u) / l),
            (t.coefficient[1] = (c + c + c - _ - _ - d) * u),
            (t.coefficient[2] = a),
            (t.coefficient[3] = r);
        }
        findIndex(t, e) {
          const { _curve: i } = this,
            s = i.keyFramesCount,
            n = t.index;
          if (-1 !== n)
            if (e > i.getKeyframeTime(n))
              for (let t = 0; t < 3; t++) {
                const r = n + t;
                if (r + 1 < s && i.getKeyframeTime(r + 1) > e) return r;
              }
            else
              for (let t = 0; t < 3; t++) {
                const s = n - t;
                if (s >= 0 && i.getKeyframeTime(s - 1) <= e) return s - 1;
              }
          let r,
            a = 0,
            o = s;
          for (; o - a > 1; )
            (r = Math.floor((a + o) / 2)),
              i.getKeyframeTime(r) >= e ? (o = r) : (a = r);
          return a;
        }
      }
      let xl, Ml;
      function Pl(t) {
        switch (t) {
          default:
          case xl.Default:
          case xl.Normal:
          case xl.Clamp:
            return _a.CLAMP;
          case xl.PingPong:
            return _a.PING_PONG;
          case xl.Loop:
            return _a.LOOP;
        }
      }
      function Nl(t) {
        switch (t) {
          default:
          case _a.LINEAR:
          case _a.CLAMP:
            return xl.Clamp;
          case _a.PING_PONG:
            return xl.PingPong;
          case _a.LOOP:
            return xl.Loop;
        }
      }
      function Ll() {
        const t = new wh();
        return (
          t.assignSorted([
            [0, { interpolationMode: ua.CUBIC, value: 1 }],
            [1, { interpolationMode: ua.CUBIC, value: 1 }],
          ]),
          t
        );
      }
      (Dl.defaultKF = [
        { time: 0, value: 1, inTangent: 0, outTangent: 0 },
        { time: 1, value: 1, inTangent: 0, outTangent: 0 },
      ]),
        hi.fastDefine("cc.AnimationCurve", Dl, { _curve: null }),
        (function (t) {
          (t[(t.Default = 0)] = "Default"),
            (t[(t.Normal = 1)] = "Normal"),
            (t[(t.Loop = 2)] = "Loop"),
            (t[(t.ShouldWrap = 4)] = "ShouldWrap"),
            (t[(t.Clamp = 8)] = "Clamp"),
            (t[(t.PingPong = 22)] = "PingPong"),
            (t[(t.Reverse = 36)] = "Reverse");
        })(xl || (xl = {})),
        (function (t) {
          (t[(t.LINEAR = 0)] = "LINEAR"),
            (t[(t.BEZIER = 1)] = "BEZIER"),
            (t[(t.CATMULL_ROM = 2)] = "CATMULL_ROM");
        })(Ml || (Ml = {}));
      const Bl = new Yi(),
        Fl = new Yi(),
        Ul = new Yi(),
        kl = new Yi();
      class zl {
        constructor(t = Ml.CATMULL_ROM, e = []) {
          (this._type = void 0),
            (this._mode = Ml.CATMULL_ROM),
            (this._knots = []),
            (this._type = Ys.SHAPE_SPLINE),
            (this._mode = t);
          for (let t = 0; t < e.length; t++) this._knots[t] = new Yi(e[t]);
        }
        static create(t, e = []) {
          return new zl(t, e);
        }
        static clone(t) {
          return new zl(t.mode, t.knots);
        }
        static copy(t, e) {
          (t._mode = e.mode), (t._knots.length = 0);
          const i = e.knots,
            s = i.length;
          for (let e = 0; e < s; e++) t._knots[e] = new Yi(i[e]);
          return t;
        }
        get type() {
          return this._type;
        }
        get mode() {
          return this._mode;
        }
        get knots() {
          return this._knots;
        }
        setModeAndKnots(t, e) {
          (this._mode = t), (this._knots.length = 0);
          for (let t = 0; t < e.length; t++) this._knots[t] = new Yi(e[t]);
        }
        clearKnots() {
          this._knots.length = 0;
        }
        getKnotCount() {
          return this._knots.length;
        }
        addKnot(t) {
          this._knots.push(new Yi(t));
        }
        insertKnot(t, e) {
          const i = new Yi(e);
          t >= this._knots.length
            ? this._knots.push(i)
            : this._knots.splice(t, 0, i);
        }
        removeKnot(t) {
          t >= 0 && this._knots.length, this._knots.splice(t, 1);
        }
        setKnot(t, e) {
          t >= 0 && this._knots.length, this._knots[t].set(e);
        }
        getKnot(t) {
          return t >= 0 && this._knots.length, this._knots[t];
        }
        getPoint(t, e = 4294967295) {
          t = Si(t, 0, 1);
          const i = this.getSegments();
          if (0 === i) return new Yi(0, 0, 0);
          if (4294967295 === e) {
            const s = 1 / i;
            (e = Math.floor(t / s)), (t = (t % s) / s);
          }
          if (e >= i) return new Yi(this._knots[this._knots.length - 1]);
          switch (this._mode) {
            case Ml.LINEAR:
              return zl.calcLinear(this._knots[e], this._knots[e + 1], t);
            case Ml.BEZIER:
              return zl.calcBezier(
                this._knots[4 * e],
                this._knots[4 * e + 1],
                this._knots[4 * e + 2],
                this._knots[4 * e + 3],
                t
              );
            case Ml.CATMULL_ROM: {
              const i = e > 0 ? this._knots[e - 1] : this._knots[e],
                s =
                  e + 2 < this._knots.length
                    ? this._knots[e + 2]
                    : this._knots[e + 1];
              return zl.calcCatmullRom(
                i,
                this._knots[e],
                this._knots[e + 1],
                s,
                t
              );
            }
            default:
              return new Yi(0, 0, 0);
          }
        }
        getPoints(t, e = 4294967295) {
          if (0 === t) return [];
          if (1 === t) return [this.getPoint(0, e)];
          const i = [],
            s = 1 / (t - 1);
          for (let n = 0; n < t; n++) {
            const t = n * s,
              r = this.getPoint(t, e);
            i.push(r);
          }
          return i;
        }
        getSegments() {
          const t = this._knots.length;
          switch (this._mode) {
            case Ml.LINEAR:
            case Ml.CATMULL_ROM:
              return t < 2 ? (z(14300), 0) : t - 1;
            case Ml.BEZIER:
              return t < 4 || t % 4 != 0 ? (z(14301), 0) : t / 4;
          }
        }
        static calcLinear(t, e, i) {
          const s = new Yi();
          return (
            Yi.multiplyScalar(Bl, t, 1 - i),
            Yi.multiplyScalar(Fl, e, i),
            Yi.add(s, Bl, Fl),
            s
          );
        }
        static calcBezier(t, e, i, s, n) {
          const r = new Yi(),
            a = 1 - n;
          return (
            Yi.multiplyScalar(Bl, t, a * a * a),
            Yi.multiplyScalar(Fl, e, 3 * n * a * a),
            Yi.multiplyScalar(Ul, i, 3 * n * n * a),
            Yi.multiplyScalar(kl, s, n * n * n),
            Yi.add(Bl, Bl, Fl),
            Yi.add(Ul, Ul, kl),
            Yi.add(r, Bl, Ul),
            r
          );
        }
        static calcCatmullRom(t, e, i, s, n) {
          const r = new Yi(),
            a = n * n,
            o = a * n;
          return (
            Yi.multiplyScalar(Bl, t, -0.5 * o + a - 0.5 * n),
            Yi.multiplyScalar(Fl, e, 1.5 * o - 2.5 * a + 1),
            Yi.multiplyScalar(Ul, i, -1.5 * o + 2 * a + 0.5 * n),
            Yi.multiplyScalar(kl, s, 0.5 * o - 0.5 * a),
            Yi.add(Bl, Bl, Fl),
            Yi.add(Ul, Ul, kl),
            Yi.add(r, Bl, Ul),
            r
          );
        }
      }
      let Hl;
      function Gl(t, e) {
        w(`${t} is deprecated, please use ${e} instead.`);
      }
      !(function (t) {
        (t[(t.ALL = 0)] = "ALL"),
          (t[(t.CLOSEST = 1)] = "CLOSEST"),
          (t[(t.ANY = 2)] = "ANY");
      })(Hl || (Hl = {})),
        $(Bn, "intersect", [
          { name: "ray_aabb", newName: "rayAABB" },
          { name: "ray_plane", newName: "rayPlane" },
          { name: "ray_triangle", newName: "rayTriangle" },
          { name: "ray_sphere", newName: "raySphere" },
          { name: "ray_obb", newName: "rayOBB" },
          { name: "ray_capsule", newName: "rayCapsule" },
          { name: "ray_subMesh", newName: "raySubMesh" },
          { name: "ray_mesh", newName: "rayMesh" },
          { name: "ray_model", newName: "rayModel" },
          { name: "line_plane", newName: "linePlane" },
          { name: "line_triangle", newName: "lineTriangle" },
          { name: "line_aabb", newName: "lineAABB" },
          { name: "line_obb", newName: "lineOBB" },
          { name: "line_sphere", newName: "lineSphere" },
          { name: "aabb_aabb", newName: "aabbWithAABB" },
          { name: "aabb_obb", newName: "aabbWithOBB" },
          { name: "aabb_plane", newName: "aabbPlane" },
          { name: "aabb_frustum", newName: "aabbFrustum" },
          { name: "aabbFrustum_accurate", newName: "aabbFrustumAccurate" },
          { name: "obb_point", newName: "obbPoint" },
          { name: "obb_plane", newName: "obbPlane" },
          { name: "obb_frustum", newName: "obbFrustum" },
          { name: "obbFrustum_accurate", newName: "obbFrustumAccurate" },
          { name: "obb_obb", newName: "obbWithOBB" },
          { name: "obb_capsule", newName: "obbCapsule" },
          { name: "sphere_plane", newName: "spherePlane" },
          { name: "sphere_frustum", newName: "sphereFrustum" },
          { name: "sphereFrustum_accurate", newName: "sphereFrustumAccurate" },
          { name: "sphere_sphere", newName: "sphereWithSphere" },
          { name: "sphere_aabb", newName: "sphereAABB" },
          { name: "sphere_obb", newName: "sphereOBB" },
          { name: "sphere_capsule", newName: "sphereCapsule" },
          { name: "capsule_capsule", newName: "capsuleWithCapsule" },
        ]);
      var Vl = Object.freeze({
        __proto__: null,
        distance: Xs,
        enums: Ys,
        intersect: Bn,
        Line: Ks,
        Plane: Hn,
        Ray: qs,
        Triangle: Gn,
        Sphere: en,
        AABB: Kr,
        OBB: ha,
        Capsule: qr,
        Frustum: ta,
        Keyframe: Il,
        AnimationCurve: Dl,
        get WrapModeMask() {
          return xl;
        },
        get SplineMode() {
          return Ml;
        },
        Spline: zl,
        constructLegacyCurveAndConvert: Ll,
        OptimizedKey: wl,
        evalOptCurve: Rl,
        get ERaycastMode() {
          return Hl;
        },
        line: class extends Ks {
          constructor() {
            super(), Gl("line", "Line");
          }
        },
        plane: class extends Hn {
          constructor() {
            super(), Gl("plane", "Plane");
          }
        },
        ray: class extends qs {
          constructor() {
            super(), Gl("ray", "Ray");
          }
        },
        triangle: class extends Gn {
          constructor() {
            super(), Gl("triangle", "Triangle");
          }
        },
        sphere: class extends en {
          constructor() {
            super(), Gl("sphere", "Sphere");
          }
        },
        aabb: class extends Kr {
          constructor() {
            super(), Gl("aabb", "AABB");
          }
        },
        obb: class extends ha {
          constructor() {
            super(), Gl("obb", "OBB");
          }
        },
        capsule: class extends qr {
          constructor() {
            super(), Gl("capsule", "Capsule");
          }
        },
        frustum: class extends ta {
          constructor() {
            super(), Gl("frustum", "Frustum");
          }
        },
      });
      t("geometry", Vl);
      class jl {
        constructor() {
          (this._id = ""), (this._priority = 0), (this._executeInEditMode = !1);
        }
        set priority(t) {
          this._priority = t;
        }
        get priority() {
          return this._priority;
        }
        set id(t) {
          this._id = t;
        }
        get id() {
          return this._id;
        }
        static sortByPriority(t, e) {
          return t._priority < e._priority
            ? 1
            : t._priority > e.priority
            ? -1
            : 0;
        }
        init() {}
        update(t) {}
        postUpdate(t) {}
        destroy() {}
      }
      t("System", jl),
        (jl.Priority = ce({
          LOW: 0,
          MEDIUM: 100,
          HIGH: 200,
          SCHEDULER: (1 << 31) >>> 0,
        }));
      const Wl = new lt("Scheduler");
      class Xl {
        static get(t, e, i, s) {
          let n = Xl._listEntries.pop();
          return (
            n
              ? ((n.target = t),
                (n.priority = e),
                (n.paused = i),
                (n.markedForDeletion = s))
              : (n = new Xl(t, e, i, s)),
            n
          );
        }
        static put(t) {
          Xl._listEntries.length < 20 &&
            ((t.target = null), Xl._listEntries.push(t));
        }
        constructor(t, e, i, s) {
          (this.target = void 0),
            (this.priority = void 0),
            (this.paused = void 0),
            (this.markedForDeletion = void 0),
            (this.target = t),
            (this.priority = e),
            (this.paused = i),
            (this.markedForDeletion = s);
        }
      }
      Xl._listEntries = [];
      class Yl {
        static get(t, e, i, s) {
          let n = Yl._hashUpdateEntries.pop();
          return (
            n
              ? ((n.list = t), (n.entry = e), (n.target = i), (n.callback = s))
              : (n = new Yl(t, e, i, s)),
            n
          );
        }
        static put(t) {
          Yl._hashUpdateEntries.length < 20 &&
            ((t.list = t.entry = t.target = t.callback = null),
            Yl._hashUpdateEntries.push(t));
        }
        constructor(t, e, i, s) {
          (this.list = void 0),
            (this.entry = void 0),
            (this.target = void 0),
            (this.callback = void 0),
            (this.list = t),
            (this.entry = e),
            (this.target = i),
            (this.callback = s);
        }
      }
      Yl._hashUpdateEntries = [];
      class Kl {
        static get(t, e, i, s, n, r) {
          let a = Kl._hashTimerEntries.pop();
          return (
            a
              ? ((a.timers = t),
                (a.target = e),
                (a.timerIndex = i),
                (a.currentTimer = s),
                (a.currentTimerSalvaged = n),
                (a.paused = r))
              : (a = new Kl(t, e, i, s, n, r)),
            a
          );
        }
        static put(t) {
          Kl._hashTimerEntries.length < 20 &&
            ((t.timers = t.target = t.currentTimer = null),
            Kl._hashTimerEntries.push(t));
        }
        constructor(t, e, i, s, n, r) {
          (this.timers = void 0),
            (this.target = void 0),
            (this.timerIndex = void 0),
            (this.currentTimer = void 0),
            (this.currentTimerSalvaged = void 0),
            (this.paused = void 0),
            (this.timers = t),
            (this.target = e),
            (this.timerIndex = i),
            (this.currentTimer = s),
            (this.currentTimerSalvaged = n),
            (this.paused = r);
        }
      }
      Kl._hashTimerEntries = [];
      class ql {
        static get() {
          return ql._timers.pop() || new ql();
        }
        static put(t) {
          ql._timers.length < 20 &&
            !t._lock &&
            ((t._scheduler = t._target = t._callback = null),
            ql._timers.push(t));
        }
        constructor() {
          (this._lock = void 0),
            (this._scheduler = void 0),
            (this._elapsed = void 0),
            (this._runForever = void 0),
            (this._useDelay = void 0),
            (this._timesExecuted = void 0),
            (this._repeat = void 0),
            (this._delay = void 0),
            (this._interval = void 0),
            (this._target = void 0),
            (this._callback = void 0),
            (this._lock = !1),
            (this._scheduler = null),
            (this._elapsed = -1),
            (this._runForever = !1),
            (this._useDelay = !1),
            (this._timesExecuted = 0),
            (this._repeat = 0),
            (this._delay = 0),
            (this._interval = 0),
            (this._target = null);
        }
        initWithCallback(t, e, i, s, n, r) {
          return (
            (this._lock = !1),
            (this._scheduler = t),
            (this._target = i),
            (this._callback = e),
            (this._timesExecuted = 0),
            (this._elapsed = -1),
            (this._interval = s),
            (this._delay = r),
            (this._useDelay = this._delay > 0),
            (this._repeat = n),
            (this._runForever = this._repeat === a.macro.REPEAT_FOREVER),
            !0
          );
        }
        getInterval() {
          return this._interval;
        }
        setInterval(t) {
          this._interval = t;
        }
        update(t) {
          -1 === this._elapsed
            ? ((this._elapsed = 0), (this._timesExecuted = 0))
            : ((this._elapsed += t),
              this._runForever && !this._useDelay
                ? this._elapsed >= this._interval &&
                  (this.trigger(), (this._elapsed = 0))
                : (this._useDelay
                    ? this._elapsed >= this._delay &&
                      (this.trigger(),
                      (this._elapsed -= this._delay),
                      (this._timesExecuted += 1),
                      (this._useDelay = !1))
                    : this._elapsed >= this._interval &&
                      (this.trigger(),
                      (this._elapsed = 0),
                      (this._timesExecuted += 1)),
                  this._callback &&
                    !this._runForever &&
                    this._timesExecuted > this._repeat &&
                    this.cancel()));
        }
        getCallback() {
          return this._callback;
        }
        trigger() {
          if (this._target && this._callback) {
            var t;
            if (
              this._lock &&
              !this._repeat &&
              window.OnJSException instanceof Function
            )
              return void window.OnJSException(
                "CallbackTimer::trigger",
                "non repeating timer triggered while executing",
                null !== (t = this._target.name) && void 0 !== t
                  ? t
                  : "(no name)"
              );
            (this._lock = !0),
              this._callback.call(this._target, this._elapsed),
              (this._lock = !1);
          }
        }
        cancel() {
          this._scheduler &&
            this._callback &&
            this._target &&
            this._scheduler.unscheduleForTimer(this, this._target);
        }
      }
      ql._timers = [];
      class $l extends jl {
        static enableForTarget(t) {
          let e = !1;
          (t.uuid || t.id) && (e = !0), e || (t.id = Wl.getNewId());
        }
        constructor() {
          super(),
            (this._timeScale = void 0),
            (this._updatesNegList = void 0),
            (this._updates0List = void 0),
            (this._updatesPosList = void 0),
            (this._hashForUpdates = void 0),
            (this._hashForTimers = void 0),
            (this._currentTarget = void 0),
            (this._currentTargetSalvaged = void 0),
            (this._updateHashLocked = void 0),
            (this._arrayForTimers = void 0),
            (this._timeScale = 1),
            (this._updatesNegList = []),
            (this._updates0List = []),
            (this._updatesPosList = []),
            (this._hashForUpdates = St(!0)),
            (this._hashForTimers = St(!0)),
            (this._currentTarget = null),
            (this._currentTargetSalvaged = !1),
            (this._updateHashLocked = !1),
            (this._arrayForTimers = []);
        }
        setTimeScale(t) {
          this._timeScale = t;
        }
        getTimeScale() {
          return this._timeScale;
        }
        update(t) {
          let e, i, s, n, r;
          for (
            this._updateHashLocked = !0,
              1 !== this._timeScale && (t *= this._timeScale),
              e = 0,
              i = this._updatesNegList,
              s = i.length;
            e < s;
            e++
          ) {
            var a, o;
            (n = i[e]),
              n.paused ||
                n.markedForDeletion ||
                !n.target ||
                null === (a = (o = n.target).update) ||
                void 0 === a ||
                a.call(o, t);
          }
          for (e = 0, i = this._updates0List, s = i.length; e < s; e++) {
            var h, l;
            (n = i[e]),
              n.paused ||
                n.markedForDeletion ||
                !n.target ||
                null === (h = (l = n.target).update) ||
                void 0 === h ||
                h.call(l, t);
          }
          for (e = 0, i = this._updatesPosList, s = i.length; e < s; e++) {
            var c, u;
            (n = i[e]),
              n.paused ||
                n.markedForDeletion ||
                !n.target ||
                null === (c = (u = n.target).update) ||
                void 0 === c ||
                c.call(u, t);
          }
          const _ = this._arrayForTimers;
          for (e = 0; e < _.length; e++) {
            var d, p;
            if (
              ((r = _[e]),
              (this._currentTarget = r),
              (this._currentTargetSalvaged = !1),
              r && !r.paused && r.timers)
            )
              for (
                r.timerIndex = 0;
                null != r.timers && r.timerIndex < r.timers.length;
                ++r.timerIndex
              )
                (r.currentTimer = r.timers[r.timerIndex]),
                  (r.currentTimerSalvaged = !1),
                  r.currentTimer.update(t),
                  (r.currentTimer = null);
            this._currentTargetSalvaged &&
              0 ===
                (null === (d = this._currentTarget) ||
                void 0 === d ||
                null === (p = d.timers) ||
                void 0 === p
                  ? void 0
                  : p.length) &&
              (this._removeHashElement(this._currentTarget), --e);
          }
          for (e = 0, i = this._updatesNegList; e < i.length; )
            (n = i[e]),
              n.markedForDeletion ? this._removeUpdateFromHash(n) : e++;
          for (e = 0, i = this._updates0List; e < i.length; )
            (n = i[e]),
              n.markedForDeletion ? this._removeUpdateFromHash(n) : e++;
          for (e = 0, i = this._updatesPosList; e < i.length; )
            (n = i[e]),
              n.markedForDeletion ? this._removeUpdateFromHash(n) : e++;
          (this._updateHashLocked = !1), (this._currentTarget = null);
        }
        schedule(t, e, i, s, n, r) {
          var o, h;
          let l, c;
          "function" != typeof t
            ? (z(1514), (l = e), (c = t))
            : ((l = t), (c = e)),
            (3 !== arguments.length &&
              4 !== arguments.length &&
              5 !== arguments.length) ||
              ((r = !!s), (s = a.macro.REPEAT_FOREVER), (n = 0)),
            j(Boolean(c), 1502);
          const u = c.uuid || c.id;
          if (!u) return void G(1510);
          let _,
            d,
            p = this._hashForTimers[u];
          if (
            (p
              ? p.paused !== r && z(1511)
              : ((p = Kl.get(null, c, 0, null, !1, Boolean(r))),
                this._arrayForTimers.push(p),
                (this._hashForTimers[u] = p)),
            null == p.timers)
          )
            p.timers = [];
          else
            for (d = 0; d < p.timers.length; ++d)
              if (((_ = p.timers[d]), _ && l === _.getCallback()))
                return B(1507, _.getInterval(), i), void _.setInterval(i);
          (_ = ql.get()),
            _.initWithCallback(
              this,
              l,
              c,
              i,
              null !== (o = s) && void 0 !== o ? o : 0,
              null !== (h = n) && void 0 !== h ? h : 0
            ),
            p.timers.push(_),
            this._currentTarget === p &&
              this._currentTargetSalvaged &&
              (this._currentTargetSalvaged = !1);
        }
        scheduleUpdate(t, e, i) {
          const s = t.uuid || t.id;
          if (!s) return void G(1510);
          const n = this._hashForUpdates[s];
          if (n && n.entry) {
            if (n.entry.priority === e)
              return (
                (n.entry.markedForDeletion = !1), void (n.entry.paused = i)
              );
            if (this._updateHashLocked)
              return (
                B(1506),
                (n.entry.markedForDeletion = !1),
                void (n.entry.paused = i)
              );
            this.unscheduleUpdate(t);
          }
          const r = Xl.get(t, e, i, !1);
          let a;
          0 === e
            ? ((a = this._updates0List), this._appendIn(a, r))
            : ((a = e < 0 ? this._updatesNegList : this._updatesPosList),
              this._priorityIn(a, r, e)),
            (this._hashForUpdates[s] = Yl.get(a, r, t, null));
        }
        unschedule(t, e) {
          if (!e || !t) return;
          const i = e.uuid || e.id;
          if (!i) return void G(1510);
          const s = this._hashForTimers[i];
          if (s) {
            const e = s.timers;
            if (!e) return;
            for (let i = 0, n = e.length; i < n; i++) {
              const n = e[i];
              if (t === n.getCallback())
                return (
                  n !== s.currentTimer ||
                    s.currentTimerSalvaged ||
                    (s.currentTimerSalvaged = !0),
                  e.splice(i, 1),
                  ql.put(n),
                  s.timerIndex >= i && s.timerIndex--,
                  void (
                    0 === e.length &&
                    (this._currentTarget === s
                      ? (this._currentTargetSalvaged = !0)
                      : this._removeHashElement(s))
                  )
                );
            }
          }
        }
        unscheduleForTimer(t, e) {
          const i = e.uuid || e.id,
            s = this._hashForTimers[i],
            n = s ? s.timers : null;
          if (n && 0 !== n.length)
            for (let e = n.length - 1; e >= 0; e--) {
              const i = n[e];
              if (i === t)
                return (
                  n.splice(e, 1),
                  ql.put(i),
                  s.timerIndex >= e && s.timerIndex--,
                  void (0 === n.length && (this._currentTargetSalvaged = !0))
                );
            }
        }
        unscheduleUpdate(t) {
          if (!t) return;
          const e = t.uuid || t.id;
          if (!e) return void G(1510);
          const i = this._hashForUpdates[e];
          null != i &&
            i.entry &&
            (this._updateHashLocked
              ? (i.entry.markedForDeletion = !0)
              : this._removeUpdateFromHash(i.entry));
        }
        unscheduleAllForTarget(t) {
          if (!t) return;
          const e = t.uuid || t.id;
          if (!e) return void G(1510);
          const i = this._hashForTimers[e];
          if (null != i && i.timers) {
            const t = i.timers;
            i.currentTimer &&
              t.indexOf(i.currentTimer) > -1 &&
              !i.currentTimerSalvaged &&
              (i.currentTimerSalvaged = !0);
            for (let e = 0, i = t.length; e < i; e++) ql.put(t[e]);
            (t.length = 0),
              this._currentTarget === i
                ? (this._currentTargetSalvaged = !0)
                : this._removeHashElement(i);
          }
          this.unscheduleUpdate(t);
        }
        unscheduleAll() {
          this.unscheduleAllWithMinPriority(jl.Priority.SCHEDULER);
        }
        unscheduleAllWithMinPriority(t) {
          let e, i;
          const s = this._arrayForTimers;
          for (e = s.length - 1; e >= 0; e--)
            (i = s[e]), i.target && this.unscheduleAllForTarget(i.target);
          let n,
            r = 0;
          if (t < 0)
            for (e = 0; e < this._updatesNegList.length; ) {
              var a;
              (r = this._updatesNegList.length),
                (n = this._updatesNegList[e]),
                null !== (a = n) &&
                  void 0 !== a &&
                  a.target &&
                  n.priority >= t &&
                  this.unscheduleUpdate(n.target),
                r === this._updatesNegList.length && e++;
            }
          if (t <= 0)
            for (e = 0; e < this._updates0List.length; ) {
              var o;
              (r = this._updates0List.length),
                (n = this._updates0List[e]),
                null !== (o = n) &&
                  void 0 !== o &&
                  o.target &&
                  this.unscheduleUpdate(n.target),
                r === this._updates0List.length && e++;
            }
          for (e = 0; e < this._updatesPosList.length; ) {
            var h;
            (r = this._updatesPosList.length),
              (n = this._updatesPosList[e]),
              null !== (h = n) &&
                void 0 !== h &&
                h.target &&
                n.priority >= t &&
                this.unscheduleUpdate(n.target),
              r === this._updatesPosList.length && e++;
          }
        }
        isScheduled(t, e) {
          j(Boolean(t), 1508), j(Boolean(e), 1509);
          const i = e.uuid || e.id;
          if (!i) return G(1510), !1;
          const s = this._hashForTimers[i];
          if (!s) return !1;
          if (null == s.timers) return !1;
          {
            const e = s.timers;
            for (let i = 0; i < e.length; ++i)
              if (t === e[i].getCallback()) return !0;
            return !1;
          }
        }
        pauseAllTargets() {
          return this.pauseAllTargetsWithMinPriority(jl.Priority.SCHEDULER);
        }
        pauseAllTargetsWithMinPriority(t) {
          const e = [];
          let i;
          const s = this._arrayForTimers;
          let n, r, a;
          for (n = 0, r = s.length; n < r; n++) {
            var o;
            (i = s[n]),
              null !== (o = i) &&
                void 0 !== o &&
                o.target &&
                ((i.paused = !0), e.push(i.target));
          }
          if (t < 0)
            for (n = 0; n < this._updatesNegList.length; n++) {
              var h;
              (a = this._updatesNegList[n]),
                null !== (h = a) &&
                  void 0 !== h &&
                  h.target &&
                  a.priority >= t &&
                  ((a.paused = !0), e.push(a.target));
            }
          if (t <= 0)
            for (n = 0; n < this._updates0List.length; n++) {
              var l;
              (a = this._updates0List[n]),
                null !== (l = a) &&
                  void 0 !== l &&
                  l.target &&
                  ((a.paused = !0), e.push(a.target));
            }
          for (n = 0; n < this._updatesPosList.length; n++) {
            var c;
            (a = this._updatesPosList[n]),
              null !== (c = a) &&
                void 0 !== c &&
                c.target &&
                a.priority >= t &&
                ((a.paused = !0), e.push(a.target));
          }
          return e;
        }
        resumeTargets(t) {
          if (t) for (let e = 0; e < t.length; e++) this.resumeTarget(t[e]);
        }
        pauseTarget(t) {
          j(Boolean(t), 1503);
          const e = t.uuid || t.id;
          if (!e) return void G(1510);
          const i = this._hashForTimers[e];
          i && (i.paused = !0);
          const s = this._hashForUpdates[e];
          null != s && s.entry && (s.entry.paused = !0);
        }
        resumeTarget(t) {
          j(Boolean(t), 1504);
          const e = t.uuid || t.id;
          if (!e) return void G(1510);
          const i = this._hashForTimers[e];
          i && (i.paused = !1);
          const s = this._hashForUpdates[e];
          null != s && s.entry && (s.entry.paused = !1);
        }
        isTargetPaused(t) {
          j(Boolean(t), 1505);
          const e = t.uuid || t.id;
          if (!e) return G(1510), !1;
          const i = this._hashForTimers[e];
          if (i) return i.paused;
          const s = this._hashForUpdates[e];
          return !(null == s || !s.entry) && s.entry.paused;
        }
        _removeHashElement(t) {
          if (!t.target) return;
          const e = t.target.uuid || t.target.id;
          if (void 0 === e) return;
          delete this._hashForTimers[e];
          const i = this._arrayForTimers;
          for (let e = 0, s = i.length; e < s; e++)
            if (i[e] === t) {
              i.splice(e, 1);
              break;
            }
          Kl.put(t);
        }
        _removeUpdateFromHash(t) {
          if (!t.target) return;
          const e = t.target.uuid || t.target.id;
          if (void 0 === e) return;
          const i = this._hashForUpdates[e];
          if (i) {
            const t = i.list,
              s = i.entry;
            if (t)
              for (let e = 0, i = t.length; e < i; e++)
                if (t[e] === s) {
                  t.splice(e, 1);
                  break;
                }
            delete this._hashForUpdates[e], s && Xl.put(s), Yl.put(i);
          }
        }
        _priorityIn(t, e, i) {
          for (let s = 0; s < t.length; s++)
            if (i < t[s].priority) return void t.splice(s, 0, e);
          t.push(e);
        }
        _appendIn(t, e) {
          t.push(e);
        }
      }
      t("Scheduler", $l), ($l.ID = "scheduler"), (a.Scheduler = $l);
      const Zl = {};
      $(Zl, "vmath", [
        { name: "vec2", newName: "Vec2", target: Ns, targetName: "math" },
        { name: "vec3", newName: "Vec3", target: Ns, targetName: "math" },
        { name: "vec4", newName: "Vec4", target: Ns, targetName: "math" },
        { name: "quat", newName: "Quat", target: Ns, targetName: "math" },
        { name: "mat3", newName: "Mat3", target: Ns, targetName: "math" },
        { name: "mat4", newName: "Mat4", target: Ns, targetName: "math" },
        { name: "color4", newName: "Color", target: Ns, targetName: "math" },
        { name: "rect", newName: "Rect", target: Ns, targetName: "math" },
        { name: "approx", newName: "approx", target: Ns, targetName: "math" },
        { name: "EPSILON", newName: "EPSILON", target: Ns, targetName: "math" },
        { name: "equals", newName: "equals", target: Ns, targetName: "math" },
        { name: "clamp", newName: "clamp", target: Ns, targetName: "math" },
        { name: "clamp01", newName: "clamp01", target: Ns, targetName: "math" },
        { name: "lerp", newName: "lerp", target: Ns, targetName: "math" },
        {
          name: "toRadian",
          newName: "toRadian",
          target: Ns,
          targetName: "math",
        },
        {
          name: "toDegree",
          newName: "toDegree",
          target: Ns,
          targetName: "math",
        },
        { name: "random", newName: "random", target: Ns, targetName: "math" },
        {
          name: "randomRange",
          newName: "randomRange",
          target: Ns,
          targetName: "math",
        },
        {
          name: "randomRangeInt",
          newName: "randomRangeInt",
          target: Ns,
          targetName: "math",
        },
        {
          name: "pseudoRandom",
          newName: "pseudoRandom",
          target: Ns,
          targetName: "math",
        },
        {
          name: "pseudoRandomRangeInt",
          newName: "pseudoRandomRangeInt",
          target: Ns,
          targetName: "math",
        },
        {
          name: "nextPow2",
          newName: "nextPow2",
          target: Ns,
          targetName: "math",
        },
        { name: "repeat", newName: "repeat", target: Ns, targetName: "math" },
        {
          name: "pingPong",
          newName: "pingPong",
          target: Ns,
          targetName: "math",
        },
        {
          name: "inverseLerp",
          newName: "inverseLerp",
          target: Ns,
          targetName: "math",
        },
      ]),
        (a.vmath = Zl),
        $($l.prototype, "Scheduler.prototype", [
          {
            name: "enableForTarget",
            newName: "enableForTarget",
            target: $l,
            targetName: "Scheduler",
          },
        ]),
        $($l, "Scheduler", [
          {
            name: "PRIORITY_SYSTEM",
            newName: "System.Priority.SCHEDULER",
            customGetter: () => jl.Priority.SCHEDULER,
          },
        ]),
        Z($l, "Scheduler", [
          {
            name: "PRIORITY_NON_SYSTEM",
            suggest: "Use enum` System.Priority` instead",
          },
        ]),
        Q(ae, "js", [
          {
            name: "js",
            suggest:
              "'js.js' is deprecated since v3.7.0, please access 'js' directly instead.",
          },
        ]);
      const Ql = String.prototype.charCodeAt;
      function Jl(t) {
        return this[t];
      }
      function tc(t, e) {
        let i = t.length,
          s = e ^ i,
          n = 0;
        const r = "string" == typeof t ? Ql : Jl;
        for (; i >= 4; ) {
          let e =
            (255 & r.call(t, n)) |
            ((255 & r.call(t, ++n)) << 8) |
            ((255 & r.call(t, ++n)) << 16) |
            ((255 & r.call(t, ++n)) << 24);
          (e =
            1540483477 * (65535 & e) +
            (((1540483477 * (e >>> 16)) & 65535) << 16)),
            (e ^= e >>> 24),
            (e =
              1540483477 * (65535 & e) +
              (((1540483477 * (e >>> 16)) & 65535) << 16)),
            (s =
              (1540483477 * (65535 & s) +
                (((1540483477 * (s >>> 16)) & 65535) << 16)) ^
              e),
            (i -= 4),
            ++n;
        }
        switch (i) {
          case 3:
            s ^= (255 & r.call(t, n + 2)) << 16;
          case 2:
            s ^= (255 & r.call(t, n + 1)) << 8;
          case 1:
            (s ^= 255 & r.call(t, n)),
              (s =
                1540483477 * (65535 & s) +
                (((1540483477 * (s >>> 16)) & 65535) << 16));
        }
        return (
          (s ^= s >>> 13),
          (s =
            1540483477 * (65535 & s) +
            (((1540483477 * (s >>> 16)) & 65535) << 16)),
          (s ^= s >>> 15),
          s >>> 0
        );
      }
      function ec(t) {
        const e = t._lpos;
        t.setPositionForJS(e.x, e.y, e.z);
        const i = t._lscale;
        t.setScaleForJS(i.x, i.y, i.z);
        const s = t._lrot;
        t.setRotationForJS(s.x, s.y, s.z, s.w);
        const n = t._euler;
        t.setRotationFromEulerForJS(n.x, n.y, n.z);
      }
      function ic(t) {
        if (!t) return;
        const e = t.children;
        if (!e) return;
        const i = e.length;
        if (i) {
          t._setChildren(e);
          for (let t = 0; t < i; ++t) ic(e[t]);
        }
      }
      function sc() {}
      function nc(t, e, i) {
        if ((he(t, e), he(t, i), e === i)) return t;
        const s = t[e];
        if (e < i) for (let s = e + 1; s <= i; ++s) t[s - 1] = t[s];
        else for (let s = e; s !== i; --s) t[s] = t[s - 1];
        return (t[i] = s), t;
      }
      (a.easing = gh),
        (sc.prototype.once = function (t, e, i) {
          return this.on(t, e, i, !0);
        }),
        (sc.prototype.targetOff = function (t) {
          this.removeAll(t);
        }),
        t(
          "jsbUtils",
          Object.freeze({
            __proto__: null,
            syncNodeValues: ec,
            updateChildrenForDeserialize: ic,
            ExtraEventMethods: sc,
          })
        );
      const rc = t(
        "garbageCollectionManager",
        new (class {
          constructor() {
            (this._finalizationRegistry = null),
              (this._gcObjects = new WeakMap());
          }
          registerGCObject(t) {
            return t;
          }
          init() {}
          finalizationRegistryCallback(t) {
            const e = this._gcObjects.get(t);
            e && (this._gcObjects.delete(t), e.destroy()),
              this._finalizationRegistry.unregister(t);
          }
          destroy() {}
        })()
      );
      class ac {
        constructor() {
          return rc.registerGCObject(this);
        }
        destroy() {}
      }
      function oc(t, e) {
        for (const i of e) Array.isArray(i) ? oc(t, i) : t.push(i);
      }
      function hc(t) {
        const e = [];
        return oc(e, t), e.join("");
      }
      function lc(t, e) {
        e.forEach((e) => {
          Object.getOwnPropertyNames(e.prototype).forEach((i) => {
            "constructor" !== i &&
              Object.defineProperty(
                t.prototype,
                i,
                Object.getOwnPropertyDescriptor(e.prototype, i)
              );
          });
        });
      }
      t("GCObject", ac), (a.math = Ns), (a.geometry = Vl);
      const cc = (t, e, i) => {
        for (let s = 0; s < e.length; ++s)
          t.length <= s && t.push(new i()), t[s].copy(e[s]);
        t.length = e.length;
      };
      let uc,
        _c,
        dc,
        pc,
        mc,
        fc,
        gc,
        yc,
        Tc,
        Sc,
        Ec,
        vc,
        bc,
        Ac,
        Cc,
        Oc,
        Ic,
        wc,
        Rc,
        Dc,
        xc,
        Mc,
        Pc,
        Nc,
        Lc,
        Bc,
        Fc,
        Uc,
        kc,
        zc,
        Hc,
        Gc,
        Vc,
        jc,
        Wc,
        Xc,
        Yc,
        Kc,
        qc,
        $c,
        Zc,
        Qc,
        Jc,
        tu,
        eu;
      !(function (t) {
        (t[(t.UNKNOWN = 0)] = "UNKNOWN"),
          (t[(t.SWAPCHAIN = 1)] = "SWAPCHAIN"),
          (t[(t.BUFFER = 2)] = "BUFFER"),
          (t[(t.TEXTURE = 3)] = "TEXTURE"),
          (t[(t.RENDER_PASS = 4)] = "RENDER_PASS"),
          (t[(t.FRAMEBUFFER = 5)] = "FRAMEBUFFER"),
          (t[(t.SAMPLER = 6)] = "SAMPLER"),
          (t[(t.SHADER = 7)] = "SHADER"),
          (t[(t.DESCRIPTOR_SET_LAYOUT = 8)] = "DESCRIPTOR_SET_LAYOUT"),
          (t[(t.PIPELINE_LAYOUT = 9)] = "PIPELINE_LAYOUT"),
          (t[(t.PIPELINE_STATE = 10)] = "PIPELINE_STATE"),
          (t[(t.DESCRIPTOR_SET = 11)] = "DESCRIPTOR_SET"),
          (t[(t.INPUT_ASSEMBLER = 12)] = "INPUT_ASSEMBLER"),
          (t[(t.COMMAND_BUFFER = 13)] = "COMMAND_BUFFER"),
          (t[(t.QUEUE = 14)] = "QUEUE"),
          (t[(t.QUERY_POOL = 15)] = "QUERY_POOL"),
          (t[(t.GLOBAL_BARRIER = 16)] = "GLOBAL_BARRIER"),
          (t[(t.TEXTURE_BARRIER = 17)] = "TEXTURE_BARRIER"),
          (t[(t.BUFFER_BARRIER = 18)] = "BUFFER_BARRIER"),
          (t[(t.COUNT = 19)] = "COUNT");
      })(uc || (uc = {})),
        (function (t) {
          (t[(t.UNREADY = 0)] = "UNREADY"),
            (t[(t.FAILED = 1)] = "FAILED"),
            (t[(t.SUCCESS = 2)] = "SUCCESS");
        })(_c || (_c = {})),
        (function (t) {
          (t[(t.UNKNOWN = 0)] = "UNKNOWN"),
            (t[(t.GLES2 = 1)] = "GLES2"),
            (t[(t.GLES3 = 2)] = "GLES3"),
            (t[(t.METAL = 3)] = "METAL"),
            (t[(t.VULKAN = 4)] = "VULKAN"),
            (t[(t.NVN = 5)] = "NVN"),
            (t[(t.WEBGL = 6)] = "WEBGL"),
            (t[(t.WEBGL2 = 7)] = "WEBGL2"),
            (t[(t.WEBGPU = 8)] = "WEBGPU");
        })(dc || (dc = {})),
        (function (t) {
          (t[(t.IDENTITY = 0)] = "IDENTITY"),
            (t[(t.ROTATE_90 = 1)] = "ROTATE_90"),
            (t[(t.ROTATE_180 = 2)] = "ROTATE_180"),
            (t[(t.ROTATE_270 = 3)] = "ROTATE_270");
        })(pc || (pc = {})),
        (function (t) {
          (t[(t.ELEMENT_INDEX_UINT = 0)] = "ELEMENT_INDEX_UINT"),
            (t[(t.INSTANCED_ARRAYS = 1)] = "INSTANCED_ARRAYS"),
            (t[(t.MULTIPLE_RENDER_TARGETS = 2)] = "MULTIPLE_RENDER_TARGETS"),
            (t[(t.BLEND_MINMAX = 3)] = "BLEND_MINMAX"),
            (t[(t.COMPUTE_SHADER = 4)] = "COMPUTE_SHADER"),
            (t[(t.INPUT_ATTACHMENT_BENEFIT = 5)] = "INPUT_ATTACHMENT_BENEFIT"),
            (t[(t.SUBPASS_COLOR_INPUT = 6)] = "SUBPASS_COLOR_INPUT"),
            (t[(t.SUBPASS_DEPTH_STENCIL_INPUT = 7)] =
              "SUBPASS_DEPTH_STENCIL_INPUT"),
            (t[(t.RASTERIZATION_ORDER_COHERENT = 8)] =
              "RASTERIZATION_ORDER_COHERENT"),
            (t[(t.MULTI_SAMPLE_RESOLVE_DEPTH_STENCIL = 9)] =
              "MULTI_SAMPLE_RESOLVE_DEPTH_STENCIL"),
            (t[(t.COUNT = 10)] = "COUNT");
        })(mc || (mc = {})),
        (function (t) {
          (t[(t.UNKNOWN = 0)] = "UNKNOWN"),
            (t[(t.A8 = 1)] = "A8"),
            (t[(t.L8 = 2)] = "L8"),
            (t[(t.LA8 = 3)] = "LA8"),
            (t[(t.R8 = 4)] = "R8"),
            (t[(t.R8SN = 5)] = "R8SN"),
            (t[(t.R8UI = 6)] = "R8UI"),
            (t[(t.R8I = 7)] = "R8I"),
            (t[(t.R16F = 8)] = "R16F"),
            (t[(t.R16UI = 9)] = "R16UI"),
            (t[(t.R16I = 10)] = "R16I"),
            (t[(t.R32F = 11)] = "R32F"),
            (t[(t.R32UI = 12)] = "R32UI"),
            (t[(t.R32I = 13)] = "R32I"),
            (t[(t.RG8 = 14)] = "RG8"),
            (t[(t.RG8SN = 15)] = "RG8SN"),
            (t[(t.RG8UI = 16)] = "RG8UI"),
            (t[(t.RG8I = 17)] = "RG8I"),
            (t[(t.RG16F = 18)] = "RG16F"),
            (t[(t.RG16UI = 19)] = "RG16UI"),
            (t[(t.RG16I = 20)] = "RG16I"),
            (t[(t.RG32F = 21)] = "RG32F"),
            (t[(t.RG32UI = 22)] = "RG32UI"),
            (t[(t.RG32I = 23)] = "RG32I"),
            (t[(t.RGB8 = 24)] = "RGB8"),
            (t[(t.SRGB8 = 25)] = "SRGB8"),
            (t[(t.RGB8SN = 26)] = "RGB8SN"),
            (t[(t.RGB8UI = 27)] = "RGB8UI"),
            (t[(t.RGB8I = 28)] = "RGB8I"),
            (t[(t.RGB16F = 29)] = "RGB16F"),
            (t[(t.RGB16UI = 30)] = "RGB16UI"),
            (t[(t.RGB16I = 31)] = "RGB16I"),
            (t[(t.RGB32F = 32)] = "RGB32F"),
            (t[(t.RGB32UI = 33)] = "RGB32UI"),
            (t[(t.RGB32I = 34)] = "RGB32I"),
            (t[(t.RGBA8 = 35)] = "RGBA8"),
            (t[(t.BGRA8 = 36)] = "BGRA8"),
            (t[(t.SRGB8_A8 = 37)] = "SRGB8_A8"),
            (t[(t.RGBA8SN = 38)] = "RGBA8SN"),
            (t[(t.RGBA8UI = 39)] = "RGBA8UI"),
            (t[(t.RGBA8I = 40)] = "RGBA8I"),
            (t[(t.RGBA16F = 41)] = "RGBA16F"),
            (t[(t.RGBA16UI = 42)] = "RGBA16UI"),
            (t[(t.RGBA16I = 43)] = "RGBA16I"),
            (t[(t.RGBA32F = 44)] = "RGBA32F"),
            (t[(t.RGBA32UI = 45)] = "RGBA32UI"),
            (t[(t.RGBA32I = 46)] = "RGBA32I"),
            (t[(t.R5G6B5 = 47)] = "R5G6B5"),
            (t[(t.R11G11B10F = 48)] = "R11G11B10F"),
            (t[(t.RGB5A1 = 49)] = "RGB5A1"),
            (t[(t.RGBA4 = 50)] = "RGBA4"),
            (t[(t.RGB10A2 = 51)] = "RGB10A2"),
            (t[(t.RGB10A2UI = 52)] = "RGB10A2UI"),
            (t[(t.RGB9E5 = 53)] = "RGB9E5"),
            (t[(t.DEPTH = 54)] = "DEPTH"),
            (t[(t.DEPTH_STENCIL = 55)] = "DEPTH_STENCIL"),
            (t[(t.BC1 = 56)] = "BC1"),
            (t[(t.BC1_ALPHA = 57)] = "BC1_ALPHA"),
            (t[(t.BC1_SRGB = 58)] = "BC1_SRGB"),
            (t[(t.BC1_SRGB_ALPHA = 59)] = "BC1_SRGB_ALPHA"),
            (t[(t.BC2 = 60)] = "BC2"),
            (t[(t.BC2_SRGB = 61)] = "BC2_SRGB"),
            (t[(t.BC3 = 62)] = "BC3"),
            (t[(t.BC3_SRGB = 63)] = "BC3_SRGB"),
            (t[(t.BC4 = 64)] = "BC4"),
            (t[(t.BC4_SNORM = 65)] = "BC4_SNORM"),
            (t[(t.BC5 = 66)] = "BC5"),
            (t[(t.BC5_SNORM = 67)] = "BC5_SNORM"),
            (t[(t.BC6H_UF16 = 68)] = "BC6H_UF16"),
            (t[(t.BC6H_SF16 = 69)] = "BC6H_SF16"),
            (t[(t.BC7 = 70)] = "BC7"),
            (t[(t.BC7_SRGB = 71)] = "BC7_SRGB"),
            (t[(t.ETC_RGB8 = 72)] = "ETC_RGB8"),
            (t[(t.ETC2_RGB8 = 73)] = "ETC2_RGB8"),
            (t[(t.ETC2_SRGB8 = 74)] = "ETC2_SRGB8"),
            (t[(t.ETC2_RGB8_A1 = 75)] = "ETC2_RGB8_A1"),
            (t[(t.ETC2_SRGB8_A1 = 76)] = "ETC2_SRGB8_A1"),
            (t[(t.ETC2_RGBA8 = 77)] = "ETC2_RGBA8"),
            (t[(t.ETC2_SRGB8_A8 = 78)] = "ETC2_SRGB8_A8"),
            (t[(t.EAC_R11 = 79)] = "EAC_R11"),
            (t[(t.EAC_R11SN = 80)] = "EAC_R11SN"),
            (t[(t.EAC_RG11 = 81)] = "EAC_RG11"),
            (t[(t.EAC_RG11SN = 82)] = "EAC_RG11SN"),
            (t[(t.PVRTC_RGB2 = 83)] = "PVRTC_RGB2"),
            (t[(t.PVRTC_RGBA2 = 84)] = "PVRTC_RGBA2"),
            (t[(t.PVRTC_RGB4 = 85)] = "PVRTC_RGB4"),
            (t[(t.PVRTC_RGBA4 = 86)] = "PVRTC_RGBA4"),
            (t[(t.PVRTC2_2BPP = 87)] = "PVRTC2_2BPP"),
            (t[(t.PVRTC2_4BPP = 88)] = "PVRTC2_4BPP"),
            (t[(t.ASTC_RGBA_4X4 = 89)] = "ASTC_RGBA_4X4"),
            (t[(t.ASTC_RGBA_5X4 = 90)] = "ASTC_RGBA_5X4"),
            (t[(t.ASTC_RGBA_5X5 = 91)] = "ASTC_RGBA_5X5"),
            (t[(t.ASTC_RGBA_6X5 = 92)] = "ASTC_RGBA_6X5"),
            (t[(t.ASTC_RGBA_6X6 = 93)] = "ASTC_RGBA_6X6"),
            (t[(t.ASTC_RGBA_8X5 = 94)] = "ASTC_RGBA_8X5"),
            (t[(t.ASTC_RGBA_8X6 = 95)] = "ASTC_RGBA_8X6"),
            (t[(t.ASTC_RGBA_8X8 = 96)] = "ASTC_RGBA_8X8"),
            (t[(t.ASTC_RGBA_10X5 = 97)] = "ASTC_RGBA_10X5"),
            (t[(t.ASTC_RGBA_10X6 = 98)] = "ASTC_RGBA_10X6"),
            (t[(t.ASTC_RGBA_10X8 = 99)] = "ASTC_RGBA_10X8"),
            (t[(t.ASTC_RGBA_10X10 = 100)] = "ASTC_RGBA_10X10"),
            (t[(t.ASTC_RGBA_12X10 = 101)] = "ASTC_RGBA_12X10"),
            (t[(t.ASTC_RGBA_12X12 = 102)] = "ASTC_RGBA_12X12"),
            (t[(t.ASTC_SRGBA_4X4 = 103)] = "ASTC_SRGBA_4X4"),
            (t[(t.ASTC_SRGBA_5X4 = 104)] = "ASTC_SRGBA_5X4"),
            (t[(t.ASTC_SRGBA_5X5 = 105)] = "ASTC_SRGBA_5X5"),
            (t[(t.ASTC_SRGBA_6X5 = 106)] = "ASTC_SRGBA_6X5"),
            (t[(t.ASTC_SRGBA_6X6 = 107)] = "ASTC_SRGBA_6X6"),
            (t[(t.ASTC_SRGBA_8X5 = 108)] = "ASTC_SRGBA_8X5"),
            (t[(t.ASTC_SRGBA_8X6 = 109)] = "ASTC_SRGBA_8X6"),
            (t[(t.ASTC_SRGBA_8X8 = 110)] = "ASTC_SRGBA_8X8"),
            (t[(t.ASTC_SRGBA_10X5 = 111)] = "ASTC_SRGBA_10X5"),
            (t[(t.ASTC_SRGBA_10X6 = 112)] = "ASTC_SRGBA_10X6"),
            (t[(t.ASTC_SRGBA_10X8 = 113)] = "ASTC_SRGBA_10X8"),
            (t[(t.ASTC_SRGBA_10X10 = 114)] = "ASTC_SRGBA_10X10"),
            (t[(t.ASTC_SRGBA_12X10 = 115)] = "ASTC_SRGBA_12X10"),
            (t[(t.ASTC_SRGBA_12X12 = 116)] = "ASTC_SRGBA_12X12"),
            (t[(t.COUNT = 117)] = "COUNT");
        })(fc || (fc = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.UNORM = 1)] = "UNORM"),
            (t[(t.SNORM = 2)] = "SNORM"),
            (t[(t.UINT = 3)] = "UINT"),
            (t[(t.INT = 4)] = "INT"),
            (t[(t.UFLOAT = 5)] = "UFLOAT"),
            (t[(t.FLOAT = 6)] = "FLOAT");
        })(gc || (gc = {})),
        (function (t) {
          (t[(t.UNKNOWN = 0)] = "UNKNOWN"),
            (t[(t.BOOL = 1)] = "BOOL"),
            (t[(t.BOOL2 = 2)] = "BOOL2"),
            (t[(t.BOOL3 = 3)] = "BOOL3"),
            (t[(t.BOOL4 = 4)] = "BOOL4"),
            (t[(t.INT = 5)] = "INT"),
            (t[(t.INT2 = 6)] = "INT2"),
            (t[(t.INT3 = 7)] = "INT3"),
            (t[(t.INT4 = 8)] = "INT4"),
            (t[(t.UINT = 9)] = "UINT"),
            (t[(t.UINT2 = 10)] = "UINT2"),
            (t[(t.UINT3 = 11)] = "UINT3"),
            (t[(t.UINT4 = 12)] = "UINT4"),
            (t[(t.FLOAT = 13)] = "FLOAT"),
            (t[(t.FLOAT2 = 14)] = "FLOAT2"),
            (t[(t.FLOAT3 = 15)] = "FLOAT3"),
            (t[(t.FLOAT4 = 16)] = "FLOAT4"),
            (t[(t.MAT2 = 17)] = "MAT2"),
            (t[(t.MAT2X3 = 18)] = "MAT2X3"),
            (t[(t.MAT2X4 = 19)] = "MAT2X4"),
            (t[(t.MAT3X2 = 20)] = "MAT3X2"),
            (t[(t.MAT3 = 21)] = "MAT3"),
            (t[(t.MAT3X4 = 22)] = "MAT3X4"),
            (t[(t.MAT4X2 = 23)] = "MAT4X2"),
            (t[(t.MAT4X3 = 24)] = "MAT4X3"),
            (t[(t.MAT4 = 25)] = "MAT4"),
            (t[(t.SAMPLER1D = 26)] = "SAMPLER1D"),
            (t[(t.SAMPLER1D_ARRAY = 27)] = "SAMPLER1D_ARRAY"),
            (t[(t.SAMPLER2D = 28)] = "SAMPLER2D"),
            (t[(t.SAMPLER2D_ARRAY = 29)] = "SAMPLER2D_ARRAY"),
            (t[(t.SAMPLER3D = 30)] = "SAMPLER3D"),
            (t[(t.SAMPLER_CUBE = 31)] = "SAMPLER_CUBE"),
            (t[(t.SAMPLER = 32)] = "SAMPLER"),
            (t[(t.TEXTURE1D = 33)] = "TEXTURE1D"),
            (t[(t.TEXTURE1D_ARRAY = 34)] = "TEXTURE1D_ARRAY"),
            (t[(t.TEXTURE2D = 35)] = "TEXTURE2D"),
            (t[(t.TEXTURE2D_ARRAY = 36)] = "TEXTURE2D_ARRAY"),
            (t[(t.TEXTURE3D = 37)] = "TEXTURE3D"),
            (t[(t.TEXTURE_CUBE = 38)] = "TEXTURE_CUBE"),
            (t[(t.IMAGE1D = 39)] = "IMAGE1D"),
            (t[(t.IMAGE1D_ARRAY = 40)] = "IMAGE1D_ARRAY"),
            (t[(t.IMAGE2D = 41)] = "IMAGE2D"),
            (t[(t.IMAGE2D_ARRAY = 42)] = "IMAGE2D_ARRAY"),
            (t[(t.IMAGE3D = 43)] = "IMAGE3D"),
            (t[(t.IMAGE_CUBE = 44)] = "IMAGE_CUBE"),
            (t[(t.SUBPASS_INPUT = 45)] = "SUBPASS_INPUT"),
            (t[(t.COUNT = 46)] = "COUNT");
        })(yc || (yc = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.TRANSFER_SRC = 1)] = "TRANSFER_SRC"),
            (t[(t.TRANSFER_DST = 2)] = "TRANSFER_DST"),
            (t[(t.INDEX = 4)] = "INDEX"),
            (t[(t.VERTEX = 8)] = "VERTEX"),
            (t[(t.UNIFORM = 16)] = "UNIFORM"),
            (t[(t.STORAGE = 32)] = "STORAGE"),
            (t[(t.INDIRECT = 64)] = "INDIRECT");
        })(Tc || (Tc = {})),
        (function (t) {
          t[(t.NONE = 0)] = "NONE";
        })(Sc || (Sc = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.READ_ONLY = 1)] = "READ_ONLY"),
            (t[(t.WRITE_ONLY = 2)] = "WRITE_ONLY"),
            (t[(t.READ_WRITE = 3)] = "READ_WRITE");
        })(Ec || (Ec = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.DEVICE = 1)] = "DEVICE"),
            (t[(t.HOST = 2)] = "HOST");
        })(vc || (vc = {})),
        (function (t) {
          (t[(t.TEX1D = 0)] = "TEX1D"),
            (t[(t.TEX2D = 1)] = "TEX2D"),
            (t[(t.TEX3D = 2)] = "TEX3D"),
            (t[(t.CUBE = 3)] = "CUBE"),
            (t[(t.TEX1D_ARRAY = 4)] = "TEX1D_ARRAY"),
            (t[(t.TEX2D_ARRAY = 5)] = "TEX2D_ARRAY");
        })(bc || (bc = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.TRANSFER_SRC = 1)] = "TRANSFER_SRC"),
            (t[(t.TRANSFER_DST = 2)] = "TRANSFER_DST"),
            (t[(t.SAMPLED = 4)] = "SAMPLED"),
            (t[(t.STORAGE = 8)] = "STORAGE"),
            (t[(t.COLOR_ATTACHMENT = 16)] = "COLOR_ATTACHMENT"),
            (t[(t.DEPTH_STENCIL_ATTACHMENT = 32)] = "DEPTH_STENCIL_ATTACHMENT"),
            (t[(t.INPUT_ATTACHMENT = 64)] = "INPUT_ATTACHMENT");
        })(Ac || (Ac = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.GEN_MIPMAP = 1)] = "GEN_MIPMAP"),
            (t[(t.GENERAL_LAYOUT = 2)] = "GENERAL_LAYOUT"),
            (t[(t.EXTERNAL_OES = 4)] = "EXTERNAL_OES"),
            (t[(t.EXTERNAL_NORMAL = 8)] = "EXTERNAL_NORMAL"),
            (t[(t.LAZILY_ALLOCATED = 16)] = "LAZILY_ALLOCATED"),
            (t[(t.MUTABLE_VIEW_FORMAT = 64)] = "MUTABLE_VIEW_FORMAT"),
            (t[(t.MUTABLE_STORAGE = 128)] = "MUTABLE_STORAGE");
        })(Cc || (Cc = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.RENDER_TARGET = 1)] = "RENDER_TARGET"),
            (t[(t.SAMPLED_TEXTURE = 2)] = "SAMPLED_TEXTURE"),
            (t[(t.LINEAR_FILTER = 4)] = "LINEAR_FILTER"),
            (t[(t.STORAGE_TEXTURE = 8)] = "STORAGE_TEXTURE"),
            (t[(t.VERTEX_ATTRIBUTE = 16)] = "VERTEX_ATTRIBUTE");
        })(Oc || (Oc = {})),
        (function (t) {
          (t[(t.X1 = 1)] = "X1"),
            (t[(t.X2 = 2)] = "X2"),
            (t[(t.X4 = 4)] = "X4"),
            (t[(t.X8 = 8)] = "X8"),
            (t[(t.X16 = 16)] = "X16"),
            (t[(t.X32 = 32)] = "X32"),
            (t[(t.X64 = 64)] = "X64");
        })(Ic || (Ic = {})),
        (function (t) {
          (t[(t.OFF = 0)] = "OFF"),
            (t[(t.ON = 1)] = "ON"),
            (t[(t.RELAXED = 2)] = "RELAXED"),
            (t[(t.MAILBOX = 3)] = "MAILBOX"),
            (t[(t.HALF = 4)] = "HALF");
        })(wc || (wc = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.POINT = 1)] = "POINT"),
            (t[(t.LINEAR = 2)] = "LINEAR"),
            (t[(t.ANISOTROPIC = 3)] = "ANISOTROPIC");
        })(Rc || (Rc = {})),
        (function (t) {
          (t[(t.WRAP = 0)] = "WRAP"),
            (t[(t.MIRROR = 1)] = "MIRROR"),
            (t[(t.CLAMP = 2)] = "CLAMP"),
            (t[(t.BORDER = 3)] = "BORDER");
        })(Dc || (Dc = {})),
        (function (t) {
          (t[(t.NEVER = 0)] = "NEVER"),
            (t[(t.LESS = 1)] = "LESS"),
            (t[(t.EQUAL = 2)] = "EQUAL"),
            (t[(t.LESS_EQUAL = 3)] = "LESS_EQUAL"),
            (t[(t.GREATER = 4)] = "GREATER"),
            (t[(t.NOT_EQUAL = 5)] = "NOT_EQUAL"),
            (t[(t.GREATER_EQUAL = 6)] = "GREATER_EQUAL"),
            (t[(t.ALWAYS = 7)] = "ALWAYS");
        })(xc || (xc = {})),
        (function (t) {
          (t[(t.ZERO = 0)] = "ZERO"),
            (t[(t.KEEP = 1)] = "KEEP"),
            (t[(t.REPLACE = 2)] = "REPLACE"),
            (t[(t.INCR = 3)] = "INCR"),
            (t[(t.DECR = 4)] = "DECR"),
            (t[(t.INVERT = 5)] = "INVERT"),
            (t[(t.INCR_WRAP = 6)] = "INCR_WRAP"),
            (t[(t.DECR_WRAP = 7)] = "DECR_WRAP");
        })(Mc || (Mc = {})),
        (function (t) {
          (t[(t.ZERO = 0)] = "ZERO"),
            (t[(t.ONE = 1)] = "ONE"),
            (t[(t.SRC_ALPHA = 2)] = "SRC_ALPHA"),
            (t[(t.DST_ALPHA = 3)] = "DST_ALPHA"),
            (t[(t.ONE_MINUS_SRC_ALPHA = 4)] = "ONE_MINUS_SRC_ALPHA"),
            (t[(t.ONE_MINUS_DST_ALPHA = 5)] = "ONE_MINUS_DST_ALPHA"),
            (t[(t.SRC_COLOR = 6)] = "SRC_COLOR"),
            (t[(t.DST_COLOR = 7)] = "DST_COLOR"),
            (t[(t.ONE_MINUS_SRC_COLOR = 8)] = "ONE_MINUS_SRC_COLOR"),
            (t[(t.ONE_MINUS_DST_COLOR = 9)] = "ONE_MINUS_DST_COLOR"),
            (t[(t.SRC_ALPHA_SATURATE = 10)] = "SRC_ALPHA_SATURATE"),
            (t[(t.CONSTANT_COLOR = 11)] = "CONSTANT_COLOR"),
            (t[(t.ONE_MINUS_CONSTANT_COLOR = 12)] = "ONE_MINUS_CONSTANT_COLOR"),
            (t[(t.CONSTANT_ALPHA = 13)] = "CONSTANT_ALPHA"),
            (t[(t.ONE_MINUS_CONSTANT_ALPHA = 14)] = "ONE_MINUS_CONSTANT_ALPHA");
        })(Pc || (Pc = {})),
        (function (t) {
          (t[(t.ADD = 0)] = "ADD"),
            (t[(t.SUB = 1)] = "SUB"),
            (t[(t.REV_SUB = 2)] = "REV_SUB"),
            (t[(t.MIN = 3)] = "MIN"),
            (t[(t.MAX = 4)] = "MAX");
        })(Nc || (Nc = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.R = 1)] = "R"),
            (t[(t.G = 2)] = "G"),
            (t[(t.B = 4)] = "B"),
            (t[(t.A = 8)] = "A"),
            (t[(t.ALL = 15)] = "ALL");
        })(Lc || (Lc = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.VERTEX = 1)] = "VERTEX"),
            (t[(t.CONTROL = 2)] = "CONTROL"),
            (t[(t.EVALUATION = 4)] = "EVALUATION"),
            (t[(t.GEOMETRY = 8)] = "GEOMETRY"),
            (t[(t.FRAGMENT = 16)] = "FRAGMENT"),
            (t[(t.COMPUTE = 32)] = "COMPUTE"),
            (t[(t.ALL = 63)] = "ALL");
        })(Bc || (Bc = {})),
        (function (t) {
          (t[(t.LOAD = 0)] = "LOAD"),
            (t[(t.CLEAR = 1)] = "CLEAR"),
            (t[(t.DISCARD = 2)] = "DISCARD");
        })(Fc || (Fc = {})),
        (function (t) {
          (t[(t.STORE = 0)] = "STORE"), (t[(t.DISCARD = 1)] = "DISCARD");
        })(Uc || (Uc = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.INDIRECT_BUFFER = 1)] = "INDIRECT_BUFFER"),
            (t[(t.INDEX_BUFFER = 2)] = "INDEX_BUFFER"),
            (t[(t.VERTEX_BUFFER = 4)] = "VERTEX_BUFFER"),
            (t[(t.VERTEX_SHADER_READ_UNIFORM_BUFFER = 8)] =
              "VERTEX_SHADER_READ_UNIFORM_BUFFER"),
            (t[(t.VERTEX_SHADER_READ_TEXTURE = 16)] =
              "VERTEX_SHADER_READ_TEXTURE"),
            (t[(t.VERTEX_SHADER_READ_OTHER = 32)] = "VERTEX_SHADER_READ_OTHER"),
            (t[(t.FRAGMENT_SHADER_READ_UNIFORM_BUFFER = 64)] =
              "FRAGMENT_SHADER_READ_UNIFORM_BUFFER"),
            (t[(t.FRAGMENT_SHADER_READ_TEXTURE = 128)] =
              "FRAGMENT_SHADER_READ_TEXTURE"),
            (t[(t.FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT = 256)] =
              "FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT"),
            (t[(t.FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT = 512)] =
              "FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT"),
            (t[(t.FRAGMENT_SHADER_READ_OTHER = 1024)] =
              "FRAGMENT_SHADER_READ_OTHER"),
            (t[(t.COLOR_ATTACHMENT_READ = 2048)] = "COLOR_ATTACHMENT_READ"),
            (t[(t.DEPTH_STENCIL_ATTACHMENT_READ = 4096)] =
              "DEPTH_STENCIL_ATTACHMENT_READ"),
            (t[(t.COMPUTE_SHADER_READ_UNIFORM_BUFFER = 8192)] =
              "COMPUTE_SHADER_READ_UNIFORM_BUFFER"),
            (t[(t.COMPUTE_SHADER_READ_TEXTURE = 16384)] =
              "COMPUTE_SHADER_READ_TEXTURE"),
            (t[(t.COMPUTE_SHADER_READ_OTHER = 32768)] =
              "COMPUTE_SHADER_READ_OTHER"),
            (t[(t.TRANSFER_READ = 65536)] = "TRANSFER_READ"),
            (t[(t.HOST_READ = 131072)] = "HOST_READ"),
            (t[(t.PRESENT = 262144)] = "PRESENT"),
            (t[(t.VERTEX_SHADER_WRITE = 524288)] = "VERTEX_SHADER_WRITE"),
            (t[(t.FRAGMENT_SHADER_WRITE = 1048576)] = "FRAGMENT_SHADER_WRITE"),
            (t[(t.COLOR_ATTACHMENT_WRITE = 2097152)] =
              "COLOR_ATTACHMENT_WRITE"),
            (t[(t.DEPTH_STENCIL_ATTACHMENT_WRITE = 4194304)] =
              "DEPTH_STENCIL_ATTACHMENT_WRITE"),
            (t[(t.COMPUTE_SHADER_WRITE = 8388608)] = "COMPUTE_SHADER_WRITE"),
            (t[(t.TRANSFER_WRITE = 16777216)] = "TRANSFER_WRITE"),
            (t[(t.HOST_PREINITIALIZED = 33554432)] = "HOST_PREINITIALIZED"),
            (t[(t.HOST_WRITE = 67108864)] = "HOST_WRITE");
        })(kc || (kc = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.SAMPLE_ZERO = 1)] = "SAMPLE_ZERO"),
            (t[(t.AVERAGE = 2)] = "AVERAGE"),
            (t[(t.MIN = 3)] = "MIN"),
            (t[(t.MAX = 4)] = "MAX");
        })(zc || (zc = {})),
        (function (t) {
          (t[(t.GRAPHICS = 0)] = "GRAPHICS"),
            (t[(t.COMPUTE = 1)] = "COMPUTE"),
            (t[(t.RAY_TRACING = 2)] = "RAY_TRACING");
        })(Hc || (Hc = {})),
        (function (t) {
          (t[(t.POINT_LIST = 0)] = "POINT_LIST"),
            (t[(t.LINE_LIST = 1)] = "LINE_LIST"),
            (t[(t.LINE_STRIP = 2)] = "LINE_STRIP"),
            (t[(t.LINE_LOOP = 3)] = "LINE_LOOP"),
            (t[(t.LINE_LIST_ADJACENCY = 4)] = "LINE_LIST_ADJACENCY"),
            (t[(t.LINE_STRIP_ADJACENCY = 5)] = "LINE_STRIP_ADJACENCY"),
            (t[(t.ISO_LINE_LIST = 6)] = "ISO_LINE_LIST"),
            (t[(t.TRIANGLE_LIST = 7)] = "TRIANGLE_LIST"),
            (t[(t.TRIANGLE_STRIP = 8)] = "TRIANGLE_STRIP"),
            (t[(t.TRIANGLE_FAN = 9)] = "TRIANGLE_FAN"),
            (t[(t.TRIANGLE_LIST_ADJACENCY = 10)] = "TRIANGLE_LIST_ADJACENCY"),
            (t[(t.TRIANGLE_STRIP_ADJACENCY = 11)] = "TRIANGLE_STRIP_ADJACENCY"),
            (t[(t.TRIANGLE_PATCH_ADJACENCY = 12)] = "TRIANGLE_PATCH_ADJACENCY"),
            (t[(t.QUAD_PATCH_LIST = 13)] = "QUAD_PATCH_LIST");
        })(Gc || (Gc = {})),
        (function (t) {
          (t[(t.FILL = 0)] = "FILL"),
            (t[(t.POINT = 1)] = "POINT"),
            (t[(t.LINE = 2)] = "LINE");
        })(Vc || (Vc = {})),
        (function (t) {
          (t[(t.GOURAND = 0)] = "GOURAND"), (t[(t.FLAT = 1)] = "FLAT");
        })(jc || (jc = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.FRONT = 1)] = "FRONT"),
            (t[(t.BACK = 2)] = "BACK");
        })(Wc || (Wc = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.LINE_WIDTH = 1)] = "LINE_WIDTH"),
            (t[(t.DEPTH_BIAS = 2)] = "DEPTH_BIAS"),
            (t[(t.BLEND_CONSTANTS = 4)] = "BLEND_CONSTANTS"),
            (t[(t.DEPTH_BOUNDS = 8)] = "DEPTH_BOUNDS"),
            (t[(t.STENCIL_WRITE_MASK = 16)] = "STENCIL_WRITE_MASK"),
            (t[(t.STENCIL_COMPARE_MASK = 32)] = "STENCIL_COMPARE_MASK");
        })(Xc || (Xc = {})),
        (function (t) {
          (t[(t.FRONT = 1)] = "FRONT"),
            (t[(t.BACK = 2)] = "BACK"),
            (t[(t.ALL = 3)] = "ALL");
        })(Yc || (Yc = {})),
        (function (t) {
          (t[(t.UNKNOWN = 0)] = "UNKNOWN"),
            (t[(t.UNIFORM_BUFFER = 1)] = "UNIFORM_BUFFER"),
            (t[(t.DYNAMIC_UNIFORM_BUFFER = 2)] = "DYNAMIC_UNIFORM_BUFFER"),
            (t[(t.STORAGE_BUFFER = 4)] = "STORAGE_BUFFER"),
            (t[(t.DYNAMIC_STORAGE_BUFFER = 8)] = "DYNAMIC_STORAGE_BUFFER"),
            (t[(t.SAMPLER_TEXTURE = 16)] = "SAMPLER_TEXTURE"),
            (t[(t.SAMPLER = 32)] = "SAMPLER"),
            (t[(t.TEXTURE = 64)] = "TEXTURE"),
            (t[(t.STORAGE_IMAGE = 128)] = "STORAGE_IMAGE"),
            (t[(t.INPUT_ATTACHMENT = 256)] = "INPUT_ATTACHMENT");
        })(Kc || (Kc = {})),
        (function (t) {
          (t[(t.GRAPHICS = 0)] = "GRAPHICS"),
            (t[(t.COMPUTE = 1)] = "COMPUTE"),
            (t[(t.TRANSFER = 2)] = "TRANSFER");
        })(qc || (qc = {})),
        (function (t) {
          (t[(t.OCCLUSION = 0)] = "OCCLUSION"),
            (t[(t.PIPELINE_STATISTICS = 1)] = "PIPELINE_STATISTICS"),
            (t[(t.TIMESTAMP = 2)] = "TIMESTAMP");
        })($c || ($c = {})),
        (function (t) {
          (t[(t.PRIMARY = 0)] = "PRIMARY"),
            (t[(t.SECONDARY = 1)] = "SECONDARY");
        })(Zc || (Zc = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.COLOR = 1)] = "COLOR"),
            (t[(t.DEPTH = 2)] = "DEPTH"),
            (t[(t.STENCIL = 4)] = "STENCIL"),
            (t[(t.DEPTH_STENCIL = 6)] = "DEPTH_STENCIL"),
            (t[(t.ALL = 7)] = "ALL");
        })(Qc || (Qc = {})),
        (function (t) {
          (t[(t.FULL = 0)] = "FULL"),
            (t[(t.SPLIT_BEGIN = 1)] = "SPLIT_BEGIN"),
            (t[(t.SPLIT_END = 2)] = "SPLIT_END");
        })(Jc || (Jc = {})),
        (function (t) {
          (t[(t.RASTER = 0)] = "RASTER"),
            (t[(t.COMPUTE = 1)] = "COMPUTE"),
            (t[(t.COPY = 2)] = "COPY"),
            (t[(t.MOVE = 3)] = "MOVE"),
            (t[(t.RAYTRACE = 4)] = "RAYTRACE"),
            (t[(t.PRESENT = 5)] = "PRESENT");
        })(tu || (tu = {}));
      class iu {
        constructor(t = 0, e = 0, i = 0) {
          (this.x = t), (this.y = e), (this.z = i);
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
        }
      }
      class su {
        constructor(
          t = 0,
          e = 0,
          i = 0,
          s = 0,
          n = 0,
          r = 0,
          a = 0,
          o = 0,
          h = 0,
          l = 0,
          c = 0,
          u = 0,
          _ = 0,
          d = 0,
          p = 0,
          m = 1,
          f = 0,
          g = 0,
          y = new iu(),
          T = new iu(),
          S = !1,
          E = -1,
          v = 1,
          b = 1
        ) {
          (this.maxVertexAttributes = t),
            (this.maxVertexUniformVectors = e),
            (this.maxFragmentUniformVectors = i),
            (this.maxTextureUnits = s),
            (this.maxImageUnits = n),
            (this.maxVertexTextureUnits = r),
            (this.maxColorRenderTargets = a),
            (this.maxShaderStorageBufferBindings = o),
            (this.maxShaderStorageBlockSize = h),
            (this.maxUniformBufferBindings = l),
            (this.maxUniformBlockSize = c),
            (this.maxTextureSize = u),
            (this.maxCubeMapTextureSize = _),
            (this.maxArrayTextureLayers = d),
            (this.max3DTextureSize = p),
            (this.uboOffsetAlignment = m),
            (this.maxComputeSharedMemorySize = f),
            (this.maxComputeWorkGroupInvocations = g),
            (this.maxComputeWorkGroupSize = y),
            (this.maxComputeWorkGroupCount = T),
            (this.supportQuery = S),
            (this.clipSpaceMinZ = E),
            (this.screenSpaceSignY = v),
            (this.clipSpaceSignY = b);
        }
        copy(t) {
          return (
            (this.maxVertexAttributes = t.maxVertexAttributes),
            (this.maxVertexUniformVectors = t.maxVertexUniformVectors),
            (this.maxFragmentUniformVectors = t.maxFragmentUniformVectors),
            (this.maxTextureUnits = t.maxTextureUnits),
            (this.maxImageUnits = t.maxImageUnits),
            (this.maxVertexTextureUnits = t.maxVertexTextureUnits),
            (this.maxColorRenderTargets = t.maxColorRenderTargets),
            (this.maxShaderStorageBufferBindings =
              t.maxShaderStorageBufferBindings),
            (this.maxShaderStorageBlockSize = t.maxShaderStorageBlockSize),
            (this.maxUniformBufferBindings = t.maxUniformBufferBindings),
            (this.maxUniformBlockSize = t.maxUniformBlockSize),
            (this.maxTextureSize = t.maxTextureSize),
            (this.maxCubeMapTextureSize = t.maxCubeMapTextureSize),
            (this.maxArrayTextureLayers = t.maxArrayTextureLayers),
            (this.max3DTextureSize = t.max3DTextureSize),
            (this.uboOffsetAlignment = t.uboOffsetAlignment),
            (this.maxComputeSharedMemorySize = t.maxComputeSharedMemorySize),
            (this.maxComputeWorkGroupInvocations =
              t.maxComputeWorkGroupInvocations),
            this.maxComputeWorkGroupSize.copy(t.maxComputeWorkGroupSize),
            this.maxComputeWorkGroupCount.copy(t.maxComputeWorkGroupCount),
            (this.supportQuery = t.supportQuery),
            (this.clipSpaceMinZ = t.clipSpaceMinZ),
            (this.screenSpaceSignY = t.screenSpaceSignY),
            (this.clipSpaceSignY = t.clipSpaceSignY),
            this
          );
        }
      }
      class nu {
        constructor(t = !0) {
          this.enableBarrierDeduce = t;
        }
        copy(t) {
          return (this.enableBarrierDeduce = t.enableBarrierDeduce), this;
        }
      }
      class ru {
        constructor(t = 0, e = 0, i = 0) {
          (this.x = t), (this.y = e), (this.z = i);
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
        }
      }
      class au {
        constructor(t = 0, e = 0, i = 0, s = 0) {
          (this.x = t), (this.y = e), (this.width = i), (this.height = s);
        }
        copy(t) {
          return (
            (this.x = t.x),
            (this.y = t.y),
            (this.width = t.width),
            (this.height = t.height),
            this
          );
        }
      }
      class ou {
        constructor(t = 0, e = 0, i = 1) {
          (this.width = t), (this.height = e), (this.depth = i);
        }
        copy(t) {
          return (
            (this.width = t.width),
            (this.height = t.height),
            (this.depth = t.depth),
            this
          );
        }
      }
      class hu {
        constructor(t = 0, e = 0, i = 1) {
          (this.mipLevel = t), (this.baseArrayLayer = e), (this.layerCount = i);
        }
        copy(t) {
          return (
            (this.mipLevel = t.mipLevel),
            (this.baseArrayLayer = t.baseArrayLayer),
            (this.layerCount = t.layerCount),
            this
          );
        }
      }
      class lu {
        constructor(t = 0, e = 1, i = 0, s = 1) {
          (this.baseMipLevel = t),
            (this.levelCount = e),
            (this.baseArrayLayer = i),
            (this.layerCount = s);
        }
        copy(t) {
          return (
            (this.baseMipLevel = t.baseMipLevel),
            (this.levelCount = t.levelCount),
            (this.baseArrayLayer = t.baseArrayLayer),
            (this.layerCount = t.layerCount),
            this
          );
        }
      }
      class cu {
        constructor(
          t = new hu(),
          e = new ru(),
          i = new hu(),
          s = new ru(),
          n = new ou()
        ) {
          (this.srcSubres = t),
            (this.srcOffset = e),
            (this.dstSubres = i),
            (this.dstOffset = s),
            (this.extent = n);
        }
        copy(t) {
          return (
            this.srcSubres.copy(t.srcSubres),
            this.srcOffset.copy(t.srcOffset),
            this.dstSubres.copy(t.dstSubres),
            this.dstOffset.copy(t.dstOffset),
            this.extent.copy(t.extent),
            this
          );
        }
      }
      class uu {
        constructor(
          t = new hu(),
          e = new ru(),
          i = new ou(),
          s = new hu(),
          n = new ru(),
          r = new ou()
        ) {
          (this.srcSubres = t),
            (this.srcOffset = e),
            (this.srcExtent = i),
            (this.dstSubres = s),
            (this.dstOffset = n),
            (this.dstExtent = r);
        }
        copy(t) {
          return (
            this.srcSubres.copy(t.srcSubres),
            this.srcOffset.copy(t.srcOffset),
            this.srcExtent.copy(t.srcExtent),
            this.dstSubres.copy(t.dstSubres),
            this.dstOffset.copy(t.dstOffset),
            this.dstExtent.copy(t.dstExtent),
            this
          );
        }
      }
      class _u {
        constructor(
          t = 0,
          e = 0,
          i = 0,
          s = new ru(),
          n = new ou(),
          r = new hu()
        ) {
          (this.buffOffset = t),
            (this.buffStride = e),
            (this.buffTexHeight = i),
            (this.texOffset = s),
            (this.texExtent = n),
            (this.texSubres = r);
        }
        copy(t) {
          return (
            (this.buffOffset = t.buffOffset),
            (this.buffStride = t.buffStride),
            (this.buffTexHeight = t.buffTexHeight),
            this.texOffset.copy(t.texOffset),
            this.texExtent.copy(t.texExtent),
            this.texSubres.copy(t.texSubres),
            this
          );
        }
      }
      class du {
        constructor(t = 0, e = 0, i = 0, s = 0, n = 0, r = 1) {
          (this.left = t),
            (this.top = e),
            (this.width = i),
            (this.height = s),
            (this.minDepth = n),
            (this.maxDepth = r);
        }
        copy(t) {
          return (
            (this.left = t.left),
            (this.top = t.top),
            (this.width = t.width),
            (this.height = t.height),
            (this.minDepth = t.minDepth),
            (this.maxDepth = t.maxDepth),
            this
          );
        }
        reset() {
          (this.left = 0),
            (this.top = 0),
            (this.width = 0),
            (this.height = 0),
            (this.minDepth = 0),
            (this.maxDepth = 1);
        }
      }
      class pu {
        constructor(t = 0, e = 0, i = 0, s = 0) {
          (this.x = t), (this.y = e), (this.z = i), (this.w = s);
        }
        copy(t) {
          return (
            (this.x = t.x), (this.y = t.y), (this.z = t.z), (this.w = t.w), this
          );
        }
        set(t, e, i, s) {
          return (this.x = t), (this.y = e), (this.z = i), (this.w = s), this;
        }
        reset() {
          (this.x = 0), (this.y = 0), (this.z = 0), (this.w = 0);
        }
      }
      class mu {
        constructor(
          t = [0],
          e = [0],
          i = [0],
          s = [0],
          n = [0],
          r = [0],
          a = [0],
          o = [0]
        ) {
          (this.maxBlockCounts = t),
            (this.maxSamplerTextureCounts = e),
            (this.maxSamplerCounts = i),
            (this.maxTextureCounts = s),
            (this.maxBufferCounts = n),
            (this.maxImageCounts = r),
            (this.maxSubpassInputCounts = a),
            (this.setIndices = o);
        }
        copy(t) {
          return (
            (this.maxBlockCounts = t.maxBlockCounts.slice()),
            (this.maxSamplerTextureCounts = t.maxSamplerTextureCounts.slice()),
            (this.maxSamplerCounts = t.maxSamplerCounts.slice()),
            (this.maxTextureCounts = t.maxTextureCounts.slice()),
            (this.maxBufferCounts = t.maxBufferCounts.slice()),
            (this.maxImageCounts = t.maxImageCounts.slice()),
            (this.maxSubpassInputCounts = t.maxSubpassInputCounts.slice()),
            (this.setIndices = t.setIndices.slice()),
            this
          );
        }
      }
      class fu {
        constructor(t = 0, e = null, i = wc.ON, s = 0, n = 0) {
          (this.windowId = t),
            (this.windowHandle = e),
            (this.vsyncMode = i),
            (this.width = s),
            (this.height = n);
        }
        copy(t) {
          return (
            (this.windowId = t.windowId),
            (this.windowHandle = t.windowHandle),
            (this.vsyncMode = t.vsyncMode),
            (this.width = t.width),
            (this.height = t.height),
            this
          );
        }
      }
      class gu {
        constructor(t = new mu()) {
          this.bindingMappingInfo = t;
        }
        copy(t) {
          return this.bindingMappingInfo.copy(t.bindingMappingInfo), this;
        }
      }
      class yu {
        constructor(t = Tc.NONE, e = vc.NONE, i = 0, s = 1, n = Sc.NONE) {
          (this.usage = t),
            (this.memUsage = e),
            (this.size = i),
            (this.stride = s),
            (this.flags = n);
        }
        copy(t) {
          return (
            (this.usage = t.usage),
            (this.memUsage = t.memUsage),
            (this.size = t.size),
            (this.stride = t.stride),
            (this.flags = t.flags),
            this
          );
        }
      }
      class Tu {
        constructor(t = null, e = 0, i = 0) {
          (this.buffer = t), (this.offset = e), (this.range = i);
        }
        copy(t) {
          return (
            (this.buffer = t.buffer),
            (this.offset = t.offset),
            (this.range = t.range),
            this
          );
        }
      }
      class Su {
        constructor(t = 0, e = 0, i = 0, s = 0, n = 0, r = 0, a = 0) {
          (this.vertexCount = t),
            (this.firstVertex = e),
            (this.indexCount = i),
            (this.firstIndex = s),
            (this.vertexOffset = n),
            (this.instanceCount = r),
            (this.firstInstance = a);
        }
        copy(t) {
          return (
            (this.vertexCount = t.vertexCount),
            (this.firstVertex = t.firstVertex),
            (this.indexCount = t.indexCount),
            (this.firstIndex = t.firstIndex),
            (this.vertexOffset = t.vertexOffset),
            (this.instanceCount = t.instanceCount),
            (this.firstInstance = t.firstInstance),
            this
          );
        }
      }
      class Eu {
        constructor(t = 0, e = 0, i = 0, s = null, n = 0) {
          (this.groupCountX = t),
            (this.groupCountY = e),
            (this.groupCountZ = i),
            (this.indirectBuffer = s),
            (this.indirectOffset = n);
        }
        copy(t) {
          return (
            (this.groupCountX = t.groupCountX),
            (this.groupCountY = t.groupCountY),
            (this.groupCountZ = t.groupCountZ),
            (this.indirectBuffer = t.indirectBuffer),
            (this.indirectOffset = t.indirectOffset),
            this
          );
        }
      }
      class vu {
        constructor(t = []) {
          this.drawInfos = t;
        }
        copy(t) {
          return cc(this.drawInfos, t.drawInfos, Su), this;
        }
      }
      class bu {
        constructor(
          t = bc.TEX2D,
          e = Ac.NONE,
          i = fc.UNKNOWN,
          s = 0,
          n = 0,
          r = Cc.NONE,
          a = 1,
          o = 1,
          h = Ic.X1,
          l = 1,
          c = 0
        ) {
          (this.type = t),
            (this.usage = e),
            (this.format = i),
            (this.width = s),
            (this.height = n),
            (this.flags = r),
            (this.layerCount = a),
            (this.levelCount = o),
            (this.samples = h),
            (this.depth = l),
            (this.externalRes = c);
        }
        copy(t) {
          return (
            (this.type = t.type),
            (this.usage = t.usage),
            (this.format = t.format),
            (this.width = t.width),
            (this.height = t.height),
            (this.flags = t.flags),
            (this.layerCount = t.layerCount),
            (this.levelCount = t.levelCount),
            (this.samples = t.samples),
            (this.depth = t.depth),
            (this.externalRes = t.externalRes),
            this
          );
        }
      }
      class Au {
        constructor(
          t = null,
          e = bc.TEX2D,
          i = fc.UNKNOWN,
          s = 0,
          n = 1,
          r = 0,
          a = 1
        ) {
          (this.texture = t),
            (this.type = e),
            (this.format = i),
            (this.baseLevel = s),
            (this.levelCount = n),
            (this.baseLayer = r),
            (this.layerCount = a);
        }
        copy(t) {
          return (
            (this.texture = t.texture),
            (this.type = t.type),
            (this.format = t.format),
            (this.baseLevel = t.baseLevel),
            (this.levelCount = t.levelCount),
            (this.baseLayer = t.baseLayer),
            (this.layerCount = t.layerCount),
            this
          );
        }
      }
      class Cu {
        constructor(
          t = Rc.LINEAR,
          e = Rc.LINEAR,
          i = Rc.NONE,
          s = Dc.WRAP,
          n = Dc.WRAP,
          r = Dc.WRAP,
          a = 0,
          o = xc.ALWAYS
        ) {
          (this.minFilter = t),
            (this.magFilter = e),
            (this.mipFilter = i),
            (this.addressU = s),
            (this.addressV = n),
            (this.addressW = r),
            (this.maxAnisotropy = a),
            (this.cmpFunc = o);
        }
        copy(t) {
          return (
            (this.minFilter = t.minFilter),
            (this.magFilter = t.magFilter),
            (this.mipFilter = t.mipFilter),
            (this.addressU = t.addressU),
            (this.addressV = t.addressV),
            (this.addressW = t.addressW),
            (this.maxAnisotropy = t.maxAnisotropy),
            (this.cmpFunc = t.cmpFunc),
            this
          );
        }
      }
      class Ou {
        constructor(t = "", e = yc.UNKNOWN, i = 0) {
          (this.name = t), (this.type = e), (this.count = i);
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.type = t.type),
            (this.count = t.count),
            this
          );
        }
      }
      class Iu {
        constructor(t = 0, e = 0, i = "", s = [], n = 0, r = 0) {
          (this.set = t),
            (this.binding = e),
            (this.name = i),
            (this.members = s),
            (this.count = n),
            (this.flattened = r);
        }
        copy(t) {
          return (
            (this.set = t.set),
            (this.binding = t.binding),
            (this.name = t.name),
            cc(this.members, t.members, Ou),
            (this.count = t.count),
            (this.flattened = t.flattened),
            this
          );
        }
      }
      class wu {
        constructor(t = 0, e = 0, i = "", s = yc.UNKNOWN, n = 0, r = 0) {
          (this.set = t),
            (this.binding = e),
            (this.name = i),
            (this.type = s),
            (this.count = n),
            (this.flattened = r);
        }
        copy(t) {
          return (
            (this.set = t.set),
            (this.binding = t.binding),
            (this.name = t.name),
            (this.type = t.type),
            (this.count = t.count),
            (this.flattened = t.flattened),
            this
          );
        }
      }
      class Ru {
        constructor(t = 0, e = 0, i = "", s = 0, n = 0) {
          (this.set = t),
            (this.binding = e),
            (this.name = i),
            (this.count = s),
            (this.flattened = n);
        }
        copy(t) {
          return (
            (this.set = t.set),
            (this.binding = t.binding),
            (this.name = t.name),
            (this.count = t.count),
            (this.flattened = t.flattened),
            this
          );
        }
      }
      class Du {
        constructor(t = 0, e = 0, i = "", s = yc.UNKNOWN, n = 0, r = 0) {
          (this.set = t),
            (this.binding = e),
            (this.name = i),
            (this.type = s),
            (this.count = n),
            (this.flattened = r);
        }
        copy(t) {
          return (
            (this.set = t.set),
            (this.binding = t.binding),
            (this.name = t.name),
            (this.type = t.type),
            (this.count = t.count),
            (this.flattened = t.flattened),
            this
          );
        }
      }
      class xu {
        constructor(
          t = 0,
          e = 0,
          i = "",
          s = yc.UNKNOWN,
          n = 0,
          r = Ec.READ_WRITE,
          a = 0
        ) {
          (this.set = t),
            (this.binding = e),
            (this.name = i),
            (this.type = s),
            (this.count = n),
            (this.memoryAccess = r),
            (this.flattened = a);
        }
        copy(t) {
          return (
            (this.set = t.set),
            (this.binding = t.binding),
            (this.name = t.name),
            (this.type = t.type),
            (this.count = t.count),
            (this.memoryAccess = t.memoryAccess),
            (this.flattened = t.flattened),
            this
          );
        }
      }
      class Mu {
        constructor(t = 0, e = 0, i = "", s = 0, n = Ec.READ_WRITE, r = 0) {
          (this.set = t),
            (this.binding = e),
            (this.name = i),
            (this.count = s),
            (this.memoryAccess = n),
            (this.flattened = r);
        }
        copy(t) {
          return (
            (this.set = t.set),
            (this.binding = t.binding),
            (this.name = t.name),
            (this.count = t.count),
            (this.memoryAccess = t.memoryAccess),
            (this.flattened = t.flattened),
            this
          );
        }
      }
      class Pu {
        constructor(t = 0, e = 0, i = "", s = 0, n = 0) {
          (this.set = t),
            (this.binding = e),
            (this.name = i),
            (this.count = s),
            (this.flattened = n);
        }
        copy(t) {
          return (
            (this.set = t.set),
            (this.binding = t.binding),
            (this.name = t.name),
            (this.count = t.count),
            (this.flattened = t.flattened),
            this
          );
        }
      }
      class Nu {
        constructor(t = Bc.NONE, e = "") {
          (this.stage = t), (this.source = e);
        }
        copy(t) {
          return (this.stage = t.stage), (this.source = t.source), this;
        }
      }
      class Lu {
        constructor(t = "", e = fc.UNKNOWN, i = !1, s = 0, n = !1, r = 0) {
          (this.name = t),
            (this.format = e),
            (this.isNormalized = i),
            (this.stream = s),
            (this.isInstanced = n),
            (this.location = r);
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.format = t.format),
            (this.isNormalized = t.isNormalized),
            (this.stream = t.stream),
            (this.isInstanced = t.isInstanced),
            (this.location = t.location),
            this
          );
        }
      }
      class Bu {
        constructor(
          t = "",
          e = [],
          i = [],
          s = [],
          n = [],
          r = [],
          a = [],
          o = [],
          h = [],
          l = []
        ) {
          (this.name = t),
            (this.stages = e),
            (this.attributes = i),
            (this.blocks = s),
            (this.buffers = n),
            (this.samplerTextures = r),
            (this.samplers = a),
            (this.textures = o),
            (this.images = h),
            (this.subpassInputs = l);
        }
        copy(t) {
          return (
            (this.name = t.name),
            cc(this.stages, t.stages, Nu),
            cc(this.attributes, t.attributes, Lu),
            cc(this.blocks, t.blocks, Iu),
            cc(this.buffers, t.buffers, Mu),
            cc(this.samplerTextures, t.samplerTextures, wu),
            cc(this.samplers, t.samplers, Ru),
            cc(this.textures, t.textures, Du),
            cc(this.images, t.images, xu),
            cc(this.subpassInputs, t.subpassInputs, Pu),
            this
          );
        }
      }
      class Fu {
        constructor(t = [], e = [], i = null, s = null) {
          (this.attributes = t),
            (this.vertexBuffers = e),
            (this.indexBuffer = i),
            (this.indirectBuffer = s);
        }
        copy(t) {
          return (
            cc(this.attributes, t.attributes, Lu),
            (this.vertexBuffers = t.vertexBuffers.slice()),
            (this.indexBuffer = t.indexBuffer),
            (this.indirectBuffer = t.indirectBuffer),
            this
          );
        }
      }
      class Uu {
        constructor(
          t = fc.UNKNOWN,
          e = Ic.X1,
          i = Fc.CLEAR,
          s = Uc.STORE,
          n = null
        ) {
          (this.format = t),
            (this.sampleCount = e),
            (this.loadOp = i),
            (this.storeOp = s),
            (this.barrier = n);
        }
        copy(t) {
          return (
            (this.format = t.format),
            (this.sampleCount = t.sampleCount),
            (this.loadOp = t.loadOp),
            (this.storeOp = t.storeOp),
            (this.barrier = t.barrier),
            this
          );
        }
      }
      class ku {
        constructor(
          t = fc.UNKNOWN,
          e = Ic.X1,
          i = Fc.CLEAR,
          s = Uc.STORE,
          n = Fc.CLEAR,
          r = Uc.STORE,
          a = null
        ) {
          (this.format = t),
            (this.sampleCount = e),
            (this.depthLoadOp = i),
            (this.depthStoreOp = s),
            (this.stencilLoadOp = n),
            (this.stencilStoreOp = r),
            (this.barrier = a);
        }
        copy(t) {
          return (
            (this.format = t.format),
            (this.sampleCount = t.sampleCount),
            (this.depthLoadOp = t.depthLoadOp),
            (this.depthStoreOp = t.depthStoreOp),
            (this.stencilLoadOp = t.stencilLoadOp),
            (this.stencilStoreOp = t.stencilStoreOp),
            (this.barrier = t.barrier),
            this
          );
        }
      }
      class zu {
        constructor(
          t = [],
          e = [],
          i = [],
          s = [],
          n = -1,
          r = -1,
          a = zc.NONE,
          o = zc.NONE
        ) {
          (this.inputs = t),
            (this.colors = e),
            (this.resolves = i),
            (this.preserves = s),
            (this.depthStencil = n),
            (this.depthStencilResolve = r),
            (this.depthResolveMode = a),
            (this.stencilResolveMode = o);
        }
        copy(t) {
          return (
            (this.inputs = t.inputs.slice()),
            (this.colors = t.colors.slice()),
            (this.resolves = t.resolves.slice()),
            (this.preserves = t.preserves.slice()),
            (this.depthStencil = t.depthStencil),
            (this.depthStencilResolve = t.depthStencilResolve),
            (this.depthResolveMode = t.depthResolveMode),
            (this.stencilResolveMode = t.stencilResolveMode),
            this
          );
        }
      }
      class Hu {
        constructor(t = 0, e = 0, i = null, s = [kc.NONE], n = [kc.NONE]) {
          (this.srcSubpass = t),
            (this.dstSubpass = e),
            (this.generalBarrier = i),
            (this.prevAccesses = s),
            (this.nextAccesses = n);
        }
        copy(t) {
          return (
            (this.srcSubpass = t.srcSubpass),
            (this.dstSubpass = t.dstSubpass),
            (this.generalBarrier = t.generalBarrier),
            (this.prevAccesses = t.prevAccesses.slice()),
            (this.nextAccesses = t.nextAccesses.slice()),
            this
          );
        }
      }
      class Gu {
        constructor(t = [], e = null, i = null, s = [], n = []) {
          (this.colorAttachments = t),
            (this.depthStencilAttachment = e),
            (this.depthStencilResolveAttachment = i),
            (this.subpasses = s),
            (this.dependencies = n);
        }
        copy(t) {
          return (
            cc(this.colorAttachments, t.colorAttachments, Uu),
            t.depthStencilAttachment &&
              this.depthStencilAttachment &&
              this.depthStencilAttachment.copy(t.depthStencilAttachment),
            t.depthStencilResolveAttachment &&
              this.depthStencilResolveAttachment &&
              this.depthStencilResolveAttachment.copy(
                t.depthStencilResolveAttachment
              ),
            cc(this.subpasses, t.subpasses, zu),
            cc(this.dependencies, t.dependencies, Hu),
            this
          );
        }
      }
      class Vu {
        constructor(t = kc.NONE, e = kc.NONE, i = Jc.FULL) {
          (this.prevAccesses = t), (this.nextAccesses = e), (this.type = i);
        }
        copy(t) {
          return (
            (this.prevAccesses = t.prevAccesses),
            (this.nextAccesses = t.nextAccesses),
            (this.type = t.type),
            this
          );
        }
      }
      class ju {
        constructor(
          t = kc.NONE,
          e = kc.NONE,
          i = Jc.FULL,
          s = 0,
          n = 1,
          r = 0,
          a = 1,
          o = !1,
          h = null,
          l = null
        ) {
          (this.prevAccesses = t),
            (this.nextAccesses = e),
            (this.type = i),
            (this.baseMipLevel = s),
            (this.levelCount = n),
            (this.baseSlice = r),
            (this.sliceCount = a),
            (this.discardContents = o),
            (this.srcQueue = h),
            (this.dstQueue = l);
        }
        copy(t) {
          return (
            (this.prevAccesses = t.prevAccesses),
            (this.nextAccesses = t.nextAccesses),
            (this.type = t.type),
            (this.baseMipLevel = t.baseMipLevel),
            (this.levelCount = t.levelCount),
            (this.baseSlice = t.baseSlice),
            (this.sliceCount = t.sliceCount),
            (this.discardContents = t.discardContents),
            (this.srcQueue = t.srcQueue),
            (this.dstQueue = t.dstQueue),
            this
          );
        }
      }
      class Wu {
        constructor(
          t = kc.NONE,
          e = kc.NONE,
          i = Jc.FULL,
          s = 0,
          n = 0,
          r = !1,
          a = null,
          o = null
        ) {
          (this.prevAccesses = t),
            (this.nextAccesses = e),
            (this.type = i),
            (this.offset = s),
            (this.size = n),
            (this.discardContents = r),
            (this.srcQueue = a),
            (this.dstQueue = o);
        }
        copy(t) {
          return (
            (this.prevAccesses = t.prevAccesses),
            (this.nextAccesses = t.nextAccesses),
            (this.type = t.type),
            (this.offset = t.offset),
            (this.size = t.size),
            (this.discardContents = t.discardContents),
            (this.srcQueue = t.srcQueue),
            (this.dstQueue = t.dstQueue),
            this
          );
        }
      }
      class Xu {
        constructor(t = null, e = [], i = null, s = null) {
          (this.renderPass = t),
            (this.colorTextures = e),
            (this.depthStencilTexture = i),
            (this.depthStencilResolveTexture = s);
        }
        copy(t) {
          return (
            (this.renderPass = t.renderPass),
            (this.colorTextures = t.colorTextures.slice()),
            (this.depthStencilTexture = t.depthStencilTexture),
            (this.depthStencilResolveTexture = t.depthStencilResolveTexture),
            this
          );
        }
      }
      class Yu {
        constructor(t = -1, e = Kc.UNKNOWN, i = 0, s = Bc.NONE, n = []) {
          (this.binding = t),
            (this.descriptorType = e),
            (this.count = i),
            (this.stageFlags = s),
            (this.immutableSamplers = n);
        }
        copy(t) {
          return (
            (this.binding = t.binding),
            (this.descriptorType = t.descriptorType),
            (this.count = t.count),
            (this.stageFlags = t.stageFlags),
            (this.immutableSamplers = t.immutableSamplers.slice()),
            this
          );
        }
      }
      class Ku {
        constructor(t = []) {
          this.bindings = t;
        }
        copy(t) {
          return cc(this.bindings, t.bindings, Yu), this;
        }
        reset() {
          this.bindings.length = 0;
        }
      }
      class qu {
        constructor(t = null) {
          this.layout = t;
        }
        copy(t) {
          return (this.layout = t.layout), this;
        }
      }
      class $u {
        constructor(t = []) {
          this.setLayouts = t;
        }
        copy(t) {
          return (this.setLayouts = t.setLayouts.slice()), this;
        }
      }
      class Zu {
        constructor(t = []) {
          this.attributes = t;
        }
        copy(t) {
          return cc(this.attributes, t.attributes, Lu), this;
        }
      }
      class Qu {
        constructor(t = null, e = Zc.PRIMARY) {
          (this.queue = t), (this.type = e);
        }
        copy(t) {
          return (this.queue = t.queue), (this.type = t.type), this;
        }
      }
      class Ju {
        constructor(t = qc.GRAPHICS) {
          this.type = t;
        }
        copy(t) {
          return (this.type = t.type), this;
        }
      }
      class t_ {
        constructor(t = $c.OCCLUSION, e = 32767, i = !0) {
          (this.type = t), (this.maxQueryObjects = e), (this.forceWait = i);
        }
        copy(t) {
          return (
            (this.type = t.type),
            (this.maxQueryObjects = t.maxQueryObjects),
            (this.forceWait = t.forceWait),
            this
          );
        }
      }
      class e_ {
        constructor(
          t = "",
          e = 0,
          i = 0,
          s = gc.NONE,
          n = !1,
          r = !1,
          a = !1,
          o = !1
        ) {
          (this.name = t),
            (this.size = e),
            (this.count = i),
            (this.type = s),
            (this.hasAlpha = n),
            (this.hasDepth = r),
            (this.hasStencil = a),
            (this.isCompressed = o);
        }
      }
      class i_ {
        constructor(t = 0, e = 0) {
          (this.bufferSize = t), (this.textureSize = e);
        }
        copy(t) {
          return (
            (this.bufferSize = t.bufferSize),
            (this.textureSize = t.textureSize),
            this
          );
        }
      }
      class s_ {
        constructor(t = 0, e = 0, i = 0) {
          (this.writeMask = t), (this.compareMask = e), (this.reference = i);
        }
        copy(t) {
          return (
            (this.writeMask = t.writeMask),
            (this.compareMask = t.compareMask),
            (this.reference = t.reference),
            this
          );
        }
      }
      class n_ {
        constructor(
          t = new du(),
          e = new au(),
          i = new pu(),
          s = 1,
          n = 0,
          r = 0,
          a = 0,
          o = 0,
          h = 0,
          l = new s_(),
          c = new s_()
        ) {
          (this.viewport = t),
            (this.scissor = e),
            (this.blendConstant = i),
            (this.lineWidth = s),
            (this.depthBiasConstant = n),
            (this.depthBiasClamp = r),
            (this.depthBiasSlope = a),
            (this.depthMinBounds = o),
            (this.depthMaxBounds = h),
            (this.stencilStatesFront = l),
            (this.stencilStatesBack = c);
        }
        copy(t) {
          return (
            this.viewport.copy(t.viewport),
            this.scissor.copy(t.scissor),
            this.blendConstant.copy(t.blendConstant),
            (this.lineWidth = t.lineWidth),
            (this.depthBiasConstant = t.depthBiasConstant),
            (this.depthBiasClamp = t.depthBiasClamp),
            (this.depthBiasSlope = t.depthBiasSlope),
            (this.depthMinBounds = t.depthMinBounds),
            (this.depthMaxBounds = t.depthMaxBounds),
            this.stencilStatesFront.copy(t.stencilStatesFront),
            this.stencilStatesBack.copy(t.stencilStatesBack),
            this
          );
        }
      }
      class r_ extends ac {
        get objectType() {
          return this._objectType;
        }
        get objectID() {
          return this._objectID;
        }
        get typedID() {
          return this._typedID;
        }
        constructor(t) {
          super(),
            (this._objectType = uc.UNKNOWN),
            (this._objectID = 0),
            (this._typedID = 0),
            (this._objectType = t),
            (this._objectID = r_._idTable[uc.UNKNOWN]++),
            (this._typedID = r_._idTable[t]++);
        }
      }
      (r_._idTable = Array(uc.COUNT).fill(65536)),
        (function (t) {
          (t.ATTR_POSITION = "a_position"),
            (t.ATTR_NORMAL = "a_normal"),
            (t.ATTR_TANGENT = "a_tangent"),
            (t.ATTR_BITANGENT = "a_bitangent"),
            (t.ATTR_WEIGHTS = "a_weights"),
            (t.ATTR_JOINTS = "a_joints"),
            (t.ATTR_COLOR = "a_color"),
            (t.ATTR_COLOR1 = "a_color1"),
            (t.ATTR_COLOR2 = "a_color2"),
            (t.ATTR_TEX_COORD = "a_texCoord"),
            (t.ATTR_TEX_COORD1 = "a_texCoord1"),
            (t.ATTR_TEX_COORD2 = "a_texCoord2"),
            (t.ATTR_TEX_COORD3 = "a_texCoord3"),
            (t.ATTR_TEX_COORD4 = "a_texCoord4"),
            (t.ATTR_TEX_COORD5 = "a_texCoord5"),
            (t.ATTR_TEX_COORD6 = "a_texCoord6"),
            (t.ATTR_TEX_COORD7 = "a_texCoord7"),
            (t.ATTR_TEX_COORD8 = "a_texCoord8"),
            (t.ATTR_BATCH_ID = "a_batch_id"),
            (t.ATTR_BATCH_UV = "a_batch_uv");
        })(eu || (eu = {}));
      const a_ = Object.freeze([
          new e_("UNKNOWN", 0, 0, gc.NONE, !1, !1, !1, !1),
          new e_("A8", 1, 1, gc.UNORM, !0, !1, !1, !1),
          new e_("L8", 1, 1, gc.UNORM, !1, !1, !1, !1),
          new e_("LA8", 1, 2, gc.UNORM, !0, !1, !1, !1),
          new e_("R8", 1, 1, gc.UNORM, !1, !1, !1, !1),
          new e_("R8SN", 1, 1, gc.SNORM, !1, !1, !1, !1),
          new e_("R8UI", 1, 1, gc.UINT, !1, !1, !1, !1),
          new e_("R8I", 1, 1, gc.INT, !1, !1, !1, !1),
          new e_("R16F", 2, 1, gc.FLOAT, !1, !1, !1, !1),
          new e_("R16UI", 2, 1, gc.UINT, !1, !1, !1, !1),
          new e_("R16I", 2, 1, gc.INT, !1, !1, !1, !1),
          new e_("R32F", 4, 1, gc.FLOAT, !1, !1, !1, !1),
          new e_("R32UI", 4, 1, gc.UINT, !1, !1, !1, !1),
          new e_("R32I", 4, 1, gc.INT, !1, !1, !1, !1),
          new e_("RG8", 2, 2, gc.UNORM, !1, !1, !1, !1),
          new e_("RG8SN", 2, 2, gc.SNORM, !1, !1, !1, !1),
          new e_("RG8UI", 2, 2, gc.UINT, !1, !1, !1, !1),
          new e_("RG8I", 2, 2, gc.INT, !1, !1, !1, !1),
          new e_("RG16F", 4, 2, gc.FLOAT, !1, !1, !1, !1),
          new e_("RG16UI", 4, 2, gc.UINT, !1, !1, !1, !1),
          new e_("RG16I", 4, 2, gc.INT, !1, !1, !1, !1),
          new e_("RG32F", 8, 2, gc.FLOAT, !1, !1, !1, !1),
          new e_("RG32UI", 8, 2, gc.UINT, !1, !1, !1, !1),
          new e_("RG32I", 8, 2, gc.INT, !1, !1, !1, !1),
          new e_("RGB8", 3, 3, gc.UNORM, !1, !1, !1, !1),
          new e_("SRGB8", 3, 3, gc.UNORM, !1, !1, !1, !1),
          new e_("RGB8SN", 3, 3, gc.SNORM, !1, !1, !1, !1),
          new e_("RGB8UI", 3, 3, gc.UINT, !1, !1, !1, !1),
          new e_("RGB8I", 3, 3, gc.INT, !1, !1, !1, !1),
          new e_("RGB16F", 6, 3, gc.FLOAT, !1, !1, !1, !1),
          new e_("RGB16UI", 6, 3, gc.UINT, !1, !1, !1, !1),
          new e_("RGB16I", 6, 3, gc.INT, !1, !1, !1, !1),
          new e_("RGB32F", 12, 3, gc.FLOAT, !1, !1, !1, !1),
          new e_("RGB32UI", 12, 3, gc.UINT, !1, !1, !1, !1),
          new e_("RGB32I", 12, 3, gc.INT, !1, !1, !1, !1),
          new e_("RGBA8", 4, 4, gc.UNORM, !0, !1, !1, !1),
          new e_("BGRA8", 4, 4, gc.UNORM, !0, !1, !1, !1),
          new e_("SRGB8_A8", 4, 4, gc.UNORM, !0, !1, !1, !1),
          new e_("RGBA8SN", 4, 4, gc.SNORM, !0, !1, !1, !1),
          new e_("RGBA8UI", 4, 4, gc.UINT, !0, !1, !1, !1),
          new e_("RGBA8I", 4, 4, gc.INT, !0, !1, !1, !1),
          new e_("RGBA16F", 8, 4, gc.FLOAT, !0, !1, !1, !1),
          new e_("RGBA16UI", 8, 4, gc.UINT, !0, !1, !1, !1),
          new e_("RGBA16I", 8, 4, gc.INT, !0, !1, !1, !1),
          new e_("RGBA32F", 16, 4, gc.FLOAT, !0, !1, !1, !1),
          new e_("RGBA32UI", 16, 4, gc.UINT, !0, !1, !1, !1),
          new e_("RGBA32I", 16, 4, gc.INT, !0, !1, !1, !1),
          new e_("R5G6B5", 2, 3, gc.UNORM, !1, !1, !1, !1),
          new e_("R11G11B10F", 4, 3, gc.FLOAT, !1, !1, !1, !1),
          new e_("RGB5A1", 2, 4, gc.UNORM, !0, !1, !1, !1),
          new e_("RGBA4", 2, 4, gc.UNORM, !0, !1, !1, !1),
          new e_("RGB10A2", 2, 4, gc.UNORM, !0, !1, !1, !1),
          new e_("RGB10A2UI", 2, 4, gc.UINT, !0, !1, !1, !1),
          new e_("RGB9E5", 2, 4, gc.FLOAT, !0, !1, !1, !1),
          new e_("DEPTH", 4, 1, gc.FLOAT, !1, !0, !1, !1),
          new e_("DEPTH_STENCIL", 5, 2, gc.FLOAT, !1, !0, !0, !1),
          new e_("BC1", 1, 3, gc.UNORM, !1, !1, !1, !0),
          new e_("BC1_ALPHA", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("BC1_SRGB", 1, 3, gc.UNORM, !1, !1, !1, !0),
          new e_("BC1_SRGB_ALPHA", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("BC2", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("BC2_SRGB", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("BC3", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("BC3_SRGB", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("BC4", 1, 1, gc.UNORM, !1, !1, !1, !0),
          new e_("BC4_SNORM", 1, 1, gc.SNORM, !1, !1, !1, !0),
          new e_("BC5", 1, 2, gc.UNORM, !1, !1, !1, !0),
          new e_("BC5_SNORM", 1, 2, gc.SNORM, !1, !1, !1, !0),
          new e_("BC6H_UF16", 1, 3, gc.UFLOAT, !1, !1, !1, !0),
          new e_("BC6H_SF16", 1, 3, gc.FLOAT, !1, !1, !1, !0),
          new e_("BC7", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("BC7_SRGB", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ETC_RGB8", 1, 3, gc.UNORM, !1, !1, !1, !0),
          new e_("ETC2_RGB8", 1, 3, gc.UNORM, !1, !1, !1, !0),
          new e_("ETC2_SRGB8", 1, 3, gc.UNORM, !1, !1, !1, !0),
          new e_("ETC2_RGB8_A1", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ETC2_SRGB8_A1", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ETC2_RGBA8", 2, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ETC2_SRGB8_A8", 2, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("EAC_R11", 1, 1, gc.UNORM, !1, !1, !1, !0),
          new e_("EAC_R11SN", 1, 1, gc.SNORM, !1, !1, !1, !0),
          new e_("EAC_RG11", 2, 2, gc.UNORM, !1, !1, !1, !0),
          new e_("EAC_RG11SN", 2, 2, gc.SNORM, !1, !1, !1, !0),
          new e_("PVRTC_RGB2", 2, 3, gc.UNORM, !1, !1, !1, !0),
          new e_("PVRTC_RGBA2", 2, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("PVRTC_RGB4", 2, 3, gc.UNORM, !1, !1, !1, !0),
          new e_("PVRTC_RGBA4", 2, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("PVRTC2_2BPP", 2, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("PVRTC2_4BPP", 2, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_RGBA_4x4", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_RGBA_5x4", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_RGBA_5x5", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_RGBA_6x5", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_RGBA_6x6", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_RGBA_8x5", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_RGBA_8x6", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_RGBA_8x8", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_RGBA_10x5", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_RGBA_10x6", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_RGBA_10x8", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_RGBA_10x10", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_RGBA_12x10", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_RGBA_12x12", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_SRGBA_4x4", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_SRGBA_5x4", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_SRGBA_5x5", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_SRGBA_6x5", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_SRGBA_6x6", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_SRGBA_8x5", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_SRGBA_8x6", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_SRGBA_8x8", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_SRGBA_10x5", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_SRGBA_10x6", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_SRGBA_10x8", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_SRGBA_10x10", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_SRGBA_12x10", 1, 4, gc.UNORM, !0, !1, !1, !0),
          new e_("ASTC_SRGBA_12x12", 1, 4, gc.UNORM, !0, !1, !1, !0),
        ]),
        o_ =
          Kc.UNIFORM_BUFFER |
          Kc.DYNAMIC_UNIFORM_BUFFER |
          Kc.STORAGE_BUFFER |
          Kc.DYNAMIC_STORAGE_BUFFER,
        h_ =
          Kc.SAMPLER_TEXTURE |
          Kc.SAMPLER |
          Kc.TEXTURE |
          Kc.STORAGE_IMAGE |
          Kc.INPUT_ATTACHMENT,
        l_ = Kc.DYNAMIC_STORAGE_BUFFER | Kc.DYNAMIC_UNIFORM_BUFFER;
      function c_(t) {
        return t > 0 && 0 == (t & (t - 1));
      }
      function u_(t, e, i, s) {
        if (!a_[t].isCompressed) return e * i * s * a_[t].size;
        switch (t) {
          case fc.BC1:
          case fc.BC1_ALPHA:
          case fc.BC1_SRGB:
          case fc.BC1_SRGB_ALPHA:
            return Math.ceil(e / 4) * Math.ceil(i / 4) * 8 * s;
          case fc.BC2:
          case fc.BC2_SRGB:
          case fc.BC3:
          case fc.BC3_SRGB:
          case fc.BC4:
          case fc.BC4_SNORM:
          case fc.BC6H_SF16:
          case fc.BC6H_UF16:
          case fc.BC7:
          case fc.BC7_SRGB:
            return Math.ceil(e / 4) * Math.ceil(i / 4) * 16 * s;
          case fc.BC5:
          case fc.BC5_SNORM:
            return Math.ceil(e / 4) * Math.ceil(i / 4) * 32 * s;
          case fc.ETC_RGB8:
          case fc.ETC2_RGB8:
          case fc.ETC2_SRGB8:
          case fc.ETC2_RGB8_A1:
          case fc.EAC_R11:
          case fc.EAC_R11SN:
            return Math.ceil(e / 4) * Math.ceil(i / 4) * 8 * s;
          case fc.ETC2_RGBA8:
          case fc.ETC2_SRGB8_A1:
          case fc.EAC_RG11:
          case fc.EAC_RG11SN:
            return Math.ceil(e / 4) * Math.ceil(i / 4) * 16 * s;
          case fc.PVRTC_RGB2:
          case fc.PVRTC_RGBA2:
          case fc.PVRTC2_2BPP:
            return Math.ceil(e / 8) * Math.ceil(i / 4) * 8 * s;
          case fc.PVRTC_RGB4:
          case fc.PVRTC_RGBA4:
          case fc.PVRTC2_4BPP:
            return Math.ceil(e / 4) * Math.ceil(i / 4) * 8 * s;
          case fc.ASTC_RGBA_4X4:
          case fc.ASTC_SRGBA_4X4:
            return Math.ceil(e / 4) * Math.ceil(i / 4) * 16 * s;
          case fc.ASTC_RGBA_5X4:
          case fc.ASTC_SRGBA_5X4:
            return Math.ceil(e / 5) * Math.ceil(i / 4) * 16 * s;
          case fc.ASTC_RGBA_5X5:
          case fc.ASTC_SRGBA_5X5:
            return Math.ceil(e / 5) * Math.ceil(i / 5) * 16 * s;
          case fc.ASTC_RGBA_6X5:
          case fc.ASTC_SRGBA_6X5:
            return Math.ceil(e / 6) * Math.ceil(i / 5) * 16 * s;
          case fc.ASTC_RGBA_6X6:
          case fc.ASTC_SRGBA_6X6:
            return Math.ceil(e / 6) * Math.ceil(i / 6) * 16 * s;
          case fc.ASTC_RGBA_8X5:
          case fc.ASTC_SRGBA_8X5:
            return Math.ceil(e / 8) * Math.ceil(i / 5) * 16 * s;
          case fc.ASTC_RGBA_8X6:
          case fc.ASTC_SRGBA_8X6:
            return Math.ceil(e / 8) * Math.ceil(i / 6) * 16 * s;
          case fc.ASTC_RGBA_8X8:
          case fc.ASTC_SRGBA_8X8:
            return Math.ceil(e / 8) * Math.ceil(i / 8) * 16 * s;
          case fc.ASTC_RGBA_10X5:
          case fc.ASTC_SRGBA_10X5:
            return Math.ceil(e / 10) * Math.ceil(i / 5) * 16 * s;
          case fc.ASTC_RGBA_10X6:
          case fc.ASTC_SRGBA_10X6:
            return Math.ceil(e / 10) * Math.ceil(i / 6) * 16 * s;
          case fc.ASTC_RGBA_10X8:
          case fc.ASTC_SRGBA_10X8:
            return Math.ceil(e / 10) * Math.ceil(i / 8) * 16 * s;
          case fc.ASTC_RGBA_10X10:
          case fc.ASTC_SRGBA_10X10:
            return Math.ceil(e / 10) * Math.ceil(i / 10) * 16 * s;
          case fc.ASTC_RGBA_12X10:
          case fc.ASTC_SRGBA_12X10:
            return Math.ceil(e / 12) * Math.ceil(i / 10) * 16 * s;
          case fc.ASTC_RGBA_12X12:
          case fc.ASTC_SRGBA_12X12:
            return Math.ceil(e / 12) * Math.ceil(i / 12) * 16 * s;
          default:
            return 0;
        }
      }
      function __(t, e, i, s, n) {
        let r = 0;
        for (let a = 0; a < n; ++a)
          (r += u_(t, e, i, s)),
            (e = Math.max(e >> 1, 1)),
            (i = Math.max(i >> 1, 1));
        return r;
      }
      const d_ = [
        0, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 16, 24, 32,
        24, 36, 48, 32, 48, 64, 4, 4, 4, 4, 4, 4,
      ];
      function p_(t) {
        return d_[t] || 0;
      }
      function m_(t) {
        if (t.isCompressed) return Uint8Array;
        const e = t.size / t.count;
        switch (t.type) {
          case gc.UNORM:
          case gc.UINT:
            switch (e) {
              case 1:
                return Uint8Array;
              case 2:
                return Uint16Array;
              case 4:
                return Uint32Array;
              default:
                return Uint8Array;
            }
          case gc.SNORM:
          case gc.INT:
            switch (e) {
              case 1:
                return Int8Array;
              case 2:
                return Int16Array;
              case 4:
                return Int32Array;
              default:
                return Int8Array;
            }
          case gc.FLOAT:
            switch (e) {
              case 2:
                return Uint16Array;
              case 4:
              default:
                return Float32Array;
            }
        }
        return Float32Array;
      }
      function f_(t) {
        switch (t) {
          case fc.BC1:
          case fc.BC1_ALPHA:
          case fc.BC1_SRGB:
          case fc.BC1_SRGB_ALPHA:
          case fc.BC2:
          case fc.BC2_SRGB:
          case fc.BC3:
          case fc.BC3_SRGB:
          case fc.BC4:
          case fc.BC4_SNORM:
          case fc.BC6H_SF16:
          case fc.BC6H_UF16:
          case fc.BC7:
          case fc.BC7_SRGB:
          case fc.BC5:
          case fc.BC5_SNORM:
          case fc.ETC_RGB8:
          case fc.ETC2_RGB8:
          case fc.ETC2_SRGB8:
          case fc.ETC2_RGB8_A1:
          case fc.EAC_R11:
          case fc.EAC_R11SN:
          case fc.ETC2_RGBA8:
          case fc.ETC2_SRGB8_A1:
          case fc.EAC_RG11:
          case fc.EAC_RG11SN:
            return { width: 4, height: 4 };
          case fc.PVRTC_RGB2:
          case fc.PVRTC_RGBA2:
          case fc.PVRTC2_2BPP:
            return { width: 8, height: 4 };
          case fc.PVRTC_RGB4:
          case fc.PVRTC_RGBA4:
          case fc.PVRTC2_4BPP:
            return { width: 4, height: 4 };
          case fc.ASTC_RGBA_4X4:
          case fc.ASTC_SRGBA_4X4:
            return { width: 4, height: 4 };
          case fc.ASTC_RGBA_5X4:
          case fc.ASTC_SRGBA_5X4:
            return { width: 5, height: 4 };
          case fc.ASTC_RGBA_5X5:
          case fc.ASTC_SRGBA_5X5:
            return { width: 5, height: 5 };
          case fc.ASTC_RGBA_6X5:
          case fc.ASTC_SRGBA_6X5:
            return { width: 6, height: 5 };
          case fc.ASTC_RGBA_6X6:
          case fc.ASTC_SRGBA_6X6:
            return { width: 6, height: 6 };
          case fc.ASTC_RGBA_8X5:
          case fc.ASTC_SRGBA_8X5:
            return { width: 8, height: 5 };
          case fc.ASTC_RGBA_8X6:
          case fc.ASTC_SRGBA_8X6:
            return { width: 8, height: 6 };
          case fc.ASTC_RGBA_8X8:
          case fc.ASTC_SRGBA_8X8:
            return { width: 8, height: 8 };
          case fc.ASTC_RGBA_10X5:
          case fc.ASTC_SRGBA_10X5:
            return { width: 10, height: 5 };
          case fc.ASTC_RGBA_10X6:
          case fc.ASTC_SRGBA_10X6:
            return { width: 10, height: 6 };
          case fc.ASTC_RGBA_10X8:
          case fc.ASTC_SRGBA_10X8:
            return { width: 10, height: 8 };
          case fc.ASTC_RGBA_10X10:
          case fc.ASTC_SRGBA_10X10:
            return { width: 10, height: 10 };
          case fc.ASTC_RGBA_12X10:
          case fc.ASTC_SRGBA_12X10:
            return { width: 12, height: 10 };
          case fc.ASTC_RGBA_12X12:
          case fc.ASTC_SRGBA_12X12:
            return { width: 12, height: 12 };
          default:
            return { width: 1, height: 1 };
        }
      }
      function g_(t, e) {
        return Math.ceil(t / e) * e;
      }
      var y_ = Object.freeze({
        __proto__: null,
        get ObjectType() {
          return uc;
        },
        get Status() {
          return _c;
        },
        get API() {
          return dc;
        },
        get SurfaceTransform() {
          return pc;
        },
        get Feature() {
          return mc;
        },
        get Format() {
          return fc;
        },
        get FormatType() {
          return gc;
        },
        get Type() {
          return yc;
        },
        get BufferUsageBit() {
          return Tc;
        },
        get BufferFlagBit() {
          return Sc;
        },
        get MemoryAccessBit() {
          return Ec;
        },
        get MemoryUsageBit() {
          return vc;
        },
        get TextureType() {
          return bc;
        },
        get TextureUsageBit() {
          return Ac;
        },
        get TextureFlagBit() {
          return Cc;
        },
        get FormatFeatureBit() {
          return Oc;
        },
        get SampleCount() {
          return Ic;
        },
        get VsyncMode() {
          return wc;
        },
        get Filter() {
          return Rc;
        },
        get Address() {
          return Dc;
        },
        get ComparisonFunc() {
          return xc;
        },
        get StencilOp() {
          return Mc;
        },
        get BlendFactor() {
          return Pc;
        },
        get BlendOp() {
          return Nc;
        },
        get ColorMask() {
          return Lc;
        },
        get ShaderStageFlagBit() {
          return Bc;
        },
        get LoadOp() {
          return Fc;
        },
        get StoreOp() {
          return Uc;
        },
        get AccessFlagBit() {
          return kc;
        },
        get ResolveMode() {
          return zc;
        },
        get PipelineBindPoint() {
          return Hc;
        },
        get PrimitiveMode() {
          return Gc;
        },
        get PolygonMode() {
          return Vc;
        },
        get ShadeModel() {
          return jc;
        },
        get CullMode() {
          return Wc;
        },
        get DynamicStateFlagBit() {
          return Xc;
        },
        get StencilFace() {
          return Yc;
        },
        get DescriptorType() {
          return Kc;
        },
        get QueueType() {
          return qc;
        },
        get QueryType() {
          return $c;
        },
        get CommandBufferType() {
          return Zc;
        },
        get ClearFlagBit() {
          return Qc;
        },
        get BarrierType() {
          return Jc;
        },
        get PassType() {
          return tu;
        },
        Size: iu,
        DeviceCaps: su,
        DeviceOptions: nu,
        Offset: ru,
        Rect: au,
        Extent: ou,
        TextureSubresLayers: hu,
        TextureSubresRange: lu,
        TextureCopy: cu,
        TextureBlit: uu,
        BufferTextureCopy: _u,
        Viewport: du,
        Color: pu,
        BindingMappingInfo: mu,
        SwapchainInfo: fu,
        DeviceInfo: gu,
        BufferInfo: yu,
        BufferViewInfo: Tu,
        DrawInfo: Su,
        DispatchInfo: Eu,
        IndirectBuffer: vu,
        TextureInfo: bu,
        TextureViewInfo: Au,
        SamplerInfo: Cu,
        Uniform: Ou,
        UniformBlock: Iu,
        UniformSamplerTexture: wu,
        UniformSampler: Ru,
        UniformTexture: Du,
        UniformStorageImage: xu,
        UniformStorageBuffer: Mu,
        UniformInputAttachment: Pu,
        ShaderStage: Nu,
        Attribute: Lu,
        ShaderInfo: Bu,
        InputAssemblerInfo: Fu,
        ColorAttachment: Uu,
        DepthStencilAttachment: ku,
        SubpassInfo: zu,
        SubpassDependency: Hu,
        RenderPassInfo: Gu,
        GeneralBarrierInfo: Vu,
        TextureBarrierInfo: ju,
        BufferBarrierInfo: Wu,
        FramebufferInfo: Xu,
        DescriptorSetLayoutBinding: Yu,
        DescriptorSetLayoutInfo: Ku,
        DescriptorSetInfo: qu,
        PipelineLayoutInfo: $u,
        InputState: Zu,
        CommandBufferInfo: Qu,
        QueueInfo: Ju,
        QueryPoolInfo: t_,
        FormatInfo: e_,
        MemoryStatus: i_,
        DynamicStencilStates: s_,
        DynamicStates: n_,
        GFXObject: r_,
        get AttributeName() {
          return eu;
        },
        FormatInfos: a_,
        DESCRIPTOR_BUFFER_TYPE: o_,
        DESCRIPTOR_SAMPLER_TYPE: h_,
        DESCRIPTOR_DYNAMIC_TYPE: l_,
        DRAW_INFO_SIZE: 28,
        IsPowerOf2: c_,
        FormatSize: u_,
        FormatSurfaceSize: __,
        GetTypeSize: p_,
        getTypedArrayConstructor: m_,
        formatAlignment: f_,
        alignTo: g_,
      });
      class T_ {
        constructor(
          t = !1,
          e = Vc.FILL,
          i = jc.GOURAND,
          s = Wc.BACK,
          n = !0,
          r = !1,
          a = 0,
          o = 0,
          h = 0,
          l = !0,
          c = !1,
          u = 1
        ) {
          (this._nativeObj = void 0),
            (this._isDiscard = !1),
            (this._polygonMode = Vc.FILL),
            (this._shadeModel = jc.GOURAND),
            (this._cullMode = Wc.BACK),
            (this._isFrontFaceCCW = !0),
            (this._depthBiasEnabled = !1),
            (this._depthBias = 0),
            (this._depthBiasClamp = 0),
            (this._depthBiasSlop = 0),
            (this._isDepthClip = !0),
            (this._isMultisample = !1),
            (this._lineWidth = 1),
            (this._nativeObj = new gfx.RasterizerState()),
            this.assignProperties(t, e, i, s, n, r, a, o, h, l, c, u);
        }
        get native() {
          return this._nativeObj;
        }
        get isDiscard() {
          return this._isDiscard;
        }
        set isDiscard(t) {
          (this._isDiscard = t), (this._nativeObj.isDiscard = t);
        }
        get polygonMode() {
          return this._polygonMode;
        }
        set polygonMode(t) {
          (this._polygonMode = t), (this._nativeObj.polygonMode = t);
        }
        get shadeModel() {
          return this._shadeModel;
        }
        set shadeModel(t) {
          (this._shadeModel = t), (this._nativeObj.shadeModel = t);
        }
        get cullMode() {
          return this._cullMode;
        }
        set cullMode(t) {
          (this._cullMode = t), (this._nativeObj.cullMode = t);
        }
        get isFrontFaceCCW() {
          return this._isFrontFaceCCW;
        }
        set isFrontFaceCCW(t) {
          (this._isFrontFaceCCW = t), (this._nativeObj.isFrontFaceCCW = t);
        }
        get depthBiasEnabled() {
          return this._depthBiasEnabled;
        }
        set depthBiasEnabled(t) {
          (this._depthBiasEnabled = t), (this._nativeObj.depthBiasEnabled = t);
        }
        get depthBias() {
          return this._depthBias;
        }
        set depthBias(t) {
          (this._depthBias = t), (this._nativeObj.depthBias = t);
        }
        get depthBiasClamp() {
          return this._depthBiasClamp;
        }
        set depthBiasClamp(t) {
          (this._depthBiasClamp = t), (this._nativeObj.depthBiasClamp = t);
        }
        get depthBiasSlop() {
          return this._depthBiasSlop;
        }
        set depthBiasSlop(t) {
          (this._depthBiasSlop = t), (this._nativeObj.depthBiasSlop = t);
        }
        get isDepthClip() {
          return this._isDepthClip;
        }
        set isDepthClip(t) {
          (this._isDepthClip = t), (this._nativeObj.isDepthClip = t);
        }
        get isMultisample() {
          return this._isMultisample;
        }
        set isMultisample(t) {
          (this._isMultisample = t), (this._nativeObj.isMultisample = t);
        }
        get lineWidth() {
          return this._lineWidth;
        }
        set lineWidth(t) {
          (this._lineWidth = t), (this._nativeObj.lineWidth = t);
        }
        reset() {
          this.assignProperties(
            !1,
            Vc.FILL,
            jc.GOURAND,
            Wc.BACK,
            !0,
            !1,
            0,
            0,
            0,
            !0,
            !1,
            1
          );
        }
        assign(t) {
          t &&
            this.assignProperties(
              t.isDiscard,
              t.polygonMode,
              t.shadeModel,
              t.cullMode,
              t.isFrontFaceCCW,
              t.depthBiasEnabled,
              t.depthBias,
              t.depthBiasClamp,
              t.depthBiasSlop,
              t.isDepthClip,
              t.isMultisample,
              t.lineWidth
            );
        }
        destroy() {
          this._nativeObj = null;
        }
        assignProperties(t, e, i, s, n, r, a, o, h, l, c, u) {
          void 0 !== t && (this.isDiscard = t),
            void 0 !== e && (this.polygonMode = e),
            void 0 !== i && (this.shadeModel = i),
            void 0 !== s && (this.cullMode = s),
            void 0 !== n && (this.isFrontFaceCCW = n),
            void 0 !== r && (this.depthBiasEnabled = r),
            void 0 !== a && (this.depthBias = a),
            void 0 !== o && (this.depthBiasClamp = o),
            void 0 !== h && (this.depthBiasSlop = h),
            void 0 !== l && (this.isDepthClip = l),
            void 0 !== c && (this.isMultisample = c),
            void 0 !== u && (this.lineWidth = u);
        }
      }
      class S_ {
        constructor(
          t = !0,
          e = !0,
          i = xc.LESS,
          s = !1,
          n = xc.ALWAYS,
          r = 65535,
          a = 65535,
          o = Mc.KEEP,
          h = Mc.KEEP,
          l = Mc.KEEP,
          c = 1,
          u = !1,
          _ = xc.ALWAYS,
          d = 65535,
          p = 65535,
          m = Mc.KEEP,
          f = Mc.KEEP,
          g = Mc.KEEP,
          y = 1
        ) {
          (this._nativeObj = void 0),
            (this._depthTest = !0),
            (this._depthWrite = !0),
            (this._depthFunc = xc.LESS),
            (this._stencilTestFront = !1),
            (this._stencilFuncFront = xc.ALWAYS),
            (this._stencilReadMaskFront = 65535),
            (this._stencilWriteMaskFront = 65535),
            (this._stencilFailOpFront = Mc.KEEP),
            (this._stencilZFailOpFront = Mc.KEEP),
            (this._stencilPassOpFront = Mc.KEEP),
            (this._stencilRefFront = 1),
            (this._stencilTestBack = !1),
            (this._stencilFuncBack = xc.ALWAYS),
            (this._stencilReadMaskBack = 65535),
            (this._stencilWriteMaskBack = 65535),
            (this._stencilFailOpBack = Mc.KEEP),
            (this._stencilZFailOpBack = Mc.KEEP),
            (this._stencilPassOpBack = Mc.KEEP),
            (this._stencilRefBack = 1),
            (this._nativeObj = new gfx.DepthStencilState()),
            this.assignProperties(
              t,
              e,
              i,
              s,
              n,
              r,
              a,
              o,
              h,
              l,
              c,
              u,
              _,
              d,
              p,
              m,
              f,
              g,
              y
            );
        }
        get native() {
          return this._nativeObj;
        }
        get depthTest() {
          return this._depthTest;
        }
        set depthTest(t) {
          (this._depthTest = t), (this._nativeObj.depthTest = t);
        }
        get depthWrite() {
          return this._depthWrite;
        }
        set depthWrite(t) {
          (this._depthWrite = t), (this._nativeObj.depthWrite = t);
        }
        get depthFunc() {
          return this._depthFunc;
        }
        set depthFunc(t) {
          (this._depthFunc = t), (this._nativeObj.depthFunc = t);
        }
        get stencilTestFront() {
          return this._stencilTestFront;
        }
        set stencilTestFront(t) {
          (this._stencilTestFront = t), (this._nativeObj.stencilTestFront = t);
        }
        get stencilFuncFront() {
          return this._stencilFuncFront;
        }
        set stencilFuncFront(t) {
          (this._stencilFuncFront = t), (this._nativeObj.stencilFuncFront = t);
        }
        get stencilReadMaskFront() {
          return this._stencilReadMaskFront;
        }
        set stencilReadMaskFront(t) {
          (this._stencilReadMaskFront = t),
            (this._nativeObj.stencilReadMaskFront = t);
        }
        get stencilWriteMaskFront() {
          return this._stencilWriteMaskFront;
        }
        set stencilWriteMaskFront(t) {
          (this._stencilWriteMaskFront = t),
            (this._nativeObj.stencilWriteMaskFront = t);
        }
        get stencilFailOpFront() {
          return this._stencilFailOpFront;
        }
        set stencilFailOpFront(t) {
          (this._stencilFailOpFront = t),
            (this._nativeObj.stencilFailOpFront = t);
        }
        get stencilZFailOpFront() {
          return this._stencilZFailOpFront;
        }
        set stencilZFailOpFront(t) {
          (this._stencilZFailOpFront = t),
            (this._nativeObj.stencilZFailOpFront = t);
        }
        get stencilPassOpFront() {
          return this._stencilPassOpFront;
        }
        set stencilPassOpFront(t) {
          (this._stencilPassOpFront = t),
            (this._nativeObj.stencilPassOpFront = t);
        }
        get stencilRefFront() {
          return this._stencilRefFront;
        }
        set stencilRefFront(t) {
          (this._stencilRefFront = t), (this._nativeObj.stencilRefFront = t);
        }
        get stencilTestBack() {
          return this._stencilTestBack;
        }
        set stencilTestBack(t) {
          (this._stencilTestBack = t), (this._nativeObj.stencilTestBack = t);
        }
        get stencilFuncBack() {
          return this._stencilFuncBack;
        }
        set stencilFuncBack(t) {
          (this._stencilFuncBack = t), (this._nativeObj.stencilFuncBack = t);
        }
        get stencilReadMaskBack() {
          return this._stencilReadMaskBack;
        }
        set stencilReadMaskBack(t) {
          (this._stencilReadMaskBack = t),
            (this._nativeObj.stencilReadMaskBack = t);
        }
        get stencilWriteMaskBack() {
          return this._stencilWriteMaskBack;
        }
        set stencilWriteMaskBack(t) {
          (this._stencilWriteMaskBack = t),
            (this._nativeObj.stencilWriteMaskBack = t);
        }
        get stencilFailOpBack() {
          return this._stencilFailOpBack;
        }
        set stencilFailOpBack(t) {
          (this._stencilFailOpBack = t),
            (this._nativeObj.stencilFailOpBack = t);
        }
        get stencilZFailOpBack() {
          return this._stencilZFailOpBack;
        }
        set stencilZFailOpBack(t) {
          (this._stencilZFailOpBack = t),
            (this._nativeObj.stencilZFailOpBack = t);
        }
        get stencilPassOpBack() {
          return this._stencilPassOpBack;
        }
        set stencilPassOpBack(t) {
          (this._stencilPassOpBack = t),
            (this._nativeObj.stencilPassOpBack = t);
        }
        get stencilRefBack() {
          return this._stencilRefBack;
        }
        set stencilRefBack(t) {
          (this._stencilRefBack = t), (this._nativeObj.stencilRefBack = t);
        }
        reset() {
          this.assignProperties(
            !0,
            !0,
            xc.LESS,
            !1,
            xc.ALWAYS,
            65535,
            65535,
            Mc.KEEP,
            Mc.KEEP,
            Mc.KEEP,
            1,
            !1,
            xc.ALWAYS,
            65535,
            65535,
            Mc.KEEP,
            Mc.KEEP,
            Mc.KEEP,
            1
          );
        }
        assign(t) {
          t &&
            this.assignProperties(
              t.depthTest,
              t.depthWrite,
              t.depthFunc,
              t.stencilTestFront,
              t.stencilFuncFront,
              t.stencilReadMaskFront,
              t.stencilWriteMaskFront,
              t.stencilFailOpFront,
              t.stencilZFailOpFront,
              t.stencilPassOpFront,
              t.stencilRefFront,
              t.stencilTestBack,
              t.stencilFuncBack,
              t.stencilReadMaskBack,
              t.stencilWriteMaskBack,
              t.stencilFailOpBack,
              t.stencilZFailOpBack,
              t.stencilPassOpBack,
              t.stencilRefBack
            );
        }
        destroy() {
          this._nativeObj = null;
        }
        assignProperties(
          t,
          e,
          i,
          s,
          n,
          r,
          a,
          o,
          h,
          l,
          c,
          u,
          _,
          d,
          p,
          m,
          f,
          g,
          y
        ) {
          void 0 !== t && (this.depthTest = t),
            void 0 !== e && (this.depthWrite = e),
            void 0 !== i && (this.depthFunc = i),
            void 0 !== s && (this.stencilTestFront = s),
            void 0 !== n && (this.stencilFuncFront = n),
            void 0 !== r && (this.stencilReadMaskFront = r),
            void 0 !== a && (this.stencilWriteMaskFront = a),
            void 0 !== o && (this.stencilFailOpFront = o),
            void 0 !== h && (this.stencilZFailOpFront = h),
            void 0 !== l && (this.stencilPassOpFront = l),
            void 0 !== c && (this.stencilRefFront = c),
            void 0 !== u && (this.stencilTestBack = u),
            void 0 !== _ && (this.stencilFuncBack = _),
            void 0 !== d && (this.stencilReadMaskBack = d),
            void 0 !== p && (this.stencilWriteMaskBack = p),
            void 0 !== m && (this.stencilFailOpBack = m),
            void 0 !== f && (this.stencilZFailOpBack = f),
            void 0 !== g && (this.stencilPassOpBack = g),
            void 0 !== y && (this.stencilRefBack = y);
        }
      }
      class E_ {
        get native() {
          return this._nativeObj;
        }
        constructor(
          t = !1,
          e = Pc.ONE,
          i = Pc.ZERO,
          s = Nc.ADD,
          n = Pc.ONE,
          r = Pc.ZERO,
          a = Nc.ADD,
          o = Lc.ALL
        ) {
          (this._nativeObj = void 0),
            (this._blend = !1),
            (this._blendSrc = Pc.ONE),
            (this._blendDst = Pc.ZERO),
            (this._blendEq = Nc.ADD),
            (this._blendSrcAlpha = Pc.ONE),
            (this._blendDstAlpha = Pc.ZERO),
            (this._blendAlphaEq = Nc.ADD),
            (this._blendColorMask = Lc.ALL),
            (this._nativeObj = new gfx.BlendTarget()),
            this.assignProperties(t, e, i, s, n, r, a, o);
        }
        get blend() {
          return this._blend;
        }
        set blend(t) {
          (this._blend = t), (this._nativeObj.blend = t);
        }
        get blendSrc() {
          return this._blendSrc;
        }
        set blendSrc(t) {
          (this._blendSrc = t), (this._nativeObj.blendSrc = t);
        }
        get blendDst() {
          return this._blendDst;
        }
        set blendDst(t) {
          (this._blendDst = t), (this._nativeObj.blendDst = t);
        }
        get blendEq() {
          return this._blendEq;
        }
        set blendEq(t) {
          (this._blendEq = t), (this._nativeObj.blendEq = t);
        }
        get blendSrcAlpha() {
          return this._blendSrcAlpha;
        }
        set blendSrcAlpha(t) {
          (this._blendSrcAlpha = t), (this._nativeObj.blendSrcAlpha = t);
        }
        get blendDstAlpha() {
          return this._blendDstAlpha;
        }
        set blendDstAlpha(t) {
          (this._blendDstAlpha = t), (this._nativeObj.blendDstAlpha = t);
        }
        get blendAlphaEq() {
          return this._blendAlphaEq;
        }
        set blendAlphaEq(t) {
          (this._blendAlphaEq = t), (this._nativeObj.blendAlphaEq = t);
        }
        get blendColorMask() {
          return this._blendColorMask;
        }
        set blendColorMask(t) {
          (this._blendColorMask = t), (this._nativeObj.blendColorMask = t);
        }
        reset() {
          this.assignProperties(
            !1,
            Pc.ONE,
            Pc.ZERO,
            Nc.ADD,
            Pc.ONE,
            Pc.ZERO,
            Nc.ADD,
            Lc.ALL
          );
        }
        destroy() {
          this._nativeObj = null;
        }
        assign(t) {
          t &&
            this.assignProperties(
              t.blend,
              t.blendSrc,
              t.blendDst,
              t.blendEq,
              t.blendSrcAlpha,
              t.blendDstAlpha,
              t.blendAlphaEq,
              t.blendColorMask
            );
        }
        assignProperties(t, e, i, s, n, r, a, o) {
          void 0 !== t && (this.blend = t),
            void 0 !== e && (this.blendSrc = e),
            void 0 !== i && (this.blendDst = i),
            void 0 !== s && (this.blendEq = s),
            void 0 !== n && (this.blendSrcAlpha = n),
            void 0 !== r && (this.blendDstAlpha = r),
            void 0 !== a && (this.blendAlphaEq = a),
            void 0 !== o && (this.blendColorMask = o);
        }
      }
      class v_ {
        _setTargets(t) {
          this.targets = t;
          const e = "$__nativeObj";
          this._syncTargetsToNativeObj(e),
            (function (t, e, i, s, n) {
              for (let r = 0, a = e.length; r < a; r++) {
                let a = e[r],
                  o = a[i].$__nativeObj || a[i];
                a[i] = new Proxy(o, {
                  get: (t, e) => (e === s ? t : Reflect.get(t, e)),
                  set: (e, i, s) => (Reflect.set(e, i, s), n(t), !0),
                });
              }
            })(this, this.targets, "_nativeObj", e, (t) => {
              t._syncTargetsToNativeObj(e);
            });
        }
        _syncTargetsToNativeObj(t) {
          const e = this.targets.map((e) => e.native[t] || e.native);
          this._nativeObj.targets = e;
        }
        get native() {
          return this._nativeObj;
        }
        constructor(t = !1, e = !1, i = new pu(), s = [new E_()]) {
          (this.targets = void 0),
            (this._blendColor = void 0),
            (this._nativeObj = void 0),
            (this._isA2C = !1),
            (this._isIndepend = !1),
            (this._nativeObj = new gfx.BlendState()),
            this._setTargets(s),
            (this.blendColor = i),
            (this.isA2C = t),
            (this.isIndepend = e);
        }
        get isA2C() {
          return this._isA2C;
        }
        set isA2C(t) {
          (this._isA2C = t), (this._nativeObj.isA2C = t);
        }
        get isIndepend() {
          return this._isIndepend;
        }
        set isIndepend(t) {
          (this._isIndepend = t), (this._nativeObj.isIndepend = t);
        }
        get blendColor() {
          return this._blendColor;
        }
        set blendColor(t) {
          (this._blendColor = t), (this._nativeObj.blendColor = t);
        }
        setTarget(t, e) {
          let i = this.targets[t];
          i || (i = this.targets[t] = new E_()),
            i.assign(e),
            this._setTargets(this.targets);
        }
        reset() {
          (this.isA2C = !1),
            (this.isIndepend = !1),
            (this.blendColor = new pu(0, 0, 0, 0));
          const t = this.targets;
          for (let e = 1, i = t.length; e < i; ++e) t[e].destroy();
          (t.length = 1), t[0].reset(), this._setTargets(t);
        }
        destroy() {
          for (let t = 0, e = this.targets.length; t < e; ++t)
            this.targets[t].destroy();
          (this.targets = null), (this._nativeObj = null);
        }
      }
      gfx.PipelineState;
      const b_ = gfx.PipelineStateInfo;
      let A_, C_;
      !(function (t) {
        (t[(t.AUTO = 0)] = "AUTO"),
          (t[(t.CANVAS = 1)] = "CANVAS"),
          (t[(t.WEBGL = 2)] = "WEBGL"),
          (t[(t.HEADLESS = 3)] = "HEADLESS"),
          (t[(t.WEBGPU = 4)] = "WEBGPU");
      })(A_ || (A_ = {})),
        (function (t) {
          (t[(t.UNKNOWN = -1)] = "UNKNOWN"),
            (t[(t.CANVAS = 0)] = "CANVAS"),
            (t[(t.WEBGL = 1)] = "WEBGL"),
            (t[(t.WEBGPU = 2)] = "WEBGPU"),
            (t[(t.OPENGL = 3)] = "OPENGL"),
            (t[(t.HEADLESS = 4)] = "HEADLESS");
        })(C_ || (C_ = {}));
      class O_ {
        constructor() {
          (this.initialized = !1),
            (this._gfxDevice = void 0),
            (this._canvas = null),
            (this._swapchain = void 0),
            (this._renderType = C_.UNKNOWN),
            (this._deviceInitialized = !1);
        }
        get gfxDevice() {
          return this._gfxDevice;
        }
        get swapchain() {
          return this._swapchain;
        }
        _tryInitializeWebGPUDevice(t, e) {
          return this._deviceInitialized
            ? Promise.resolve(!0)
            : t
            ? ((this._gfxDevice = new t()),
              new Promise((t, i) => {
                this._gfxDevice
                  .initialize(e)
                  .then((e) => {
                    (this._deviceInitialized = e), t(e);
                  })
                  .catch((t) => {
                    i(t);
                  });
              }))
            : Promise.resolve(!1);
        }
        _tryInitializeDeviceSync(t, e) {
          return (
            !!this._deviceInitialized ||
            (t &&
              ((this._gfxDevice = new t()),
              (this._deviceInitialized = this._gfxDevice.initialize(e))),
            this._deviceInitialized)
          );
        }
        init(t, e) {
          if (this.initialized) return !0;
          const i = ge.querySettings(fe.Category.RENDERING, "renderMode");
          (this._canvas = t),
            this._canvas && (this._canvas.oncontextmenu = () => !1),
            (this._renderType = this._determineRenderType(i)),
            (this._deviceInitialized = !1);
          const s = new gu(e);
          if (this._renderType === C_.WEBGL || this._renderType === C_.WEBGPU)
            if (globalThis.gfx) this._gfxDevice = gfx.DeviceManager.create(s);
            else {
              let t = !!globalThis.WebGL2RenderingContext;
              if (
                (globalThis.navigator.userAgent.toLowerCase(),
                zr.browserType === cr.UC && (t = !1),
                this._renderType === C_.WEBGPU && a.WebGPUDevice)
              )
                return new Promise((t, e) => {
                  this._tryInitializeWebGPUDevice(a.WebGPUDevice, s)
                    .then((e) => {
                      this._initSwapchain(), t(e);
                    })
                    .catch((t) => {
                      e(t);
                    });
                });
              t &&
                a.WebGL2Device &&
                this._tryInitializeDeviceSync(a.WebGL2Device, s),
                a.WebGLDevice &&
                  this._tryInitializeDeviceSync(a.WebGLDevice, s),
                a.EmptyDevice &&
                  this._tryInitializeDeviceSync(a.EmptyDevice, s),
                this._initSwapchain();
            }
          else
            this._renderType === C_.HEADLESS &&
              a.EmptyDevice &&
              (this._tryInitializeDeviceSync(a.EmptyDevice, s),
              this._initSwapchain());
          return (
            !!this._gfxDevice || (G(16337), (this._renderType = C_.UNKNOWN), !1)
          );
        }
        _initSwapchain() {
          const t = new fu(1, this._canvas),
            e = kr.windowSize;
          (t.width = e.width),
            (t.height = e.height),
            (this._swapchain = this._gfxDevice.createSwapchain(t));
        }
        _supportWebGPU() {
          return "gpu" in globalThis.navigator;
        }
        _determineRenderType(t) {
          ("number" != typeof t || t > A_.WEBGPU || t < A_.AUTO) &&
            (t = A_.AUTO);
          let e = C_.CANVAS,
            i = !1;
          if (
            (t === A_.CANVAS
              ? ((e = C_.CANVAS), (i = !0))
              : t === A_.AUTO || t === A_.WEBGPU
              ? ((e = this._supportWebGPU() ? C_.WEBGPU : C_.WEBGL), (i = !0))
              : t === A_.WEBGL
              ? ((e = C_.WEBGL), (i = !0))
              : t === A_.HEADLESS && ((e = C_.HEADLESS), (i = !0)),
            !i)
          )
            throw new Error(X(3820, t));
          return e;
        }
      }
      const I_ = new O_(),
        w_ = {
          GFXDevice: !0,
          GFXBuffer: !0,
          GFXTexture: !0,
          GFXSampler: !0,
          GFXShader: !0,
          GFXInputAssembler: !0,
          GFXRenderPass: !0,
          GFXFramebuffer: !0,
          GFXPipelineState: !0,
          GFXCommandBuffer: !0,
          GFXQueue: !0,
          GFXObjectType: !0,
          GFXObject: !1,
          GFXAttributeName: !0,
          GFXType: !0,
          GFXFormat: !0,
          GFXBufferUsageBit: !0,
          GFXMemoryUsageBit: !0,
          GFXBufferFlagBit: !0,
          GFXBufferAccessBit: "MemoryAccessBit",
          GFXPrimitiveMode: !0,
          GFXPolygonMode: !0,
          GFXShadeModel: !0,
          GFXCullMode: !0,
          GFXComparisonFunc: !0,
          GFXStencilOp: !0,
          GFXBlendOp: !0,
          GFXBlendFactor: !0,
          GFXColorMask: !0,
          GFXFilter: !0,
          GFXAddress: !0,
          GFXTextureType: !0,
          GFXTextureUsageBit: !0,
          GFXSampleCount: !0,
          GFXTextureFlagBit: !0,
          GFXShaderStageFlagBit: !0,
          GFXDescriptorType: !0,
          GFXCommandBufferType: !0,
          GFXLoadOp: !0,
          GFXStoreOp: !0,
          GFXPipelineBindPoint: !0,
          GFXDynamicStateFlagBit: !0,
          GFXStencilFace: !0,
          GFXQueueType: !0,
          GFXRect: !0,
          GFXViewport: !0,
          GFXColor: !0,
          GFXClearFlag: !0,
          GFXOffset: !0,
          GFXExtent: !0,
          GFXTextureSubres: "TextureSubresLayers",
          GFXTextureCopy: !0,
          GFXBufferTextureCopy: !0,
          GFXFormatType: !0,
          GFXFormatInfo: !0,
          GFXMemoryStatus: !0,
          GFXFormatInfos: !0,
          GFXFormatSize: !0,
          GFXFormatSurfaceSize: !0,
          GFXGetTypeSize: !0,
          getTypedArrayConstructor: !1,
        };
      for (const t in w_) {
        let e = w_[t];
        !0 === e ? (e = t.slice(3)) : !1 === e && (e = t),
          $(a, "cc", [
            { name: t, newName: e, target: a.gfx, targetName: "cc.gfx" },
          ]);
      }
      Z(a, "cc", [
        { name: "GFX_MAX_VERTEX_ATTRIBUTES" },
        { name: "GFX_MAX_TEXTURE_UNITS" },
        { name: "GFX_MAX_ATTACHMENTS" },
        { name: "GFX_MAX_BUFFER_BINDINGS" },
        { name: "GFXTextureLayout" },
      ]);
      const R_ = gfx.DescriptorSet,
        D_ = gfx.Buffer,
        x_ = gfx.CommandBuffer,
        M_ = gfx.Device,
        P_ = gfx.Swapchain,
        N_ = gfx.Framebuffer,
        L_ = gfx.InputAssembler,
        B_ = gfx.DescriptorSetLayout,
        F_ = gfx.PipelineLayout,
        U_ = gfx.PipelineState,
        k_ = gfx.Queue,
        z_ = gfx.RenderPass,
        H_ = gfx.Shader,
        G_ = gfx.Texture,
        V_ = gfx.Sampler,
        j_ = gfx.GeneralBarrier,
        W_ = gfx.TextureBarrier,
        X_ = Object.assign({}, y_);
      (X_.GFXObject = gfx.GFXObject),
        (X_.Device = gfx.Device),
        (X_.Swapchain = gfx.Swapchain),
        (X_.Buffer = gfx.Buffer),
        (X_.Texture = gfx.Texture),
        (X_.Sampler = gfx.Sampler),
        (X_.Shader = gfx.Shader),
        (X_.InputAssembler = gfx.InputAssembler),
        (X_.RenderPass = gfx.RenderPass),
        (X_.Framebuffer = gfx.Framebuffer),
        (X_.DescriptorSet = gfx.DescriptorSet),
        (X_.DescriptorSetLayout = gfx.DescriptorSetLayout),
        (X_.PipelineLayout = gfx.PipelineLayout),
        (X_.PipelineState = gfx.PipelineState),
        (X_.CommandBuffer = gfx.CommandBuffer),
        (X_.Queue = gfx.Queue),
        (X_.GeneralBarrier = gfx.GeneralBarrier),
        (X_.TextureBarrier = gfx.TextureBarrier),
        (a.gfx = X_),
        (X_.BlendTarget = E_),
        (X_.BlendState = v_),
        (X_.RasterizerState = T_),
        (X_.DepthStencilState = S_),
        (X_.PipelineStateInfo = b_),
        t(
          "gfx",
          Object.freeze({
            __proto__: null,
            BlendState: v_,
            BlendTarget: E_,
            RasterizerState: T_,
            DepthStencilState: S_,
            PipelineState: U_,
            PipelineStateInfo: b_,
            get ObjectType() {
              return uc;
            },
            get Status() {
              return _c;
            },
            get API() {
              return dc;
            },
            get SurfaceTransform() {
              return pc;
            },
            get Feature() {
              return mc;
            },
            get Format() {
              return fc;
            },
            get FormatType() {
              return gc;
            },
            get Type() {
              return yc;
            },
            get BufferUsageBit() {
              return Tc;
            },
            get BufferFlagBit() {
              return Sc;
            },
            get MemoryAccessBit() {
              return Ec;
            },
            get MemoryUsageBit() {
              return vc;
            },
            get TextureType() {
              return bc;
            },
            get TextureUsageBit() {
              return Ac;
            },
            get TextureFlagBit() {
              return Cc;
            },
            get FormatFeatureBit() {
              return Oc;
            },
            get SampleCount() {
              return Ic;
            },
            get VsyncMode() {
              return wc;
            },
            get Filter() {
              return Rc;
            },
            get Address() {
              return Dc;
            },
            get ComparisonFunc() {
              return xc;
            },
            get StencilOp() {
              return Mc;
            },
            get BlendFactor() {
              return Pc;
            },
            get BlendOp() {
              return Nc;
            },
            get ColorMask() {
              return Lc;
            },
            get ShaderStageFlagBit() {
              return Bc;
            },
            get LoadOp() {
              return Fc;
            },
            get StoreOp() {
              return Uc;
            },
            get AccessFlagBit() {
              return kc;
            },
            get ResolveMode() {
              return zc;
            },
            get PipelineBindPoint() {
              return Hc;
            },
            get PrimitiveMode() {
              return Gc;
            },
            get PolygonMode() {
              return Vc;
            },
            get ShadeModel() {
              return jc;
            },
            get CullMode() {
              return Wc;
            },
            get DynamicStateFlagBit() {
              return Xc;
            },
            get StencilFace() {
              return Yc;
            },
            get DescriptorType() {
              return Kc;
            },
            get QueueType() {
              return qc;
            },
            get QueryType() {
              return $c;
            },
            get CommandBufferType() {
              return Zc;
            },
            get ClearFlagBit() {
              return Qc;
            },
            get BarrierType() {
              return Jc;
            },
            get PassType() {
              return tu;
            },
            Size: iu,
            DeviceCaps: su,
            DeviceOptions: nu,
            Offset: ru,
            Rect: au,
            Extent: ou,
            TextureSubresLayers: hu,
            TextureSubresRange: lu,
            TextureCopy: cu,
            TextureBlit: uu,
            BufferTextureCopy: _u,
            Viewport: du,
            Color: pu,
            BindingMappingInfo: mu,
            SwapchainInfo: fu,
            DeviceInfo: gu,
            BufferInfo: yu,
            BufferViewInfo: Tu,
            DrawInfo: Su,
            DispatchInfo: Eu,
            IndirectBuffer: vu,
            TextureInfo: bu,
            TextureViewInfo: Au,
            SamplerInfo: Cu,
            Uniform: Ou,
            UniformBlock: Iu,
            UniformSamplerTexture: wu,
            UniformSampler: Ru,
            UniformTexture: Du,
            UniformStorageImage: xu,
            UniformStorageBuffer: Mu,
            UniformInputAttachment: Pu,
            ShaderStage: Nu,
            Attribute: Lu,
            ShaderInfo: Bu,
            InputAssemblerInfo: Fu,
            ColorAttachment: Uu,
            DepthStencilAttachment: ku,
            SubpassInfo: zu,
            SubpassDependency: Hu,
            RenderPassInfo: Gu,
            GeneralBarrierInfo: Vu,
            TextureBarrierInfo: ju,
            BufferBarrierInfo: Wu,
            FramebufferInfo: Xu,
            DescriptorSetLayoutBinding: Yu,
            DescriptorSetLayoutInfo: Ku,
            DescriptorSetInfo: qu,
            PipelineLayoutInfo: $u,
            InputState: Zu,
            CommandBufferInfo: Qu,
            QueueInfo: Ju,
            QueryPoolInfo: t_,
            FormatInfo: e_,
            MemoryStatus: i_,
            DynamicStencilStates: s_,
            DynamicStates: n_,
            GFXObject: r_,
            get AttributeName() {
              return eu;
            },
            FormatInfos: a_,
            DESCRIPTOR_BUFFER_TYPE: o_,
            DESCRIPTOR_SAMPLER_TYPE: h_,
            DESCRIPTOR_DYNAMIC_TYPE: l_,
            DRAW_INFO_SIZE: 28,
            IsPowerOf2: c_,
            FormatSize: u_,
            FormatSurfaceSize: __,
            GetTypeSize: p_,
            getTypedArrayConstructor: m_,
            formatAlignment: f_,
            alignTo: g_,
            get LegacyRenderMode() {
              return A_;
            },
            get RenderType() {
              return C_;
            },
            DeviceManager: O_,
            deviceManager: I_,
            DescriptorSet: R_,
            Buffer: D_,
            CommandBuffer: x_,
            Device: M_,
            Swapchain: P_,
            Framebuffer: N_,
            InputAssembler: L_,
            DescriptorSetLayout: B_,
            PipelineLayout: F_,
            Queue: k_,
            RenderPass: z_,
            Shader: H_,
            Texture: G_,
            Sampler: V_,
            GeneralBarrier: j_,
            TextureBarrier: W_,
          })
        );
      const Y_ = new Wi();
      function K_(t, e, i, s) {
        const n = i.chunk,
          r = i.data,
          a = n.vb,
          o = i.vertexCount,
          h = t.worldMatrix,
          l = h.m00,
          c = h.m01,
          u = h.m02,
          _ = h.m03,
          d = h.m04,
          p = h.m05,
          m = h.m06,
          f = h.m07,
          g = h.m12,
          y = h.m13,
          T = h.m14,
          S = h.m15;
        Y_.set(s.r / 255, s.g / 255, s.b / 255, s.a / 255);
        let E = 0;
        for (let t = 0; t < o; ++t) {
          const e = r[t],
            i = e.x,
            s = e.y;
          let n = _ * i + f * s + S;
          (n = n ? 1 / n : 1),
            (a[E + 0] = (l * i + d * s + g) * n),
            (a[E + 1] = (c * i + p * s + y) * n),
            (a[E + 2] = (u * i + m * s + T) * n),
            Wi.toArray(a, Y_, E + 5),
            (E += 9);
        }
        n.bufferId;
        const v = n.vertexOffset,
          b = n.meshBuffer,
          A = n.meshBuffer.iData;
        let C = b.indexOffset;
        for (let t = 0, e = o / 4; t < e; t++) {
          const e = v + 4 * t;
          (A[C++] = e),
            (A[C++] = e + 1),
            (A[C++] = e + 2),
            (A[C++] = e + 1),
            (A[C++] = e + 3),
            (A[C++] = e + 2);
        }
        (b.indexOffset += i.indexCount), b.setDirty();
      }
      const q_ = {};
      class $_ {
        get map() {
          return this._map;
        }
        constructor(t) {
          (this._map = null),
            (this._count = 0),
            t
              ? ((this._map = t), (this._count = Object.keys(t).length))
              : ((this._map = St(!0)), (this._count = 0));
        }
        add(t, e) {
          return t in this._map || this._count++, (this._map[t] = e);
        }
        get(t) {
          return this._map[t];
        }
        has(t) {
          return t in this._map;
        }
        remove(t) {
          const e = this._map[t];
          return t in this._map && (delete this._map[t], this._count--), e;
        }
        clear() {
          0 !== this._count && ((this._map = St(!0)), (this._count = 0));
        }
        forEach(t) {
          for (const e in this._map) t(this._map[e], e);
        }
        find(t) {
          for (const e in this._map)
            if (t(this._map[e], e)) return this._map[e];
          return null;
        }
        get count() {
          return this._count;
        }
        destroy() {
          this._map = null;
        }
      }
      class Z_ {
        constructor(t, e) {
          (this.id = Z_._pipelineId++),
            (this.name = ""),
            (this.pipes = []),
            (this.name = t);
          for (let t = 0, i = e.length; t < i; t++) this.pipes.push(e[t]);
        }
        insert(t, e) {
          return e > this.pipes.length
            ? (z(4921), this)
            : (this.pipes.splice(e, 0, t), this);
        }
        append(t) {
          return this.pipes.push(t), this;
        }
        remove(t) {
          return this.pipes.splice(t, 1), this;
        }
        sync(t) {
          const e = this.pipes;
          if (0 === e.length) return null;
          t.isFinished = !1;
          for (let i = 0, s = e.length; i < s; ) {
            const n = (0, e[i])(t);
            if (n) return (t.isFinished = !0), n;
            i++, i !== s && ((t.input = t.output), (t.output = null));
          }
          return (t.isFinished = !0), t.output;
        }
        async(t) {
          0 !== this.pipes.length && ((t.isFinished = !1), this._flow(0, t));
        }
        _flow(t, e) {
          (0, this.pipes[t])(e, (i) => {
            i
              ? ((e.isFinished = !0), e.dispatch("complete", i))
              : ++t < this.pipes.length
              ? ((e.input = e.output), (e.output = null), this._flow(t, e))
              : ((e.isFinished = !0), e.dispatch("complete", i, e.output));
          });
        }
      }
      Z_._pipelineId = 0;
      const Q_ = new $_(),
        J_ = new $_(),
        td = new $_(),
        ed = new $_(),
        id = new Z_("normal load", []),
        sd = new Z_("fetch", []),
        nd = new Z_("transform url", []),
        rd = new Map();
      let ad;
      !(function (t) {
        (t.UUID = "uuid"),
          (t.PATH = "path"),
          (t.DIR = "dir"),
          (t.URL = "url"),
          (t.SCENE = "scene");
      })(ad || (ad = {}));
      const od = {
        default: { priority: 0 },
        preload: { maxConcurrency: 6, maxRequestsPerFrame: 2, priority: -1 },
        scene: { maxConcurrency: 20, maxRequestsPerFrame: 20, priority: 1 },
        bundle: { maxConcurrency: 20, maxRequestsPerFrame: 20, priority: 2 },
        remote: { maxRetryCount: 4 },
      };
      let hd;
      !(function (t) {
        (t.INTERNAL = "internal"),
          (t.RESOURCES = "resources"),
          (t.MAIN = "main"),
          (t.START_SCENE = "start-scene");
      })(hd || (hd = {}));
      class ld {
        static create(t) {
          let e;
          return (
            0 !== ld._deadPool.length
              ? ((e = ld._deadPool.pop()), e.set(t))
              : (e = new ld(t)),
            e
          );
        }
        get isFinish() {
          return this.isFinished;
        }
        set isFinish(t) {
          this.isFinished = t;
        }
        constructor(t) {
          (this.id = ld._taskId++),
            (this.onComplete = null),
            (this.onProgress = null),
            (this.onError = null),
            (this.source = null),
            (this.output = null),
            (this.input = null),
            (this.progress = null),
            (this.options = null),
            (this.isFinished = !0),
            this.set(t);
        }
        set(t = Object.create(null)) {
          (this.onComplete = t.onComplete || null),
            (this.onProgress = t.onProgress || null),
            (this.onError = t.onError || null),
            (this.source = this.input = t.input),
            (this.output = null),
            (this.progress = t.progress),
            (this.options = t.options || Object.create(null));
        }
        dispatch(t, e, i, s, n) {
          switch (t) {
            case "complete":
              this.onComplete && this.onComplete(e, i);
              break;
            case "progress":
              this.onProgress && this.onProgress(e, i, s, n);
              break;
            case "error":
              this.onError && this.onError(e, i, s, n);
              break;
            default: {
              const r = `on${t[0].toUpperCase()}${t.substr(1)}`;
              "function" == typeof this[r] && this[r](e, i, s, n);
              break;
            }
          }
        }
        recycle() {
          ld._deadPool.length !== ld.MAX_DEAD_NUM &&
            ((this.onComplete = null),
            (this.onProgress = null),
            (this.onError = null),
            (this.source = this.output = this.input = null),
            (this.progress = null),
            (this.options = null),
            ld._deadPool.push(this));
        }
      }
      (ld.MAX_DEAD_NUM = 500), (ld._taskId = 0), (ld._deadPool = []);
      const cd = "0123456789abcdef".split(""),
        ud = ["", "", "", ""],
        _d = ud.concat(ud, "-", ud, "-", ud, "-", ud, "-", ud, ud, ud),
        dd = _d.map((t, e) => ("-" === t ? NaN : e)).filter(Number.isFinite);
      function pd(t) {
        const e = t.split("@")[0];
        if (22 !== e.length) return t;
        (_d[0] = t[0]), (_d[1] = t[1]);
        for (let e = 2, i = 2; e < 22; e += 2) {
          const s = ve[t.charCodeAt(e)],
            n = ve[t.charCodeAt(e + 1)];
          (_d[dd[i++]] = cd[s >> 2]),
            (_d[dd[i++]] = cd[((3 & s) << 2) | (n >> 4)]),
            (_d[dd[i++]] = cd[15 & n]);
        }
        return t.replace(e, _d.join(""));
      }
      const md = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;
      function fd(t) {
        const e = md.exec(t);
        return e ? e[1] : "";
      }
      function gd(t, e) {
        ((e = e || Object.create(null)).__isNative__ = e.isNative),
          e.nativeExt && (e.ext = e.nativeExt);
        const i = ed.find((e) => !!e.getAssetInfo(t));
        return i && (e.bundle = i.name), Sd(t, e);
      }
      function yd(t) {
        return !!t && (t instanceof a.SceneAsset || t instanceof a.Scene);
      }
      function Td(t) {
        return (
          t &&
            (46 === t.charCodeAt(0) && 47 === t.charCodeAt(1)
              ? (t = t.slice(2))
              : 47 === t.charCodeAt(0) && (t = t.slice(1))),
          t
        );
      }
      function Sd(t, e) {
        const i = ld.create({ input: t, options: e }),
          s = [];
        try {
          const t = nd.sync(i);
          for (const e of t) {
            const t = e.url;
            e.recycle(), s.push(t);
          }
        } catch (t) {
          for (const t of i.output) t.recycle();
          R(t.message, t.stack);
        }
        return i.recycle(), s.length > 1 ? s : s[0];
      }
      var Ed = Object.freeze({
        __proto__: null,
        getUuidFromURL: fd,
        getUrlWithUuid: gd,
        isScene: yd,
        normalize: Td,
        transform: Sd,
        decodeUuid: pd,
      });
      const vd = (t) => {
        t();
      };
      lc(jsb.Asset, [ar, sc]);
      const bd = jsb.Asset.prototype;
      (bd._ctor = function () {
        (this.loaded = !0),
          (this._ref = 0),
          (this.__nativeRefs = {}),
          (this.__jsb_ref_id = void 0),
          (this._iN$t = null),
          (this.__editorExtras__ = { editorOnly: !0 }),
          (this._callbackTable = St(!0)),
          (this._file = null);
      }),
        Object.defineProperty(bd, "_nativeAsset", {
          get() {
            return this._file;
          },
          set(t) {
            this._file = t;
          },
        }),
        Object.defineProperty(bd, "nativeUrl", {
          get() {
            if (!this._nativeUrl) {
              if (!this._native) return "";
              const t = this._native;
              if (47 === t.charCodeAt(0)) return t.slice(1);
              46 === t.charCodeAt(0)
                ? (this._nativeUrl = gd(this._uuid, {
                    nativeExt: t,
                    isNative: !0,
                  }))
                : (this._nativeUrl = gd(this._uuid, {
                    __nativeName__: t,
                    nativeExt: br(t),
                    isNative: !0,
                  }));
            }
            return this._nativeUrl;
          },
        }),
        Object.defineProperty(bd, "refCount", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._ref;
          },
        }),
        (bd.addRef = function () {
          return this._ref++, this.addAssetRef(), this;
        }),
        (bd.decRef = function (t = !0) {
          return (
            this.decAssetRef(),
            this._ref > 0 && this._ref--,
            t && a.assetManager._releaseManager.tryRelease(this),
            this
          );
        }),
        (bd.toString = function () {
          return this.nativeUrl;
        }),
        (bd.createNode = null);
      const Ad = t("Asset", jsb.Asset);
      (a.Asset = jsb.Asset),
        (function (t, e = vd) {
          const { Asset: i } = { ...t },
            s = Object.getOwnPropertyDescriptor(i.prototype, "_nativeAsset");
          e(
            () => {
              Na(i.prototype, "_native", () => "");
            },
            "serializable",
            "_native"
          ),
            e(
              () => {
                Ra(i.prototype, "_nativeAsset", s);
              },
              "property",
              "_nativeAsset"
            ),
            e(
              () => {
                Ca("cc.Asset")(i);
              },
              "ccclass",
              null
            );
        })({ Asset: Ad });
      let Cd, Od, Id;
      !(function (t) {
        (t[(t.RGB565 = fc.R5G6B5)] = "RGB565"),
          (t[(t.RGB5A1 = fc.RGB5A1)] = "RGB5A1"),
          (t[(t.RGBA4444 = fc.RGBA4)] = "RGBA4444"),
          (t[(t.RGB888 = fc.RGB8)] = "RGB888"),
          (t[(t.RGB32F = fc.RGB32F)] = "RGB32F"),
          (t[(t.RGBA8888 = fc.RGBA8)] = "RGBA8888"),
          (t[(t.BGRA8888 = fc.BGRA8)] = "BGRA8888"),
          (t[(t.RGBA32F = fc.RGBA32F)] = "RGBA32F"),
          (t[(t.A8 = fc.A8)] = "A8"),
          (t[(t.I8 = fc.L8)] = "I8"),
          (t[(t.AI8 = fc.LA8)] = "AI8"),
          (t[(t.RGB_PVRTC_2BPPV1 = fc.PVRTC_RGB2)] = "RGB_PVRTC_2BPPV1"),
          (t[(t.RGBA_PVRTC_2BPPV1 = fc.PVRTC_RGBA2)] = "RGBA_PVRTC_2BPPV1"),
          (t[(t.RGB_A_PVRTC_2BPPV1 = 1024)] = "RGB_A_PVRTC_2BPPV1"),
          (t[(t.RGB_PVRTC_4BPPV1 = fc.PVRTC_RGB4)] = "RGB_PVRTC_4BPPV1"),
          (t[(t.RGBA_PVRTC_4BPPV1 = fc.PVRTC_RGBA4)] = "RGBA_PVRTC_4BPPV1"),
          (t[(t.RGB_A_PVRTC_4BPPV1 = 1025)] = "RGB_A_PVRTC_4BPPV1"),
          (t[(t.RGB_ETC1 = fc.ETC_RGB8)] = "RGB_ETC1"),
          (t[(t.RGBA_ETC1 = 1026)] = "RGBA_ETC1"),
          (t[(t.RGB_ETC2 = fc.ETC2_RGB8)] = "RGB_ETC2"),
          (t[(t.RGBA_ETC2 = fc.ETC2_RGBA8)] = "RGBA_ETC2"),
          (t[(t.RGBA_ASTC_4x4 = fc.ASTC_RGBA_4X4)] = "RGBA_ASTC_4x4"),
          (t[(t.RGBA_ASTC_5x4 = fc.ASTC_RGBA_5X4)] = "RGBA_ASTC_5x4"),
          (t[(t.RGBA_ASTC_5x5 = fc.ASTC_RGBA_5X5)] = "RGBA_ASTC_5x5"),
          (t[(t.RGBA_ASTC_6x5 = fc.ASTC_RGBA_6X5)] = "RGBA_ASTC_6x5"),
          (t[(t.RGBA_ASTC_6x6 = fc.ASTC_RGBA_6X6)] = "RGBA_ASTC_6x6"),
          (t[(t.RGBA_ASTC_8x5 = fc.ASTC_RGBA_8X5)] = "RGBA_ASTC_8x5"),
          (t[(t.RGBA_ASTC_8x6 = fc.ASTC_RGBA_8X6)] = "RGBA_ASTC_8x6"),
          (t[(t.RGBA_ASTC_8x8 = fc.ASTC_RGBA_8X8)] = "RGBA_ASTC_8x8"),
          (t[(t.RGBA_ASTC_10x5 = fc.ASTC_RGBA_10X5)] = "RGBA_ASTC_10x5"),
          (t[(t.RGBA_ASTC_10x6 = fc.ASTC_RGBA_10X6)] = "RGBA_ASTC_10x6"),
          (t[(t.RGBA_ASTC_10x8 = fc.ASTC_RGBA_10X8)] = "RGBA_ASTC_10x8"),
          (t[(t.RGBA_ASTC_10x10 = fc.ASTC_RGBA_10X10)] = "RGBA_ASTC_10x10"),
          (t[(t.RGBA_ASTC_12x10 = fc.ASTC_RGBA_12X10)] = "RGBA_ASTC_12x10"),
          (t[(t.RGBA_ASTC_12x12 = fc.ASTC_RGBA_12X12)] = "RGBA_ASTC_12x12"),
          (t[(t.RGBA_BC7 = fc.BC7)] = "RGBA_BC7");
      })(Cd || (Cd = {})),
        (function (t) {
          (t[(t.REPEAT = Dc.WRAP)] = "REPEAT"),
            (t[(t.CLAMP_TO_EDGE = Dc.CLAMP)] = "CLAMP_TO_EDGE"),
            (t[(t.MIRRORED_REPEAT = Dc.MIRROR)] = "MIRRORED_REPEAT"),
            (t[(t.CLAMP_TO_BORDER = Dc.BORDER)] = "CLAMP_TO_BORDER");
        })(Od || (Od = {})),
        (function (t) {
          (t[(t.NONE = Rc.NONE)] = "NONE"),
            (t[(t.LINEAR = Rc.LINEAR)] = "LINEAR"),
            (t[(t.NEAREST = Rc.POINT)] = "NEAREST");
        })(Id || (Id = {}));
      const wd = t("ImageAsset", jsb.ImageAsset),
        Rd = jsb.window,
        Dd = [
          ".png",
          ".jpg",
          ".jpeg",
          ".bmp",
          ".webp",
          ".pvr",
          ".pkm",
          ".astc",
          ".dds",
        ];
      function xd(t) {
        return !!(
          zr.hasFeature(zr.Feature.IMAGE_BITMAP) && t instanceof ImageBitmap
        );
      }
      const Md = wd.prototype;
      (Md._ctor = function (t) {
        jsb.Asset.prototype._ctor.apply(this, arguments),
          (this._width = 0),
          (this._height = 0),
          (this._nativeData = {
            _data: null,
            width: 0,
            height: 0,
            format: 0,
            _compressed: !1,
            mipmapLevelDataSize: [],
          }),
          void 0 !== t && this.reset(t);
      }),
        Object.defineProperty(Md, "_nativeAsset", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._nativeData;
          },
          set(t) {
            t instanceof Rd.HTMLElement ||
              xd(t) ||
              (t.format = t.format || this.format),
              this.reset(t);
          },
        }),
        Object.defineProperty(Md, "data", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._nativeData &&
              !0 !== (t = this._nativeData)._compressed &&
              (t instanceof Rd.HTMLImageElement ||
                t instanceof Rd.HTMLCanvasElement ||
                xd(t))
              ? this._nativeData
              : this._nativeData && this._nativeData._data;
            var t;
          },
        }),
        (Md._setRawAsset = function (t, e = !0) {
          this._native = !1 !== e ? t || "" : `/${t}`;
        }),
        (Md.reset = function (t) {
          (this._nativeData = t),
            t instanceof Rd.HTMLElement ||
              (void 0 !== t.format && (this.format = t.format)),
            this._syncDataToNative();
        });
      const Pd = jsb.Asset.prototype.destroy;
      var Nd, Ld, Bd;
      (Md.destroy = function () {
        return (
          this.data && this.data instanceof Rd.HTMLImageElement
            ? ((this.data.src = ""), this._setRawAsset(""), this.data.destroy())
            : xd(this.data) && this.data.close && this.data.close(),
          Pd.call(this)
        );
      }),
        Object.defineProperty(Md, "width", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._nativeData.width || this._width;
          },
        }),
        Object.defineProperty(Md, "height", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._nativeData.height || this._height;
          },
        }),
        (Md._syncDataToNative = function () {
          const t = this._nativeData;
          if (
            ((this._width = t.width),
            (this._height = t.height),
            this.setWidth(this._width),
            this.setHeight(this._height),
            (this.url = this.nativeUrl),
            t instanceof Rd.HTMLCanvasElement)
          )
            this.setData(t._data.data);
          else if (t instanceof Rd.HTMLImageElement)
            this.setData(t._data),
              t._mipmapLevelDataSize &&
                this.setMipmapLevelDataSize(t._mipmapLevelDataSize);
          else {
            if (!this._nativeData._data)
              return void console.error(
                `[ImageAsset] setData bad argument ${this._nativeData}`
              );
            this.setData(this._nativeData._data),
              this._nativeData.mipmapLevelDataSize &&
                this.setMipmapLevelDataSize(
                  this._nativeData.mipmapLevelDataSize
                );
          }
        }),
        (Md._serialize = function () {}),
        (Md._deserialize = function (t) {
          let e = "";
          "string" == typeof t
            ? (e = t)
            : ((this._width = t.w), (this._height = t.h), (e = t.fmt));
          const i = I_.gfxDevice,
            s = e.split("_");
          let n = Number.MAX_VALUE,
            r = this.format,
            a = "";
          const o = Te.SUPPORT_TEXTURE_FORMATS;
          for (const t of s) {
            const e = t.split("@"),
              s = parseInt(e[0], void 0),
              h = Dd[s] || e[0],
              l = o.indexOf(h);
            if (-1 !== l && l < n) {
              const t = e[1] ? parseInt(e[1]) : this.format;
              if (
                !(
                  ".astc" !== h ||
                  (i &&
                    i.getFormatFeatures(fc.ASTC_RGBA_4X4) & Oc.SAMPLED_TEXTURE)
                )
              )
                continue;
              if (
                !(
                  ".pvr" !== h ||
                  (i &&
                    i.getFormatFeatures(fc.PVRTC_RGBA4) & Oc.SAMPLED_TEXTURE)
                )
              )
                continue;
              if (
                !(
                  (t !== Cd.RGB_ETC1 && t !== Cd.RGBA_ETC1) ||
                  (i && i.getFormatFeatures(fc.ETC_RGB8) & Oc.SAMPLED_TEXTURE)
                )
              )
                continue;
              if (
                !(
                  (t !== Cd.RGB_ETC2 && t !== Cd.RGBA_ETC2) ||
                  (i && i.getFormatFeatures(fc.ETC2_RGB8) & Oc.SAMPLED_TEXTURE)
                )
              )
                continue;
              if (".webp" === h && !zr.hasFeature(zr.Feature.WEBP)) continue;
              if (
                !(
                  ".dds" !== h ||
                  (i && i.getFormatFeatures(fc.BC7) & Oc.SAMPLED_TEXTURE)
                )
              )
                continue;
              (n = l), (a = h), (r = t);
            }
          }
          a ? (this._setRawAsset(a), (this.format = r)) : z(3121);
        }),
        (a.ImageAsset = jsb.ImageAsset),
        (function (t, e = vd) {
          const { ImageAsset: i } = { ...t },
            s = Object.getOwnPropertyDescriptor(i.prototype, "_nativeAsset");
          e(
            () => {
              oo(i.prototype, "_nativeAsset", s);
            },
            "override",
            "_nativeAsset"
          ),
            e(
              () => {
                Ca("cc.ImageAsset")(i);
              },
              "ccclass",
              null
            );
        })({ ImageAsset: wd });
      let Fd = t("Script", Ca("cc.Script")((Nd = class extends Ad {})) || Nd);
      a._Script = Fd;
      let Ud = t(
        "JavaScript",
        Ca("cc.JavaScript")((Ld = class extends Fd {})) || Ld
      );
      a._JavaScript = Ud;
      let kd = t(
        "TypeScript",
        Ca("cc.TypeScript")((Bd = class extends Fd {})) || Bd
      );
      var zd, Hd, Gd, Vd, jd, Wd, Xd;
      a._TypeScript = kd;
      let Yd = t(
        "EventHandler",
        Ca("cc.ClickEvent")(
          ((Hd = class t {
            constructor() {
              (this.target = Gd && Gd()),
                (this.component = Vd && Vd()),
                (this._componentId = jd && jd()),
                (this.handler = Wd && Wd()),
                (this.customEventData = Xd && Xd());
            }
            get _componentName() {
              return (
                this._genCompIdIfNeeded(), this._compId2Name(this._componentId)
              );
            }
            set _componentName(t) {
              this._componentId = this._compName2Id(t);
            }
            static emitEvents(e, ...i) {
              for (let s = 0, n = e.length; s < n; s++) {
                const n = e[s];
                n instanceof t && n.emit(i);
              }
            }
            emit(t) {
              const e = this.target;
              if (!a.isValid(e)) return;
              this._genCompIdIfNeeded();
              const i = a.js.getClassById(this._componentId),
                s = e.getComponent(i);
              if (!a.isValid(s)) return;
              const n = s[this.handler];
              "function" == typeof n &&
                (null != this.customEventData &&
                  "" !== this.customEventData &&
                  (t = t.slice()).push(this.customEventData),
                n.apply(s, t));
            }
            _compName2Id(t) {
              const e = a.js.getClassByName(t);
              return a.js.getClassId(e);
            }
            _compId2Name(t) {
              const e = a.js.getClassById(t);
              return a.js.getClassName(e);
            }
            _genCompIdIfNeeded() {
              this._componentId ||
                ((this._componentName = this.component), (this.component = ""));
            }
          }),
          (Gd = fa(Hd.prototype, "target", [Na], function () {
            return null;
          })),
          (Vd = fa(Hd.prototype, "component", [Na], function () {
            return "";
          })),
          (jd = fa(Hd.prototype, "_componentId", [Na], function () {
            return "";
          })),
          (Wd = fa(Hd.prototype, "handler", [Na], function () {
            return "";
          })),
          (Xd = fa(Hd.prototype, "customEventData", [Na], function () {
            return "";
          })),
          (zd = Hd))
        ) || zd
      );
      var Kd, qd, $d, Zd, Qd, Jd, tp, ep;
      const ip = new lt("Comp"),
        sp = $n.Flags.IsOnLoadCalled;
      let np = t(
        "Component",
        ((Kd = Ca("cc.Component")),
        (qd = ao(Fd)),
        Kd(
          (((ep = class extends $n {
            constructor() {
              super(),
                (this.node = Qd && Qd()),
                (this._enabled = Jd && Jd()),
                (this.__prefab = tp && tp()),
                (this._sceneGetter = null),
                (this._id = ip.getNewId());
            }
            get name() {
              if (this._name) return this._name;
              let t = Et(this);
              const e = t.lastIndexOf(".");
              return (
                e >= 0 && (t = t.slice(e + 1)),
                this.node ? `${this.node.name}<${t}>` : t
              );
            }
            set name(t) {
              this._name = t;
            }
            get uuid() {
              return this._id;
            }
            get __scriptAsset() {
              return null;
            }
            get enabled() {
              return this._enabled;
            }
            set enabled(t) {
              if (this._enabled !== t) {
                if (((this._enabled = t), this.node.activeInHierarchy)) {
                  const e = a.director._compScheduler;
                  t ? e.enableComp(this) : e.disableComp(this);
                }
                this.onSetInternalEnabled(t);
              }
            }
            onSetInternalEnabled(t) {}
            get enabledInHierarchy() {
              return this._enabled && this.node && this.node.activeInHierarchy;
            }
            get _isOnLoadCalled() {
              return this._objFlags & sp;
            }
            _getRenderScene() {
              return this._sceneGetter
                ? this._sceneGetter()
                : this.node.scene.renderScene;
            }
            addComponent(t) {
              return this.node.addComponent(t);
            }
            getComponent(t) {
              return Qn(this.node, !0) ? this.node.getComponent(t) : null;
            }
            getComponents(t) {
              return this.node.getComponents(t);
            }
            getComponentInChildren(t) {
              return this.node.getComponentInChildren(t);
            }
            getComponentsInChildren(t) {
              return this.node.getComponentsInChildren(t);
            }
            destroy() {
              return (
                !!super.destroy() &&
                (this._enabled &&
                  this.node.activeInHierarchy &&
                  a.director._compScheduler.disableComp(this),
                !0)
              );
            }
            _onPreDestroy() {
              this.unscheduleAllCallbacks(),
                a.director._nodeActivator.destroyComp(this),
                this.node._removeComponent(this);
            }
            _instantiate(t) {
              return (
                t || (t = a.instantiate._clone(this, this)),
                t && (t.node = null),
                t
              );
            }
            schedule(t, e = 0, i = a.macro.REPEAT_FOREVER, s = 0) {
              j(Boolean(t), 1619),
                j((e = e || 0) >= 0, 1620),
                (i = Number.isNaN(i) ? a.macro.REPEAT_FOREVER : i),
                (s = s || 0);
              const n = a.director.getScheduler(),
                r = n.isTargetPaused(this);
              n.schedule(t, this, e, i, s, r);
            }
            scheduleOnce(t, e = 0) {
              this.schedule(t, 0, 0, e);
            }
            unschedule(t) {
              t && a.director.getScheduler().unschedule(t, this);
            }
            unscheduleAllCallbacks() {
              a.director.getScheduler().unscheduleAllForTarget(this);
            }
            get internalUpdate() {
              return this.update;
            }
            get internalLateUpdate() {
              return this.lateUpdate;
            }
            get internalPreload() {
              return this.__preload;
            }
            get internalOnLoad() {
              return this.onLoad;
            }
            get internalStart() {
              return this.start;
            }
            get internalOnEnable() {
              return this.onEnable;
            }
            get internalOnDisable() {
              return this.onDisable;
            }
            get internalOnDestroy() {
              return this.onDestroy;
            }
          }).EventHandler = Yd),
          (ep._executionOrder = 0),
          (ep._requireComponent = null),
          (ep.system = null),
          s(
            (Zd = ep).prototype,
            "__scriptAsset",
            [qd],
            Object.getOwnPropertyDescriptor(Zd.prototype, "__scriptAsset"),
            Zd.prototype
          ),
          (Qd = fa(Zd.prototype, "node", [Na], function () {
            return null;
          })),
          (Jd = fa(Zd.prototype, "_enabled", [Na], function () {
            return !0;
          })),
          (tp = fa(Zd.prototype, "__prefab", [Na], function () {
            return null;
          })),
          ($d = Zd))
        ) || $d)
      );
      var rp, ap, op;
      ft(np, "_registerEditorProps", (t, e) => {
        let i = e.requireComponent;
        i &&
          (Array.isArray(i) && (i = i.filter(Boolean)),
          (t._requireComponent = i));
        const s = e.executionOrder;
        s && "number" == typeof s && (t._executionOrder = s);
      }),
        (a.Component = np);
      let hp = t(
        "MissingScript",
        Ca("cc.MissingScript")(
          ((ap = class extends np {
            static safeFindClass(t) {
              const e = Xt(t);
              if (e) return e;
              a.deserialize.reportMissingClass(t);
            }
            constructor() {
              super(), (this._$erialized = op && op());
            }
            onLoad() {
              z(4600, this.node.name);
            }
          }),
          (op = fa(ap.prototype, "_$erialized", [Na, Ba], function () {
            return null;
          })),
          (rp = ap))
        ) || rp
      );
      a._MissingScript = hp;
      try {
        const t = hp.__values__;
        (0 !== t.length && "_$erialized" === t[t.length - 1]) ||
          (G(16338), G(16339, t.join(", ")));
      } catch (Gs) {
        G(16340, `${Gs}`);
      }
      class lp {
        constructor(t, e) {
          (this._document = t), (this._chunks = e);
        }
        get document() {
          return this._document;
        }
        get chunks() {
          return this._chunks;
        }
      }
      function cp(t) {
        const e = t;
        return { chunks: e.chunks, document: e.document };
      }
      function up(t) {
        if (t.length < 16) throw new _p(X(13102));
        const e = new DataView(t.buffer, t.byteOffset, t.byteLength);
        if (1313817411 !== e.getUint32(0, !0)) throw new _p(X(13100));
        const i = e.getUint32(4, !0);
        if (1 !== i) throw new _p(X(13101, i));
        if (e.getUint32(8, !0) !== e.byteLength) throw new _p(X(13102));
        let s = 12;
        const n = e.getUint32(s, !0);
        s += 4;
        const r = new Uint8Array(e.buffer, s + e.byteOffset, n);
        s += n;
        const a = (function (t) {
          if ("undefined" != typeof TextDecoder)
            return new TextDecoder().decode(t);
          if ("Buffer" in globalThis) {
            const { Buffer: e } = globalThis;
            return e.from(t.buffer, t.byteOffset, t.byteLength).toString();
          }
          throw new Error(X(13104));
        })(r);
        let o;
        try {
          o = JSON.parse(a);
        } catch (t) {
          throw new _p(t);
        }
        const h = [];
        for (; s < e.byteLength; ) {
          s % 8 != 0 && (s += 8 - (s % 8));
          const t = e.getUint32(s, !0);
          (s += 4),
            h.push(new Uint8Array(e.buffer, s + e.byteOffset, t)),
            (s += t);
        }
        if (s !== e.byteLength) throw new _p(X(13102));
        return new lp(o, h);
      }
      class _p extends Error {}
      function dp(t, e, i, s, n) {
        if (e instanceof a.ValueType) {
          n || t.push("if(prop){");
          const s = Et(e);
          t.push(`s._deserializeFastDefinedObject(o${i},prop,${s});`),
            n || t.push(`}else o${i}=null;`);
        } else
          t.push(
            `\nif (prop) {\n    s._deserializeAndAssignField(o, prop, ${s});\n} else {\n    o${i}=null;\n}\n`
          );
      }
      (a.internal.parseCCONJson = cp),
        (a.internal.decodeCCONBinary = up),
        (a.internal.CCON = lp);
      const pp = hi.Attr.DELIMETER,
        mp = `${pp}type`,
        fp = `${pp}default`,
        gp = `${pp}formerlySerializedAs`;
      function yp(t, e) {
        if (void 0 === t)
          return e instanceof hi.Attr.PrimitiveType || e === si || e === ni;
        {
          const e = typeof t;
          return "string" === e || "number" === e || "boolean" === e;
        }
      }
      class Tp extends $t {
        constructor() {
          super((t) => {
            t.clear();
          }, 1);
        }
      }
      Tp.prototype.get = function (t, e, i, s, n) {
        const r = this._get();
        return r ? (r.reset(t, e, i, s, n), r) : new Sp(t, e, i, s, n);
      };
      class Sp {
        get ignoreEditorOnly() {
          return this._ignoreEditorOnly;
        }
        constructor(t, e, i, s, n) {
          (this.deserializedList = []),
            (this.deserializedData = null),
            (this.result = t),
            (this.customEnv = s),
            (this._classFinder = e),
            (this._reportMissingClass = i),
            (this._onDereferenced = null == e ? void 0 : e.onDereferenced);
        }
        reset(t, e, i, s, n) {
          (this.result = t),
            (this.customEnv = s),
            (this._classFinder = e),
            (this._reportMissingClass = i),
            (this._onDereferenced = null == e ? void 0 : e.onDereferenced);
        }
        clear() {
          (this.result = null),
            (this.customEnv = null),
            (this.deserializedList.length = 0),
            (this.deserializedData = null),
            (this._classFinder = null),
            (this._reportMissingClass = null),
            (this._onDereferenced = null);
        }
        deserialize(t) {
          let e,
            i = !1;
          t instanceof lp
            ? ((i = !0),
              (e = t.document),
              t.chunks.length > 0 &&
                (t.chunks.length, (this._mainBinChunk = t.chunks[0])))
            : (e = t),
            (this._serializedData = e),
            (this._context = { fromCCON: i });
          const s = Array.isArray(e) ? e[0] : e;
          return (
            (this.deserializedData = this._deserializeObject(s, 0)),
            (this._serializedData = void 0),
            (this._mainBinChunk = void 0),
            (this._context = void 0),
            this.deserializedData
          );
        }
        _deserializeObject(t, e, i, s) {
          switch (t.__type__) {
            case "TypedArray":
              return this._deserializeTypedArrayView(t);
            case "TypedArrayRef":
              return this._deserializeTypedArrayViewRef(t);
            default:
              return t.__type__
                ? this._deserializeTypeTaggedObject(t, e, i, s)
                : Array.isArray(t)
                ? this._deserializeArray(t)
                : this._deserializePlainObject(t);
          }
        }
        _deserializeTypedArrayView(t) {
          return globalThis[t.ctor].from(t.array);
        }
        _deserializeTypedArrayViewRef(t) {
          const { offset: e, length: i, ctor: s } = t;
          return new globalThis[s](
            this._mainBinChunk.buffer,
            this._mainBinChunk.byteOffset + e,
            i
          );
        }
        _deserializeArray(t) {
          const e = new Array(t.length);
          let i;
          for (let s = 0; s < t.length; s++)
            (i = t[s]),
              "object" == typeof i && i
                ? this._deserializeAndAssignField(e, i, `${s}`) && (e[s] = null)
                : (e[s] = i);
          return e;
        }
        _deserializePlainObject(t) {
          const e = {};
          return this._fillPlainObject(e, t), e;
        }
        _deserializeTypeTaggedObject(t, e, i, s) {
          const n = t.__type__,
            r = this._classFinder(n, t, i, s);
          if (!r)
            return (
              this._classFinder === Xt && this._reportMissingClass(n), null
            );
          {
            const i = ((t) => {
              const i = new t();
              return e >= 0 && (this.deserializedList[e] = i), i;
            })(r);
            return this._deserializeInto(t, i, r), i;
          }
        }
        _deserializeInto(t, e, i, s = !1) {
          s || !e[Co]
            ? e._deserialize
              ? e._deserialize(t.content, this)
              : a.Class._isCCClass(i)
              ? this._deserializeFireClass(e, t, i)
              : this._deserializeFastDefinedObject(e, t, i)
            : this._runCustomizedDeserialize(t, e, i);
        }
        _runCustomizedDeserialize(t, e, i) {
          const s = {
            readProperty: (e) => {
              const i = t[e];
              return "object" == typeof i && i
                ? this._deserializeObjectField(i)
                : i;
            },
            readThis: () => {
              this._deserializeInto(t, e, i, !0);
            },
            readSuper: () => {
              const s = Nt(i);
              s && this._deserializeInto(t, e, s);
            },
          };
          e[Co](s, this._context);
        }
        _deserializeFireClass(t, e, i) {
          let s;
          if (i.hasOwnProperty("__deserialize__")) s = i.__deserialize__;
          else {
            s = (function (t, e) {
              const i = hi.Attr.getClassAttrs(e),
                s = e.__values__,
                n = ["var prop;"],
                r = (function (t) {
                  return Se.test(qt(t));
                })(e);
              for (let t = 0; t < s.length; t++) {
                const e = s[t];
                let a, o;
                hi.IDENTIFIER_RE.test(e)
                  ? ((o = `"${e}"`), (a = `.${e}`))
                  : ((o = hi.escapeForJS(e)), (a = `[${o}]`));
                let h = a;
                if (i[e + gp]) {
                  const t = i[e + gp];
                  h = hi.IDENTIFIER_RE.test(t)
                    ? `.${t}`
                    : `[${hi.escapeForJS(t)}]`;
                }
                n.push(`prop=d${h};`),
                  n.push('if(typeof (prop)!=="undefined"){');
                const l = hi.getDefault(i[e + fp]),
                  c = i[e + mp];
                r && (void 0 !== l || c)
                  ? yp(l, c)
                    ? n.push(`o${a}=prop;`)
                    : dp(n, l, a, o, !0)
                  : (n.push(`if(typeof (prop)!=="object"){o${a}=prop;}else{`),
                    dp(n, l, a, o, !1),
                    n.push("}")),
                  n.push("}");
              }
              return (
                (Lt(e, a.Node) || Lt(e, a.Component)) &&
                  n.push("d._id&&(o._id=d._id);"),
                "_$erialized" === s[s.length - 1] &&
                  (n.push("o._$erialized=JSON.parse(JSON.stringify(d));"),
                  n.push("s._fillPlainObject(o._$erialized,d);")),
                Function("s", "o", "d", "k", n.join(""))
              );
            })(0, i);
            try {
              if (i === hp) {
                const t = i.__values__;
                (0 !== t.length && "_$erialized" === t[t.length - 1]) ||
                  (G(16341), G(16342, t.join(", ")));
                const e = s;
                s = function (t, i, s, n) {
                  e(t, i, s, n), i._$erialized || G(16343, JSON.stringify(s));
                };
              }
            } catch (t) {
              G(16344, `${t}`);
            }
            ft(i, "__deserialize__", s, !0);
          }
          s(this, t, e, i);
        }
        _deserializeAndAssignField(t, e, i) {
          const s = e.__id__;
          if ("number" == typeof s) {
            const e = this.deserializedList[s];
            if (e) t[i] = e;
            else {
              var n;
              const e = this._serializedData[s];
              (t[i] = this._deserializeObject(e, s, void 0, i)),
                null === (n = this._onDereferenced) ||
                  void 0 === n ||
                  n.call(this, this.deserializedList, s, t, i);
            }
          } else {
            const s = e.__uuid__;
            if (s) {
              const n = e.__expectedType__;
              this.result.push(t, i, s, n);
            } else t[i] = this._deserializeObject(e, -1);
          }
          return !1;
        }
        _deserializeObjectField(t) {
          const e = t.__id__;
          if ("number" == typeof e) {
            const t = this.deserializedList[e];
            if (t) return t;
            {
              const t = this._serializedData[e];
              return this._deserializeObject(t, e, void 0, void 0);
            }
          }
          if (t.__uuid__)
            throw (
              (t.__expectedType__,
              new Error(
                "Asset reference field serialization is currently not supported in custom serialization."
              ))
            );
          return this._deserializeObject(t, -1);
        }
        _fillPlainObject(t, e) {
          for (const i in e) {
            if (!e.hasOwnProperty(i)) continue;
            const s = e[i];
            "object" != typeof s
              ? "__type__" !== i && (t[i] = s)
              : s
              ? this._deserializeAndAssignField(t, s, i) && (t[i] = null)
              : (t[i] = null);
          }
        }
        _deserializeFastDefinedObject(t, e, i) {
          if (i === a.Vec2) return (t.x = e.x || 0), void (t.y = e.y || 0);
          if (i === a.Vec3)
            return (t.x = e.x || 0), (t.y = e.y || 0), void (t.z = e.z || 0);
          if (i === a.Color) {
            (t.r = e.r || 0), (t.g = e.g || 0), (t.b = e.b || 0);
            const i = e.a;
            return void (t.a = void 0 === i ? 255 : i);
          }
          if (i === a.Size)
            return (t.width = e.width || 0), void (t.height = e.height || 0);
          const s = hi.Attr.getClassAttrs(i),
            n = i.__values__;
          for (let i = 0; i < n.length; i++) {
            const r = n[i];
            let a = e[r];
            void 0 !== a ||
              e.hasOwnProperty(r) ||
              (a = hi.getDefault(s[r + fp])),
              "object" != typeof a
                ? (t[r] = a)
                : a
                ? this._deserializeAndAssignField(t, a, r)
                : (t[r] = null);
          }
        }
      }
      Sp.pool = new Tp();
      const Ep = [Ss, Yi, Wi, as, Qi, ws, Ds, ms];
      function vp(t, e) {
        (t.x = e[1]), (t.y = e[2]), (t.z = e[3]), (t.w = e[4]);
      }
      const bp = [
        (t, e) => {
          (t.x = e[1]), (t.y = e[2]);
        },
        (t, e) => {
          (t.x = e[1]), (t.y = e[2]), (t.z = e[3]);
        },
        vp,
        vp,
        (t, e) => {
          Qi.fromUint32(t, e[1]);
        },
        (t, e) => {
          (t.width = e[1]), (t.height = e[2]);
        },
        (t, e) => {
          (t.x = e[1]), (t.y = e[2]), (t.width = e[3]), (t.height = e[4]);
        },
        (t, e) => {
          ms.fromArray(t, e, 1);
        },
      ];
      class Ap {
        constructor() {
          (this.uuidObjList = null),
            (this.uuidPropList = null),
            (this.uuidList = null),
            (this.uuidTypeList = []);
        }
        init(t) {
          t
            ? ((this.uuidObjList = t[8]),
              (this.uuidPropList = t[9]),
              (this.uuidList = t[10]))
            : this.uuidList ||
              ((this.uuidList = []),
              (this.uuidObjList = []),
              (this.uuidPropList = []),
              (this.uuidTypeList = []));
        }
        reset() {
          this.uuidList &&
            ((this.uuidList.length = 0),
            (this.uuidObjList.length = 0),
            (this.uuidPropList.length = 0),
            (this.uuidTypeList.length = 0));
        }
        push(t, e, i, s) {
          this.uuidObjList.push(t),
            this.uuidPropList.push(e),
            this.uuidList.push(i),
            this.uuidTypeList.push(s || "");
        }
      }
      function Cp(t, e) {
        const i = t[4][e[0]],
          s = i[0],
          n = new (0, s[0])(),
          r = s[1],
          a = s[2],
          o = i[i.length - 1];
        let h = 1;
        for (; h < o; ++h) n[r[i[h]]] = e[h];
        for (; h < e.length; ++h) {
          const o = r[i[h]],
            l = s[i[h] + a];
          (0, xp[l])(t, n, o, e[h]);
        }
        return n;
      }
      function Op(t, e, i) {
        const s = new e();
        return s._deserialize ? s._deserialize(i, t[0]) : G(5303, Et(e)), s;
      }
      function Ip(t, e, i, s) {
        s >= 0 ? (e[i] = t[5][s]) : (t[7][3 * ~s] = e);
      }
      function wp(t) {
        return (e, i, s, n) => {
          for (let i = 0; i < n.length; ++i) t(e, n, i, n[i]);
          i[s] = n;
        };
      }
      function Rp(t, e, i, s) {
        (e[i] = null), (t[8][s] = e);
      }
      function Dp(t, e, i, s) {
        e[i] = Cp(t, s);
      }
      t("Details", Ap),
        (Ap.pool = new $t((t) => {
          t.reset();
        }, 5)),
        (Ap.pool.get = function () {
          return this._get() || new Ap();
        });
      const xp = new Array(13);
      function Mp(t, e, i) {
        return t || i(e), Object;
      }
      function Pp(t, e, i, s, n, r, a) {
        let o = t(e);
        if (!o) {
          if (n)
            return void (i[s] =
              ((h = i),
              (l = s),
              (c = e),
              function () {
                const e = t(c) || Mp(r, c, a);
                return (h[l] = e), new e();
              }));
          o = Mp(r, e, a);
        }
        var h, l, c;
        i[s] = o;
      }
      function Np(t, e, i, s) {
        const n = i || Xt,
          r = t[3];
        for (let t = 0; t < r.length; ++t) {
          const a = r[t];
          "string" != typeof a
            ? Pp(n, a[0], a, 0, e, i, s)
            : Pp(n, a, r, t, e, i, s);
        }
      }
      function Lp(t) {
        const e = t[4];
        if (e) {
          const i = t[3];
          for (let t = 0; t < e.length; ++t) {
            const s = e[t];
            s[0] = i[s[0]];
          }
        }
      }
      function Bp(t, e, i) {
        "string" == typeof t && (t = JSON.parse(t));
        let s,
          n = !1;
        if (
          (e || ((e = Ap.pool.get()), (n = !0)),
          (function (t) {
            if (Array.isArray(t)) {
              const e = t[0];
              return "number" == typeof e || e instanceof Fp;
            }
            return !1;
          })(t))
        ) {
          !(function (t, e, i) {
            var s;
            e.init(t), (null !== (s = i) && void 0 !== s) || (i = {});
            let n = t[0],
              r = !1;
            if (
              ("object" == typeof n && ((r = n.preprocessed), (n = n.version)),
              n < 1)
            )
              throw new Error(X(5304, n));
            const a = i;
            var o;
            (a._version = n),
              (a.result = e),
              (t[0] = a),
              r ||
                (Np(
                  t,
                  !1,
                  i.classFinder,
                  null !== (o = i.reportMissingClass) && void 0 !== o
                    ? o
                    : Bp.reportMissingClass
                ),
                Lp(t));
          })(t, e, i);
          const n = t;
          a.game._isCloning = !0;
          const r = n[5],
            o = (function (t) {
              const e = t[5],
                i = t[6],
                s = 0 === i ? 0 : i.length;
              let n = e[e.length - 1],
                r = e.length - s;
              "number" != typeof n ? (n = 0) : (n < 0 && (n = ~n), --r);
              let a = 0;
              for (; a < r; ++a) e[a] = Cp(t, e[a]);
              const o = t[3];
              for (let n = 0; n < s; ++n, ++a) {
                let s = i[n];
                const r = e[a];
                if (s >= 0) {
                  const i = o[s];
                  e[a] = Op(t, i, r);
                } else (s = ~s), (0, xp[s])(t, e, a, r);
              }
              return n;
            })(n);
          (a.game._isCloning = !1),
            n[7] &&
              (function (t, e, i) {
                const s = t.length - 1;
                let n = 0;
                const r = 3 * t[s];
                for (; n < r; n += 3) {
                  const s = t[n],
                    r = e[t[n + 2]],
                    a = t[n + 1];
                  a >= 0 ? (s[i[a]] = r) : (s[~a] = r);
                }
                for (; n < s; n += 3) {
                  const s = e[t[n]],
                    r = e[t[n + 2]],
                    a = t[n + 1];
                  a >= 0 ? (s[i[a]] = r) : (s[~a] = r);
                }
              })(n[7], r, n[2]),
            (function (t) {
              const e = t[5],
                i = t[2],
                s = t[1],
                n = t[8],
                r = t[9],
                a = t[10];
              for (let t = 0; t < n.length; ++t) {
                const o = n[t];
                "number" == typeof o && (n[t] = e[o]);
                let h = r[t];
                "number" == typeof h && ((h = h >= 0 ? i[h] : ~h), (r[t] = h));
                const l = a[t];
                "number" == typeof l && (a[t] = s[l]);
              }
            })(n),
            (s = r[o]);
        } else
          s = (function (t, e, i) {
            var s;
            const n = (i = i || {}).classFinder || Xt,
              r = i.createAssetRefs || zr.platform === pr.EDITOR_CORE,
              o = i.customEnv,
              h = i.ignoreEditorOnly,
              l =
                null !== (s = i.reportMissingClass) && void 0 !== s
                  ? s
                  : a.deserialize.reportMissingClass;
            e.init();
            const c = Sp.pool.get(e, n, l, o, h);
            a.game._isCloning = !0;
            const u = c.deserialize(t);
            return (
              (a.game._isCloning = !1),
              Sp.pool.put(c),
              r &&
                e.assignAssetsBy((t, e) =>
                  EditorExtends.serialize.asAsset(t, e.type)
                ),
              u
            );
          })(t, e, i);
        return n && Ap.pool.put(e), s;
      }
      (xp[0] = function (t, e, i, s) {
        e[i] = s;
      }),
        (xp[1] = Ip),
        (xp[2] = wp(Ip)),
        (xp[3] = wp(Rp)),
        (xp[4] = Dp),
        (xp[5] = function (t, e, i, s) {
          const n = s[0];
          {
            const t = e[i];
            (0, bp[n])(t, s), (e[i] = t);
          }
        }),
        (xp[6] = Rp),
        (xp[7] = function (t, e, i, s) {
          e[i].set(s);
        }),
        (xp[8] = function (t, e, i, s) {
          const n = s[0],
            r = new Ep[n]();
          (0, bp[n])(r, s), (e[i] = r);
        }),
        (xp[9] = wp(Dp)),
        (xp[10] = function (t, e, i, s) {
          const n = t[3][s[0]];
          e[i] = Op(t, n, s[1]);
        }),
        (xp[11] = function (t, e, i, s) {
          const n = s[0];
          e[i] = n;
          for (let e = 1; e < s.length; e += 3) {
            const i = s[e],
              r = s[e + 1],
              a = s[e + 2];
            (0, xp[r])(t, n, i, a);
          }
        }),
        (xp[12] = function (t, e, i, s) {
          const n = s[0];
          for (let e = 0; e < n.length; ++e) {
            const i = n[e],
              r = s[e + 1];
            0 !== r && (0, xp[r])(t, n, e, i);
          }
          e[i] = n;
        }),
        (Bp.Details = Ap),
        (Bp.reportMissingClass = function (t) {
          G(5302, t);
        });
      class Fp {
        constructor(t) {
          (this.preprocessed = !0), (this.version = t);
        }
      }
      function Up(t, e, i) {
        return [1, 0, 0, [t], 0, i ? [e, -1] : [e], [0], 0, [], [], []];
      }
      a.deserialize = Bp;
      const kp = new WeakMap(),
        zp = new WeakSet(),
        Hp = new WeakSet();
      function Gp(t, e) {
        let i;
        i = hp.safeFindClass;
        const s = Ap.pool.get();
        let n;
        try {
          n = Bp(t, s, { classFinder: i, customEnv: e });
        } catch (t) {
          throw (R(t), Ap.pool.put(s), t);
        }
        n._uuid = e.__uuid__ || "";
        const r = s.uuidList,
          a = s.uuidObjList,
          o = s.uuidPropList,
          h = s.uuidTypeList || [],
          l = [];
        for (let t = 0; t < r.length; t++) {
          const e = r[t];
          l[t] = { uuid: pd(e), owner: a[t], prop: o[t], type: Xt(h[t]) };
        }
        return kp.set(n, l), n._native && zp.add(n), Ap.pool.put(s), n;
      }
      class Vp {
        static get instance() {
          return this._instance || (this._instance = new Vp()), this._instance;
        }
        constructor() {
          this._depends = new $_();
        }
        init() {
          this._depends.clear();
        }
        getNativeDep(t) {
          const e = this._depends.get(t);
          return e && e.nativeDep ? { ...e.nativeDep } : null;
        }
        getDeps(t) {
          return this._depends.has(t) ? this._depends.get(t).deps : [];
        }
        getDepsRecursively(t) {
          const e = Object.create(null),
            i = [];
          return this._descend(t, e, i), i;
        }
        remove(t) {
          this._depends.remove(t);
        }
        parse(t, e) {
          let i = null;
          if (Array.isArray(e) || e.__type__ || e instanceof lp) {
            if (this._depends.has(t)) return this._depends.get(t);
            if (
              Array.isArray(e) &&
              !(function (t) {
                const e = t[5],
                  i = e[e.length - 1];
                return "number" == typeof i && i < 0;
              })(e)
            )
              i = { deps: this._parseDepsFromJson(e) };
            else
              try {
                const s = Gp(e, { __uuid__: t });
                (i = this._parseDepsFromAsset(s)),
                  i.nativeDep && (i.nativeDep.uuid = t),
                  td.add(`${t}@import`, s);
              } catch (e) {
                J_.remove(`${t}@import`), (i = { deps: [] });
              }
          } else {
            if (
              this._depends.has(t) &&
              ((i = this._depends.get(t)), i.parsedFromExistAsset)
            )
              return i;
            i = this._parseDepsFromAsset(e);
          }
          return this._depends.add(t, i), i;
        }
        _parseDepsFromAsset(t) {
          const e = { deps: [], parsedFromExistAsset: !0 },
            i = kp.get(t);
          for (let t = 0, s = i.length; t < s; t++) e.deps.push(i[t].uuid);
          return zp.has(t) && (e.nativeDep = t._nativeDep), e;
        }
        _parseDepsFromJson(t) {
          const e = (function (t) {
            const e = t[1];
            return t[10].map((t) => e[t]);
          })(t);
          return e.forEach((t, i) => (e[i] = pd(t))), e;
        }
        _descend(t, e, i) {
          const s = this.getDeps(t);
          for (let t = 0; t < s.length; t++) {
            const n = s[t];
            e[n] || ((e[n] = !0), i.push(n), this._descend(n, e, i));
          }
        }
      }
      Vp._instance = void 0;
      var jp = Vp.instance;
      const Wp = jsb.TextureBase.prototype;
      (Wp._serialize = function () {
        return "";
      }),
        (Wp._deserialize = function (t) {
          const e = t.split(",");
          e.unshift(""),
            e.length >= 5 &&
              (this.setFilters(parseInt(e[1]), parseInt(e[2])),
              this.setWrapMode(parseInt(e[3]), parseInt(e[4]))),
            e.length >= 7 &&
              (this.setMipFilter(parseInt(e[5])),
              this.setAnisotropy(parseInt(e[6])));
        }),
        (Wp._getGFXDevice = function () {
          return I_.gfxDevice;
        }),
        (Wp._getGFXFormat = function () {
          return this._getGFXPixelFormat(this.format);
        }),
        (Wp._setGFXFormat = function (t) {
          this.format = void 0 === t ? Cd.RGBA8888 : t;
        }),
        (Wp._getGFXPixelFormat = function (t) {
          return (
            t === Cd.RGBA_ETC1
              ? (t = Cd.RGB_ETC1)
              : t === Cd.RGB_A_PVRTC_4BPPV1
              ? (t = Cd.RGB_PVRTC_4BPPV1)
              : t === Cd.RGB_A_PVRTC_2BPPV1 && (t = Cd.RGB_PVRTC_2BPPV1),
            t
          );
        }),
        (Wp.createNode = null);
      const Xp = jsb.TextureBase;
      (Xp.Filter = Id),
        (Xp.PixelFormat = Cd),
        (Xp.WrapMode = Od),
        (Wp._ctor = function () {
          jsb.Asset.prototype._ctor.apply(this, arguments),
            (this._gfxSampler = null),
            (this._samplerInfo = null),
            (this._textureHash = 0),
            this._registerGFXSamplerUpdatedListener();
        });
      const Yp = Wp.getGFXSampler;
      Wp.getGFXSampler = function () {
        return (
          this._gfxSampler || (this._gfxSampler = Yp.call(this)),
          this._gfxSampler
        );
      };
      const Kp = Wp.getHash;
      Wp.getHash = function () {
        return (
          0 === this._textureHash && (this._textureHash = Kp.call(this)),
          this._textureHash
        );
      };
      const qp = Wp.getSamplerInfo;
      Wp.getSamplerInfo = function () {
        return (
          this._samplerInfo || (this._samplerInfo = qp.call(this)),
          this._samplerInfo
        );
      };
      const $p = Wp.destroy;
      (Wp.destroy = function () {
        var t;
        return (
          null !== (t = a.director.root) &&
            void 0 !== t &&
            t.batcher2D &&
            a.director.root.batcher2D._releaseDescriptorSetCache(
              this.getGFXTexture(),
              this.getGFXSampler()
            ),
          $p.call(this)
        );
      }),
        (Wp._onGFXSamplerUpdated = function (t, e) {
          (this._gfxSampler = t), (this._samplerInfo = e);
        }),
        (a.TextureBase = jsb.TextureBase),
        (function (t, e = vd) {
          const {
            TextureBase: i,
            PixelFormat: s,
            Filter: n,
            WrapMode: r,
          } = { ...t };
          e(
            () => {
              Na(i.prototype, "_format", () => s.RGBA8888);
            },
            "serializable",
            "_format"
          ),
            e(
              () => {
                Na(i.prototype, "_minFilter", () => n.LINEAR);
              },
              "serializable",
              "_minFilter"
            ),
            e(
              () => {
                Na(i.prototype, "_magFilter", () => n.LINEAR);
              },
              "serializable",
              "_magFilter"
            ),
            e(
              () => {
                Na(i.prototype, "_mipFilter", () => n.NONE);
              },
              "serializable",
              "_mipFilter"
            ),
            e(
              () => {
                Na(i.prototype, "_wrapS", () => r.REPEAT);
              },
              "serializable",
              "_wrapS"
            ),
            e(
              () => {
                Na(i.prototype, "_wrapT", () => r.REPEAT);
              },
              "serializable",
              "_wrapT"
            ),
            e(
              () => {
                Na(i.prototype, "_wrapR", () => r.REPEAT);
              },
              "serializable",
              "_wrapR"
            ),
            e(
              () => {
                Na(i.prototype, "_anisotropy", () => 0);
              },
              "serializable",
              "_anisotropy"
            ),
            e(
              () => {
                Ca("cc.TextureBase")(i);
              },
              "ccclass",
              null
            );
        })({ TextureBase: Xp, Filter: Id, WrapMode: Od, PixelFormat: Cd });
      const Zp = jsb.SimpleTexture,
        Qp = jsb.window;
      (Zp.Filter = Id), (Zp.PixelFormat = Cd), (Zp.WrapMode = Od);
      const Jp = jsb.SimpleTexture.prototype,
        tm = Jp.uploadData;
      (Jp.uploadData = function (t, e = 0, i = 0) {
        let s;
        t instanceof Qp.HTMLCanvasElement
          ? (s = t.data)
          : t instanceof Qp.HTMLImageElement
          ? (s = t._data)
          : ArrayBuffer.isView(t) && (s = t.buffer),
          tm.call(this, s, e, i);
      }),
        (Jp._ctor = function () {
          jsb.TextureBase.prototype._ctor.apply(this, arguments),
            (this._gfxTexture = null),
            this._registerListeners();
        });
      const em = Jp.getGFXTexture;
      (Jp.getGFXTexture = function () {
        return (
          this._gfxTexture || (this._gfxTexture = em.call(this)),
          this._gfxTexture
        );
      }),
        (Jp._onGFXTextureUpdated = function (t) {
          this._gfxTexture = t;
        }),
        (Jp._onAfterAssignImage = function (t) {
          if (Te.CLEANUP_IMAGE_CACHE) {
            const e = jp.getDeps(this._uuid),
              i = e.indexOf(t._uuid);
            -1 !== i && (Jt(e, i), t.decRef());
          }
        }),
        (function (t, e = vd) {
          const { SimpleTexture: i } = { ...t };
          e(
            () => {
              Ca("cc.SimpleTexture")(i);
            },
            "ccclass",
            null
          );
        })({ SimpleTexture: Zp }),
        (a.SimpleTexture = jsb.SimpleTexture);
      const im = jsb.Texture2D.prototype;
      im.createNode = null;
      const sm = t("Texture2D", jsb.Texture2D);
      (sm.Filter = Id),
        (sm.PixelFormat = Cd),
        (sm.WrapMode = Od),
        (im._ctor = function () {
          Zp.prototype._ctor.apply(this, arguments), (this._mipmaps = []);
        }),
        (im._serialize = function () {
          return null;
        }),
        (im._deserialize = function (t, e) {
          const i = t;
          Xp.prototype._deserialize.call(this, i.base, void 0),
            (this._mipmaps = new Array(i.mipmaps.length));
          for (let t = 0; t < i.mipmaps.length; ++t) {
            if (((this._mipmaps[t] = new wd()), !i.mipmaps[t])) continue;
            const s = i.mipmaps[t];
            e.result.push(this._mipmaps, `${t}`, s, qt(wd));
          }
        });
      const nm = im.onLoaded;
      (im.onLoaded = function () {
        this.syncMipmapsForJS(this._mipmaps), nm.call(this);
      }),
        Object.defineProperty(im, "image", {
          configurable: !0,
          enumerable: !0,
          get() {
            return 0 === this._mipmaps.length ? null : this._mipmaps[0];
          },
          set(t) {
            this.mipmaps = t ? [t] : [];
          },
        }),
        Object.defineProperty(im, "mipmaps", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._mipmaps;
          },
          set(t) {
            for (let e = 0, i = t.length; e < i; ++e) t[e]._syncDataToNative();
            (this._mipmaps = t), this.setMipmaps(t);
          },
        }),
        (a.Texture2D = jsb.Texture2D),
        (function (t, e = vd) {
          const { Texture2D: i, ImageAsset: s } = { ...t };
          e(
            () => {
              ao([s])(i.prototype, "_mipmaps", () => []);
            },
            "type",
            "_mipmaps"
          ),
            e(
              () => {
                Ca("cc.Texture2D")(i);
              },
              "ccclass",
              null
            );
        })({ Texture2D: sm, ImageAsset: wd });
      class rm {
        constructor(t, e) {
          (this._innerTextureInfos = {}),
            (this._innerSpriteFrames = []),
            (this._count = 0);
          const i = new am();
          i.initWithSize(t, e),
            (this._texture = i),
            (this._width = t),
            (this._height = e),
            (this._x = 2),
            (this._y = 2),
            (this._nextY = 2);
        }
        insertSpriteFrame(t) {
          const e = t.rect,
            i = t.texture,
            s = this._innerTextureInfos[i.getId()];
          let n = e.x,
            r = e.y;
          if (s) (n += s.x), (r += s.y);
          else {
            const t = i.width,
              e = i.height;
            if (
              (this._x + t + 2 > this._width &&
                ((this._x = 2), (this._y = this._nextY)),
              this._y + e + 2 > this._nextY && (this._nextY = this._y + e + 2),
              this._nextY > this._height)
            )
              return null;
            a.internal.dynamicAtlasManager.textureBleeding &&
              ((t <= 8 || e <= 8) &&
                (this._texture.drawTextureAt(i.image, this._x - 1, this._y - 1),
                this._texture.drawTextureAt(i.image, this._x - 1, this._y + 1),
                this._texture.drawTextureAt(i.image, this._x + 1, this._y - 1),
                this._texture.drawTextureAt(i.image, this._x + 1, this._y + 1)),
              this._texture.drawTextureAt(i.image, this._x - 1, this._y),
              this._texture.drawTextureAt(i.image, this._x + 1, this._y),
              this._texture.drawTextureAt(i.image, this._x, this._y - 1),
              this._texture.drawTextureAt(i.image, this._x, this._y + 1)),
              this._texture.drawTextureAt(i.image, this._x, this._y),
              (this._innerTextureInfos[i.getId()] = {
                x: this._x,
                y: this._y,
                texture: i,
              }),
              this._count++,
              (n += this._x),
              (r += this._y),
              (this._x += t + 2);
          }
          const o = { x: n, y: r, texture: this._texture };
          return this._innerSpriteFrames.push(t), o;
        }
        removeSpriteFrame(t) {
          ee(this._innerSpriteFrames, t);
        }
        deleteInnerTexture(t) {
          t &&
            this._innerTextureInfos[t.getId()] &&
            (delete this._innerTextureInfos[t.getId()], this._count--);
        }
        isEmpty() {
          return this._count <= 0;
        }
        reset() {
          (this._x = 2), (this._y = 2), (this._nextY = 2);
          const t = this._innerSpriteFrames;
          for (let e = 0, i = t.length; e < i; e++) {
            const i = t[e];
            i.isValid && i._resetDynamicAtlasFrame();
          }
          (this._innerSpriteFrames.length = 0), (this._innerTextureInfos = {});
        }
        destroy() {
          this.reset(), this._texture.destroy();
        }
      }
      t("Atlas", rm);
      class am extends sm {
        initWithSize(t, e, i = Cd.RGBA8888) {
          this.reset({ width: t, height: e, format: i });
        }
        drawTextureAt(t, e, i) {
          const s = this.getGFXTexture();
          if (!t || !s) return;
          const n = this._getGFXDevice();
          if (!n) return void z(16363);
          const r = new _u();
          (r.texOffset.x = e),
            (r.texOffset.y = i),
            (r.texExtent.width = t.width),
            (r.texExtent.height = t.height),
            n.copyTexImagesToTexture([t.data], s, [r]);
        }
      }
      const om = t("SceneAsset", jsb.SceneAsset);
      a.SceneAsset = om;
      const hm = om.prototype;
      Object.defineProperty(hm, "scene", {
        enumerable: !0,
        configurable: !0,
        get() {
          return this._scene || (this._scene = this.getScene()), this._scene;
        },
        set(t) {
          (this._scene = t), this.setScene(t);
        },
      }),
        (hm._ctor = function () {
          jsb.Asset.prototype._ctor.apply(this, arguments),
            (this._scene = null);
        }),
        (function (t, e = vd) {
          const { SceneAsset: i } = { ...t };
          e(
            () => {
              Na(i.prototype, "scene", () => null);
            },
            "serializable",
            "scene"
          ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "scene"
            ),
            e(
              () => {
                Ca("cc.SceneAsset")(i);
              },
              "ccclass",
              null
            );
        })({ SceneAsset: om }),
        rt({
          SystemEventType: {
            newName: "Input.EventType",
            since: "3.3.0",
            removed: !1,
          },
        }),
        rt({
          SystemEvent: { newName: "Input", since: "3.4.0", removed: !1 },
          systemEvent: { newName: "input", since: "3.4.0", removed: !1 },
        });
      class lm {
        constructor(t, e) {
          (this.target = null),
            (this.currentTarget = null),
            (this.eventPhase = 0),
            (this.propagationStopped = !1),
            (this.propagationImmediateStopped = !1),
            (this.type = t),
            (this.bubbles = !!e);
        }
        unuse() {
          (this.type = lm.NO_TYPE),
            (this.target = null),
            (this.currentTarget = null),
            (this.eventPhase = lm.NONE),
            (this.propagationStopped = !1),
            (this.propagationImmediateStopped = !1);
        }
        reuse(t, e) {
          (this.type = t), (this.bubbles = e || !1);
        }
        isStopped() {
          return this.propagationStopped || this.propagationImmediateStopped;
        }
        getCurrentTarget() {
          return this.currentTarget;
        }
        getType() {
          return this.type;
        }
      }
      let cm, um;
      t("Event", lm),
        (lm.NO_TYPE = "no_type"),
        (lm.TOUCH = "touch"),
        (lm.MOUSE = "mouse"),
        (lm.KEYBOARD = "keyboard"),
        (lm.ACCELERATION = "acceleration"),
        (lm.NONE = 0),
        (lm.CAPTURING_PHASE = 1),
        (lm.AT_TARGET = 2),
        (lm.BUBBLING_PHASE = 3),
        (a.Event = lm),
        t("SystemEventType", cm),
        (function (t) {
          (t.TOUCH_START = "touch-start"),
            (t.TOUCH_MOVE = "touch-move"),
            (t.TOUCH_END = "touch-end"),
            (t.TOUCH_CANCEL = "touch-cancel"),
            (t.MOUSE_DOWN = "mouse-down"),
            (t.MOUSE_MOVE = "mouse-move"),
            (t.MOUSE_UP = "mouse-up"),
            (t.MOUSE_WHEEL = "mouse-wheel"),
            (t.MOUSE_ENTER = "mouse-enter"),
            (t.MOUSE_LEAVE = "mouse-leave"),
            (t.KEY_DOWN = "keydown"),
            (t.KEY_UP = "keyup"),
            (t.DEVICEMOTION = "devicemotion"),
            (t.TRANSFORM_CHANGED = "transform-changed"),
            (t.SCENE_CHANGED_FOR_PERSISTS = "scene-changed-for-persists"),
            (t.SIZE_CHANGED = "size-changed"),
            (t.ANCHOR_CHANGED = "anchor-changed"),
            (t.COLOR_CHANGED = "color-changed"),
            (t.CHILD_ADDED = "child-added"),
            (t.CHILD_REMOVED = "child-removed"),
            (t.PARENT_CHANGED = "parent-changed"),
            (t.NODE_DESTROYED = "node-destroyed"),
            (t.LAYER_CHANGED = "layer-changed"),
            (t.SIBLING_ORDER_CHANGED = "sibling-order-changed");
        })(cm || t("SystemEventType", (cm = {}))),
        (function (t) {
          (t.TOUCH_START = "touch-start"),
            (t.TOUCH_MOVE = "touch-move"),
            (t.TOUCH_END = "touch-end"),
            (t.TOUCH_CANCEL = "touch-cancel"),
            (t.MOUSE_DOWN = "mouse-down"),
            (t.MOUSE_MOVE = "mouse-move"),
            (t.MOUSE_UP = "mouse-up"),
            (t.MOUSE_LEAVE = "mouse-leave-window"),
            (t.MOUSE_ENTER = "mouse-enter-window"),
            (t.MOUSE_WHEEL = "mouse-wheel"),
            (t.KEY_DOWN = "keydown"),
            (t.KEY_PRESSING = "key-pressing"),
            (t.KEY_UP = "keyup"),
            (t.DEVICEMOTION = "devicemotion"),
            (t.GAMEPAD_INPUT = "gamepad-input"),
            (t.GAMEPAD_CHANGE = "gamepad-change"),
            (t.HANDLE_INPUT = "handle-input"),
            (t.HANDLE_POSE_INPUT = "handle-pose-input"),
            (t.HMD_POSE_INPUT = "hmd-pose-input"),
            (t.HANDHELD_POSE_INPUT = "handheld-pose-input");
        })(um || (um = {})),
        (a.SystemEventType = cm);
      class _m extends lm {
        constructor(t, e) {
          super(cm.DEVICEMOTION, e), (this.acc = t);
        }
      }
      t("EventAcceleration", _m), (lm.EventAcceleration = _m);
      class dm extends lm {
        get isPressed() {
          return this._isPressed;
        }
        constructor(t, e, i) {
          "boolean" == typeof e && (e = e ? cm.KEY_DOWN : cm.KEY_UP),
            super(e, i),
            (this.rawEvent = void 0),
            (this._isPressed = e !== cm.KEY_UP),
            "number" == typeof t
              ? (this.keyCode = t)
              : ((this.keyCode = t.keyCode), (this.rawEvent = t)),
            (this.windowId = 0);
        }
      }
      t("EventKeyboard", dm), (lm.EventKeyboard = dm);
      class pm extends lm {
        get eventType() {
          return this._eventType;
        }
        constructor(t, e, i, s) {
          super(t, e),
            (this.movementX = 0),
            (this.movementY = 0),
            (this.windowId = 0),
            (this.preventSwallow = !1),
            (this._button = pm.BUTTON_MISSING),
            (this._x = 0),
            (this._y = 0),
            (this._prevX = 0),
            (this._prevY = 0),
            (this._scrollX = 0),
            (this._scrollY = 0),
            (this._eventType = t),
            i && ((this._prevX = i.x), (this._prevY = i.y)),
            (this.windowId = null != s ? s : this.windowId);
        }
        setScrollData(t, e) {
          (this._scrollX = t), (this._scrollY = e);
        }
        getScrollX() {
          return this._scrollX;
        }
        getScrollY() {
          return this._scrollY;
        }
        setLocation(t, e) {
          (this._x = t), (this._y = e);
        }
        getLocation(t) {
          return t || (t = new Ss()), Ss.set(t, this._x, this._y), t;
        }
        getLocationInView(t) {
          t || (t = new Ss());
          const e = a.view.scenes.get(this.windowId),
            i = e
              ? e.designResolutionSize.height
              : a.view._designResolutionSize.height;
          return Ss.set(t, this._x, i - this._y), t;
        }
        getUILocation(t) {
          return (
            t || (t = new Ss()),
            Ss.set(t, this._x, this._y),
            a.view._convertToUISpace(t, this.windowId),
            t
          );
        }
        getPreviousLocation(t) {
          return t || (t = new Ss()), Ss.set(t, this._prevX, this._prevY), t;
        }
        getUIPreviousLocation(t) {
          return (
            t || (t = new Ss()),
            Ss.set(t, this._prevX, this._prevY),
            a.view._convertToUISpace(t, this.windowId),
            t
          );
        }
        getDelta(t) {
          return (
            t || (t = new Ss()),
            Ss.set(t, this._x - this._prevX, this._y - this._prevY),
            t
          );
        }
        getDeltaX() {
          return this._x - this._prevX;
        }
        getDeltaY() {
          return this._y - this._prevY;
        }
        getUIDelta(t) {
          t || (t = new Ss());
          const e = a.view.scenes.get(this.windowId),
            i = e ? e.designResolutionScaleX : a.view.getScaleX(),
            s = e ? e.designResolutionScaleY : a.view.getScaleY();
          return (
            Ss.set(t, (this._x - this._prevX) / i, (this._y - this._prevY) / s),
            t
          );
        }
        getUIDeltaX() {
          const t = a.view.scenes.get(this.windowId),
            e = t ? t.designResolutionScaleX : a.view.getScaleX();
          return (this._x - this._prevX) / e;
        }
        getUIDeltaY() {
          const t = a.view.scenes.get(this.windowId),
            e = t ? t.designResolutionScaleY : a.view.getScaleY();
          return (this._y - this._prevY) / e;
        }
        setButton(t) {
          this._button = t;
        }
        getButton() {
          return this._button;
        }
        getLocationX() {
          return this._x;
        }
        getLocationY() {
          return this._y;
        }
        getUILocationX() {
          const t = a.view.scenes.get(this.windowId),
            e = t ? t.viewportRect : a.view.getViewportRect(),
            i = t ? t.designResolutionScaleX : a.view.getScaleX();
          return (this._x - e.x) / i;
        }
        getUILocationY() {
          const t = a.view.scenes.get(this.windowId),
            e = t ? t.viewportRect : a.view.getViewportRect(),
            i = t ? t.designResolutionScaleY : a.view.getScaleY();
          return (this._y - e.y) / i;
        }
      }
      t("EventMouse", pm),
        (pm.BUTTON_MISSING = -1),
        (pm.BUTTON_LEFT = 0),
        (pm.BUTTON_RIGHT = 2),
        (pm.BUTTON_MIDDLE = 1),
        (pm.BUTTON_4 = 3),
        (pm.BUTTON_5 = 4),
        (pm.BUTTON_6 = 5),
        (pm.BUTTON_7 = 6),
        (pm.BUTTON_8 = 7),
        (lm.EventMouse = pm);
      const mm = new Ss();
      class fm extends lm {
        constructor(t, e, i, s = []) {
          super(i, e),
            (this.touch = null),
            (this.simulate = !1),
            (this.windowId = 0),
            (this.preventSwallow = !1),
            (this._eventCode = i),
            (this._touches = t || []),
            (this._allTouches = s);
        }
        getEventCode() {
          return this._eventCode;
        }
        getTouches() {
          return this._touches;
        }
        getAllTouches() {
          return this._allTouches;
        }
        setLocation(t, e) {
          this.touch && this.touch.setTouchInfo(this.touch.getID(), t, e);
        }
        getLocation(t) {
          return this.touch ? this.touch.getLocation(t) : new Ss();
        }
        getUILocation(t) {
          return this.touch ? this.touch.getUILocation(t) : new Ss();
        }
        getLocationInView(t) {
          return this.touch ? this.touch.getLocationInView(t) : new Ss();
        }
        getPreviousLocation(t) {
          return this.touch ? this.touch.getPreviousLocation(t) : new Ss();
        }
        getStartLocation(t) {
          return this.touch ? this.touch.getStartLocation(t) : new Ss();
        }
        getUIStartLocation(t) {
          return this.touch ? this.touch.getUIStartLocation(t) : new Ss();
        }
        getID() {
          return this.touch ? this.touch.getID() : null;
        }
        getDelta(t) {
          return this.touch ? this.touch.getDelta(t) : new Ss();
        }
        getUIDelta(t) {
          return this.touch ? this.touch.getUIDelta(t) : new Ss();
        }
        getDeltaX() {
          return this.touch ? this.touch.getDelta(mm).x : 0;
        }
        getDeltaY() {
          return this.touch ? this.touch.getDelta(mm).y : 0;
        }
        getLocationX() {
          return this.touch ? this.touch.getLocationX() : 0;
        }
        getLocationY() {
          return this.touch ? this.touch.getLocationY() : 0;
        }
      }
      t("EventTouch", fm), (fm.MAX_TOUCHES = 5), (lm.EventTouch = fm);
      class gm extends lm {
        constructor(t, e) {
          super(t, !1), (this.gamepad = e);
        }
      }
      t("EventGamepad", gm);
      class ym extends lm {
        constructor(t, e) {
          super(t, !1), (this.handleInputDevice = e);
        }
      }
      t("EventHandle", ym);
      class Tm extends lm {
        constructor(t, e) {
          super(t, !1), (this.hmdInputDevice = e);
        }
      }
      t("EventHMD", Tm);
      class Sm extends lm {
        constructor(t, e) {
          super(t, !1), (this.handheldInputDevice = e);
        }
      }
      t("EventHandheld", Sm);
      class Em {
        constructor(t = 0, e = 0, i = 0, s = 0) {
          (this.x = t), (this.y = e), (this.z = i), (this.timestamp = s);
        }
      }
      let vm;
      t("Acceleration", Em),
        t("KeyCode", vm),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.MOBILE_BACK = 6)] = "MOBILE_BACK"),
            (t[(t.BACKSPACE = 8)] = "BACKSPACE"),
            (t[(t.TAB = 9)] = "TAB"),
            (t[(t.ENTER = 13)] = "ENTER"),
            (t[(t.SHIFT_LEFT = 16)] = "SHIFT_LEFT"),
            (t[(t.CTRL_LEFT = 17)] = "CTRL_LEFT"),
            (t[(t.ALT_LEFT = 18)] = "ALT_LEFT"),
            (t[(t.PAUSE = 19)] = "PAUSE"),
            (t[(t.CAPS_LOCK = 20)] = "CAPS_LOCK"),
            (t[(t.ESCAPE = 27)] = "ESCAPE"),
            (t[(t.SPACE = 32)] = "SPACE"),
            (t[(t.PAGE_UP = 33)] = "PAGE_UP"),
            (t[(t.PAGE_DOWN = 34)] = "PAGE_DOWN"),
            (t[(t.END = 35)] = "END"),
            (t[(t.HOME = 36)] = "HOME"),
            (t[(t.ARROW_LEFT = 37)] = "ARROW_LEFT"),
            (t[(t.ARROW_UP = 38)] = "ARROW_UP"),
            (t[(t.ARROW_RIGHT = 39)] = "ARROW_RIGHT"),
            (t[(t.ARROW_DOWN = 40)] = "ARROW_DOWN"),
            (t[(t.INSERT = 45)] = "INSERT"),
            (t[(t.DELETE = 46)] = "DELETE"),
            (t[(t.DIGIT_0 = 48)] = "DIGIT_0"),
            (t[(t.DIGIT_1 = 49)] = "DIGIT_1"),
            (t[(t.DIGIT_2 = 50)] = "DIGIT_2"),
            (t[(t.DIGIT_3 = 51)] = "DIGIT_3"),
            (t[(t.DIGIT_4 = 52)] = "DIGIT_4"),
            (t[(t.DIGIT_5 = 53)] = "DIGIT_5"),
            (t[(t.DIGIT_6 = 54)] = "DIGIT_6"),
            (t[(t.DIGIT_7 = 55)] = "DIGIT_7"),
            (t[(t.DIGIT_8 = 56)] = "DIGIT_8"),
            (t[(t.DIGIT_9 = 57)] = "DIGIT_9"),
            (t[(t.KEY_A = 65)] = "KEY_A"),
            (t[(t.KEY_B = 66)] = "KEY_B"),
            (t[(t.KEY_C = 67)] = "KEY_C"),
            (t[(t.KEY_D = 68)] = "KEY_D"),
            (t[(t.KEY_E = 69)] = "KEY_E"),
            (t[(t.KEY_F = 70)] = "KEY_F"),
            (t[(t.KEY_G = 71)] = "KEY_G"),
            (t[(t.KEY_H = 72)] = "KEY_H"),
            (t[(t.KEY_I = 73)] = "KEY_I"),
            (t[(t.KEY_J = 74)] = "KEY_J"),
            (t[(t.KEY_K = 75)] = "KEY_K"),
            (t[(t.KEY_L = 76)] = "KEY_L"),
            (t[(t.KEY_M = 77)] = "KEY_M"),
            (t[(t.KEY_N = 78)] = "KEY_N"),
            (t[(t.KEY_O = 79)] = "KEY_O"),
            (t[(t.KEY_P = 80)] = "KEY_P"),
            (t[(t.KEY_Q = 81)] = "KEY_Q"),
            (t[(t.KEY_R = 82)] = "KEY_R"),
            (t[(t.KEY_S = 83)] = "KEY_S"),
            (t[(t.KEY_T = 84)] = "KEY_T"),
            (t[(t.KEY_U = 85)] = "KEY_U"),
            (t[(t.KEY_V = 86)] = "KEY_V"),
            (t[(t.KEY_W = 87)] = "KEY_W"),
            (t[(t.KEY_X = 88)] = "KEY_X"),
            (t[(t.KEY_Y = 89)] = "KEY_Y"),
            (t[(t.KEY_Z = 90)] = "KEY_Z"),
            (t[(t.NUM_0 = 96)] = "NUM_0"),
            (t[(t.NUM_1 = 97)] = "NUM_1"),
            (t[(t.NUM_2 = 98)] = "NUM_2"),
            (t[(t.NUM_3 = 99)] = "NUM_3"),
            (t[(t.NUM_4 = 100)] = "NUM_4"),
            (t[(t.NUM_5 = 101)] = "NUM_5"),
            (t[(t.NUM_6 = 102)] = "NUM_6"),
            (t[(t.NUM_7 = 103)] = "NUM_7"),
            (t[(t.NUM_8 = 104)] = "NUM_8"),
            (t[(t.NUM_9 = 105)] = "NUM_9"),
            (t[(t.NUM_MULTIPLY = 106)] = "NUM_MULTIPLY"),
            (t[(t.NUM_PLUS = 107)] = "NUM_PLUS"),
            (t[(t.NUM_SUBTRACT = 109)] = "NUM_SUBTRACT"),
            (t[(t.NUM_DECIMAL = 110)] = "NUM_DECIMAL"),
            (t[(t.NUM_DIVIDE = 111)] = "NUM_DIVIDE"),
            (t[(t.F1 = 112)] = "F1"),
            (t[(t.F2 = 113)] = "F2"),
            (t[(t.F3 = 114)] = "F3"),
            (t[(t.F4 = 115)] = "F4"),
            (t[(t.F5 = 116)] = "F5"),
            (t[(t.F6 = 117)] = "F6"),
            (t[(t.F7 = 118)] = "F7"),
            (t[(t.F8 = 119)] = "F8"),
            (t[(t.F9 = 120)] = "F9"),
            (t[(t.F10 = 121)] = "F10"),
            (t[(t.F11 = 122)] = "F11"),
            (t[(t.F12 = 123)] = "F12"),
            (t[(t.NUM_LOCK = 144)] = "NUM_LOCK"),
            (t[(t.SCROLL_LOCK = 145)] = "SCROLL_LOCK"),
            (t[(t.SEMICOLON = 186)] = "SEMICOLON"),
            (t[(t.EQUAL = 187)] = "EQUAL"),
            (t[(t.COMMA = 188)] = "COMMA"),
            (t[(t.DASH = 189)] = "DASH"),
            (t[(t.PERIOD = 190)] = "PERIOD"),
            (t[(t.SLASH = 191)] = "SLASH"),
            (t[(t.BACK_QUOTE = 192)] = "BACK_QUOTE"),
            (t[(t.BRACKET_LEFT = 219)] = "BRACKET_LEFT"),
            (t[(t.BACKSLASH = 220)] = "BACKSLASH"),
            (t[(t.BRACKET_RIGHT = 221)] = "BRACKET_RIGHT"),
            (t[(t.QUOTE = 222)] = "QUOTE"),
            (t[(t.SHIFT_RIGHT = 2e3)] = "SHIFT_RIGHT"),
            (t[(t.CTRL_RIGHT = 2001)] = "CTRL_RIGHT"),
            (t[(t.ALT_RIGHT = 2002)] = "ALT_RIGHT"),
            (t[(t.NUM_ENTER = 2003)] = "NUM_ENTER");
        })(vm || t("KeyCode", (vm = {})));
      const bm = new Ss();
      class Am {
        get lastModified() {
          return this._lastModified;
        }
        constructor(t, e, i = 0, s) {
          (this._point = new Ss()),
            (this._prevPoint = new Ss()),
            (this._lastModified = 0),
            (this._id = 0),
            (this._startPoint = new Ss()),
            (this._startPointCaptured = !1),
            (this.windowId = 0),
            this.setTouchInfo(i, t, e, s);
        }
        getLocation(t) {
          return t || (t = new Ss()), t.set(this._point.x, this._point.y), t;
        }
        getLocationX() {
          return this._point.x;
        }
        getLocationY() {
          return this._point.y;
        }
        getUILocation(t) {
          return (
            t || (t = new Ss()),
            t.set(this._point.x, this._point.y),
            a.view._convertToUISpace(t, this.windowId),
            t
          );
        }
        getUILocationX() {
          const t = a.view.scenes.get(this.windowId),
            e = t ? t.viewportRect : a.view.getViewportRect(),
            i = t ? t.designResolutionScaleX : a.view.getScaleX();
          return (this._point.x - e.x) / i;
        }
        getUILocationY() {
          const t = a.view.scenes.get(this.windowId),
            e = t ? t.viewportRect : a.view.getViewportRect(),
            i = t ? t.designResolutionScaleY : a.view.getScaleY();
          return (this._point.y - e.y) / i;
        }
        getPreviousLocation(t) {
          return (
            t || (t = new Ss()), t.set(this._prevPoint.x, this._prevPoint.y), t
          );
        }
        getUIPreviousLocation(t) {
          return (
            t || (t = new Ss()),
            t.set(this._prevPoint.x, this._prevPoint.y),
            a.view._convertToUISpace(t, this.windowId),
            t
          );
        }
        getStartLocation(t) {
          return (
            t || (t = new Ss()),
            t.set(this._startPoint.x, this._startPoint.y),
            t
          );
        }
        getUIStartLocation(t) {
          return (
            t || (t = new Ss()),
            t.set(this._startPoint.x, this._startPoint.y),
            a.view._convertToUISpace(t, this.windowId),
            t
          );
        }
        getDelta(t) {
          return (
            t || (t = new Ss()),
            t.set(this._point),
            t.subtract(this._prevPoint),
            t
          );
        }
        getUIDelta(t) {
          t || (t = new Ss()),
            bm.set(this._point),
            bm.subtract(this._prevPoint);
          const e = a.view.scenes.get(this.windowId),
            i = e ? e.designResolutionScaleX : a.view.getScaleX(),
            s = e ? e.designResolutionScaleY : a.view.getScaleY();
          return t.set(i, s), Ss.divide(t, bm, t), t;
        }
        getLocationInView(t) {
          t || (t = new Ss());
          const e = a.view.scenes.get(this.windowId),
            i = e
              ? e.designResolutionSize.height
              : a.view._designResolutionSize.height;
          return t.set(this._point.x, i - this._point.y), t;
        }
        getPreviousLocationInView(t) {
          t || (t = new Ss());
          const e = a.view.scenes.get(this.windowId),
            i = e
              ? e.designResolutionSize.height
              : a.view._designResolutionSize.height;
          return t.set(this._prevPoint.x, i - this._prevPoint.y), t;
        }
        getStartLocationInView(t) {
          t || (t = new Ss());
          const e = a.view.scenes.get(this.windowId),
            i = e
              ? e.designResolutionSize.height
              : a.view._designResolutionSize.height;
          return t.set(this._startPoint.x, i - this._startPoint.y), t;
        }
        getID() {
          return this._id;
        }
        setTouchInfo(t = 0, e = 0, i = 0, s) {
          (this._prevPoint = this._point),
            (this._point = new Ss(e || 0, i || 0)),
            (this._id = t),
            (this.windowId = null != s ? s : this.windowId),
            this._startPointCaptured ||
              ((this._startPoint = new Ss(this._point)),
              (this._startPointCaptured = !0));
        }
        setPoint(t, e) {
          "object" == typeof t
            ? ((this._point.x = t.x), (this._point.y = t.y))
            : ((this._point.x = t || 0), (this._point.y = e || 0)),
            (this._lastModified = a.game.frameStartTime);
        }
        setPrevPoint(t, e) {
          (this._prevPoint =
            "object" == typeof t ? new Ss(t.x, t.y) : new Ss(t || 0, e || 0)),
            (this._lastModified = a.game.frameStartTime);
        }
        clone() {
          const t = this.getID();
          this.getStartLocation(bm);
          const e = new Am(bm.x, bm.y, t);
          return (
            this.getLocation(bm),
            e.setPoint(bm.x, bm.y),
            this.getPreviousLocation(bm),
            e.setPrevPoint(bm),
            e
          );
        }
      }
      t("Touch", Am), (a.Touch = Am);
      class Cm {
        constructor() {
          (this._intervalInSeconds = 0.2),
            (this._intervalId = void 0),
            (this._isEnabled = !1),
            (this._eventTarget = new hr()),
            (this._didAccelerateFunc = this._didAccelerate.bind(this));
        }
        _didAccelerate() {
          const t = jsb.device.getDeviceMotionValue();
          let e = 0.1 * t[3],
            i = 0.1 * t[4];
          const s = 0.1 * t[5],
            n = Ur.orientation,
            r = e;
          n === ye.LANDSCAPE_RIGHT
            ? ((e = -i), (i = r))
            : n === ye.LANDSCAPE_LEFT
            ? ((e = i), (i = -r))
            : n === ye.PORTRAIT_UPSIDE_DOWN && ((e = -e), (i = -i)),
            (yr.os !== dr.ANDROID &&
              yr.os !== dr.OHOS &&
              yr.os !== dr.OPENHARMONY) ||
              ((e = -e), (i = -i));
          const a = performance.now(),
            o = new Em(e, i, s, a),
            h = new _m(o);
          this._eventTarget.emit(um.DEVICEMOTION, h);
        }
        start() {
          this._intervalId && clearInterval(this._intervalId),
            (this._intervalId = setInterval(
              this._didAccelerateFunc,
              1e3 * this._intervalInSeconds
            )),
            jsb.device.setAccelerometerInterval(this._intervalInSeconds),
            jsb.device.setAccelerometerEnabled(!0),
            (this._isEnabled = !0);
        }
        stop() {
          this._intervalId &&
            (clearInterval(this._intervalId), (this._intervalId = void 0)),
            jsb.device.setAccelerometerEnabled(!1),
            (this._isEnabled = !1);
        }
        setInterval(t) {
          (this._intervalInSeconds = t / 1e3),
            jsb.device.setAccelerometerInterval(this._intervalInSeconds),
            this._isEnabled &&
              (jsb.device.setAccelerometerEnabled(!1),
              jsb.device.setAccelerometerEnabled(!0));
        }
        on(t, e, i) {
          this._eventTarget.on(t, e, i);
        }
      }
      class Om {}
      class Im extends Om {
        getValue() {
          throw new Error("Method not implemented.");
        }
      }
      class wm extends Om {
        getValue() {
          throw new Error("Method not implemented.");
        }
      }
      class Rm extends Om {
        getValue() {
          throw new Error("Method not implemented.");
        }
      }
      class Dm extends Om {
        getValue() {
          throw new Error("Method not implemented.");
        }
      }
      class xm extends Im {
        constructor(t) {
          super(), (this.positive = t.positive), (this.negative = t.negative);
        }
        getValue() {
          const t = this.positive.getValue(),
            e = this.negative.getValue();
          return Math.abs(t) > Math.abs(e) ? t : -e;
        }
      }
      class Mm extends wm {
        constructor(t) {
          super(),
            (this.up = t.up),
            (this.down = t.down),
            (this.left = t.left),
            (this.right = t.right),
            (this.xAxis = new xm({
              positive: this.right,
              negative: this.left,
            })),
            (this.yAxis = new xm({ positive: this.up, negative: this.down }));
        }
        getValue() {
          return new Ss(this.xAxis.getValue(), this.yAxis.getValue());
        }
      }
      class Pm extends Im {
        getValue() {
          return super.getValue();
        }
      }
      class Nm extends Mm {}
      class Lm extends Mm {}
      class Bm extends Dm {
        getValue() {
          return super.getValue();
        }
      }
      class Fm extends Rm {
        getValue() {
          return super.getValue();
        }
      }
      class Um extends Im {
        getValue() {
          return super.getValue();
        }
      }
      var km;
      !(function (t) {
        (t[(t.BUTTON_SOUTH = 0)] = "BUTTON_SOUTH"),
          (t[(t.BUTTON_EAST = 1)] = "BUTTON_EAST"),
          (t[(t.BUTTON_WEST = 2)] = "BUTTON_WEST"),
          (t[(t.BUTTON_NORTH = 3)] = "BUTTON_NORTH"),
          (t[(t.NS_MINUS = 4)] = "NS_MINUS"),
          (t[(t.NS_PLUS = 5)] = "NS_PLUS"),
          (t[(t.BUTTON_L1 = 6)] = "BUTTON_L1"),
          (t[(t.BUTTON_L2 = 7)] = "BUTTON_L2"),
          (t[(t.BUTTON_L3 = 8)] = "BUTTON_L3"),
          (t[(t.BUTTON_R1 = 9)] = "BUTTON_R1"),
          (t[(t.BUTTON_R2 = 10)] = "BUTTON_R2"),
          (t[(t.BUTTON_R3 = 11)] = "BUTTON_R3"),
          (t[(t.DPAD_UP = 12)] = "DPAD_UP"),
          (t[(t.DPAD_DOWN = 13)] = "DPAD_DOWN"),
          (t[(t.DPAD_LEFT = 14)] = "DPAD_LEFT"),
          (t[(t.DPAD_RIGHT = 15)] = "DPAD_RIGHT"),
          (t[(t.LEFT_STICK_UP = 16)] = "LEFT_STICK_UP"),
          (t[(t.LEFT_STICK_DOWN = 17)] = "LEFT_STICK_DOWN"),
          (t[(t.LEFT_STICK_LEFT = 18)] = "LEFT_STICK_LEFT"),
          (t[(t.LEFT_STICK_RIGHT = 19)] = "LEFT_STICK_RIGHT"),
          (t[(t.RIGHT_STICK_UP = 20)] = "RIGHT_STICK_UP"),
          (t[(t.RIGHT_STICK_DOWN = 21)] = "RIGHT_STICK_DOWN"),
          (t[(t.RIGHT_STICK_LEFT = 22)] = "RIGHT_STICK_LEFT"),
          (t[(t.RIGHT_STICK_RIGHT = 23)] = "RIGHT_STICK_RIGHT"),
          (t[(t.ROKID_MENU = 24)] = "ROKID_MENU"),
          (t[(t.ROKID_START = 25)] = "ROKID_START");
      })(km || (km = {}));
      const zm = {
        1: km.BUTTON_EAST,
        2: km.BUTTON_SOUTH,
        3: km.BUTTON_NORTH,
        4: km.BUTTON_WEST,
        5: km.BUTTON_L1,
        6: km.BUTTON_R1,
        7: km.NS_MINUS,
        8: km.NS_PLUS,
        9: km.BUTTON_L3,
        10: km.BUTTON_R3,
        11: km.ROKID_MENU,
        12: km.ROKID_START,
      };
      class Hm {
        get buttonNorth() {
          return this._buttonNorth;
        }
        get buttonEast() {
          return this._buttonEast;
        }
        get buttonWest() {
          return this._buttonWest;
        }
        get buttonSouth() {
          return this._buttonSouth;
        }
        get buttonL1() {
          return this._buttonL1;
        }
        get buttonL2() {
          return this._buttonL2;
        }
        get buttonL3() {
          return this._buttonL3;
        }
        get buttonR1() {
          return this._buttonR1;
        }
        get buttonR2() {
          return this._buttonR2;
        }
        get buttonR3() {
          return this._buttonR3;
        }
        get buttonShare() {
          return this._buttonShare;
        }
        get buttonOptions() {
          return this._buttonOptions;
        }
        get dpad() {
          return this._dpad;
        }
        get leftStick() {
          return this._leftStick;
        }
        get rightStick() {
          return this._rightStick;
        }
        get buttonStart() {
          return this._buttonStart;
        }
        get gripLeft() {
          return this._gripLeft;
        }
        get gripRight() {
          return this._gripRight;
        }
        get handLeftPosition() {
          return this._handLeftPosition;
        }
        get handLeftOrientation() {
          return this._handLeftOrientation;
        }
        get handRightPosition() {
          return this._handRightPosition;
        }
        get handRightOrientation() {
          return this._handRightOrientation;
        }
        get aimLeftPosition() {
          return this._aimLeftPosition;
        }
        get aimLeftOrientation() {
          return this._aimLeftOrientation;
        }
        get aimRightPosition() {
          return this._aimRightPosition;
        }
        get aimRightOrientation() {
          return this._aimRightOrientation;
        }
        get deviceId() {
          return this._deviceId;
        }
        get connected() {
          return this._connected;
        }
        constructor(t) {
          (this._deviceId = -1),
            (this._connected = !1),
            (this._nativeButtonState = {
              [km.BUTTON_SOUTH]: 0,
              [km.BUTTON_EAST]: 0,
              [km.BUTTON_WEST]: 0,
              [km.BUTTON_NORTH]: 0,
              [km.NS_MINUS]: 0,
              [km.NS_PLUS]: 0,
              [km.BUTTON_L1]: 0,
              [km.BUTTON_L2]: 0,
              [km.BUTTON_L3]: 0,
              [km.BUTTON_R1]: 0,
              [km.BUTTON_R2]: 0,
              [km.BUTTON_R3]: 0,
              [km.DPAD_UP]: 0,
              [km.DPAD_DOWN]: 0,
              [km.DPAD_LEFT]: 0,
              [km.DPAD_RIGHT]: 0,
              [km.LEFT_STICK_UP]: 0,
              [km.LEFT_STICK_DOWN]: 0,
              [km.LEFT_STICK_LEFT]: 0,
              [km.LEFT_STICK_RIGHT]: 0,
              [km.RIGHT_STICK_UP]: 0,
              [km.RIGHT_STICK_DOWN]: 0,
              [km.RIGHT_STICK_LEFT]: 0,
              [km.RIGHT_STICK_RIGHT]: 0,
              [km.ROKID_MENU]: 0,
              [km.ROKID_START]: 0,
            }),
            (this._deviceId = t),
            this._initInputSource();
        }
        static _init() {
          yr.hasFeature(mr.EVENT_GAMEPAD) && Hm._registerEvent();
        }
        static _on(t, e, i) {
          Hm._eventTarget.on(t, e, i);
        }
        static _removeInputDevice(t) {
          const e = Hm.all.findIndex((e) => e.deviceId === t);
          -1 !== e && Jt(Hm.all, e);
        }
        static _getInputDevice(t) {
          return Hm.all.find((e) => e.deviceId === t);
        }
        static _createInputDevice(t, e) {
          const i = new Hm(t);
          return (i._connected = e), Hm.all.push(i), i;
        }
        static _getOrCreateInputDevice(t, e) {
          let i = Hm._getInputDevice(t);
          return i || (i = Hm._createInputDevice(t, e)), (i._connected = e), i;
        }
        static _registerEvent() {
          (jsb.onControllerInput = (t) => {
            for (let e = 0; e < t.length; ++e) {
              const i = t[e],
                s = Hm._getOrCreateInputDevice(i.id, !0);
              s._updateNativeButtonState(i),
                Hm._eventTarget.emit(
                  um.GAMEPAD_INPUT,
                  new gm(um.GAMEPAD_INPUT, s)
                );
            }
          }),
            (jsb.onControllerChange = (t) => {
              for (let e = 0; e < t.length; ++e) {
                const i = t[e];
                let s = Hm._getInputDevice(i);
                s ||
                  ((s = Hm._createInputDevice(i, !0)),
                  Hm._eventTarget.emit(
                    um.GAMEPAD_CHANGE,
                    new gm(um.GAMEPAD_CHANGE, s)
                  ));
              }
              const e = Hm.all;
              for (let i = 0; i < e.length; ++i) {
                const s = e[i];
                t.includes(s.deviceId) ||
                  (Hm._removeInputDevice(s.deviceId),
                  (s._connected = !1),
                  Hm._eventTarget.emit(
                    um.GAMEPAD_CHANGE,
                    new gm(um.GAMEPAD_CHANGE, s)
                  ));
              }
            });
        }
        _axisToButtons(t) {
          const e = Math.abs(t);
          return t > 0
            ? { negative: 0, positive: e }
            : t < 0
            ? { negative: e, positive: 0 }
            : { negative: 0, positive: 0 };
        }
        _updateNativeButtonState(t) {
          const { buttonInfoList: e, axisInfoList: i } = t;
          for (let t = 0; t < e.length; ++t) {
            const i = e[t],
              s = zm[i.code];
            this._nativeButtonState[s] = i.isPressed ? 1 : 0;
          }
          for (let t = 0; t < i.length; ++t) {
            const e = i[t],
              { code: s, value: n } = e;
            let r, a, o;
            switch (s) {
              case 1:
                (r = km.DPAD_LEFT),
                  (a = km.DPAD_RIGHT),
                  (o = this._axisToButtons(n));
                break;
              case 2:
                (r = km.DPAD_DOWN),
                  (a = km.DPAD_UP),
                  (o = this._axisToButtons(n));
                break;
              case 3:
                (r = km.LEFT_STICK_LEFT),
                  (a = km.LEFT_STICK_RIGHT),
                  (o = this._axisToButtons(n));
                break;
              case 4:
                (r = km.LEFT_STICK_DOWN),
                  (a = km.LEFT_STICK_UP),
                  (o = this._axisToButtons(n));
                break;
              case 5:
                (r = km.RIGHT_STICK_LEFT),
                  (a = km.RIGHT_STICK_RIGHT),
                  (o = this._axisToButtons(n));
                break;
              case 6:
                (r = km.RIGHT_STICK_DOWN),
                  (a = km.RIGHT_STICK_UP),
                  (o = this._axisToButtons(n));
                break;
              default:
                7 === s
                  ? (this._nativeButtonState[km.BUTTON_L2] = n)
                  : 8 === s && (this._nativeButtonState[km.BUTTON_R2] = n);
            }
            r &&
              a &&
              o &&
              ((this._nativeButtonState[r] = o.negative),
              (this._nativeButtonState[a] = o.positive));
          }
        }
        _initInputSource() {
          (this._buttonNorth = new Pm()),
            (this._buttonNorth.getValue = () =>
              this._nativeButtonState[km.BUTTON_NORTH]),
            (this._buttonEast = new Pm()),
            (this._buttonEast.getValue = () =>
              this._nativeButtonState[km.BUTTON_EAST]),
            (this._buttonWest = new Pm()),
            (this._buttonWest.getValue = () =>
              this._nativeButtonState[km.BUTTON_WEST]),
            (this._buttonSouth = new Pm()),
            (this._buttonSouth.getValue = () =>
              this._nativeButtonState[km.BUTTON_SOUTH]),
            (this._buttonL1 = new Pm()),
            (this._buttonL1.getValue = () =>
              this._nativeButtonState[km.BUTTON_L1]),
            (this._buttonL2 = new Pm()),
            (this._buttonL2.getValue = () =>
              this._nativeButtonState[km.BUTTON_L2]),
            (this._buttonL3 = new Pm()),
            (this._buttonL3.getValue = () =>
              this._nativeButtonState[km.BUTTON_L3]),
            (this._buttonR1 = new Pm()),
            (this._buttonR1.getValue = () =>
              this._nativeButtonState[km.BUTTON_R1]),
            (this._buttonR2 = new Pm()),
            (this._buttonR2.getValue = () =>
              this._nativeButtonState[km.BUTTON_R2]),
            (this._buttonR3 = new Pm()),
            (this._buttonR3.getValue = () =>
              this._nativeButtonState[km.BUTTON_R3]),
            (this._buttonShare = new Pm()),
            (this._buttonShare.getValue = () =>
              this._nativeButtonState[km.NS_MINUS]),
            (this._buttonOptions = new Pm()),
            (this._buttonOptions.getValue = () =>
              this._nativeButtonState[km.NS_PLUS] ||
              this._nativeButtonState[km.ROKID_MENU]);
          const t = new Pm();
          t.getValue = () => this._nativeButtonState[km.DPAD_UP];
          const e = new Pm();
          e.getValue = () => this._nativeButtonState[km.DPAD_DOWN];
          const i = new Pm();
          i.getValue = () => this._nativeButtonState[km.DPAD_LEFT];
          const s = new Pm();
          (s.getValue = () => this._nativeButtonState[km.DPAD_RIGHT]),
            (this._dpad = new Nm({ up: t, down: e, left: i, right: s }));
          const n = new Pm();
          n.getValue = () => this._nativeButtonState[km.LEFT_STICK_UP];
          const r = new Pm();
          r.getValue = () => this._nativeButtonState[km.LEFT_STICK_DOWN];
          const a = new Pm();
          a.getValue = () => this._nativeButtonState[km.LEFT_STICK_LEFT];
          const o = new Pm();
          (o.getValue = () => this._nativeButtonState[km.LEFT_STICK_RIGHT]),
            (this._leftStick = new Lm({ up: n, down: r, left: a, right: o }));
          const h = new Pm();
          h.getValue = () => this._nativeButtonState[km.RIGHT_STICK_UP];
          const l = new Pm();
          l.getValue = () => this._nativeButtonState[km.RIGHT_STICK_DOWN];
          const c = new Pm();
          c.getValue = () => this._nativeButtonState[km.RIGHT_STICK_LEFT];
          const u = new Pm();
          (u.getValue = () => this._nativeButtonState[km.RIGHT_STICK_RIGHT]),
            (this._rightStick = new Lm({ up: h, down: l, left: c, right: u })),
            (this._buttonStart = new Pm()),
            (this._buttonStart.getValue = () =>
              this._nativeButtonState[km.ROKID_START]),
            (this._gripLeft = new Pm()),
            (this._gripLeft.getValue = () => 0),
            (this._gripRight = new Pm()),
            (this._gripRight.getValue = () => 0),
            (this._handLeftPosition = new Fm()),
            (this._handLeftPosition.getValue = () => Yi.ZERO),
            (this._handLeftOrientation = new Bm()),
            (this._handLeftOrientation.getValue = () => as.IDENTITY),
            (this._handRightPosition = new Fm()),
            (this._handRightPosition.getValue = () => Yi.ZERO),
            (this._handRightOrientation = new Bm()),
            (this._handRightOrientation.getValue = () => as.IDENTITY),
            (this._aimLeftPosition = new Fm()),
            (this._aimLeftPosition.getValue = () => Yi.ZERO),
            (this._aimLeftOrientation = new Bm()),
            (this._aimLeftOrientation.getValue = () => as.IDENTITY),
            (this._aimRightPosition = new Fm()),
            (this._aimRightPosition.getValue = () => Yi.ZERO),
            (this._aimRightOrientation = new Bm()),
            (this._aimRightOrientation.getValue = () => as.IDENTITY);
        }
      }
      var Gm, Vm, jm, Wm, Xm;
      (Hm.all = []),
        (Hm.xr = null),
        (Hm._eventTarget = new hr()),
        (function (t) {
          (t[(t.BUTTON_EAST = 0)] = "BUTTON_EAST"),
            (t[(t.BUTTON_SOUTH = 1)] = "BUTTON_SOUTH"),
            (t[(t.BUTTON_WEST = 2)] = "BUTTON_WEST"),
            (t[(t.BUTTON_NORTH = 3)] = "BUTTON_NORTH"),
            (t[(t.BUTTON_TRIGGER_LEFT = 4)] = "BUTTON_TRIGGER_LEFT"),
            (t[(t.BUTTON_TRIGGER_RIGHT = 5)] = "BUTTON_TRIGGER_RIGHT"),
            (t[(t.TRIGGER_LEFT = 6)] = "TRIGGER_LEFT"),
            (t[(t.TRIGGER_RIGHT = 7)] = "TRIGGER_RIGHT"),
            (t[(t.GRIP_LEFT = 8)] = "GRIP_LEFT"),
            (t[(t.GRIP_RIGHT = 9)] = "GRIP_RIGHT"),
            (t[(t.BUTTON_LEFT_STICK = 10)] = "BUTTON_LEFT_STICK"),
            (t[(t.LEFT_STICK_UP = 11)] = "LEFT_STICK_UP"),
            (t[(t.LEFT_STICK_DOWN = 12)] = "LEFT_STICK_DOWN"),
            (t[(t.LEFT_STICK_LEFT = 13)] = "LEFT_STICK_LEFT"),
            (t[(t.LEFT_STICK_RIGHT = 14)] = "LEFT_STICK_RIGHT"),
            (t[(t.BUTTON_RIGHT_STICK = 15)] = "BUTTON_RIGHT_STICK"),
            (t[(t.RIGHT_STICK_UP = 16)] = "RIGHT_STICK_UP"),
            (t[(t.RIGHT_STICK_DOWN = 17)] = "RIGHT_STICK_DOWN"),
            (t[(t.RIGHT_STICK_LEFT = 18)] = "RIGHT_STICK_LEFT"),
            (t[(t.RIGHT_STICK_RIGHT = 19)] = "RIGHT_STICK_RIGHT"),
            (t[(t.ROKID_MENU = 20)] = "ROKID_MENU"),
            (t[(t.ROKID_START = 21)] = "ROKID_START");
        })(Gm || (Gm = {})),
        (function (t) {
          (t[(t.HAND_LEFT = 0)] = "HAND_LEFT"),
            (t[(t.HAND_RIGHT = 1)] = "HAND_RIGHT"),
            (t[(t.AIM_LEFT = 2)] = "AIM_LEFT"),
            (t[(t.AIM_RIGHT = 3)] = "AIM_RIGHT");
        })(Vm || (Vm = {})),
        (function (t) {
          (t[(t.UNDEFINE = 0)] = "UNDEFINE"),
            (t[(t.A = 1)] = "A"),
            (t[(t.B = 2)] = "B"),
            (t[(t.X = 3)] = "X"),
            (t[(t.Y = 4)] = "Y"),
            (t[(t.L1 = 5)] = "L1"),
            (t[(t.R1 = 6)] = "R1"),
            (t[(t.MINUS = 7)] = "MINUS"),
            (t[(t.PLUS = 8)] = "PLUS"),
            (t[(t.L3 = 9)] = "L3"),
            (t[(t.R3 = 10)] = "R3"),
            (t[(t.MENU = 11)] = "MENU"),
            (t[(t.START = 12)] = "START"),
            (t[(t.TRIGGER_LEFT = 13)] = "TRIGGER_LEFT"),
            (t[(t.TRIGGER_RIGHT = 14)] = "TRIGGER_RIGHT");
        })(jm || (jm = {})),
        (function (t) {
          (t[(t.UNDEFINE = 0)] = "UNDEFINE"),
            (t[(t.X = 1)] = "X"),
            (t[(t.Y = 2)] = "Y"),
            (t[(t.LEFT_STICK_X = 3)] = "LEFT_STICK_X"),
            (t[(t.LEFT_STICK_Y = 4)] = "LEFT_STICK_Y"),
            (t[(t.RIGHT_STICK_X = 5)] = "RIGHT_STICK_X"),
            (t[(t.RIGHT_STICK_Y = 6)] = "RIGHT_STICK_Y"),
            (t[(t.L2 = 7)] = "L2"),
            (t[(t.R2 = 8)] = "R2"),
            (t[(t.LEFT_GRIP = 9)] = "LEFT_GRIP"),
            (t[(t.RIGHT_GRIP = 10)] = "RIGHT_GRIP");
        })(Wm || (Wm = {})),
        (function (t) {
          (t[(t.UNDEFINE = 0)] = "UNDEFINE"),
            (t[(t.A = 1)] = "A"),
            (t[(t.B = 2)] = "B"),
            (t[(t.X = 3)] = "X"),
            (t[(t.Y = 4)] = "Y"),
            (t[(t.LEFT_TRIGGER = 5)] = "LEFT_TRIGGER"),
            (t[(t.RIGHT_TRIGGER = 6)] = "RIGHT_TRIGGER"),
            (t[(t.LEFT_THUMBSTICK = 7)] = "LEFT_THUMBSTICK"),
            (t[(t.RIGHT_THUMBSTICK = 8)] = "RIGHT_THUMBSTICK");
        })(Xm || (Xm = {}));
      const Ym = {
        1: Gm.BUTTON_EAST,
        2: Gm.BUTTON_SOUTH,
        3: Gm.BUTTON_NORTH,
        4: Gm.BUTTON_WEST,
        9: Gm.BUTTON_LEFT_STICK,
        10: Gm.BUTTON_RIGHT_STICK,
        11: Gm.ROKID_MENU,
        12: Gm.ROKID_START,
        13: Gm.BUTTON_TRIGGER_LEFT,
        14: Gm.BUTTON_TRIGGER_RIGHT,
      };
      class Km {
        get buttonNorth() {
          return this._buttonNorth;
        }
        get buttonEast() {
          return this._buttonEast;
        }
        get buttonWest() {
          return this._buttonWest;
        }
        get buttonSouth() {
          return this._buttonSouth;
        }
        get buttonTriggerLeft() {
          return this._buttonTriggerLeft;
        }
        get buttonTriggerRight() {
          return this._buttonTriggerRight;
        }
        get triggerLeft() {
          return this._triggerLeft;
        }
        get triggerRight() {
          return this._triggerRight;
        }
        get gripLeft() {
          return this._gripLeft;
        }
        get gripRight() {
          return this._gripRight;
        }
        get leftStick() {
          return this._leftStick;
        }
        get rightStick() {
          return this._rightStick;
        }
        get buttonLeftStick() {
          return this._buttonLeftStick;
        }
        get buttonRightStick() {
          return this._buttonRightStick;
        }
        get buttonOptions() {
          return this._buttonOptions;
        }
        get buttonStart() {
          return this._buttonStart;
        }
        get handLeftPosition() {
          return this._handLeftPosition;
        }
        get handLeftOrientation() {
          return this._handLeftOrientation;
        }
        get handRightPosition() {
          return this._handRightPosition;
        }
        get handRightOrientation() {
          return this._handRightOrientation;
        }
        get aimLeftPosition() {
          return this._aimLeftPosition;
        }
        get aimLeftOrientation() {
          return this._aimLeftOrientation;
        }
        get aimRightPosition() {
          return this._aimRightPosition;
        }
        get aimRightOrientation() {
          return this._aimRightOrientation;
        }
        get touchButtonA() {
          return this._touchButtonA;
        }
        get touchButtonB() {
          return this._touchButtonB;
        }
        get touchButtonX() {
          return this._touchButtonX;
        }
        get touchButtonY() {
          return this._touchButtonY;
        }
        get touchButtonTriggerLeft() {
          return this._touchButtonTriggerLeft;
        }
        get touchButtonTriggerRight() {
          return this._touchButtonTriggerRight;
        }
        get touchButtonThumbStickLeft() {
          return this._touchButtonThumbStickLeft;
        }
        get touchButtonThumbStickRight() {
          return this._touchButtonThumbStickRight;
        }
        constructor() {
          (this._eventTarget = new hr()),
            (this._nativeButtonState = {
              [Gm.BUTTON_SOUTH]: 0,
              [Gm.BUTTON_EAST]: 0,
              [Gm.BUTTON_WEST]: 0,
              [Gm.BUTTON_NORTH]: 0,
              [Gm.BUTTON_TRIGGER_LEFT]: 0,
              [Gm.BUTTON_TRIGGER_RIGHT]: 0,
              [Gm.TRIGGER_LEFT]: 0,
              [Gm.TRIGGER_RIGHT]: 0,
              [Gm.GRIP_LEFT]: 0,
              [Gm.GRIP_RIGHT]: 0,
              [Gm.LEFT_STICK_UP]: 0,
              [Gm.LEFT_STICK_DOWN]: 0,
              [Gm.LEFT_STICK_LEFT]: 0,
              [Gm.LEFT_STICK_RIGHT]: 0,
              [Gm.RIGHT_STICK_UP]: 0,
              [Gm.RIGHT_STICK_DOWN]: 0,
              [Gm.RIGHT_STICK_LEFT]: 0,
              [Gm.RIGHT_STICK_RIGHT]: 0,
              [Gm.BUTTON_LEFT_STICK]: 0,
              [Gm.BUTTON_RIGHT_STICK]: 0,
              [Gm.ROKID_MENU]: 0,
              [Gm.ROKID_START]: 0,
            }),
            (this._nativeTouchState = {
              [Xm.UNDEFINE]: 0,
              [Xm.A]: 0,
              [Xm.B]: 0,
              [Xm.X]: 0,
              [Xm.Y]: 0,
              [Xm.LEFT_TRIGGER]: 0,
              [Xm.RIGHT_TRIGGER]: 0,
              [Xm.LEFT_THUMBSTICK]: 0,
              [Xm.RIGHT_THUMBSTICK]: 0,
            }),
            (this._nativePoseState = {
              [Vm.HAND_LEFT]: { position: Yi.ZERO, orientation: as.IDENTITY },
              [Vm.HAND_RIGHT]: { position: Yi.ZERO, orientation: as.IDENTITY },
              [Vm.AIM_LEFT]: { position: Yi.ZERO, orientation: as.IDENTITY },
              [Vm.AIM_RIGHT]: { position: Yi.ZERO, orientation: as.IDENTITY },
            }),
            this._initInputSource(),
            this._registerEvent();
        }
        _registerEvent() {
          (jsb.onHandleInput = (t) => {
            for (let e = 0; e < t.length; ++e) {
              const i = t[e];
              this._updateNativeButtonState(i),
                this._eventTarget.emit(
                  um.HANDLE_INPUT,
                  new ym(um.HANDLE_INPUT, this)
                );
            }
          }),
            (jsb.onHandlePoseInput = (t) => {
              for (let e = 0; e < t.length; ++e) {
                const i = t[e];
                this._updateNativePoseState(i);
              }
              this._eventTarget.emit(
                um.HANDLE_POSE_INPUT,
                new ym(um.HANDLE_POSE_INPUT, this)
              );
            });
        }
        _on(t, e, i) {
          this._eventTarget.on(t, e, i);
        }
        _axisToButtons(t) {
          const e = Math.abs(t);
          return t > 0
            ? { negative: 0, positive: e }
            : t < 0
            ? { negative: e, positive: 0 }
            : { negative: 0, positive: 0 };
        }
        _updateNativeButtonState(t) {
          const { buttonInfoList: e, axisInfoList: i, touchInfoList: s } = t;
          for (let t = 0; t < e.length; ++t) {
            const i = e[t],
              s = Ym[i.code];
            this._nativeButtonState[s] = i.isPressed ? 1 : 0;
          }
          for (let t = 0; t < i.length; ++t) {
            const e = i[t],
              { code: s, value: n } = e;
            let r, a, o;
            switch (s) {
              case Wm.LEFT_STICK_X:
                (r = Gm.LEFT_STICK_LEFT),
                  (a = Gm.LEFT_STICK_RIGHT),
                  (o = this._axisToButtons(n));
                break;
              case Wm.LEFT_STICK_Y:
                (r = Gm.LEFT_STICK_DOWN),
                  (a = Gm.LEFT_STICK_UP),
                  (o = this._axisToButtons(n));
                break;
              case Wm.RIGHT_STICK_X:
                (r = Gm.RIGHT_STICK_LEFT),
                  (a = Gm.RIGHT_STICK_RIGHT),
                  (o = this._axisToButtons(n));
                break;
              case Wm.RIGHT_STICK_Y:
                (r = Gm.RIGHT_STICK_DOWN),
                  (a = Gm.RIGHT_STICK_UP),
                  (o = this._axisToButtons(n));
                break;
              case Wm.L2:
                this._nativeButtonState[Gm.TRIGGER_LEFT] = n;
                break;
              case Wm.R2:
                this._nativeButtonState[Gm.TRIGGER_RIGHT] = n;
                break;
              case Wm.LEFT_GRIP:
                this._nativeButtonState[Gm.GRIP_LEFT] = n;
                break;
              case Wm.RIGHT_GRIP:
                this._nativeButtonState[Gm.GRIP_RIGHT] = n;
            }
            r &&
              a &&
              o &&
              ((this._nativeButtonState[r] = o.negative),
              (this._nativeButtonState[a] = o.positive));
          }
          if (s)
            for (let t = 0; t < s.length; ++t) {
              const e = s[t],
                { code: i, value: n } = e;
              switch (i) {
                case Xm.A:
                case Xm.B:
                case Xm.X:
                case Xm.Y:
                case Xm.LEFT_TRIGGER:
                case Xm.RIGHT_TRIGGER:
                case Xm.LEFT_THUMBSTICK:
                case Xm.RIGHT_THUMBSTICK:
                  this._nativeTouchState[i] = n;
              }
            }
        }
        _updateNativePoseState(t) {
          switch (t.code) {
            case 1:
              this._nativePoseState[Vm.HAND_LEFT] = {
                position: new Yi(t.x, t.y, t.z),
                orientation: new as(
                  t.quaternionX,
                  t.quaternionY,
                  t.quaternionZ,
                  t.quaternionW
                ),
              };
              break;
            case 2:
              this._nativePoseState[Vm.AIM_LEFT] = {
                position: new Yi(t.x, t.y, t.z),
                orientation: new as(
                  t.quaternionX,
                  t.quaternionY,
                  t.quaternionZ,
                  t.quaternionW
                ),
              };
              break;
            case 4:
              this._nativePoseState[Vm.HAND_RIGHT] = {
                position: new Yi(t.x, t.y, t.z),
                orientation: new as(
                  t.quaternionX,
                  t.quaternionY,
                  t.quaternionZ,
                  t.quaternionW
                ),
              };
              break;
            case 5:
              this._nativePoseState[Vm.AIM_RIGHT] = {
                position: new Yi(t.x, t.y, t.z),
                orientation: new as(
                  t.quaternionX,
                  t.quaternionY,
                  t.quaternionZ,
                  t.quaternionW
                ),
              };
          }
        }
        _initInputSource() {
          (this._buttonNorth = new Pm()),
            (this._buttonNorth.getValue = () =>
              this._nativeButtonState[Gm.BUTTON_NORTH]),
            (this._buttonEast = new Pm()),
            (this._buttonEast.getValue = () =>
              this._nativeButtonState[Gm.BUTTON_EAST]),
            (this._buttonWest = new Pm()),
            (this._buttonWest.getValue = () =>
              this._nativeButtonState[Gm.BUTTON_WEST]),
            (this._buttonSouth = new Pm()),
            (this._buttonSouth.getValue = () =>
              this._nativeButtonState[Gm.BUTTON_SOUTH]),
            (this._buttonTriggerLeft = new Pm()),
            (this._buttonTriggerLeft.getValue = () =>
              this._nativeButtonState[Gm.BUTTON_TRIGGER_LEFT]),
            (this._buttonTriggerRight = new Pm()),
            (this._buttonTriggerRight.getValue = () =>
              this._nativeButtonState[Gm.BUTTON_TRIGGER_RIGHT]),
            (this._triggerLeft = new Pm()),
            (this._triggerLeft.getValue = () =>
              this._nativeButtonState[Gm.TRIGGER_LEFT]),
            (this._triggerRight = new Pm()),
            (this._triggerRight.getValue = () =>
              this._nativeButtonState[Gm.TRIGGER_RIGHT]),
            (this._gripLeft = new Pm()),
            (this._gripLeft.getValue = () =>
              this._nativeButtonState[Gm.GRIP_LEFT]),
            (this._gripRight = new Pm()),
            (this._gripRight.getValue = () =>
              this._nativeButtonState[Gm.GRIP_RIGHT]),
            (this._buttonLeftStick = new Pm()),
            (this._buttonLeftStick.getValue = () =>
              this._nativeButtonState[Gm.BUTTON_LEFT_STICK]);
          const t = new Pm();
          t.getValue = () => this._nativeButtonState[Gm.LEFT_STICK_UP];
          const e = new Pm();
          e.getValue = () => this._nativeButtonState[Gm.LEFT_STICK_DOWN];
          const i = new Pm();
          i.getValue = () => this._nativeButtonState[Gm.LEFT_STICK_LEFT];
          const s = new Pm();
          (s.getValue = () => this._nativeButtonState[Gm.LEFT_STICK_RIGHT]),
            (this._leftStick = new Lm({ up: t, down: e, left: i, right: s })),
            (this._buttonRightStick = new Pm()),
            (this._buttonRightStick.getValue = () =>
              this._nativeButtonState[Gm.BUTTON_RIGHT_STICK]);
          const n = new Pm();
          n.getValue = () => this._nativeButtonState[Gm.RIGHT_STICK_UP];
          const r = new Pm();
          r.getValue = () => this._nativeButtonState[Gm.RIGHT_STICK_DOWN];
          const a = new Pm();
          a.getValue = () => this._nativeButtonState[Gm.RIGHT_STICK_LEFT];
          const o = new Pm();
          (o.getValue = () => this._nativeButtonState[Gm.RIGHT_STICK_RIGHT]),
            (this._rightStick = new Lm({ up: n, down: r, left: a, right: o })),
            (this._buttonOptions = new Pm()),
            (this._buttonOptions.getValue = () =>
              this._nativeButtonState[Gm.ROKID_MENU]),
            (this._buttonStart = new Pm()),
            (this._buttonStart.getValue = () =>
              this._nativeButtonState[Gm.ROKID_START]),
            (this._handLeftPosition = new Fm()),
            (this._handLeftPosition.getValue = () =>
              this._nativePoseState[Vm.HAND_LEFT].position),
            (this._handLeftOrientation = new Bm()),
            (this._handLeftOrientation.getValue = () =>
              this._nativePoseState[Vm.HAND_LEFT].orientation),
            (this._handRightPosition = new Fm()),
            (this._handRightPosition.getValue = () =>
              this._nativePoseState[Vm.HAND_RIGHT].position),
            (this._handRightOrientation = new Bm()),
            (this._handRightOrientation.getValue = () =>
              this._nativePoseState[Vm.HAND_RIGHT].orientation),
            (this._aimLeftPosition = new Fm()),
            (this._aimLeftPosition.getValue = () =>
              this._nativePoseState[Vm.AIM_LEFT].position),
            (this._aimLeftOrientation = new Bm()),
            (this._aimLeftOrientation.getValue = () =>
              this._nativePoseState[Vm.AIM_LEFT].orientation),
            (this._aimRightPosition = new Fm()),
            (this._aimRightPosition.getValue = () =>
              this._nativePoseState[Vm.AIM_RIGHT].position),
            (this._aimRightOrientation = new Bm()),
            (this._aimRightOrientation.getValue = () =>
              this._nativePoseState[Vm.AIM_RIGHT].orientation),
            (this._touchButtonA = new Um()),
            (this._touchButtonA.getValue = () => this._nativeTouchState[Xm.A]),
            (this._touchButtonB = new Um()),
            (this._touchButtonB.getValue = () => this._nativeTouchState[Xm.B]),
            (this._touchButtonX = new Um()),
            (this._touchButtonX.getValue = () => this._nativeTouchState[Xm.X]),
            (this._touchButtonY = new Um()),
            (this._touchButtonY.getValue = () => this._nativeTouchState[Xm.Y]),
            (this._touchButtonTriggerLeft = new Um()),
            (this._touchButtonTriggerLeft.getValue = () =>
              this._nativeTouchState[Xm.LEFT_TRIGGER]),
            (this._touchButtonTriggerRight = new Um()),
            (this._touchButtonTriggerRight.getValue = () =>
              this._nativeTouchState[Xm.RIGHT_TRIGGER]),
            (this._touchButtonThumbStickLeft = new Um()),
            (this._touchButtonThumbStickLeft.getValue = () =>
              this._nativeTouchState[Xm.LEFT_THUMBSTICK]),
            (this._touchButtonThumbStickRight = new Um()),
            (this._touchButtonThumbStickRight.getValue = () =>
              this._nativeTouchState[Xm.RIGHT_THUMBSTICK]);
        }
      }
      var qm, $m;
      !(function (t) {
        (t[(t.VIEW_LEFT = 0)] = "VIEW_LEFT"),
          (t[(t.VIEW_RIGHT = 1)] = "VIEW_RIGHT"),
          (t[(t.HEAD_MIDDLE = 2)] = "HEAD_MIDDLE");
      })(qm || (qm = {}));
      class Zm {
        get viewLeftPosition() {
          return this._viewLeftPosition;
        }
        get viewLeftOrientation() {
          return this._viewLeftOrientation;
        }
        get viewRightPosition() {
          return this._viewRightPosition;
        }
        get viewRightOrientation() {
          return this._viewRightOrientation;
        }
        get headMiddlePosition() {
          return this._headMiddlePosition;
        }
        get headMiddleOrientation() {
          return this._headMiddleOrientation;
        }
        constructor() {
          (this._eventTarget = new hr()),
            (this._nativePoseState = {
              [qm.VIEW_LEFT]: { position: Yi.ZERO, orientation: as.IDENTITY },
              [qm.VIEW_RIGHT]: { position: Yi.ZERO, orientation: as.IDENTITY },
              [qm.HEAD_MIDDLE]: { position: Yi.ZERO, orientation: as.IDENTITY },
            }),
            this._initInputSource(),
            this._registerEvent();
        }
        _registerEvent() {
          jsb.onHMDPoseInput = (t) => {
            for (let e = 0; e < t.length; ++e) {
              const i = t[e];
              this._updateNativePoseState(i);
            }
            this._eventTarget.emit(
              um.HMD_POSE_INPUT,
              new Tm(um.HMD_POSE_INPUT, this)
            );
          };
        }
        _on(t, e, i) {
          this._eventTarget.on(t, e, i);
        }
        _updateNativePoseState(t) {
          switch (t.code) {
            case 0:
              this._nativePoseState[qm.VIEW_LEFT] = {
                position: new Yi(t.x, t.y, t.z),
                orientation: new as(
                  t.quaternionX,
                  t.quaternionY,
                  t.quaternionZ,
                  t.quaternionW
                ),
              };
              break;
            case 3:
              this._nativePoseState[qm.VIEW_RIGHT] = {
                position: new Yi(t.x, t.y, t.z),
                orientation: new as(
                  t.quaternionX,
                  t.quaternionY,
                  t.quaternionZ,
                  t.quaternionW
                ),
              };
              break;
            case 6:
              this._nativePoseState[qm.HEAD_MIDDLE] = {
                position: new Yi(t.x, t.y, t.z),
                orientation: new as(
                  t.quaternionX,
                  t.quaternionY,
                  t.quaternionZ,
                  t.quaternionW
                ),
              };
          }
        }
        _initInputSource() {
          (this._viewLeftPosition = new Fm()),
            (this._viewLeftPosition.getValue = () =>
              this._nativePoseState[qm.VIEW_LEFT].position),
            (this._viewLeftOrientation = new Bm()),
            (this._viewLeftOrientation.getValue = () =>
              this._nativePoseState[qm.VIEW_LEFT].orientation),
            (this._viewRightPosition = new Fm()),
            (this._viewRightPosition.getValue = () =>
              this._nativePoseState[qm.VIEW_RIGHT].position),
            (this._viewRightOrientation = new Bm()),
            (this._viewRightOrientation.getValue = () =>
              this._nativePoseState[qm.VIEW_RIGHT].orientation),
            (this._headMiddlePosition = new Fm()),
            (this._headMiddlePosition.getValue = () =>
              this._nativePoseState[qm.HEAD_MIDDLE].position),
            (this._headMiddleOrientation = new Bm()),
            (this._headMiddleOrientation.getValue = () =>
              this._nativePoseState[qm.HEAD_MIDDLE].orientation);
        }
      }
      !(function (t) {
        t[(t.AR_MOBILE = 0)] = "AR_MOBILE";
      })($m || ($m = {}));
      class Qm {
        get handheldPosition() {
          return this._handheldPosition;
        }
        get handheldOrientation() {
          return this._handheldOrientation;
        }
        constructor() {
          (this._eventTarget = new hr()),
            (this._nativePoseState = {
              [$m.AR_MOBILE]: { position: Yi.ZERO, orientation: as.IDENTITY },
            }),
            this._initInputSource(),
            this._registerEvent();
        }
        _registerEvent() {
          jsb.onHandheldPoseInput = (t) => {
            for (let e = 0; e < t.length; ++e) {
              const i = t[e];
              this._updateNativePoseState(i);
            }
            this._eventTarget.emit(
              um.HANDHELD_POSE_INPUT,
              new Sm(um.HANDHELD_POSE_INPUT, this)
            );
          };
        }
        _on(t, e, i) {
          this._eventTarget.on(t, e, i);
        }
        _updateNativePoseState(t) {
          switch (t.code) {
            case 7:
              this._nativePoseState[$m.AR_MOBILE] = {
                position: new Yi(t.x, t.y, t.z),
                orientation: new as(
                  t.quaternionX,
                  t.quaternionY,
                  t.quaternionZ,
                  t.quaternionW
                ),
              };
          }
        }
        _initInputSource() {
          (this._handheldPosition = new Fm()),
            (this._handheldPosition.getValue = () =>
              this._nativePoseState[$m.AR_MOBILE].position),
            (this._handheldOrientation = new Bm()),
            (this._handheldOrientation.getValue = () =>
              this._nativePoseState[$m.AR_MOBILE].orientation);
        }
      }
      const Jm = {
          Backspace: vm.BACKSPACE,
          Tab: vm.TAB,
          Enter: vm.ENTER,
          ShiftLeft: vm.SHIFT_LEFT,
          ControlLeft: vm.CTRL_LEFT,
          AltLeft: vm.ALT_LEFT,
          ShiftRight: vm.SHIFT_RIGHT,
          ControlRight: vm.CTRL_RIGHT,
          AltRight: vm.ALT_RIGHT,
          Pause: vm.PAUSE,
          CapsLock: vm.CAPS_LOCK,
          Escape: vm.ESCAPE,
          Space: vm.SPACE,
          PageUp: vm.PAGE_UP,
          PageDown: vm.PAGE_DOWN,
          End: vm.END,
          Home: vm.HOME,
          ArrowLeft: vm.ARROW_LEFT,
          ArrowUp: vm.ARROW_UP,
          ArrowRight: vm.ARROW_RIGHT,
          ArrowDown: vm.ARROW_DOWN,
          Insert: vm.INSERT,
          Delete: vm.DELETE,
          Digit0: vm.DIGIT_0,
          Digit1: vm.DIGIT_1,
          Digit2: vm.DIGIT_2,
          Digit3: vm.DIGIT_3,
          Digit4: vm.DIGIT_4,
          Digit5: vm.DIGIT_5,
          Digit6: vm.DIGIT_6,
          Digit7: vm.DIGIT_7,
          Digit8: vm.DIGIT_8,
          Digit9: vm.DIGIT_9,
          KeyA: vm.KEY_A,
          KeyB: vm.KEY_B,
          KeyC: vm.KEY_C,
          KeyD: vm.KEY_D,
          KeyE: vm.KEY_E,
          KeyF: vm.KEY_F,
          KeyG: vm.KEY_G,
          KeyH: vm.KEY_H,
          KeyI: vm.KEY_I,
          KeyJ: vm.KEY_J,
          KeyK: vm.KEY_K,
          KeyL: vm.KEY_L,
          KeyM: vm.KEY_M,
          KeyN: vm.KEY_N,
          KeyO: vm.KEY_O,
          KeyP: vm.KEY_P,
          KeyQ: vm.KEY_Q,
          KeyR: vm.KEY_R,
          KeyS: vm.KEY_S,
          KeyT: vm.KEY_T,
          KeyU: vm.KEY_U,
          KeyV: vm.KEY_V,
          KeyW: vm.KEY_W,
          KeyX: vm.KEY_X,
          KeyY: vm.KEY_Y,
          KeyZ: vm.KEY_Z,
          Numpad0: vm.NUM_0,
          Numpad1: vm.NUM_1,
          Numpad2: vm.NUM_2,
          Numpad3: vm.NUM_3,
          Numpad4: vm.NUM_4,
          Numpad5: vm.NUM_5,
          Numpad6: vm.NUM_6,
          Numpad7: vm.NUM_7,
          Numpad8: vm.NUM_8,
          Numpad9: vm.NUM_9,
          NumpadMultiply: vm.NUM_MULTIPLY,
          NumpadAdd: vm.NUM_PLUS,
          NumpadSubtract: vm.NUM_SUBTRACT,
          NumpadDecimal: vm.NUM_DECIMAL,
          NumpadDivide: vm.NUM_DIVIDE,
          NumpadEnter: vm.NUM_ENTER,
          F1: vm.F1,
          F2: vm.F2,
          F3: vm.F3,
          F4: vm.F4,
          F5: vm.F5,
          F6: vm.F6,
          F7: vm.F7,
          F8: vm.F8,
          F9: vm.F9,
          F10: vm.F10,
          F11: vm.F11,
          F12: vm.F12,
          NumLock: vm.NUM_LOCK,
          ScrollLock: vm.SCROLL_LOCK,
          Semicolon: vm.SEMICOLON,
          Equal: vm.EQUAL,
          Comma: vm.COMMA,
          Minus: vm.DASH,
          Period: vm.PERIOD,
          Slash: vm.SLASH,
          Backquote: vm.BACK_QUOTE,
          BracketLeft: vm.BRACKET_LEFT,
          Backslash: vm.BACKSLASH,
          BracketRight: vm.BRACKET_RIGHT,
          Quote: vm.QUOTE,
        },
        tf = {
          12: vm.NUM_LOCK,
          10048: vm.NUM_0,
          10049: vm.NUM_1,
          10050: vm.NUM_2,
          10051: vm.NUM_3,
          10052: vm.NUM_4,
          10053: vm.NUM_5,
          10054: vm.NUM_6,
          10055: vm.NUM_7,
          10056: vm.NUM_8,
          10057: vm.NUM_9,
          20013: vm.NUM_ENTER,
          20016: vm.SHIFT_RIGHT,
          20017: vm.CTRL_RIGHT,
          20018: vm.ALT_RIGHT,
        };
      function ef(t) {
        if (t.code) {
          if (t.code in Jm) return Jm[t.code];
          console.error(`Can not find keyCode for code: ${t.code}`);
        }
        return tf[t.keyCode] || t.keyCode;
      }
      class sf {
        constructor() {
          (this._eventTarget = new hr()),
            (this._keyStateMap = {}),
            (this._handleKeyboardDown = void 0),
            (this._handleKeyboardUp = void 0),
            (this._handleKeyboardDown = (t) => {
              const e = ef(t);
              if (this._keyStateMap[e]) {
                const e = this._getInputEvent(t, um.KEY_PRESSING);
                this._eventTarget.emit(um.KEY_PRESSING, e);
              } else {
                const e = this._getInputEvent(t, um.KEY_DOWN);
                this._eventTarget.emit(um.KEY_DOWN, e);
              }
              this._keyStateMap[e] = !0;
            }),
            (this._handleKeyboardUp = (t) => {
              const e = ef(t),
                i = this._getInputEvent(t, um.KEY_UP);
              (this._keyStateMap[e] = !1), this._eventTarget.emit(um.KEY_UP, i);
            }),
            this._registerEvent();
        }
        dispatchKeyboardDownEvent(t) {
          this._handleKeyboardDown(t);
        }
        dispatchKeyboardUpEvent(t) {
          this._handleKeyboardUp(t);
        }
        _registerEvent() {
          (jsb.onKeyDown = this._handleKeyboardDown),
            (jsb.onKeyUp = this._handleKeyboardUp);
        }
        _getInputEvent(t, e) {
          const i = ef(t),
            s = new dm(i, e);
          return (s.windowId = t.windowId), s;
        }
        on(t, e, i) {
          this._eventTarget.on(t, e, i);
        }
      }
      class nf {
        constructor() {
          (this._eventTarget = new hr()),
            (this._preMousePos = new Ss()),
            (this._isPressed = !1),
            (this._windowManager = void 0),
            (this._pointLocked = !1),
            (this._handleMouseDown = void 0),
            (this._handleMouseMove = void 0),
            (this._handleMouseUp = void 0),
            (this._boundedHandleMouseWheel = void 0),
            (this._handleMouseDown = this._createCallback(um.MOUSE_DOWN)),
            (this._handleMouseMove = this._createCallback(um.MOUSE_MOVE)),
            (this._handleMouseUp = this._createCallback(um.MOUSE_UP)),
            (this._boundedHandleMouseWheel = this._handleMouseWheel.bind(this)),
            this._registerEvent(),
            (this._windowManager = jsb.ISystemWindowManager.getInstance());
        }
        dispatchMouseDownEvent(t) {
          this._handleMouseDown(t);
        }
        dispatchMouseMoveEvent(t) {
          this._handleMouseMove(t);
        }
        dispatchMouseUpEvent(t) {
          this._handleMouseUp(t);
        }
        dispatchScrollEvent(t) {
          this._boundedHandleMouseWheel(t);
        }
        _getLocation(t) {
          const e = this._windowManager.getWindow(t.windowId);
          if (!e) return Ss.ZERO;
          const i = e.getViewSize(),
            s = jsb.device.getDevicePixelRatio(t.windowId),
            n = t.x * s,
            r = i.height - t.y * s;
          return new Ss(n, r);
        }
        _registerEvent() {
          (jsb.onMouseDown = this._handleMouseDown),
            (jsb.onMouseMove = this._handleMouseMove),
            (jsb.onMouseUp = this._handleMouseUp),
            (jsb.onMouseWheel = this._boundedHandleMouseWheel),
            (jsb.onPointerlockChange = (t) => {
              this._pointLocked = t;
            }),
            (jsb.onWindowLeave = this._handleWindowLeave.bind(this)),
            (jsb.onWindowEnter = this._handleWindowEnter.bind(this));
        }
        _createCallback(t) {
          return (e) => {
            const i = this._getLocation(e);
            let s = e.button;
            switch (t) {
              case um.MOUSE_DOWN:
                this._isPressed = !0;
                break;
              case um.MOUSE_UP:
                this._isPressed = !1;
                break;
              case um.MOUSE_MOVE:
                this._isPressed || (s = pm.BUTTON_MISSING);
            }
            const n = new pm(t, !1, this._preMousePos, e.windowId);
            n.setLocation(i.x, i.y), n.setButton(s);
            const r = jsb.device.getDevicePixelRatio(e.windowId);
            (n.movementX = void 0 === e.xDelta ? 0 : e.xDelta * r),
              (n.movementY = void 0 === e.yDelta ? 0 : e.yDelta * r),
              this._preMousePos.set(i.x, i.y),
              this._eventTarget.emit(t, n);
          };
        }
        _handleMouseWheel(t) {
          const e = um.MOUSE_WHEEL,
            i = this._getLocation(t),
            s = t.button,
            n = new pm(e, !1, this._preMousePos, t.windowId);
          n.setLocation(i.x, i.y),
            n.setButton(s),
            (n.movementX = i.x - this._preMousePos.x),
            (n.movementY = this._preMousePos.y - i.y),
            n.setScrollData(120 * t.wheelDeltaX, 120 * t.wheelDeltaY),
            this._preMousePos.set(i.x, i.y),
            this._eventTarget.emit(e, n);
        }
        on(t, e, i) {
          this._eventTarget.on(t, e, i);
        }
        _handleWindowLeave() {
          const t = um.MOUSE_LEAVE,
            e = new pm(t, !1);
          this._eventTarget.emit(t, e);
        }
        _handleWindowEnter() {
          const t = um.MOUSE_ENTER,
            e = new pm(t, !1);
          this._eventTarget.emit(t, e);
        }
      }
      const rf = new Ss(),
        af = new (class {
          constructor() {
            (this._touchMap = new Map()), (this._maxTouches = 8);
          }
          _createTouch(t, e, i, s) {
            if (this._touchMap.has(t))
              return void I("Cannot create the same touch object.");
            if (this._checkTouchMapSizeMoreThanMax(t))
              return void I("The touches is more than MAX_TOUCHES.");
            const n = new Am(e, i, t, s);
            return this._touchMap.set(t, n), this._updateTouch(n, e, i), n;
          }
          releaseTouch(t) {
            this._touchMap.has(t) && this._touchMap.delete(t);
          }
          getTouch(t) {
            return this._touchMap.get(t);
          }
          getOrCreateTouch(t, e, i, s) {
            let n = this.getTouch(t);
            return (
              n
                ? this._updateTouch(n, e, i)
                : (n = this._createTouch(t, e, i, s)),
              n
            );
          }
          getAllTouches() {
            const t = [];
            return (
              this._touchMap.forEach((e) => {
                e && t.push(e);
              }),
              t
            );
          }
          getTouchCount() {
            return af._touchMap.size;
          }
          _updateTouch(t, e, i) {
            t.getLocation(rf), t.setPrevPoint(rf), t.setPoint(e, i);
          }
          _checkTouchMapSizeMoreThanMax(t) {
            if (this._touchMap.has(t)) return !1;
            const e = Te.ENABLE_MULTI_TOUCH ? this._maxTouches : 1;
            if (this._touchMap.size < e) return !1;
            const i = performance.now();
            return (
              this._touchMap.forEach((t) => {
                i - t.lastModified > Te.TOUCH_TIMEOUT &&
                  (I(
                    `The touches is more than MAX_TOUCHES, release touch id ${t.getID()}.`
                  ),
                  this.releaseTouch(t.getID()));
              }),
              e >= this._touchMap.size
            );
          }
        })();
      class of {
        constructor() {
          (this._eventTarget = new hr()),
            (this._windowManager = void 0),
            this._registerEvent(),
            (this._windowManager = jsb.ISystemWindowManager.getInstance());
        }
        _registerEvent() {
          (jsb.onTouchStart = this._createCallback(um.TOUCH_START)),
            (jsb.onTouchMove = this._createCallback(um.TOUCH_MOVE)),
            (jsb.onTouchEnd = this._createCallback(um.TOUCH_END)),
            (jsb.onTouchCancel = this._createCallback(um.TOUCH_CANCEL));
        }
        _createCallback(t) {
          return (e, i) => {
            const s = this._windowManager.getWindow(i);
            if (!s) return;
            const n = [],
              r = e.length,
              a = s.getViewSize();
            for (let s = 0; s < r; ++s) {
              const r = e[s],
                o = r.identifier;
              if (null === o) continue;
              const h = this._getLocation(r, a),
                l = af.getOrCreateTouch(o, h.x, h.y, i);
              l &&
                ((t !== um.TOUCH_END && t !== um.TOUCH_CANCEL) ||
                  af.releaseTouch(o),
                n.push(l));
            }
            if (n.length > 0) {
              const e = new fm(n, !1, t, af.getAllTouches());
              (e.windowId = i), this._eventTarget.emit(t, e);
            }
          };
        }
        _getLocation(t, e) {
          const i = Ur.devicePixelRatio,
            s = t.clientX * i,
            n = e.height - t.clientY * i;
          return new Ss(s, n);
        }
        on(t, e, i) {
          this._eventTarget.on(t, e, i);
        }
      }
      let hf;
      !(function (t) {
        (t[(t.GLOBAL = 0)] = "GLOBAL"), (t[(t.UI = 1)] = "UI");
      })(hf || (hf = {}));
      class lf {
        constructor(t) {
          (this.priority = hf.GLOBAL), (this._inputEventTarget = t);
        }
        onThrowException() {}
        dispatchEvent(t) {
          return this._inputEventTarget.emit(t.type, t), !0;
        }
      }
      const cf = {
        [um.MOUSE_DOWN]: um.TOUCH_START,
        [um.MOUSE_MOVE]: um.TOUCH_MOVE,
        [um.MOUSE_UP]: um.TOUCH_END,
      };
      class uf {
        constructor() {
          (this._dispatchImmediately = !1),
            (this._eventTarget = new hr()),
            (this._touchInput = new of()),
            (this._mouseInput = new nf()),
            (this._keyboardInput = new sf()),
            (this._accelerometerInput = new Cm()),
            (this._handleInput = new Km()),
            (this._hmdInput = new Zm()),
            (this._handheldInput = new Qm()),
            (this._eventTouchList = []),
            (this._eventMouseList = []),
            (this._eventKeyboardList = []),
            (this._eventAccelerationList = []),
            (this._eventGamepadList = []),
            (this._eventHandleList = []),
            (this._eventHMDList = []),
            (this._eventHandheldList = []),
            (this._needSimulateTouchMoveEvent = !1),
            (this._eventDispatcherList = []),
            this._registerEvent(),
            (this._inputEventDispatcher = new lf(this._eventTarget)),
            this._registerEventDispatcher(this._inputEventDispatcher),
            Hm._init();
        }
        _dispatchMouseDownEvent(t) {
          var e, i;
          null === (e = (i = this._mouseInput).dispatchMouseDownEvent) ||
            void 0 === e ||
            e.call(i, t);
        }
        _dispatchMouseMoveEvent(t) {
          var e, i;
          null === (e = (i = this._mouseInput).dispatchMouseMoveEvent) ||
            void 0 === e ||
            e.call(i, t);
        }
        _dispatchMouseUpEvent(t) {
          var e, i;
          null === (e = (i = this._mouseInput).dispatchMouseUpEvent) ||
            void 0 === e ||
            e.call(i, t);
        }
        _dispatchMouseScrollEvent(t) {
          var e, i;
          null === (e = (i = this._mouseInput).dispatchScrollEvent) ||
            void 0 === e ||
            e.call(i, t);
        }
        _dispatchKeyboardDownEvent(t) {
          var e, i;
          null === (e = (i = this._keyboardInput).dispatchKeyboardDownEvent) ||
            void 0 === e ||
            e.call(i, t);
        }
        _dispatchKeyboardUpEvent(t) {
          var e, i;
          null === (e = (i = this._keyboardInput).dispatchKeyboardUpEvent) ||
            void 0 === e ||
            e.call(i, t);
        }
        on(t, e, i) {
          return this._eventTarget.on(t, e, i), e;
        }
        once(t, e, i) {
          return this._eventTarget.once(t, e, i), e;
        }
        off(t, e, i) {
          this._eventTarget.off(t, e, i);
        }
        getTouch(t) {
          return af.getTouch(t);
        }
        getAllTouches() {
          return af.getAllTouches();
        }
        getTouchCount() {
          return af.getTouchCount();
        }
        setAccelerometerEnabled(t) {
          t
            ? this._accelerometerInput.start()
            : this._accelerometerInput.stop();
        }
        setAccelerometerInterval(t) {
          this._accelerometerInput.setInterval(t);
        }
        _simulateEventTouch(t) {
          const e = cf[t.type],
            i = af.getOrCreateTouch(
              0,
              t.getLocationX(),
              t.getLocationY(),
              t.windowId
            );
          if (!i) return;
          const s = [i],
            n = new fm(s, !1, e, e === um.TOUCH_END ? [] : s);
          (n.windowId = t.windowId),
            e === um.TOUCH_END && af.releaseTouch(0),
            this._dispatchOrPushEventTouch(n, this._eventTouchList);
        }
        _registerEventDispatcher(t) {
          this._eventDispatcherList.push(t),
            this._eventDispatcherList.sort((t, e) => e.priority - t.priority);
        }
        _emitEvent(t) {
          const e = this._eventDispatcherList.length;
          for (let i = 0; i < e; ++i) {
            const e = this._eventDispatcherList[i];
            try {
              if (!e.dispatchEvent(t)) break;
            } catch (t) {
              throw (this._clearEvents(), e.onThrowException(), t);
            }
          }
        }
        _registerEvent() {
          if (zr.hasFeature(zr.Feature.INPUT_TOUCH)) {
            const t = this._eventTouchList;
            this._touchInput.on(um.TOUCH_START, (e) => {
              this._dispatchOrPushEventTouch(e, t);
            }),
              this._touchInput.on(um.TOUCH_MOVE, (e) => {
                this._dispatchOrPushEventTouch(e, t);
              }),
              this._touchInput.on(um.TOUCH_END, (e) => {
                this._dispatchOrPushEventTouch(e, t);
              }),
              this._touchInput.on(um.TOUCH_CANCEL, (e) => {
                this._dispatchOrPushEventTouch(e, t);
              });
          }
          if (zr.hasFeature(zr.Feature.EVENT_MOUSE)) {
            const t = this._eventMouseList;
            this._mouseInput.on(um.MOUSE_DOWN, (e) => {
              (this._needSimulateTouchMoveEvent = !0),
                this._simulateEventTouch(e),
                this._dispatchOrPushEvent(e, t);
            }),
              this._mouseInput.on(um.MOUSE_MOVE, (e) => {
                this._needSimulateTouchMoveEvent && this._simulateEventTouch(e),
                  this._dispatchOrPushEvent(e, t);
              }),
              this._mouseInput.on(um.MOUSE_UP, (e) => {
                (this._needSimulateTouchMoveEvent = !1),
                  this._simulateEventTouch(e),
                  this._dispatchOrPushEvent(e, t);
              }),
              this._mouseInput.on(um.MOUSE_WHEEL, (e) => {
                this._dispatchOrPushEvent(e, t);
              }),
              this._mouseInput.on(um.MOUSE_LEAVE, (e) => {
                this._dispatchOrPushEvent(e, t);
              }),
              this._mouseInput.on(um.MOUSE_ENTER, (e) => {
                this._dispatchOrPushEvent(e, t);
              });
          }
          if (zr.hasFeature(zr.Feature.EVENT_KEYBOARD)) {
            const t = this._eventKeyboardList;
            this._keyboardInput.on(um.KEY_DOWN, (e) => {
              this._dispatchOrPushEvent(e, t);
            }),
              this._keyboardInput.on(um.KEY_PRESSING, (e) => {
                this._dispatchOrPushEvent(e, t);
              }),
              this._keyboardInput.on(um.KEY_UP, (e) => {
                this._dispatchOrPushEvent(e, t);
              });
          }
          if (zr.hasFeature(zr.Feature.EVENT_ACCELEROMETER)) {
            const t = this._eventAccelerationList;
            this._accelerometerInput.on(um.DEVICEMOTION, (e) => {
              this._dispatchOrPushEvent(e, t);
            });
          }
          if (zr.hasFeature(zr.Feature.EVENT_GAMEPAD)) {
            const t = this._eventGamepadList;
            Hm._on(um.GAMEPAD_CHANGE, (e) => {
              this._dispatchOrPushEvent(e, t);
            }),
              Hm._on(um.GAMEPAD_INPUT, (e) => {
                this._dispatchOrPushEvent(e, t);
              }),
              Hm._on(um.HANDLE_POSE_INPUT, (e) => {
                this._dispatchOrPushEvent(e, t);
              });
          }
          if (zr.hasFeature(zr.Feature.EVENT_HANDLE)) {
            const t = this._eventHandleList;
            this._handleInput._on(um.HANDLE_INPUT, (e) => {
              this._dispatchOrPushEvent(e, t);
            }),
              this._handleInput._on(um.HANDLE_POSE_INPUT, (e) => {
                this._dispatchOrPushEvent(e, t);
              });
          }
          if (zr.hasFeature(zr.Feature.EVENT_HMD)) {
            const t = this._eventHMDList;
            this._hmdInput._on(um.HMD_POSE_INPUT, (e) => {
              this._dispatchOrPushEvent(e, t);
            });
          }
          if (zr.hasFeature(zr.Feature.EVENT_HANDHELD)) {
            const t = this._eventHandheldList;
            this._handheldInput._on(um.HANDHELD_POSE_INPUT, (e) => {
              this._dispatchOrPushEvent(e, t);
            });
          }
        }
        _clearEvents() {
          (this._eventMouseList.length = 0),
            (this._eventTouchList.length = 0),
            (this._eventKeyboardList.length = 0),
            (this._eventAccelerationList.length = 0),
            (this._eventGamepadList.length = 0),
            (this._eventHandleList.length = 0),
            (this._eventHMDList.length = 0);
        }
        _dispatchOrPushEvent(t, e) {
          this._dispatchImmediately ? this._emitEvent(t) : e.push(t);
        }
        _dispatchOrPushEventTouch(t, e) {
          if (this._dispatchImmediately) {
            const e = t.getTouches(),
              i = e.length;
            for (let s = 0; s < i; ++s)
              (t.touch = e[s]),
                (t.propagationStopped = t.propagationImmediateStopped = !1),
                this._emitEvent(t);
          } else e.push(t);
        }
        _frameDispatchEvents() {
          const t = this._eventHMDList;
          for (let e = 0, i = t.length; e < i; ++e) {
            const i = t[e];
            this._emitEvent(i);
          }
          const e = this._eventHandheldList;
          for (let t = 0, i = e.length; t < i; ++t) {
            const i = e[t];
            this._emitEvent(i);
          }
          const i = this._eventMouseList;
          for (let t = 0, e = i.length; t < e; ++t) {
            const e = i[t];
            this._emitEvent(e);
          }
          const s = this._eventTouchList;
          for (let t = 0, e = s.length; t < e; ++t) {
            const e = s[t];
            if (!e) continue;
            const i = e.getTouches(),
              n = i.length;
            for (let t = 0; t < n; ++t)
              (e.touch = i[t]),
                (e.propagationStopped = e.propagationImmediateStopped = !1),
                this._emitEvent(e);
          }
          const n = this._eventKeyboardList;
          for (let t = 0, e = n.length; t < e; ++t) {
            const e = n[t];
            this._emitEvent(e);
          }
          const r = this._eventAccelerationList;
          for (let t = 0, e = r.length; t < e; ++t) {
            const e = r[t];
            this._emitEvent(e);
          }
          const a = this._eventGamepadList;
          for (let t = 0, e = a.length; t < e; ++t) {
            const e = a[t];
            this._emitEvent(e);
          }
          const o = this._eventHandleList;
          for (let t = 0, e = o.length; t < e; ++t) {
            const e = o[t];
            this._emitEvent(e);
          }
          this._clearEvents();
        }
      }
      t("Input", uf), (uf.EventType = um);
      const _f = t("input", new uf());
      class df extends hr {
        constructor() {
          super(),
            _f.on(um.MOUSE_DOWN, (t) => {
              this.emit(cm.MOUSE_DOWN, t);
            }),
            _f.on(um.MOUSE_MOVE, (t) => {
              this.emit(cm.MOUSE_MOVE, t);
            }),
            _f.on(um.MOUSE_UP, (t) => {
              this.emit(cm.MOUSE_UP, t);
            }),
            _f.on(um.MOUSE_WHEEL, (t) => {
              this.emit(cm.MOUSE_WHEEL, t);
            }),
            _f.on(um.TOUCH_START, (t) => {
              this.emit(cm.TOUCH_START, t.touch, t);
            }),
            _f.on(um.TOUCH_MOVE, (t) => {
              this.emit(cm.TOUCH_MOVE, t.touch, t);
            }),
            _f.on(um.TOUCH_END, (t) => {
              this.emit(cm.TOUCH_END, t.touch, t);
            }),
            _f.on(um.TOUCH_CANCEL, (t) => {
              this.emit(cm.TOUCH_CANCEL, t.touch, t);
            }),
            _f.on(um.KEY_DOWN, (t) => {
              this.emit(cm.KEY_DOWN, t);
            }),
            _f.on(um.KEY_PRESSING, (t) => {
              this.emit(cm.KEY_DOWN, t);
            }),
            _f.on(um.KEY_UP, (t) => {
              this.emit(cm.KEY_UP, t);
            }),
            _f.on(um.DEVICEMOTION, (t) => {
              this.emit(cm.DEVICEMOTION, t);
            });
        }
        setAccelerometerEnabled(t) {
          _f.setAccelerometerEnabled(t);
        }
        setAccelerometerInterval(t) {
          _f.setAccelerometerInterval(t);
        }
        on(t, e, i, s) {
          return super.on(t, e, i, s), e;
        }
        off(t, e, i) {
          super.off(t, e, i);
        }
      }
      t("SystemEvent", df), (df.EventType = cm), (a.SystemEvent = df);
      const pf = t("systemEvent", new df());
      let mf;
      (a.systemEvent = pf),
        $(cm, "Node.EventType", [
          { name: "POSITION_PART", newName: "TRANSFORM_CHANGED" },
          { name: "ROTATION_PART", newName: "TRANSFORM_CHANGED" },
          { name: "SCALE_PART", newName: "TRANSFORM_CHANGED" },
        ]),
        $(lm, "Event", [
          {
            name: "ACCELERATION",
            newName: "DEVICEMOTION",
            target: df.EventType,
            targetName: "SystemEvent.EventType",
          },
        ]),
        Q(lm, "Event", [
          {
            name: "TOUCH",
            suggest:
              "please use SystemEvent.EventType.TOUCH_START, SystemEvent.EventType.TOUCH_MOVE, SystemEvent.EventType.TOUCH_END and SystemEvent.EventType.TOUCH_CANCEL instead",
          },
          {
            name: "MOUSE",
            suggest:
              "please use SystemEvent.EventType.MOUSE_DOWN, SystemEvent.EventType.MOUSE_MOVE, SystemEvent.EventType.MOUSE_UP, SystemEvent.EventType.MOUSE_WHEEL, Node.EventType.MOUSE_ENTER and Node.EventType.MOUSE_LEAVE instead",
          },
          {
            name: "KEYBOARD",
            suggest:
              "please use SystemEvent.EventType.KEY_DOWN and SystemEvent.EventType.KEY_UP instead",
          },
        ]),
        $(
          pm,
          "EventMouse",
          ["DOWN", "UP", "MOVE"].map((t) => ({
            name: t,
            newName: `MOUSE_${t}`,
            target: df.EventType,
            targetName: "SystemEvent.EventType",
          }))
        ),
        $(pm, "EventMouse", [
          {
            name: "SCROLL",
            newName: "MOUSE_WHEEL",
            target: df.EventType,
            targetName: "SystemEvent.EventType",
          },
        ]),
        Q(pm.prototype, "EventMouse.prototype", [
          {
            name: "eventType",
            suggest: "please use EventMouse.prototype.type instead",
          },
        ]),
        $(fm, "EventTouch", [
          {
            name: "BEGAN",
            newName: "TOUCH_START",
            target: df.EventType,
            targetName: "SystemEvent.EventType",
          },
        ]),
        $(fm, "EventTouch", [
          {
            name: "MOVED",
            newName: "TOUCH_MOVE",
            target: df.EventType,
            targetName: "SystemEvent.EventType",
          },
        ]),
        $(fm, "EventTouch", [
          {
            name: "ENDED",
            newName: "TOUCH_END",
            target: df.EventType,
            targetName: "SystemEvent.EventType",
          },
        ]),
        $(fm, "EventTouch", [
          {
            name: "CANCELLED",
            newName: "TOUCH_CANCEL",
            target: df.EventType,
            targetName: "SystemEvent.EventType",
          },
        ]),
        Q(fm.prototype, "EventTouch.prototype", [
          {
            name: "getEventCode",
            suggest: "please use EventTouch.prototype.type instead",
          },
        ]),
        $(fm.prototype, "EventTouch.prototype", [
          {
            name: "getUILocationInView",
            newName: "getLocationInView",
            target: fm,
            targetName: "EventTouch",
          },
        ]),
        Q(
          Te.KEY,
          "macro.KEY",
          [
            "back",
            "menu",
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "0",
            "*",
            "+",
            "-",
            "/",
            ";",
            "=",
            ",",
            ".",
            "[",
            "]",
            "dpadLeft",
            "dpadRight",
            "dpadUp",
            "dpadDown",
            "dpadCenter",
          ].map((t) => ({ name: t }))
        ),
        Q(Te.KEY, "macro.KEY", [
          { name: "shift", suggest: "please use KeyCode.SHIFT_LEFT instead" },
        ]),
        Q(Te.KEY, "macro.KEY", [
          { name: "ctrl", suggest: "please use KeyCode.CTRL_LEFT instead" },
        ]),
        Q(Te.KEY, "macro.KEY", [
          { name: "alt", suggest: "please use KeyCode.ALT_LEFT instead" },
        ]),
        Q(Te, "macro", [
          { name: "KEY", suggest: "please use KeyCode instead" },
        ]),
        t("PipelineEventType", mf),
        (function (t) {
          (t.RENDER_FRAME_BEGIN = "render-frame-begin"),
            (t.RENDER_FRAME_END = "render-frame-end"),
            (t.RENDER_CAMERA_BEGIN = "render-camera-begin"),
            (t.RENDER_CAMERA_END = "render-camera-end"),
            (t.ATTACHMENT_SCALE_CAHNGED = "attachment-scale-changed");
        })(mf || t("PipelineEventType", (mf = {})));
      class ff extends hr {
        constructor() {
          super(),
            (this.eventTargetOn = super.on),
            (this.eventTargetOnce = super.once);
        }
        on(t, e, i, s) {
          return this.eventTargetOn(t, e, i, s);
        }
        once(t, e, i) {
          return this.eventTargetOnce(t, e, i);
        }
      }
      const gf = t("Root", jsb.Root);
      var yf;
      !(function (t) {
        (t[(t.DIRECTIONAL = 0)] = "DIRECTIONAL"),
          (t[(t.SPHERE = 1)] = "SPHERE"),
          (t[(t.SPOT = 2)] = "SPOT"),
          (t[(t.POINT = 3)] = "POINT"),
          (t[(t.RANGED_DIRECTIONAL = 4)] = "RANGED_DIRECTIONAL"),
          (t[(t.UNKNOWN = 5)] = "UNKNOWN");
      })(yf || (yf = {}));
      const Tf = gf.prototype;
      (Tf._createBatcher2D = function () {
        if (!this._batcher && a.internal.Batcher2D) {
          if (
            ((this._batcher = new a.internal.Batcher2D(this)),
            !this._batcher.initialize())
          )
            return (this._batcher = null), void this.destroy();
          this._batcher._nativeObj = this.getBatcher2D();
        }
      }),
        Object.defineProperty(Tf, "batcher2D", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._batcher;
          },
        }),
        Object.defineProperty(Tf, "dataPoolManager", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._dataPoolMgr;
          },
        }),
        Object.defineProperty(Tf, "pipelineEvent", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._pipelineEvent;
          },
        }),
        (Tf._ctor = function (t) {
          (this._device = t),
            (this._dataPoolMgr =
              a.internal.DataPoolManager && new a.internal.DataPoolManager(t)),
            (this._modelPools = new Map()),
            (this._lightPools = new Map()),
            (this._batcher = null),
            (this._pipelineEvent = new ff()),
            this._registerListeners();
        }),
        (Tf.initialize = function () {
          var t;
          this._initialize(I_.swapchain);
          const e =
            ge.querySettings(
              fe.Category.ANIMATION,
              "customJointTextureLayouts"
            ) || [];
          null === (t = this._dataPoolMgr) ||
            void 0 === t ||
            t.jointTexturePool.registerCustomTextureLayouts(e);
        }),
        (Tf.createModel = function (t) {
          let e = this._modelPools.get(t);
          e ||
            (this._modelPools.set(
              t,
              new Wn(
                () => new t(),
                10,
                (t) => t.destroy()
              )
            ),
            (e = this._modelPools.get(t)));
          const i = e.alloc();
          return i.initialize(), i;
        }),
        (Tf.destroyModel = function (t) {
          const e = this._modelPools.get(t.constructor);
          e
            ? (e.free(t), t.scene && t.scene.removeModel(t))
            : z(1300, t.constructor.name),
            t.destroy();
        }),
        (Tf.createLight = function (t) {
          let e = this._lightPools.get(t);
          e ||
            (this._lightPools.set(
              t,
              new Wn(
                () => new t(),
                4,
                (t) => t.destroy()
              )
            ),
            (e = this._lightPools.get(t)));
          const i = e.alloc();
          return i.initialize(), i;
        }),
        (Tf.destroyLight = function (t) {
          if (t.scene)
            switch (t.type) {
              case yf.DIRECTIONAL:
                t.scene.removeDirectionalLight(t);
                break;
              case yf.SPHERE:
                t.scene.removeSphereLight(t);
                break;
              case yf.SPOT:
                t.scene.removeSpotLight(t);
                break;
              case yf.POINT:
                t.scene.removePointLight(t);
                break;
              case yf.RANGED_DIRECTIONAL:
                t.scene.removeRangedDirLight(t);
            }
          t.destroy();
        }),
        (Tf.recycleLight = function (t) {
          const e = this._lightPools.get(t.constructor);
          if (e && (e.free(t), t.scene))
            switch (t.type) {
              case yf.DIRECTIONAL:
                t.scene.removeDirectionalLight(t);
                break;
              case yf.SPHERE:
                t.scene.removeSphereLight(t);
                break;
              case yf.SPOT:
                t.scene.removeSpotLight(t);
                break;
              case yf.POINT:
                t.scene.removePointLight(t);
                break;
              case yf.RANGED_DIRECTIONAL:
                t.scene.removeRangedDirLight(t);
            }
        }),
        (Tf._onDirectorBeforeCommit = function () {
          a.director.emit(a.Director.EVENT_BEFORE_COMMIT);
        }),
        (Tf._onDirectorBeforeRender = function () {
          a.director.emit(a.Director.EVENT_BEFORE_RENDER);
        }),
        (Tf._onDirectorAfterRender = function () {
          a.director.emit(a.Director.EVENT_AFTER_RENDER);
        }),
        (Tf._onDirectorPipelineChanged = function () {
          const t = a.director.getScene();
          t && t._activate();
        });
      const Sf = Tf.onGlobalPipelineStateChanged;
      Tf.onGlobalPipelineStateChanged = function () {
        Sf.call(this);
        const t = a.rendering.getCustomPipeline(Te.CUSTOM_PIPELINE_NAME);
        t &&
          ("function" == typeof t.onGlobalPipelineStateChanged &&
            t.onGlobalPipelineStateChanged(),
          a.rendering.forceResizeAllWindows());
      };
      const Ef = Tf.frameMove;
      Tf.frameMove = function (t) {
        Ef.call(this, t, a.director.getTotalFrames());
      };
      const vf = Tf.setRenderPipeline;
      let bf, Af, Cf;
      (Tf.setRenderPipeline = function (t) {
        let e;
        if (t)
          a.rendering.createCustomPipeline(),
            (e = vf.call(this, null)),
            I(`Using custom pipeline: ${Te.CUSTOM_PIPELINE_NAME}`);
        else if (a.legacy_rendering) {
          const t = a.legacy_rendering.createDefaultPipeline();
          t.init(), (e = vf.call(this, t));
        } else I("No render pipeline: legacy-pipeline is not available");
        return this._createBatcher2D(), e;
      }),
        (Tf.addBatch = function () {
          console.error(
            "The Draw Batch class is implemented differently in the native platform and does not support this interface."
          );
        }),
        (Tf.removeBatch = function () {
          console.error(
            "The Draw Batch class is implemented differently in the native platform and does not support this interface."
          );
        }),
        (Tf.removeBatches = function () {
          console.error(
            "The Draw Batch class is implemented differently in the native platform and does not support this interface."
          );
        }),
        t("NodeEventType", bf),
        (function (t) {
          (t.TOUCH_START = "touch-start"),
            (t.TOUCH_MOVE = "touch-move"),
            (t.TOUCH_END = "touch-end"),
            (t.TOUCH_CANCEL = "touch-cancel"),
            (t.MOUSE_DOWN = "mouse-down"),
            (t.MOUSE_MOVE = "mouse-move"),
            (t.MOUSE_UP = "mouse-up"),
            (t.MOUSE_WHEEL = "mouse-wheel"),
            (t.MOUSE_ENTER = "mouse-enter"),
            (t.MOUSE_LEAVE = "mouse-leave"),
            (t.KEY_DOWN = "keydown"),
            (t.KEY_UP = "keyup"),
            (t.DEVICEMOTION = "devicemotion"),
            (t.TRANSFORM_CHANGED = "transform-changed"),
            (t.MOBILITY_CHANGED = "mobility-changed"),
            (t.SCENE_CHANGED_FOR_PERSISTS = "scene-changed-for-persists"),
            (t.SIZE_CHANGED = "size-changed"),
            (t.ANCHOR_CHANGED = "anchor-changed"),
            (t.COLOR_CHANGED = "color-changed"),
            (t.CHILD_ADDED = "child-added"),
            (t.CHILD_REMOVED = "child-removed"),
            (t.PARENT_CHANGED = "parent-changed"),
            (t.NODE_DESTROYED = "node-destroyed"),
            (t.LAYER_CHANGED = "layer-changed"),
            (t.SIBLING_ORDER_CHANGED = "sibling-order-changed"),
            (t.CHILDREN_ORDER_CHANGED = "sibling-order-changed"),
            (t.ACTIVE_IN_HIERARCHY_CHANGED = "active-in-hierarchy-changed"),
            (t.COMPONENT_ADDED = "component-added"),
            (t.COMPONENT_REMOVED = "component-removed"),
            (t.LIGHT_PROBE_CHANGED = "light-probe-changed"),
            (t.LIGHT_PROBE_BAKING_CHANGED = "light-probe-baking-changed"),
            (t.ACTIVE_CHANGED = "active-changed");
        })(bf || t("NodeEventType", (bf = {})));
      class Of {
        get uiTransformComp() {
          return (
            this._uiTransformComp ||
              (this._uiTransformComp =
                this._node.getComponent("cc.UITransform")),
            this._uiTransformComp
          );
        }
        set uiTransformComp(t) {
          this._uiTransformComp = t;
        }
        get uiComp() {
          return this._uiComp;
        }
        set uiComp(t) {
          this._uiComp && t ? z(12002) : (this._uiComp = t);
        }
        setOpacity(t) {
          this._opacity = t;
        }
        get opacity() {
          return this._opacity;
        }
        get localOpacity() {
          return this._localOpacity;
        }
        set localOpacity(t) {
          (this._localOpacity = t), (this.colorDirty = !0);
        }
        constructor(t) {
          (this._uiComp = null),
            (this._opacity = 1),
            (this._localOpacity = 1),
            (this.colorDirty = !0),
            (this._uiTransformComp = null),
            (this._node = t);
        }
        applyOpacity(t) {
          this._opacity = this._localOpacity * t;
        }
        static markOpacityTree(t, e = !0) {}
      }
      t("NodeSpace", Af),
        (function (t) {
          (t[(t.LOCAL = 0)] = "LOCAL"), (t[(t.WORLD = 1)] = "WORLD");
        })(Af || t("NodeSpace", (Af = {}))),
        t("TransformBit", Cf),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.POSITION = 1)] = "POSITION"),
            (t[(t.ROTATION = 2)] = "ROTATION"),
            (t[(t.SCALE = 4)] = "SCALE"),
            (t[(t.RS = t.ROTATION | t.SCALE)] = "RS"),
            (t[(t.TRS = t.POSITION | t.ROTATION | t.SCALE)] = "TRS"),
            (t[(t.TRS_MASK = ~t.TRS)] = "TRS_MASK");
        })(Cf || t("TransformBit", (Cf = {}))),
        (a.internal.TransformBit = Cf);
      const If = t(
          "MobilityMode",
          ce({ Static: 0, Stationary: 1, Movable: 2 })
        ),
        wf = {
          NONE: 0,
          IGNORE_RAYCAST: 1 << 20,
          GIZMOS: 1 << 21,
          EDITOR: 1 << 22,
          UI_3D: 1 << 23,
          SCENE_GIZMO: 1 << 24,
          UI_2D: 1 << 25,
          PROFILER: 1 << 28,
          DEFAULT: 1 << 30,
          ALL: 4294967295,
        };
      class Rf {
        static init() {
          const t = ge.querySettings(fe.Category.ENGINE, "customLayers");
          if (t)
            for (let e = 0; e < t.length; e++) {
              const i = t[e];
              Rf.addLayer(i.name, i.bit);
            }
        }
        static makeMaskInclude(t) {
          let e = 0;
          for (const i of t) e |= i;
          return e;
        }
        static makeMaskExclude(t) {
          return ~Rf.makeMaskInclude(t);
        }
        static addLayer(t, e) {
          if (void 0 === e) return void z(16364);
          if (e > 19 || e < 0) return void z(16365);
          const i = 1 << e;
          Rf.Enum[t],
            X(2104, t),
            (Rf.Enum[t] = i),
            ft(Rf.Enum, String(i), t),
            (Rf.BitMask[t] = i),
            ft(Rf.BitMask, String(i), t),
            oe.update(Rf.BitMask),
            ce.update(Rf.Enum);
        }
        static deleteLayer(t) {
          if (t > 19 || t < 0) return void z(16366);
          const e = 1 << t;
          delete Rf.Enum[Rf.Enum[e]],
            delete Rf.Enum[e],
            delete Rf.BitMask[Rf.BitMask[e]],
            delete Rf.BitMask[e],
            oe.update(Rf.BitMask),
            ce.update(Rf.Enum);
        }
        static nameToLayer(t) {
          return void 0 === t ? (z(16367), -1) : _(Rf.Enum[t]);
        }
        static layerToName(t) {
          return t > 31 || t < 0 ? (z(16368), "") : Rf.Enum[1 << t];
        }
      }
      t("Layers", Rf),
        (Rf.Enum = ce(wf)),
        (Rf.BitMask = oe({ ...wf })),
        (a.Layers = Rf);
      const Df = new Float32Array(jsb.createExternalArrayBuffer(80)),
        xf = function (t) {
          ms.set(
            t,
            Df[0],
            Df[1],
            Df[2],
            Df[3],
            Df[4],
            Df[5],
            Df[6],
            Df[7],
            Df[8],
            Df[9],
            Df[10],
            Df[11],
            Df[12],
            Df[13],
            Df[14],
            Df[15]
          );
        };
      $n.Flags.Destroying, a.GAME_VIEW;
      const Mf = Symbol("ReserveContentsForAllSyncablePrefab"),
        Pf = jsb.Node;
      t({ Node: Pf, BaseNode: Pf }), (a.Node = Pf);
      const Nf = Pf;
      (Nf.reserveContentsForAllSyncablePrefabTag = Mf),
        (Nf.EventType = bf),
        (Nf.NodeSpace = Af),
        (Nf.TransformDirtyBit = Cf),
        (Nf.TransformBit = Cf);
      const Lf = Cf.TRS,
        Bf = jsb.Node.prototype,
        Ff = $n.Flags.Destroying;
      function Uf(t) {
        return t ? ("string" == typeof t ? Yt(t) : t) : null;
      }
      Pf._setTempFloatArray(Df.buffer),
        (Bf.attr = function (t) {
          Mt(this, t);
        }),
        (Bf.getComponent = function (t) {
          const e = Uf(t);
          return e ? Nf._findComponent(this, e) : null;
        }),
        (Bf.getComponents = function (t) {
          const e = Uf(t),
            i = [];
          return e && Nf._findComponents(this, e, i), i;
        }),
        (Bf.getComponentInChildren = function (t) {
          const e = Uf(t);
          return e ? Nf._findChildComponent(this._children, e) : null;
        }),
        (Bf.getComponentsInChildren = function (t) {
          const e = Uf(t),
            i = [];
          return (
            e &&
              (Nf._findComponents(this, e, i),
              Nf._findChildComponents(this.children, e, i)),
            i
          );
        }),
        (Bf.addComponent = function (t) {
          let e;
          if ("string" == typeof t) {
            if (((e = Yt(t)), !e))
              throw (a._RF.peek() && G(3808, t), TypeError(X(3807, t)));
          } else {
            if (!t) throw TypeError(X(3804));
            e = t;
          }
          if ("function" != typeof e) throw TypeError(X(3809));
          if (!Lt(e, np)) throw TypeError(X(3810));
          const i = e._requireComponent;
          if (i) {
            const t = (t) => {
              this.getComponent(t) || this.addComponent(t);
            };
            Array.isArray(i) ? i.forEach((e) => t(e)) : t(i);
          }
          const s = new e();
          return (
            (s.node = this),
            this._components.push(s),
            this.emit(bf.COMPONENT_ADDED, s),
            this._activeInHierarchy &&
              a.director._nodeActivator.activateComp(s),
            s
          );
        }),
        (Bf.removeComponent = function (t) {
          if (!t) return void G(3813);
          let e = null;
          (e = t instanceof np ? t : this.getComponent(t)), e && e.destroy();
        }),
        (Bf.on = function (t, e, i, s = !1) {
          switch (t) {
            case bf.TRANSFORM_CHANGED:
              (this._eventMask |= 1),
                1 & this._registeredNodeEventTypeMask ||
                  (this._registerOnTransformChanged(),
                  (this._registeredNodeEventTypeMask |= 1));
              break;
            case bf.ACTIVE_CHANGED:
              this._eventMask |= 2;
              break;
            case bf.PARENT_CHANGED:
              2 & this._registeredNodeEventTypeMask ||
                (this._registerOnParentChanged(),
                (this._registeredNodeEventTypeMask |= 2));
              break;
            case bf.MOBILITY_CHANGED:
              4 & this._registeredNodeEventTypeMask ||
                (this._registerOnMobilityChanged(),
                (this._registeredNodeEventTypeMask |= 4));
              break;
            case bf.LAYER_CHANGED:
              8 & this._registeredNodeEventTypeMask ||
                (this._registerOnLayerChanged(),
                (this._registeredNodeEventTypeMask |= 8));
              break;
            case bf.CHILDREN_ORDER_CHANGED:
              16 & this._registeredNodeEventTypeMask ||
                (this._registerOnSiblingOrderChanged(),
                (this._registeredNodeEventTypeMask |= 16));
              break;
            case bf.LIGHT_PROBE_BAKING_CHANGED:
              32 & this._registeredNodeEventTypeMask ||
                (this._registerOnLightProbeBakingChanged(),
                (this._registeredNodeEventTypeMask |= 32));
          }
          this._eventProcessor.on(t, e, i, s);
        }),
        (Bf.off = function (t, e, i, s = !1) {
          var n;
          if (
            (null === (n = this._eventProcessor) ||
              void 0 === n ||
              n.off(t, e, i, s),
            !this._eventProcessor || !this._eventProcessor.hasEventListener(t))
          )
            switch (t) {
              case bf.TRANSFORM_CHANGED:
                this._eventMask &= -2;
                break;
              case bf.ACTIVE_CHANGED:
                this._eventMask &= -3;
            }
        }),
        (Bf.once = function (t, e, i, s) {
          this._eventProcessor.once(t, e, i, s);
        }),
        (Bf.emit = function (t, e, i, s, n, r) {
          var a;
          null === (a = this._eventProcessor) ||
            void 0 === a ||
            a.emit(t, e, i, s, n, r);
        }),
        (Bf.dispatchEvent = function (t) {
          this._eventProcessor.dispatchEvent(t);
        }),
        (Bf.hasEventListener = function (t, e, i) {
          return this._eventProcessor.hasEventListener(t, e, i);
        }),
        (Bf.targetOff = function (t) {
          this._eventProcessor.targetOff(t),
            1 & this._eventMask &&
              !this._eventProcessor.hasEventListener(bf.TRANSFORM_CHANGED) &&
              (this._eventMask &= -2),
            2 & this._eventMask &&
              !this._eventProcessor.hasEventListener(bf.ACTIVE_CHANGED) &&
              (this._eventMask &= -3);
        }),
        (Bf.pauseSystemEvents = function (t) {
          this._eventProcessor.setEnabled(!1, t);
        }),
        (Bf.resumeSystemEvents = function (t) {
          this._eventProcessor.setEnabled(!0, t);
        }),
        (Bf.getWritableComponents = function () {
          return this._components;
        }),
        (Bf._setActiveInHierarchy = function (t) {
          return (this._activeInHierarchy = t);
        }),
        (Bf._removeComponent = function (t) {
          if (t) {
            if (!(this._objFlags & Ff)) {
              const e = this._components.indexOf(t);
              -1 !== e
                ? (this._components.splice(e, 1),
                  this.emit(bf.COMPONENT_REMOVED, t))
                : t.node !== this && G(3815);
            }
          } else G(3814);
        }),
        (Bf._registerIfAttached = void 0),
        (Bf._onTransformChanged = function (t) {
          this.emit(bf.TRANSFORM_CHANGED, t);
        }),
        (Bf._onParentChanged = function (t) {
          this.emit(bf.PARENT_CHANGED, t);
        }),
        (Bf._onReAttach = function () {
          this._eventProcessor.reattach();
        }),
        (Bf._onEditorAttached = function () {}),
        (Bf._onRemovePersistRootNode = function () {
          a.game.removePersistRootNode(this);
        }),
        (Bf._onDestroyComponents = function () {
          this._eventProcessor.destroy();
          const t = this._components;
          for (let e = 0; e < t.length; ++e) t[e]._destroyImmediate();
        }),
        (Bf._onMobilityChanged = function () {
          this.emit(bf.MOBILITY_CHANGED);
        }),
        (Bf._onLayerChanged = function (t) {
          this.emit(bf.LAYER_CHANGED, t);
        }),
        (Bf._onChildRemoved = function (t) {
          const e = this._children.indexOf(t);
          e < 0
            ? G(1633)
            : (this._children.splice(e, 1), this.emit(bf.CHILD_REMOVED, t));
        }),
        (Bf._onChildAdded = function (t) {
          this._children.push(t), this.emit(bf.CHILD_ADDED, t);
        });
      const kf = Bf._onPreDestroy;
      (Bf._onPreDestroy = function () {
        const t = kf.call(this);
        this.emit(bf.NODE_DESTROYED, this), this._eventProcessor.destroy();
        const e = this._children;
        for (let t = 0; t < e.length; ++t) e[t]._destroyImmediate();
        const i = this._components;
        for (let t = 0; t < i.length; ++t) i[t]._destroyImmediate();
        return t;
      }),
        (Bf.destroyAllChildren = function () {
          const t = this._children;
          for (let e = 0, i = t.length; e < i; ++e) t[e].destroy();
        }),
        (Bf._onSiblingOrderChanged = function () {
          this.emit(bf.CHILDREN_ORDER_CHANGED);
        }),
        (Bf._onActivateNode = function (t) {
          a.director._nodeActivator.activateNode(this, t);
        }),
        (Bf._onPostActivated = function (t) {
          2 & this._eventMask && this.emit(bf.ACTIVE_CHANGED, this, t),
            this._eventProcessor.setEnabled(t),
            t &&
              (this.invalidateChildren(Cf.TRS),
              this._uiProps &&
                this._uiProps.uiComp &&
                (this._uiProps.uiComp.setNodeDirty(),
                this._uiProps.uiComp.setTextureDirty(),
                this._uiProps.uiComp.markForUpdateRenderData()));
        }),
        (Bf._onLightProbeBakingChanged = function () {
          this.emit(bf.LIGHT_PROBE_BAKING_CHANGED);
        }),
        (Nf._findComponent = function (t, e) {
          if (!t || !t._components || !e) return null;
          const i = e,
            s = t._components;
          if (i._sealed)
            for (let t = 0; t < s.length; ++t) {
              const i = s[t];
              if (i && i.constructor === e) return i;
            }
          else
            for (let t = 0; t < s.length; ++t) {
              const i = s[t];
              if (i instanceof e) return i;
            }
          return null;
        }),
        (Nf._findComponents = function (t, e, i) {
          if (!(t && t._components && e && i)) return;
          const s = e,
            n = t._components;
          if (s._sealed)
            for (let t = 0; t < n.length; ++t) {
              const s = n[t];
              s && s.constructor === e && i.push(s);
            }
          else
            for (let t = 0; t < n.length; ++t) {
              const s = n[t];
              s instanceof e && i.push(s);
            }
        }),
        (Nf._findChildComponent = function (t, e) {
          for (let i = 0; i < t.length; ++i) {
            const s = t[i];
            let n = Nf._findComponent(s, e);
            if (n) return n;
            const r = s.children;
            if (r.length > 0 && ((n = Nf._findChildComponent(r, e)), n))
              return n;
          }
          return null;
        }),
        (Nf._findChildComponents = function (t, e, i) {
          for (let s = 0; s < t.length; ++s) {
            const n = t[s];
            Nf._findComponents(n, e, i);
            const r = n.children;
            r.length > 0 && Nf._findChildComponents(r, e, i);
          }
        }),
        (Nf.isNode = function (t) {
          return (
            t instanceof jsb.Node &&
            (t.constructor === jsb.Node || !(t instanceof a.Scene))
          );
        });
      let zf = new as();
      (Bf.setRTS = function (t, e, i) {
        if (t) {
          let e = zf;
          t instanceof as ? (e = t) : as.fromEuler(e, t.x, t.y, t.z),
            (Df[0] = 4),
            (Df[1] = e.x),
            (Df[2] = e.y),
            (Df[3] = e.z),
            (Df[4] = e.w),
            this._lrot.set(e.x, e.y, e.z, e.w);
        } else Df[0] = 0;
        e
          ? ((Df[5] = 3),
            (Df[6] = e.x),
            (Df[7] = e.y),
            (Df[8] = e.z),
            this._lpos.set(e.x, e.y, e.z))
          : (Df[5] = 0),
          i
            ? ((Df[9] = 3),
              (Df[10] = i.x),
              (Df[11] = i.y),
              (Df[12] = i.z),
              this._lscale.set(i.x, i.y, i.z))
            : (Df[9] = 0),
          this._setRTS();
      }),
        (Bf.getPosition = function (t) {
          return t
            ? Yi.set(t, this._lpos.x, this._lpos.y, this._lpos.z)
            : Yi.copy(new Yi(), this._lpos);
        }),
        (Bf.setPosition = function (t, e, i) {
          if (void 0 === e && void 0 === i) {
            Df[0] = 3;
            const e = t;
            (this._lpos.x = Df[1] = e.x),
              (this._lpos.y = Df[2] = e.y),
              (this._lpos.z = Df[3] = e.z);
          } else
            void 0 === i
              ? ((Df[0] = 2),
                (this._lpos.x = Df[1] = t),
                (this._lpos.y = Df[2] = e))
              : ((Df[0] = 3),
                (this._lpos.x = Df[1] = t),
                (this._lpos.y = Df[2] = e),
                (this._lpos.z = Df[3] = i));
          this._setPosition();
        }),
        (Bf.getRotation = function (t) {
          const e = this._lrot;
          return t ? as.set(t, e.x, e.y, e.z, e.w) : as.copy(new as(), e);
        }),
        (Bf.setRotation = function (t, e, i, s) {
          if (void 0 === e || void 0 === i || void 0 === s) {
            const e = t;
            (this._lrot.x = Df[0] = e.x),
              (this._lrot.y = Df[1] = e.y),
              (this._lrot.z = Df[2] = e.z),
              (this._lrot.w = Df[3] = e.w);
          } else
            (this._lrot.x = Df[0] = t),
              (this._lrot.y = Df[1] = e),
              (this._lrot.z = Df[2] = i),
              (this._lrot.w = Df[3] = s);
          this._setRotation();
        }),
        (Bf.setRotationFromEuler = function (t, e, i) {
          const s = void 0 === i ? this._euler.z : i;
          if (void 0 === e) {
            const e = t;
            (this._euler.x = Df[0] = e.x),
              (this._euler.y = Df[1] = e.y),
              (this._euler.z = Df[2] = e.z);
          } else
            (this._euler.x = Df[0] = t),
              (this._euler.y = Df[1] = e),
              (this._euler.z = Df[2] = s);
          this._setRotationFromEuler();
        }),
        (Bf.getScale = function (t) {
          return t
            ? Yi.set(t, this._lscale.x, this._lscale.y, this._lscale.z)
            : Yi.copy(new Yi(), this._lscale);
        }),
        (Bf.setScale = function (t, e, i) {
          if (void 0 === e && void 0 === i) {
            Df[0] = 3;
            const e = t;
            (this._lscale.x = Df[1] = e.x),
              (this._lscale.y = Df[2] = e.y),
              (this._lscale.z = Df[3] = e.z);
          } else
            void 0 === i
              ? ((Df[0] = 2),
                (this._lscale.x = Df[1] = t),
                (this._lscale.y = Df[2] = e))
              : ((Df[0] = 3),
                (this._lscale.x = Df[1] = t),
                (this._lscale.y = Df[2] = e),
                (this._lscale.z = Df[3] = i));
          this._setScale();
        }),
        (Bf.getWorldPosition = function (t) {
          return (
            this._getWorldPosition(),
            (t = t || new Yi()).set(Df[0], Df[1], Df[2])
          );
        }),
        (Bf.getWorldRotation = function (t) {
          return (
            this._getWorldRotation(),
            (t = t || new as()).set(Df[0], Df[1], Df[2], Df[3])
          );
        }),
        (Bf.getWorldScale = function (t) {
          return (
            this._getWorldScale(), (t = t || new Yi()).set(Df[0], Df[1], Df[2])
          );
        }),
        (Bf.getWorldMatrix = function (t) {
          return this._getWorldMatrix(), (t = t || new ms()), xf(t), t;
        }),
        (Bf.getEulerAngles = function (t) {
          return (
            this._getEulerAngles(), (t = t || new Yi()).set(Df[0], Df[1], Df[2])
          );
        }),
        (Bf.getForward = function (t) {
          return (
            this._getForward(), (t = t || new Yi()).set(Df[0], Df[1], Df[2])
          );
        }),
        (Bf.getUp = function (t) {
          return this._getUp(), (t = t || new Yi()).set(Df[0], Df[1], Df[2]);
        }),
        (Bf.getRight = function (t) {
          return this._getRight(), (t = t || new Yi()).set(Df[0], Df[1], Df[2]);
        }),
        (Bf.inverseTransformPoint = function (t, e) {
          return (
            (Df[0] = e.x),
            (Df[1] = e.y),
            (Df[2] = e.z),
            this._inverseTransformPoint(),
            (t.x = Df[0]),
            (t.y = Df[1]),
            (t.z = Df[2]),
            t
          );
        }),
        (Bf.getWorldRT = function (t) {
          return (t = t || new ms()), this._getWorldRT(), xf(t), t;
        }),
        (Bf.getWorldRS = function (t) {
          return (t = t || new ms()), this._getWorldRS(), xf(t), t;
        }),
        (Bf.isTransformDirty = function () {
          return this._transformFlags !== Cf.NONE;
        }),
        Object.defineProperty(Bf, "name", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._name;
          },
          set(t) {
            this._name = t;
          },
        }),
        Object.defineProperty(Bf, "position", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._lpos;
          },
          set(t) {
            this.setPosition(t);
          },
        }),
        Object.defineProperty(Bf, "rotation", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._lrot;
          },
          set(t) {
            this.setRotation(t);
          },
        }),
        Object.defineProperty(Bf, "scale", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._lscale;
          },
          set(t) {
            this.setScale(t);
          },
        }),
        Object.defineProperty(Bf, "worldPosition", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getWorldPosition();
          },
          set(t) {
            this.setWorldPosition(t);
          },
        }),
        Object.defineProperty(Bf, "worldRotation", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getWorldRotation();
          },
          set(t) {
            this.setWorldRotation(t);
          },
        }),
        Object.defineProperty(Bf, "worldScale", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getWorldScale();
          },
          set(t) {
            this.setWorldScale(t);
          },
        }),
        Object.defineProperty(Bf, "_pos", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getWorldPosition();
          },
        }),
        Object.defineProperty(Bf, "_rot", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getWorldRotation();
          },
        }),
        Object.defineProperty(Bf, "_scale", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getWorldScale();
          },
        }),
        Object.defineProperty(Bf, "eulerAngles", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getEulerAngles();
          },
          set(t) {
            this.setRotationFromEuler(t.x, t.y, t.z);
          },
        }),
        Object.defineProperty(Bf, "worldMatrix", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getWorldMatrix();
          },
        }),
        Object.defineProperty(Bf, "_mat", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getWorldMatrix();
          },
        }),
        Object.defineProperty(Bf, "activeInHierarchy", {
          configurable: !0,
          enumerable: !0,
          get() {
            return null != this._sharedUint8Arr && 0 != this._sharedUint8Arr[0];
          },
          set(t) {
            this._sharedUint8Arr[0] = t ? 1 : 0;
          },
        }),
        Object.defineProperty(Bf, "_activeInHierarchy", {
          configurable: !0,
          enumerable: !0,
          get() {
            return 0 != this._sharedUint8Arr[0];
          },
          set(t) {
            this._sharedUint8Arr[0] = t ? 1 : 0;
          },
        }),
        Object.defineProperty(Bf, "layer", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._sharedUint32Arr[1];
          },
          set(t) {
            (this._sharedUint32Arr[1] = t),
              this._uiProps &&
                this._uiProps.uiComp &&
                (this._uiProps.uiComp.setNodeDirty(),
                this._uiProps.uiComp.markForUpdateRenderData()),
              this.emit(bf.LAYER_CHANGED, t);
          },
        }),
        Object.defineProperty(Bf, "_layer", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._sharedUint32Arr[1];
          },
          set(t) {
            this._sharedUint32Arr[1] = t;
          },
        }),
        Object.defineProperty(Bf, "_eventMask", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._sharedUint32Arr[0];
          },
          set(t) {
            this._sharedUint32Arr[0] = t;
          },
        }),
        Object.defineProperty(Bf, "_siblingIndex", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._sharedInt32Arr[0];
          },
          set(t) {
            this._sharedInt32Arr[0] = t;
          },
        }),
        Object.defineProperty(Bf, "prefab", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._prefab;
          },
        }),
        Object.defineProperty(Bf, "siblingIndex", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._sharedInt32Arr[0];
          },
          set(t) {
            this._sharedInt32Arr[0] = t;
          },
        }),
        (Bf.getSiblingIndex = function () {
          return this._sharedInt32Arr[0];
        }),
        Object.defineProperty(Bf, "_transformFlags", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._sharedUint32Arr[2];
          },
          set(t) {
            this._sharedUint32Arr[2] = t;
          },
        }),
        Object.defineProperty(Bf, "_active", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._sharedUint8Arr && 0 != this._sharedUint8Arr[1];
          },
          set(t) {
            this._sharedUint8Arr && (this._sharedUint8Arr[1] = t ? 1 : 0);
          },
        }),
        Object.defineProperty(Bf, "id", {
          configurable: !0,
          enumerable: !0,
          set(t) {
            this._id = t;
          },
        }),
        Object.defineProperty(Bf, "active", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._sharedUint8Arr && 0 != this._sharedUint8Arr[1];
          },
          set(t) {
            this.setActive(!!t);
          },
        }),
        Object.defineProperty(Bf, "_static", {
          configurable: !0,
          enumerable: !0,
          get() {
            return 0 != this._sharedUint8Arr[2];
          },
          set(t) {
            this._sharedUint8Arr[2] = t ? 1 : 0;
          },
        }),
        Object.defineProperty(Bf, "forward", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getForward();
          },
          set(t) {
            this.setForward(t);
          },
        }),
        Object.defineProperty(Bf, "up", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getUp();
          },
        }),
        Object.defineProperty(Bf, "right", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getRight();
          },
        }),
        Object.defineProperty(Bf, "eventProcessor", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._eventProcessor;
          },
        }),
        Object.defineProperty(Bf, "components", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._components;
          },
        }),
        Object.defineProperty(Bf, "_parent", {
          configurable: !0,
          enumerable: !0,
          get() {
            return (this._parentRef = this._parentInternal), this._parentRef;
          },
          set(t) {
            this._parentRef = this._parentInternal = t;
          },
        }),
        Object.defineProperty(Bf, "parent", {
          configurable: !0,
          enumerable: !0,
          get() {
            return (this._parentRef = this.getParent()), this._parentRef;
          },
          set(t) {
            (this._parentRef = t), this.setParent(t);
          },
        }),
        Object.defineProperty(Bf, "children", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._children;
          },
          set(t) {
            this._children = t;
          },
        }),
        Object.defineProperty(Bf, "scene", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._scene;
          },
        }),
        (Bf.rotate = function (t, e) {
          (Df[1] = t.x),
            (Df[2] = t.y),
            (Df[3] = t.z),
            (Df[4] = t.w),
            e ? ((Df[5] = e), (Df[0] = 5)) : (Df[0] = 4),
            this._rotateForJS();
          const i = this._lrot;
          (i.x = Df[0]), (i.y = Df[1]), (i.z = Df[2]), (i.w = Df[3]);
        }),
        (Bf.addChild = function (t) {
          t.setParent(this);
        }),
        (Bf.insertChild = function (t, e) {
          (t.parent = this), t.setSiblingIndex(e);
        }),
        (Bf[Ao] = function (t, e) {
          t.writeThis();
          const i = () => {
              var t;
              return !(
                null === (t = this[Kn]) ||
                void 0 === t ||
                !t.mountedRoot
              );
            },
            s = () => {
              var t, e, s, n;
              return (
                (null === (t = this._prefab) ||
                void 0 === t ||
                null === (e = t.root) ||
                void 0 === e ||
                null === (s = e._prefab) ||
                void 0 === s
                  ? void 0
                  : s.instance) &&
                ((null == this || null === (n = this._prefab) || void 0 === n
                  ? void 0
                  : n.instance) ||
                  !i())
              );
            };
          var n;
          if ((() => !(e.customArguments[Mf] || !s() || e.root === this))()) {
            if (
              (null === (n = this._prefab) || void 0 === n
                ? void 0
                : n.root) === this
            ) {
              let i = !1,
                s = this.getParent();
              for (; s; ) {
                var r;
                const t =
                  null === (r = s._prefab) || void 0 === r
                    ? void 0
                    : r.nestedPrefabInstanceRoots;
                if (t && t.length > 0) {
                  i = !t.some((t) => t === this);
                  break;
                }
                s = s.getParent();
              }
              i ||
                (t.writeProperty("_objFlags", this._objFlags),
                t.writeProperty("_parent", this._parent),
                t.writeProperty("_prefab", this._prefab),
                e.customArguments.keepNodeUuid &&
                  t.writeProperty("_id", this._id)),
                t.writeProperty(Kn, this[Kn]);
            }
          } else t.writeThis();
        }),
        (Bf._onActiveNode = function (t) {
          a.director._nodeActivator.activateNode(this, t);
        }),
        (Bf._onBatchCreated = function (t) {
          2 & this._eventMask &&
            (this._activeInHierarchy || this.emit(bf.ACTIVE_CHANGED, this, !1)),
            (this.hasChangedFlags = Lf);
          const e = this._children,
            i = e.length;
          let s;
          for (let n = 0; n < i; ++n)
            (s = e[n]), (s._siblingIndex = n), s._onBatchCreated(t);
          ec(this);
        }),
        (Bf._onSceneUpdated = function (t) {
          this._scene = t;
        }),
        (Bf._onLocalPositionUpdated = function (t, e, i) {
          const s = this._lpos;
          (s.x = t), (s.y = e), (s.z = i);
        }),
        (Bf._onLocalRotationUpdated = function (t, e, i, s) {
          const n = this._lrot;
          (n.x = t), (n.y = e), (n.z = i), (n.w = s);
        }),
        (Bf._onLocalScaleUpdated = function (t, e, i) {
          const s = this._lscale;
          (s.x = t), (s.y = e), (s.z = i);
        }),
        (Bf._onLocalPositionRotationScaleUpdated = function (
          t,
          e,
          i,
          s,
          n,
          r,
          a,
          o,
          h,
          l
        ) {
          const c = this._lpos;
          (c.x = t), (c.y = e), (c.z = i);
          const u = this._lrot;
          (u.x = s), (u.y = n), (u.z = r), (u.w = a);
          const _ = this._lscale;
          (_.x = o), (_.y = h), (_.z = l);
        }),
        (Bf._instantiate = function (t, e) {
          return (
            t || (t = a.instantiate._clone(this, this)),
            t._prefab,
            (t._parent = null),
            t._onBatchCreated(e),
            t
          );
        }),
        (Bf._onSiblingIndexChanged = function (t) {
          const e = this._parent._children;
          t = -1 !== t ? t : e.length - 1;
          const i = e.indexOf(this);
          t !== i &&
            (e.splice(i, 1),
            t < e.length ? e.splice(t, 0, this) : e.push(this),
            this._eventProcessor.onUpdatingSiblingIndex());
        }),
        (Bf._ctor = function () {
          (this.__nativeRefs = {}),
            (this._parentRef = null),
            (this.__jsb_ref_id = void 0),
            (this._iN$t = null),
            (this.__editorExtras__ = { editorOnly: !0 }),
            (this._components = []),
            (this._eventProcessor = new a.NodeEventProcessor(this)),
            (this._uiProps = new Of(this));
          const t = this._initAndReturnSharedBuffer();
          (this._sharedUint32Arr = new Uint32Array(t, 0, 3)),
            (this._sharedInt32Arr = new Int32Array(t, 12, 1)),
            (this._sharedUint8Arr = new Uint8Array(t, 16, 3)),
            (this._sharedUint32Arr[1] = Rf.Enum.DEFAULT),
            (this._scene = null),
            (this._prefab = null),
            (this._originalSceneId = ""),
            (this._children = []),
            (this._lpos = new Yi()),
            (this._lrot = new as()),
            (this._lscale = new Yi(1, 1, 1)),
            (this._euler = new Yi()),
            (this._registeredNodeEventTypeMask = 0);
        }),
        (function (t, e = vd) {
          const {
              Node: i,
              Vec3: s,
              Quat: n,
              MobilityMode: r,
              Layers: a,
            } = { ...t },
            o = Object.getOwnPropertyDescriptor(i.prototype, "_persistNode");
          Object.getOwnPropertyDescriptor(i.prototype, "name"),
            Object.getOwnPropertyDescriptor(i.prototype, "children"),
            Object.getOwnPropertyDescriptor(i.prototype, "active"),
            Object.getOwnPropertyDescriptor(i.prototype, "activeInHierarchy"),
            Object.getOwnPropertyDescriptor(i.prototype, "parent");
          const h = Object.getOwnPropertyDescriptor(i.prototype, "eulerAngles");
          Object.getOwnPropertyDescriptor(i.prototype, "angle");
          const l = Object.getOwnPropertyDescriptor(i.prototype, "mobility");
          Object.getOwnPropertyDescriptor(i.prototype, "layer"),
            e(
              () => {
                Ra(i.prototype, "_persistNode", o);
              },
              "property",
              "_persistNode"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "name"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "children"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "active"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "activeInHierarchy"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "parent"
            ),
            e(
              () => {
                Na(i.prototype, "_parent", () => null);
              },
              "serializable",
              "_parent"
            ),
            e(
              () => {
                Na(i.prototype, "_children", () => []);
              },
              "serializable",
              "_children"
            ),
            e(
              () => {
                Na(i.prototype, "_active", () => !0);
              },
              "serializable",
              "_active"
            ),
            e(
              () => {
                Na(i.prototype, "_components", () => []);
              },
              "serializable",
              "_components"
            ),
            e(
              () => {
                Na(i.prototype, "_prefab", () => null);
              },
              "serializable",
              "_prefab"
            ),
            e(
              () => {
                Na(i.prototype, "_lpos", () => new s());
              },
              "serializable",
              "_lpos"
            ),
            e(
              () => {
                Na(i.prototype, "_lrot", () => new n());
              },
              "serializable",
              "_lrot"
            ),
            e(
              () => {
                Na(i.prototype, "_lscale", () => new s(1, 1, 1));
              },
              "serializable",
              "_lscale"
            ),
            e(
              () => {
                Na(i.prototype, "_mobility", () => r.Static);
              },
              "serializable",
              "_mobility"
            ),
            e(
              () => {
                Na(i.prototype, "_layer", () => a.Enum.DEFAULT);
              },
              "serializable",
              "_layer"
            ),
            e(
              () => {
                Na(i.prototype, "_euler", () => new s());
              },
              "serializable",
              "_euler"
            ),
            e(
              () => {
                ao(s)(i.prototype, "eulerAngles", h);
              },
              "type",
              "eulerAngles"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "angle"
            ),
            e(
              () => {
                ao(r)(i.prototype, "mobility", l);
              },
              "type",
              "mobility"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "mobility"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "layer"
            ),
            e(
              () => {
                Ca("cc.Node")(i);
              },
              "ccclass",
              null
            );
        })({ Node: Pf, Vec3: Yi, Quat: as, MobilityMode: If, Layers: Rf }),
        hi.Attr.setClassAttr(Yd, "target", "type", "Object"),
        hi.Attr.setClassAttr(Yd, "target", "ctor", Pf);
      const Hf = new Wn(() => new Array(16), 3);
      let Gf = null;
      const Vf = new Ss(),
        jf = [bf.TOUCH_START, bf.TOUCH_MOVE, bf.TOUCH_END, bf.TOUCH_CANCEL],
        Wf = [
          bf.MOUSE_DOWN,
          bf.MOUSE_ENTER,
          bf.MOUSE_MOVE,
          bf.MOUSE_LEAVE,
          bf.MOUSE_UP,
          bf.MOUSE_WHEEL,
        ];
      let Xf;
      !(function (t) {
        (t[(t.ADD_POINTER_EVENT_PROCESSOR = 0)] =
          "ADD_POINTER_EVENT_PROCESSOR"),
          (t[(t.REMOVE_POINTER_EVENT_PROCESSOR = 1)] =
            "REMOVE_POINTER_EVENT_PROCESSOR"),
          (t[(t.MARK_LIST_DIRTY = 2)] = "MARK_LIST_DIRTY");
      })(Xf || (Xf = {}));
      class Yf {
        get isEnabled() {
          return this._isEnabled;
        }
        get node() {
          return this._node;
        }
        constructor(t) {
          (this.claimedTouchIdList = []),
            (this.maskList = null),
            (this.cachedCameraPriority = 0),
            (this.previousMouseIn = !1),
            (this.bubblingTarget = null),
            (this.capturingTarget = null),
            (this.shouldHandleEventMouse = !1),
            (this.shouldHandleEventTouch = !1),
            (this._dispatchingTouch = null),
            (this._isEnabled = !1),
            (this._isMouseLeaveWindow = !1),
            (this._node = t);
        }
        setEnabled(t, e = !1) {
          if (this._isEnabled === t) return;
          t && (this._isMouseLeaveWindow = !1), (this._isEnabled = t);
          const i = this.node.children;
          if (
            (t && this._attachMask(),
            Yf.callbacksInvoker.emit(Xf.MARK_LIST_DIRTY),
            e && i.length > 0)
          )
            for (let e = 0; e < i.length; ++e)
              i[e].eventProcessor.setEnabled(t, !0);
        }
        reattach() {
          this.node.walk((t) => {
            const e = t.eventProcessor,
              i = e._searchComponentsInParent(Yf._maskComp);
            e.maskList = i;
          });
        }
        destroy() {
          if (
            (Gf === this._node && (Gf = null),
            this.capturingTarget && this.capturingTarget.clear(),
            this.bubblingTarget && this.bubblingTarget.clear(),
            Yf.callbacksInvoker.emit(Xf.REMOVE_POINTER_EVENT_PROCESSOR, this),
            this._dispatchingTouch)
          ) {
            const t = new fm([this._dispatchingTouch], !0, um.TOUCH_CANCEL);
            (t.touch = this._dispatchingTouch),
              this.dispatchEvent(t),
              (this._dispatchingTouch = null);
          }
        }
        on(t, e, i, s) {
          let n;
          var r, a;
          return (
            this._tryEmittingAddEvent(t),
            (n = (s = !!s)
              ? null !== (r = this.capturingTarget) && void 0 !== r
                ? r
                : (this.capturingTarget = this._newCallbacksInvoker())
              : null !== (a = this.bubblingTarget) && void 0 !== a
              ? a
              : (this.bubblingTarget = this._newCallbacksInvoker())),
            n.on(t, e, i),
            e
          );
        }
        once(t, e, i, s) {
          let n;
          var r, a;
          return (
            this._tryEmittingAddEvent(t),
            (n = (s = !!s)
              ? null !== (r = this.capturingTarget) && void 0 !== r
                ? r
                : (this.capturingTarget = this._newCallbacksInvoker())
              : null !== (a = this.bubblingTarget) && void 0 !== a
              ? a
              : (this.bubblingTarget = this._newCallbacksInvoker())),
            n.on(t, e, i, !0),
            e
          );
        }
        off(t, e, i, s) {
          var n;
          let r;
          (r = (s = !!s) ? this.capturingTarget : this.bubblingTarget),
            null === (n = r) || void 0 === n || n.off(t, e, i);
        }
        targetOff(t) {
          var e, i;
          null === (e = this.capturingTarget) || void 0 === e || e.removeAll(t),
            null === (i = this.bubblingTarget) ||
              void 0 === i ||
              i.removeAll(t),
            this.shouldHandleEventTouch &&
              !this._hasTouchListeners() &&
              (this.shouldHandleEventTouch = !1),
            this.shouldHandleEventMouse &&
              !this._hasMouseListeners() &&
              (this.shouldHandleEventMouse = !1),
            this._hasPointerListeners() ||
              Yf.callbacksInvoker.emit(Xf.REMOVE_POINTER_EVENT_PROCESSOR, this);
        }
        emit(t, e, i, s, n, r) {
          var a;
          null === (a = this.bubblingTarget) ||
            void 0 === a ||
            a.emit(t, e, i, s, n, r);
        }
        dispatchEvent(t) {
          const e = this.node;
          let i,
            s = 0;
          t.target = e;
          const n = Hf.alloc();
          for (
            n.length = 0,
              this.getCapturingTargets(t.type, n),
              t.eventPhase = 1,
              s = n.length - 1;
            s >= 0;
            --s
          )
            if (
              ((i = n[s]),
              i.eventProcessor.capturingTarget &&
                ((t.currentTarget = i),
                i.eventProcessor.capturingTarget.emit(t.type, t, n),
                t.propagationStopped))
            )
              return void Hf.free(n);
          if (
            ((t.eventPhase = 2),
            (t.currentTarget = e),
            this.capturingTarget && this.capturingTarget.emit(t.type, t),
            !t.propagationImmediateStopped &&
              this.bubblingTarget &&
              this.bubblingTarget.emit(t.type, t),
            !t.propagationStopped && t.bubbles)
          )
            for (
              n.length = 0,
                this.getBubblingTargets(t.type, n),
                t.eventPhase = 3,
                s = 0;
              s < n.length;
              ++s
            )
              if (
                ((i = n[s]),
                i.eventProcessor.bubblingTarget &&
                  ((t.currentTarget = i),
                  i.eventProcessor.bubblingTarget.emit(t.type, t),
                  t.propagationStopped))
              )
                return void Hf.free(n);
          Hf.free(n);
        }
        hasEventListener(t, e, i) {
          let s = !1;
          return (
            this.bubblingTarget &&
              (s = this.bubblingTarget.hasEventListener(t, e, i)),
            !s &&
              this.capturingTarget &&
              (s = this.capturingTarget.hasEventListener(t, e, i)),
            s
          );
        }
        getCapturingTargets(t, e) {
          let i = this._node.parent;
          for (; i; ) {
            var s;
            null !== (s = i.eventProcessor.capturingTarget) &&
              void 0 !== s &&
              s.hasEventListener(t) &&
              e.push(i),
              (i = i.parent);
          }
        }
        getBubblingTargets(t, e) {
          let i = this._node.parent;
          for (; i; ) {
            var s;
            null !== (s = i.eventProcessor.bubblingTarget) &&
              void 0 !== s &&
              s.hasEventListener(t) &&
              e.push(i),
              (i = i.parent);
          }
        }
        onUpdatingSiblingIndex() {
          Yf.callbacksInvoker.emit(Xf.MARK_LIST_DIRTY);
        }
        _searchComponentsInParent(t) {
          const e = this.node;
          if (t) {
            let i = 0,
              s = [];
            for (let n = e; n && Pf.isNode(n); n = n.parent, ++i) {
              const e = n.getComponent(t);
              if (e) {
                const t = { index: i, comp: e };
                s ? s.push(t) : (s = [t]);
              }
            }
            return s.length > 0 ? s : null;
          }
          return null;
        }
        _attachMask() {
          this.maskList = this._searchComponentsInParent(Yf._maskComp);
        }
        _isTouchEvent(t) {
          return -1 !== jf.indexOf(t);
        }
        _isMouseEvent(t) {
          return -1 !== Wf.indexOf(t);
        }
        _hasTouchListeners() {
          for (let t = 0; t < jf.length; ++t) {
            const e = jf[t];
            if (this.hasEventListener(e)) return !0;
          }
          return !1;
        }
        _hasMouseListeners() {
          for (let t = 0; t < Wf.length; ++t) {
            const e = Wf[t];
            if (this.hasEventListener(e)) return !0;
          }
          return !1;
        }
        _hasPointerListeners() {
          return !!this._hasTouchListeners() || this._hasMouseListeners();
        }
        _tryEmittingAddEvent(t) {
          const e = this._isTouchEvent(t),
            i = this._isMouseEvent(t);
          e
            ? (this.shouldHandleEventTouch = !0)
            : i && (this.shouldHandleEventMouse = !0),
            (!e && !i) ||
              this._hasPointerListeners() ||
              Yf.callbacksInvoker.emit(Xf.ADD_POINTER_EVENT_PROCESSOR, this);
        }
        _newCallbacksInvoker() {
          const t = new ar();
          return (
            t._registerOffCallback(() => {
              this.shouldHandleEventTouch &&
                !this._hasTouchListeners() &&
                (this.shouldHandleEventTouch = !1),
                this.shouldHandleEventMouse &&
                  !this._hasMouseListeners() &&
                  (this.shouldHandleEventMouse = !1),
                this._hasPointerListeners() ||
                  Yf.callbacksInvoker.emit(
                    Xf.REMOVE_POINTER_EVENT_PROCESSOR,
                    this
                  );
            }),
            t
          );
        }
        _handleEventMouse(t) {
          switch (t.type) {
            case um.MOUSE_DOWN:
              return this._handleMouseDown(t);
            case um.MOUSE_MOVE:
              return this._handleMouseMove(t);
            case um.MOUSE_UP:
              return this._handleMouseUp(t);
            case um.MOUSE_WHEEL:
              return this._handleMouseWheel(t);
            case um.MOUSE_LEAVE:
              return this._handleMouseLeave(t);
            case um.MOUSE_ENTER:
              return this._handleMouseEnter(t);
            default:
              return !1;
          }
        }
        _handleMouseDown(t) {
          const e = this._node;
          return !(
            !e ||
            !e._uiProps.uiTransformComp ||
            (t.getLocation(Vf),
            !e._uiProps.uiTransformComp.hitTest(Vf, t.windowId) ||
              ((t.type = bf.MOUSE_DOWN),
              (t.bubbles = !0),
              e.dispatchEvent(t),
              (t.propagationStopped = !0),
              0))
          );
        }
        _handleMouseMove(t) {
          const e = this._node;
          return (
            !(!e || !e._uiProps.uiTransformComp || this._isMouseLeaveWindow) &&
            (t.getLocation(Vf),
            e._uiProps.uiTransformComp.hitTest(Vf, t.windowId)
              ? (this.previousMouseIn ||
                  (Gf &&
                    Gf !== e &&
                    ((t.type = bf.MOUSE_LEAVE),
                    Gf.dispatchEvent(t),
                    (Gf.eventProcessor.previousMouseIn = !1)),
                  (Gf = e),
                  (t.type = bf.MOUSE_ENTER),
                  e.dispatchEvent(t),
                  (this.previousMouseIn = !0)),
                (t.type = bf.MOUSE_MOVE),
                (t.bubbles = !0),
                e.dispatchEvent(t),
                (t.propagationStopped = !0),
                !0)
              : (this.previousMouseIn &&
                  ((t.type = bf.MOUSE_LEAVE),
                  e.dispatchEvent(t),
                  (this.previousMouseIn = !1),
                  (Gf = null)),
                !1))
          );
        }
        _handleMouseUp(t) {
          const e = this._node;
          return !(
            !e ||
            !e._uiProps.uiTransformComp ||
            (t.getLocation(Vf),
            !e._uiProps.uiTransformComp.hitTest(Vf, t.windowId) ||
              ((t.type = bf.MOUSE_UP),
              (t.bubbles = !0),
              e.dispatchEvent(t),
              (t.propagationStopped = !0),
              0))
          );
        }
        _handleMouseWheel(t) {
          const e = this._node;
          return !(
            !e ||
            !e._uiProps.uiTransformComp ||
            (t.getLocation(Vf),
            !e._uiProps.uiTransformComp.hitTest(Vf, t.windowId) ||
              ((t.type = bf.MOUSE_WHEEL),
              (t.bubbles = !0),
              e.dispatchEvent(t),
              (t.propagationStopped = !0),
              0))
          );
        }
        _handleMouseLeave(t) {
          return (
            (this._isMouseLeaveWindow = !0),
            this.previousMouseIn &&
              ((t.type = bf.MOUSE_LEAVE),
              this._node.dispatchEvent(t),
              (this.previousMouseIn = !1),
              (Gf = null)),
            !1
          );
        }
        _handleMouseEnter(t) {
          return (this._isMouseLeaveWindow = !1), !1;
        }
        _handleEventTouch(t) {
          try {
            switch (t.type) {
              case um.TOUCH_START:
                return this._handleTouchStart(t);
              case um.TOUCH_MOVE:
                return this._handleTouchMove(t);
              case um.TOUCH_END:
                return this._handleTouchEnd(t);
              case um.TOUCH_CANCEL:
                return this._handleTouchCancel(t);
              default:
                return !1;
            }
          } catch (t) {
            throw ((this.claimedTouchIdList.length = 0), t);
          }
        }
        _handleTouchStart(t) {
          const e = this.node;
          return !(
            !e ||
            !e._uiProps.uiTransformComp ||
            (t.getLocation(Vf),
            !e._uiProps.uiTransformComp.hitTest(Vf, t.windowId) ||
              ((t.type = bf.TOUCH_START),
              (t.bubbles = !0),
              (this._dispatchingTouch = t.touch),
              e.dispatchEvent(t),
              0))
          );
        }
        _handleTouchMove(t) {
          const e = this.node;
          return !(
            !e ||
            !e._uiProps.uiTransformComp ||
            ((t.type = bf.TOUCH_MOVE),
            (t.bubbles = !0),
            (this._dispatchingTouch = t.touch),
            e.dispatchEvent(t),
            0)
          );
        }
        _handleTouchEnd(t) {
          const e = this.node;
          e &&
            e._uiProps.uiTransformComp &&
            (t.getLocation(Vf),
            e._uiProps.uiTransformComp.hitTest(Vf, t.windowId)
              ? (t.type = bf.TOUCH_END)
              : (t.type = bf.TOUCH_CANCEL),
            (t.bubbles = !0),
            e.dispatchEvent(t),
            (this._dispatchingTouch = null));
        }
        _handleTouchCancel(t) {
          const e = this.node;
          e &&
            e._uiProps.uiTransformComp &&
            ((t.type = bf.TOUCH_CANCEL),
            (t.bubbles = !0),
            e.dispatchEvent(t),
            (this._dispatchingTouch = null));
        }
      }
      (Yf._maskComp = null),
        (Yf.callbacksInvoker = new ar()),
        (a.NodeEventProcessor = Yf);
      const Kf = jsb.TextureCube.prototype;
      var qf, $f;
      !(function (t) {
        (t[(t.right = 0)] = "right"),
          (t[(t.left = 1)] = "left"),
          (t[(t.top = 2)] = "top"),
          (t[(t.bottom = 3)] = "bottom"),
          (t[(t.front = 4)] = "front"),
          (t[(t.back = 5)] = "back");
      })(qf || (qf = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.AUTO = 1)] = "AUTO"),
            (t[(t.BAKED_CONVOLUTION_MAP = 2)] = "BAKED_CONVOLUTION_MAP");
        })($f || ($f = {})),
        (Kf.createNode = null);
      const Zf = t("TextureCube", jsb.TextureCube);
      (Zf.Filter = Id),
        (Zf.PixelFormat = Cd),
        (Zf.WrapMode = Od),
        (Kf._ctor = function () {
          jsb.SimpleTexture.prototype._ctor.apply(this, arguments),
            (this._mipmaps = null),
            (this._mipmapAtlas = null);
        }),
        Object.defineProperty(Kf, "mipmaps", {
          get() {
            return this._mipmaps;
          },
          set(t) {
            (this._mipmaps = t), this.setMipmaps(t);
          },
        }),
        Object.defineProperty(Kf, "image", {
          get() {
            return 0 === this._mipmaps.length ? null : this._mipmaps[0];
          },
          set(t) {
            this.mipmaps = t ? [t] : [];
          },
        });
      const Qf = Kf.onLoaded;
      let Jf;
      (Kf.onLoaded = function () {
        this._mipmapMode === $f.BAKED_CONVOLUTION_MAP
          ? this.setMipmapAtlasForJS(this._mipmapAtlas)
          : this.setMipmapsForJS(this._mipmaps),
          Qf.apply(this);
      }),
        (Kf._serialize = function () {
          return null;
        }),
        (Kf._deserialize = function (t, e) {
          const i = t;
          if (
            (jsb.TextureBase.prototype._deserialize.call(this, i.base, e),
            (this.isRGBE = i.rgbe),
            null != i.mipmapMode && (this._mipmapMode = i.mipmapMode),
            this._mipmapMode === $f.BAKED_CONVOLUTION_MAP)
          ) {
            const t = i.mipmapAtlas,
              s = i.mipmapLayout;
            if (
              ((this._mipmapAtlas = { atlas: {}, layout: s }),
              (this._mipmapAtlas.atlas = {
                front: new jsb.ImageAsset(),
                back: new jsb.ImageAsset(),
                left: new jsb.ImageAsset(),
                right: new jsb.ImageAsset(),
                top: new jsb.ImageAsset(),
                bottom: new jsb.ImageAsset(),
              }),
              t)
            ) {
              const i = qt(jsb.ImageAsset);
              e.result.push(this._mipmapAtlas.atlas, "front", t.front, i),
                e.result.push(this._mipmapAtlas.atlas, "back", t.back, i),
                e.result.push(this._mipmapAtlas.atlas, "left", t.left, i),
                e.result.push(this._mipmapAtlas.atlas, "right", t.right, i),
                e.result.push(this._mipmapAtlas.atlas, "top", t.top, i),
                e.result.push(this._mipmapAtlas.atlas, "bottom", t.bottom, i);
            }
          } else {
            this._mipmaps = new Array(i.mipmaps.length);
            for (let t = 0; t < i.mipmaps.length; ++t) {
              this._mipmaps[t] = {
                front: new jsb.ImageAsset(),
                back: new jsb.ImageAsset(),
                left: new jsb.ImageAsset(),
                right: new jsb.ImageAsset(),
                top: new jsb.ImageAsset(),
                bottom: new jsb.ImageAsset(),
              };
              const s = i.mipmaps[t],
                n = qt(jsb.ImageAsset);
              e.result.push(this._mipmaps[t], "front", s.front, n),
                e.result.push(this._mipmaps[t], "back", s.back, n),
                e.result.push(this._mipmaps[t], "left", s.left, n),
                e.result.push(this._mipmaps[t], "right", s.right, n),
                e.result.push(this._mipmaps[t], "top", s.top, n),
                e.result.push(this._mipmaps[t], "bottom", s.bottom, n);
            }
          }
        }),
        (a.TextureCube = jsb.TextureCube),
        (function (t, e = vd) {
          const { TextureCube: i, MipmapMode: s } = { ...t };
          e(
            () => {
              Na(i.prototype, "isRGBE", () => !1);
            },
            "serializable",
            "isRGBE"
          ),
            e(
              () => {
                Na(i.prototype, "_mipmapAtlas", () => null);
              },
              "serializable",
              "_mipmapAtlas"
            ),
            e(
              () => {
                Na(i.prototype, "_mipmapMode", () => s.NONE);
              },
              "serializable",
              "_mipmapMode"
            ),
            e(
              () => {
                Na(i.prototype, "_mipmaps", () => []);
              },
              "serializable",
              "_mipmaps"
            ),
            e(
              () => {
                Ca("cc.TextureCube")(i);
              },
              "ccclass",
              null
            );
        })({ TextureCube: Zf, MipmapMode: $f }),
        (function (t) {
          (t[(t.DEFAULT = 0)] = "DEFAULT"),
            (t[(t.SKINNING = 1)] = "SKINNING"),
            (t[(t.BAKED_SKINNING = 2)] = "BAKED_SKINNING"),
            (t[(t.BATCH_2D = 3)] = "BATCH_2D"),
            (t[(t.PARTICLE_BATCH = 4)] = "PARTICLE_BATCH"),
            (t[(t.LINE = 5)] = "LINE");
        })(Jf || (Jf = {}));
      const tg = jsb.Model,
        eg = tg.prototype;
      eg._ctor = function () {
        this._device = I_.gfxDevice;
      };
      const ig = eg.createBoundingShape;
      eg.createBoundingShape = function (t, e) {
        t && e && ig.call(this, t, e);
      };
      const sg = jsb.SubModel;
      let ng, rg, ag, og, hg, lg, cg, ug;
      !(function (t) {
        (t[(t.VERTICAL = 0)] = "VERTICAL"),
          (t[(t.HORIZONTAL = 1)] = "HORIZONTAL");
      })(ng || (ng = {})),
        (function (t) {
          (t[(t.ORTHO = 0)] = "ORTHO"),
            (t[(t.PERSPECTIVE = 1)] = "PERSPECTIVE");
        })(rg || (rg = {})),
        (function (t) {
          (t[(t.F1_8 = 0)] = "F1_8"),
            (t[(t.F2_0 = 1)] = "F2_0"),
            (t[(t.F2_2 = 2)] = "F2_2"),
            (t[(t.F2_5 = 3)] = "F2_5"),
            (t[(t.F2_8 = 4)] = "F2_8"),
            (t[(t.F3_2 = 5)] = "F3_2"),
            (t[(t.F3_5 = 6)] = "F3_5"),
            (t[(t.F4_0 = 7)] = "F4_0"),
            (t[(t.F4_5 = 8)] = "F4_5"),
            (t[(t.F5_0 = 9)] = "F5_0"),
            (t[(t.F5_6 = 10)] = "F5_6"),
            (t[(t.F6_3 = 11)] = "F6_3"),
            (t[(t.F7_1 = 12)] = "F7_1"),
            (t[(t.F8_0 = 13)] = "F8_0"),
            (t[(t.F9_0 = 14)] = "F9_0"),
            (t[(t.F10_0 = 15)] = "F10_0"),
            (t[(t.F11_0 = 16)] = "F11_0"),
            (t[(t.F13_0 = 17)] = "F13_0"),
            (t[(t.F14_0 = 18)] = "F14_0"),
            (t[(t.F16_0 = 19)] = "F16_0"),
            (t[(t.F18_0 = 20)] = "F18_0"),
            (t[(t.F20_0 = 21)] = "F20_0"),
            (t[(t.F22_0 = 22)] = "F22_0");
        })(ag || (ag = {})),
        (function (t) {
          (t[(t.ISO100 = 0)] = "ISO100"),
            (t[(t.ISO200 = 1)] = "ISO200"),
            (t[(t.ISO400 = 2)] = "ISO400"),
            (t[(t.ISO800 = 3)] = "ISO800");
        })(og || (og = {})),
        (function (t) {
          (t[(t.D1 = 0)] = "D1"),
            (t[(t.D2 = 1)] = "D2"),
            (t[(t.D4 = 2)] = "D4"),
            (t[(t.D8 = 3)] = "D8"),
            (t[(t.D15 = 4)] = "D15"),
            (t[(t.D30 = 5)] = "D30"),
            (t[(t.D60 = 6)] = "D60"),
            (t[(t.D125 = 7)] = "D125"),
            (t[(t.D250 = 8)] = "D250"),
            (t[(t.D500 = 9)] = "D500"),
            (t[(t.D1000 = 10)] = "D1000"),
            (t[(t.D2000 = 11)] = "D2000"),
            (t[(t.D4000 = 12)] = "D4000");
        })(hg || (hg = {})),
        (function (t) {
          (t[(t.DEFAULT = -1)] = "DEFAULT"),
            (t[(t.LEFT_EYE = 0)] = "LEFT_EYE"),
            (t[(t.RIGHT_EYE = 1)] = "RIGHT_EYE"),
            (t[(t.MAIN = 2)] = "MAIN");
        })(lg || (lg = {})),
        (function (t) {
          (t[(t.NO_TRACKING = 0)] = "NO_TRACKING"),
            (t[(t.POSITION_AND_ROTATION = 1)] = "POSITION_AND_ROTATION"),
            (t[(t.POSITION = 2)] = "POSITION"),
            (t[(t.ROTATION = 3)] = "ROTATION");
        })(cg || (cg = {})),
        (function (t) {
          (t[(t.EDITOR = 0)] = "EDITOR"),
            (t[(t.GAME_VIEW = 1)] = "GAME_VIEW"),
            (t[(t.SCENE_VIEW = 2)] = "SCENE_VIEW"),
            (t[(t.PREVIEW = 3)] = "PREVIEW"),
            (t[(t.GAME = 100)] = "GAME");
        })(ug || (ug = {}));
      const _g = Qc.STENCIL << 1,
        dg = jsb.Camera,
        pg = jsb.Camera.prototype;
      Object.defineProperty(dg, "standardExposureValue", {
        configurable: !0,
        enumerable: !0,
        get: () => dg.getStandardExposureValue(),
      }),
        Object.defineProperty(dg, "standardLightMeterScale", {
          configurable: !0,
          enumerable: !0,
          get: () => dg.getStandardLightMeterScale(),
        }),
        Object.defineProperty(pg, "matView", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getMatView(), xf(this._matView), this._matView;
          },
        }),
        Object.defineProperty(pg, "matProj", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getMatProj(), xf(this._matProj), this._matProj;
          },
        }),
        Object.defineProperty(pg, "matProjInv", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getMatProjInv(), xf(this._matProjInv), this._matProjInv;
          },
        }),
        Object.defineProperty(pg, "matViewProj", {
          configurable: !0,
          enumerable: !0,
          get() {
            return (
              this.getMatViewProj(), xf(this._matViewProj), this._matViewProj
            );
          },
        }),
        Object.defineProperty(pg, "matViewProjInv", {
          configurable: !0,
          enumerable: !0,
          get() {
            return (
              this.getMatViewProjInv(),
              xf(this._matViewProjInv),
              this._matViewProjInv
            );
          },
        });
      const mg = pg.initialize;
      pg.initialize = function () {
        mg.apply(this, arguments),
          (this._matView = new ms()),
          (this._matProj = new ms()),
          (this._matProjInv = new ms()),
          (this._matViewProj = new ms()),
          (this._matViewProjInv = new ms());
      };
      const fg = pg.screenPointToRay,
        gg = pg.screenToWorld,
        yg = pg.worldToScreen,
        Tg = pg.worldMatrixToScreen;
      let Sg, Eg;
      (pg.screenPointToRay = function (t, e, i) {
        return (
          (Df[0] = e),
          (Df[1] = i),
          fg.call(this),
          (t.o.x = Df[0]),
          (t.o.y = Df[1]),
          (t.o.z = Df[2]),
          (t.d.x = Df[3]),
          (t.d.y = Df[4]),
          (t.d.z = Df[5]),
          t
        );
      }),
        (pg.screenToWorld = function (t, e) {
          return (
            (Df[0] = e.x),
            (Df[1] = e.y),
            (Df[2] = e.z),
            gg.call(this),
            Yi.set(t, Df[0], Df[1], Df[2]),
            t
          );
        }),
        (pg.worldToScreen = function (t, e) {
          return (
            (Df[0] = e.x),
            (Df[1] = e.y),
            (Df[2] = e.z),
            yg.call(this),
            Yi.set(t, Df[0], Df[1], Df[2]),
            t
          );
        }),
        (pg.worldMatrixToScreen = function (t, e, i, s) {
          return (
            (Df[0] = e.m00),
            (Df[1] = e.m01),
            (Df[2] = e.m02),
            (Df[3] = e.m03),
            (Df[4] = e.m04),
            (Df[5] = e.m05),
            (Df[6] = e.m06),
            (Df[7] = e.m07),
            (Df[8] = e.m08),
            (Df[9] = e.m09),
            (Df[10] = e.m10),
            (Df[11] = e.m11),
            (Df[12] = e.m12),
            (Df[13] = e.m13),
            (Df[14] = e.m14),
            (Df[15] = e.m15),
            (Df[16] = i),
            (Df[17] = s),
            Tg.call(this),
            xf(t),
            t
          );
        }),
        (function (t) {
          (t[(t.SKYBOX = _g | Qc.DEPTH_STENCIL)] = "SKYBOX"),
            (t[(t.SOLID_COLOR = Qc.ALL)] = "SOLID_COLOR");
        })(Sg || (Sg = {})),
        (function (t) {
          (t[(t.CUBE = 0)] = "CUBE"), (t[(t.PLANAR = 1)] = "PLANAR");
        })(Eg || (Eg = {}));
      const vg = jsb.ReflectionProbe;
      jsb.ReflectionProbe.prototype._ctor = function (t) {
        this._probeId = t;
      };
      const bg = jsb.LODData,
        Ag = jsb.LODGroup,
        Cg = jsb.Ambient;
      let Og;
      (a.Ambient = Cg),
        (Cg.SUN_ILLUM = 65e3),
        (Cg.SKY_ILLUM = 2e4),
        (function (t) {
          (t[(t.DIRECTIONAL = 0)] = "DIRECTIONAL"),
            (t[(t.SPHERE = 1)] = "SPHERE"),
            (t[(t.SPOT = 2)] = "SPOT"),
            (t[(t.POINT = 3)] = "POINT"),
            (t[(t.RANGED_DIRECTIONAL = 4)] = "RANGED_DIRECTIONAL"),
            (t[(t.UNKNOWN = 5)] = "UNKNOWN");
        })(Og || (Og = {}));
      const Ig = (t) => 4 * Math.PI * Math.PI * t * t,
        wg = jsb.Light;
      a.Light = jsb.Light;
      const Rg = jsb.DirectionalLight;
      a.DirectionalLight = jsb.DirectionalLight;
      const Dg = jsb.SpotLight;
      a.SpotLight = jsb.SpotLight;
      const xg = jsb.SphereLight;
      a.SphereLight = jsb.SphereLight;
      const Mg = jsb.PointLight;
      a.PointLight = jsb.PointLight;
      const Pg = jsb.RangedDirectionalLight;
      a.RangedDirectionalLight = jsb.RangedDirectionalLight;
      const Ng = ce({ LINEAR: 0, EXP: 1, EXP_SQUARED: 2, LAYERED: 3 }),
        Lg = Ng.LAYERED + 1,
        Bg = jsb.FogInfo,
        Fg = jsb.Fog;
      a.Fog = Fg;
      const Ug = ce({
          Low_256x256: 256,
          Medium_512x512: 512,
          High_1024x1024: 1024,
          Ultra_2048x2048: 2048,
        }),
        kg = ce({ Planar: 0, ShadowMap: 1 }),
        zg = ce({ HARD: 0, SOFT: 1, SOFT_2X: 2, SOFT_4X: 3 }),
        Hg = ce({ LEVEL_1: 1, LEVEL_2: 2, LEVEL_3: 3, LEVEL_4: 4 }),
        Gg = ce({ NONE: 1, RemoveDuplicates: 2, DisableRotationFix: 3 }),
        Vg = ce({
          HEMISPHERE_DIFFUSE: 0,
          AUTOGEN_HEMISPHERE_DIFFUSE_WITH_REFLECTION: 1,
          DIFFUSEMAP_WITH_REFLECTION: 2,
        }),
        jg = ce({ DEFAULT: 0, LINEAR: 1 }),
        Wg = jsb.ShadowsInfo,
        Xg = jsb.Shadows;
      (a.Shadows = Xg),
        Object.defineProperty(Xg, "MAX_FAR", {
          configurable: !0,
          enumerable: !0,
          get: () => 2e3,
        });
      const Yg = 2 * Math.sqrt(3);
      Object.defineProperty(Xg, "COEFFICIENT_OF_EXPANSION", {
        configurable: !0,
        enumerable: !0,
        get: () => Yg,
      });
      const Kg = jsb.Skybox;
      a.Skybox = Kg;
      const qg = jsb.PostSettings;
      a.PostSettings = qg;
      var $g = Object.freeze({
        __proto__: null,
        get ModelType() {
          return Jf;
        },
        Model: tg,
        SubModel: sg,
        get CameraFOVAxis() {
          return ng;
        },
        get CameraProjection() {
          return rg;
        },
        get CameraAperture() {
          return ag;
        },
        get CameraISO() {
          return og;
        },
        get CameraShutter() {
          return hg;
        },
        get CameraType() {
          return lg;
        },
        get TrackingType() {
          return cg;
        },
        get CameraUsage() {
          return ug;
        },
        SKYBOX_FLAG: _g,
        Camera: dg,
        get ProbeClearFlag() {
          return Sg;
        },
        get ProbeType() {
          return Eg;
        },
        ReflectionProbe: vg,
        LODData: bg,
        LODGroup: Ag,
        Ambient: Cg,
        ColorTemperatureToRGB: function (t, e) {
          e < 1e3 ? (e = 1e3) : e > 15e3 && (e = 15e3);
          const i = e * e,
            s =
              (0.860117757 + 0.000154118254 * e + 1.28641212e-7 * i) /
              (1 + 0.000842420235 * e + 7.08145163e-7 * i),
            n =
              (0.317398726 + 422806245e-13 * e + 4.20481691e-8 * i) /
              (1 - 289741816e-13 * e + 1.61456053e-7 * i),
            r = 2 * s - 8 * n + 4,
            a = (3 * s) / r,
            o = (2 * n) / r,
            h = (1 / o) * a,
            l = (1 / o) * (1 - a - o);
          (t.x = 3.2404542 * h - 1.5371385 + -0.4985314 * l),
            (t.y = -0.969266 * h + 1.8760108 + 0.041556 * l),
            (t.z = 0.0556434 * h - 0.2040259 + 1.0572252 * l);
        },
        get LightType() {
          return Og;
        },
        nt2lm: Ig,
        Light: wg,
        DirectionalLight: Rg,
        SpotLight: Dg,
        SphereLight: xg,
        PointLight: Mg,
        RangedDirectionalLight: Pg,
        FogType: Ng,
        FOG_TYPE_NONE: Lg,
        FogInfo: Bg,
        Fog: Fg,
        ShadowSize: Ug,
        ShadowType: kg,
        PCFType: zg,
        CSMLevel: Hg,
        CSMOptimizationMode: Gg,
        EnvironmentLightingType: Vg,
        ToneMappingType: jg,
        ShadowsInfo: Wg,
        Shadows: Xg,
        Skybox: Kg,
        PostSettings: qg,
      });
      const Zg = t("EffectAsset", jsb.EffectAsset);
      (a.EffectAsset = Zg),
        (Zg.prototype._ctor = function () {
          jsb.Asset.prototype._ctor.apply(this, arguments),
            (this.hideInEditor = !1);
        }),
        (function (t, e = vd) {
          const { EffectAsset: i } = { ...t };
          e(
            () => {
              Wa(i.prototype);
            },
            "editable",
            "techniques"
          ),
            e(
              () => {
                Na(i.prototype, "techniques", () => []);
              },
              "serializable",
              "techniques"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "shaders"
            ),
            e(
              () => {
                Na(i.prototype, "shaders", () => []);
              },
              "serializable",
              "shaders"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "combinations"
            ),
            e(
              () => {
                Na(i.prototype, "combinations", () => []);
              },
              "serializable",
              "combinations"
            ),
            e(
              () => {
                Ba(i.prototype, "hideInEditor", () => !1);
              },
              "editorOnly",
              "hideInEditor"
            ),
            e(
              () => {
                Na(i.prototype, "hideInEditor", () => !1);
              },
              "serializable",
              "hideInEditor"
            ),
            e(
              () => {
                Ca("cc.EffectAsset")(i);
              },
              "ccclass",
              null
            );
        })({ EffectAsset: Zg });
      const Qg = jsb.Material.prototype;
      function Jg(t, e, i, s, n) {
        null != n ? t.call(e, i, s, n) : t.call(e, i, s);
      }
      var ty;
      !(function (t) {
        (t[(t.VEC2 = 0)] = "VEC2"),
          (t[(t.VEC3 = 1)] = "VEC3"),
          (t[(t.VEC4 = 2)] = "VEC4"),
          (t[(t.QUATERNION = 3)] = "QUATERNION"),
          (t[(t.MAT3 = 4)] = "MAT3"),
          (t[(t.MAT4 = 5)] = "MAT4"),
          (t[(t.SIZE = 6)] = "SIZE"),
          (t[(t.RECT = 7)] = "RECT"),
          (t[(t.COLOR = 8)] = "COLOR");
      })(ty || (ty = {})),
        (Qg.setProperty = function (t, e, i) {
          if (Array.isArray(e)) {
            const s = e[0];
            "number" == typeof s
              ? Number.isInteger(s)
                ? Jg(this.setPropertyInt32Array, this, t, e, i)
                : Jg(this.setPropertyFloat32Array, this, t, e, i)
              : s instanceof Ss
              ? Jg(this.setPropertyVec2Array, this, t, e, i)
              : s instanceof Yi
              ? Jg(this.setPropertyVec3Array, this, t, e, i)
              : s instanceof Wi
              ? Jg(this.setPropertyVec4Array, this, t, e, i)
              : s instanceof Qi
              ? Jg(this.setPropertyColorArray, this, t, e, i)
              : s instanceof es
              ? Jg(this.setPropertyMat3Array, this, t, e, i)
              : s instanceof ms
              ? Jg(this.setPropertyMat4Array, this, t, e, i)
              : s instanceof as
              ? Jg(this.setPropertyQuatArray, this, t, e, i)
              : s instanceof Xp
              ? Jg(this.setPropertyTextureBaseArray, this, t, e, i)
              : s instanceof G_
              ? Jg(this.setPropertyGFXTextureArray, this, t, e, i)
              : a.error(`Material.setProperty Unknown type: ${e}`);
          } else
            "number" == typeof e
              ? Number.isInteger(e)
                ? Jg(this.setPropertyInt32, this, t, e, i)
                : Jg(this.setPropertyFloat32, this, t, e, i)
              : e instanceof Ss
              ? Jg(this.setPropertyVec2, this, t, e, i)
              : e instanceof Yi
              ? Jg(this.setPropertyVec3, this, t, e, i)
              : e instanceof Wi
              ? Jg(this.setPropertyVec4, this, t, e, i)
              : e instanceof Qi
              ? Jg(this.setPropertyColor, this, t, e, i)
              : e instanceof es
              ? Jg(this.setPropertyMat3, this, t, e, i)
              : e instanceof ms
              ? Jg(this.setPropertyMat4, this, t, e, i)
              : e instanceof as
              ? Jg(this.setPropertyQuat, this, t, e, i)
              : e instanceof Xp
              ? Jg(this.setPropertyTextureBase, this, t, e, i)
              : e instanceof G_
              ? Jg(this.setPropertyGFXTexture, this, t, e, i)
              : null === e
              ? i
                ? this.setPropertyNull(t, i)
                : this.setPropertyNull(t)
              : a.error(`Material.setProperty Unknown type: ${e}`);
        }),
        (Qg.getProperty = function (t, e) {
          let i, s;
          if (
            ((i =
              void 0 !== e ? this._getProperty(t, e) : this._getProperty(t)),
            Array.isArray(i))
          ) {
            const t = i[0],
              e = [];
            if (t instanceof jsb.Vec2 || t.type === ty.VEC2)
              for (let t = 0, s = i.length; t < s; ++t) {
                const s = i[t];
                e.push(new Ss(s.x, s.y));
              }
            else if (t.type === ty.VEC3)
              for (let t = 0, s = i.length; t < s; ++t) {
                const s = i[t];
                e.push(new Yi(s.x, s.y, s.z));
              }
            else if (t.type === ty.VEC4)
              for (let t = 0, s = i.length; t < s; ++t) {
                const s = i[t];
                e.push(new Wi(s.x, s.y, s.z, s.w));
              }
            else if (t instanceof jsb.Color)
              for (let t = 0, s = i.length; t < s; ++t) {
                const s = i[t];
                e.push(new Qi(s.r, s.g, s.b, s.a));
              }
            else if (t.type === ty.MAT3)
              for (let t = 0, s = i.length; t < s; ++t) {
                const s = i[t];
                e.push(
                  new es(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8])
                );
              }
            else if (t.type === ty.MAT4)
              for (let t = 0, s = i.length; t < s; ++t) {
                const s = i[t];
                e.push(
                  new ms(
                    s[0],
                    s[1],
                    s[2],
                    s[3],
                    s[4],
                    s[5],
                    s[6],
                    s[7],
                    s[8],
                    s[9],
                    s[10],
                    s[11],
                    s[12],
                    s[13],
                    s[14],
                    s[15]
                  )
                );
              }
            else if (t.type === ty.QUATERNION)
              for (let t = 0, s = i.length; t < s; ++t) {
                const s = i[t];
                e.push(new as(s.x, s.y, s.z, s.w));
              }
            return e || i;
          }
          if (null == i) return null;
          const n = i;
          return (
            i instanceof jsb.Vec2 || i.type === ty.VEC2
              ? (s = new Yi(n.x, n.y))
              : i.type === ty.VEC3
              ? (s = new Yi(n.x, n.y, n.z))
              : i.type === ty.VEC4
              ? (s = new Wi(n.x, n.y, n.z, n.w))
              : i instanceof jsb.Color
              ? (s = new Qi(n.r, n.g, n.b, n.a))
              : i.type === ty.MAT3
              ? (s = new es(
                  n[0],
                  n[1],
                  n[2],
                  n[3],
                  n[4],
                  n[5],
                  n[6],
                  n[7],
                  n[8]
                ))
              : i.type === ty.MAT4
              ? (s = new ms(
                  n[0],
                  n[1],
                  n[2],
                  n[3],
                  n[4],
                  n[5],
                  n[6],
                  n[7],
                  n[8],
                  n[9],
                  n[10],
                  n[11],
                  n[12],
                  n[13],
                  n[14],
                  n[15]
                ))
              : i.type === ty.QUATERNION && (s = new as(n.x, n.y, n.z, n.w)),
            s || i
          );
        });
      const ey = t("Material", jsb.Material);
      a.Material = ey;
      const iy = ey.prototype;
      iy._ctor = function () {
        jsb.Asset.prototype._ctor.apply(this, arguments),
          (this._props = []),
          (this._passes = []),
          this._registerPassesUpdatedListener(),
          (this._isCtorCalled = !0);
      };
      const sy = iy.onLoaded;
      (iy.onLoaded = function () {
        (this._propsInternal = this._props), sy.call(this);
      }),
        (iy._onPassesUpdated = function () {
          this._passes = this.getPasses();
        }),
        Object.defineProperty(iy, "passes", {
          enumerable: !0,
          configurable: !0,
          get() {
            return (
              this._isCtorCalled ||
                (this._ctor(), (this._passes = this.getPasses())),
              this._passes
            );
          },
        }),
        (function (t, e = vd) {
          const { Material: i, EffectAsset: s } = { ...t };
          e(
            () => {
              ao(s)(i.prototype, "_effectAsset", () => null);
            },
            "type",
            "_effectAsset"
          ),
            e(
              () => {
                Na(i.prototype, "_techIdx", () => 0);
              },
              "serializable",
              "_techIdx"
            ),
            e(
              () => {
                Na(i.prototype, "_defines", () => []);
              },
              "serializable",
              "_defines"
            ),
            e(
              () => {
                Na(i.prototype, "_states", () => []);
              },
              "serializable",
              "_states"
            ),
            e(
              () => {
                Na(i.prototype, "_props", () => []);
              },
              "serializable",
              "_props"
            ),
            e(
              () => {
                Ca("cc.Material")(i);
              },
              "ccclass",
              null
            );
        })({ Material: ey, EffectAsset: Zg });
      const ny = t("DEFAULT_WORLD_MIN_POS", new Yi(-1024, -1024, -1024)),
        ry = t("DEFAULT_WORLD_MAX_POS", new Yi(1024, 1024, 1024)),
        ay = t("DEFAULT_OCTREE_DEPTH", 8),
        oy = t(
          "FogType",
          ce({ LINEAR: 0, EXP: 1, EXP_SQUARED: 2, LAYERED: 3 })
        ),
        hy = t(
          "ShadowSize",
          ce({
            Low_256x256: 256,
            Medium_512x512: 512,
            High_1024x1024: 1024,
            Ultra_2048x2048: 2048,
          })
        ),
        ly = t("ShadowType", ce({ Planar: 0, ShadowMap: 1 })),
        cy = t("AmbientInfo", jsb.AmbientInfo);
      a.AmbientInfo = cy;
      const uy = t("SkyboxInfo", jsb.SkyboxInfo);
      a.SkyboxInfo = uy;
      const _y = t("FogInfo", jsb.FogInfo);
      (a.FogInfo = _y), (_y.FogType = oy);
      const dy = t("ShadowsInfo", jsb.ShadowsInfo);
      a.ShadowsInfo = dy;
      const py = t("OctreeInfo", jsb.OctreeInfo);
      a.OctreeInfo = py;
      const my = t("LightProbeInfo", jsb.LightProbeInfo),
        fy = t("SceneGlobals", jsb.SceneGlobals);
      a.SceneGlobals = fy;
      const gy = t("SkinInfo", jsb.SkinInfo);
      a.SkinInfo = gy;
      const yy = t("PostSettingsInfo", jsb.PostSettingsInfo);
      var Ty;
      (a.PostSettingsInfo = yy),
        (function () {
          const t = fy.prototype;
          (t._ctor = function () {
            (this._ambientRef = this.getAmbientInfo()),
              (this._shadowsRef = this.getShadowsInfo()),
              (this._skyboxRef = this.getSkyboxInfo()),
              (this._fogRef = this.getFogInfo()),
              (this._octreeRef = this.getOctreeInfo()),
              (this._lightProbeRef = this.getLightProbeInfo()),
              (this._skinRef = this.getSkinInfo()),
              (this._postSettingsRef = this.getPostSettingsInfo());
          }),
            Object.defineProperty(t, "ambient", {
              enumerable: !0,
              configurable: !0,
              get() {
                return this._ambientRef;
              },
              set(t) {
                (this._ambientRef = t), this.setAmbientInfo(t);
              },
            }),
            Object.defineProperty(t, "shadows", {
              enumerable: !0,
              configurable: !0,
              get() {
                return this._shadowsRef;
              },
              set(t) {
                (this._shadowsRef = t), this.setShadowsInfo(t);
              },
            }),
            Object.defineProperty(t, "_skybox", {
              enumerable: !0,
              configurable: !0,
              get() {
                return this._skyboxRef;
              },
              set(t) {
                (this._skyboxRef = t), this.setSkyboxInfo(t);
              },
            }),
            Object.defineProperty(t, "skybox", {
              enumerable: !0,
              configurable: !0,
              get() {
                return this._skyboxRef;
              },
              set(t) {
                (this._skyboxRef = t), this.setSkyboxInfo(t);
              },
            }),
            Object.defineProperty(t, "fog", {
              enumerable: !0,
              configurable: !0,
              get() {
                return this._fogRef;
              },
              set(t) {
                (this._fogRef = t), this.setFogInfo(t);
              },
            }),
            Object.defineProperty(t, "octree", {
              enumerable: !0,
              configurable: !0,
              get() {
                return this._octreeRef;
              },
              set(t) {
                (this._octreeRef = t), this.setOctreeInfo(t);
              },
            }),
            Object.defineProperty(t, "lightProbeInfo", {
              enumerable: !0,
              configurable: !0,
              get() {
                return this._lightProbeRef;
              },
              set(t) {
                (this._lightProbeRef = t), this.setLightProbeInfo(t);
              },
            }),
            Object.defineProperty(t, "skin", {
              enumerable: !0,
              configurable: !0,
              get() {
                return this._skinRef;
              },
              set(t) {
                (this._skinRef = t), this.setSkinInfo(t);
              },
            }),
            Object.defineProperty(t, "postSettings", {
              enumerable: !0,
              configurable: !0,
              get() {
                return this._postSettingsRef;
              },
              set(t) {
                (this._postSettingsRef = t), this.setPostSettingsInfo(t);
              },
            });
        })(),
        (function (t, e = vd) {
          const {
              SceneGlobals: i,
              AmbientInfo: s,
              ShadowsInfo: n,
              SkyboxInfo: r,
              FogInfo: a,
              OctreeInfo: o,
              SkinInfo: h,
              LightProbeInfo: l,
              PostSettingsInfo: c,
            } = { ...t },
            u = Object.getOwnPropertyDescriptor(i.prototype, "skybox");
          e(
            () => {
              Wa(i.prototype);
            },
            "editable",
            "ambient"
          ),
            e(
              () => {
                Na(i.prototype, "ambient", () => new s());
              },
              "serializable",
              "ambient"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "shadows"
            ),
            e(
              () => {
                Na(i.prototype, "shadows", () => new n());
              },
              "serializable",
              "shadows"
            ),
            e(
              () => {
                Na(i.prototype, "_skybox", () => new r());
              },
              "serializable",
              "_skybox"
            ),
            e(
              () => {
                Na(i.prototype, "fog", () => new a());
              },
              "serializable",
              "fog"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "fog"
            ),
            e(
              () => {
                ao(r)(i.prototype, "skybox", u);
              },
              "type",
              "skybox"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "skybox"
            ),
            e(
              () => {
                Na(i.prototype, "octree", () => new o());
              },
              "serializable",
              "octree"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "octree"
            ),
            e(
              () => {
                Na(i.prototype, "skin", () => new h());
              },
              "serializable",
              "skin"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "skin"
            ),
            e(
              () => {
                Na(i.prototype, "lightProbeInfo", () => new l());
              },
              "serializable",
              "lightProbeInfo"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "lightProbeInfo"
            ),
            e(
              () => {
                Na(i.prototype, "postSettings", () => new c());
              },
              "serializable",
              "postSettings"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "postSettings"
            ),
            e(
              () => {
                Na(i.prototype, "bakedWithStationaryMainLight", () => !1);
              },
              "serializable",
              "bakedWithStationaryMainLight"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "bakedWithStationaryMainLight"
            ),
            e(
              () => {
                Na(i.prototype, "bakedWithHighpLightmap", () => !1);
              },
              "serializable",
              "bakedWithHighpLightmap"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "bakedWithHighpLightmap"
            ),
            e(
              () => {
                Ca("cc.SceneGlobals")(i);
              },
              "ccclass",
              null
            );
        })({
          SceneGlobals: fy,
          AmbientInfo: cy,
          SkyboxInfo: uy,
          FogInfo: _y,
          ShadowsInfo: dy,
          LightProbeInfo: my,
          OctreeInfo: py,
          SkinInfo: gy,
          PostSettingsInfo: yy,
        }),
        (function (t, e = vd) {
          const {
              OctreeInfo: i,
              CCInteger: s,
              Vec3: n,
              DEFAULT_WORLD_MIN_POS: r,
              DEFAULT_WORLD_MAX_POS: a,
              DEFAULT_OCTREE_DEPTH: o,
            } = { ...t },
            h = Object.getOwnPropertyDescriptor(i.prototype, "enabled"),
            l = Object.getOwnPropertyDescriptor(i.prototype, "minPos"),
            c = Object.getOwnPropertyDescriptor(i.prototype, "maxPos"),
            u = Object.getOwnPropertyDescriptor(i.prototype, "depth");
          e(
            () => {
              qa()(i.prototype, "enabled", h);
            },
            "tooltip",
            "enabled"
          ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "enabled"
            ),
            e(
              () => {
                Ka()(i.prototype, "minPos", l);
              },
              "displayName",
              "minPos"
            ),
            e(
              () => {
                qa()(i.prototype, "minPos", l);
              },
              "tooltip",
              "minPos"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "minPos"
            ),
            e(
              () => {
                Ka()(i.prototype, "maxPos", c);
              },
              "displayName",
              "maxPos"
            ),
            e(
              () => {
                qa()(i.prototype, "maxPos", c);
              },
              "tooltip",
              "maxPos"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "maxPos"
            ),
            e(
              () => {
                qa()(i.prototype, "depth", u);
              },
              "tooltip",
              "depth"
            ),
            e(
              () => {
                ao(s)(i.prototype, "depth", u);
              },
              "type",
              "depth"
            ),
            e(
              () => {
                Ja(i.prototype);
              },
              "slide",
              "depth"
            ),
            e(
              () => {
                $a()(i.prototype, "depth", u);
              },
              "range",
              "depth"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "depth"
            ),
            e(
              () => {
                Na(i.prototype, "_enabled", () => !1);
              },
              "serializable",
              "_enabled"
            ),
            e(
              () => {
                Na(i.prototype, "_minPos", () => new n(r));
              },
              "serializable",
              "_minPos"
            ),
            e(
              () => {
                Na(i.prototype, "_maxPos", () => new n(a));
              },
              "serializable",
              "_maxPos"
            ),
            e(
              () => {
                Na(i.prototype, "_depth", () => o);
              },
              "serializable",
              "_depth"
            ),
            e(
              () => {
                Ca("cc.OctreeInfo")(i);
              },
              "ccclass",
              null
            );
        })({
          OctreeInfo: py,
          CCInteger: ke,
          Vec3: Yi,
          DEFAULT_WORLD_MAX_POS: ry,
          DEFAULT_WORLD_MIN_POS: ny,
          DEFAULT_OCTREE_DEPTH: ay,
        }),
        (function (t, e = vd) {
          const {
              ShadowsInfo: i,
              ShadowType: s,
              CCFloat: n,
              CCInteger: r,
              ShadowSize: a,
              Vec3: o,
              Color: h,
              Vec2: l,
            } = { ...t },
            c = Object.getOwnPropertyDescriptor(i.prototype, "enabled"),
            u = Object.getOwnPropertyDescriptor(i.prototype, "type"),
            _ = Object.getOwnPropertyDescriptor(i.prototype, "shadowColor"),
            d = Object.getOwnPropertyDescriptor(i.prototype, "planeDirection"),
            p = Object.getOwnPropertyDescriptor(i.prototype, "planeHeight"),
            m = Object.getOwnPropertyDescriptor(i.prototype, "planeBias"),
            f = Object.getOwnPropertyDescriptor(i.prototype, "maxReceived"),
            g = Object.getOwnPropertyDescriptor(i.prototype, "shadowMapSize");
          e(
            () => {
              qa()(i.prototype, "enabled", c);
            },
            "tooltip",
            "enabled"
          ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "enabled"
            ),
            e(
              () => {
                ao(s)(i.prototype, "type", u);
              },
              "type",
              "type"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "type"
            ),
            e(
              () => {
                qa()(i.prototype, "type", u);
              },
              "tooltip",
              "type"
            ),
            e(
              () => {
                Xa()(i.prototype, "shadowColor", _);
              },
              "visible",
              "shadowColor"
            ),
            e(
              () => {
                qa()(i.prototype, "shadowColor", _);
              },
              "tooltip",
              "shadowColor"
            ),
            e(
              () => {
                Xa()(i.prototype, "planeDirection", d);
              },
              "visible",
              "planeDirection"
            ),
            e(
              () => {
                qa()(i.prototype, "planeDirection", d);
              },
              "tooltip",
              "planeDirection"
            ),
            e(
              () => {
                Xa()(i.prototype, "planeHeight", p);
              },
              "visible",
              "planeHeight"
            ),
            e(
              () => {
                ao(n)(i.prototype, "planeHeight", p);
              },
              "type",
              "planeHeight"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "planeHeight"
            ),
            e(
              () => {
                qa()(i.prototype, "planeHeight", p);
              },
              "tooltip",
              "planeHeight"
            ),
            e(
              () => {
                Xa()(i.prototype, "planeBias", m);
              },
              "visible",
              "planeBias"
            ),
            e(
              () => {
                ao(n)(i.prototype, "planeBias", m);
              },
              "type",
              "planeBias"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "planeBias"
            ),
            e(
              () => {
                qa()(i.prototype, "planeBias", m);
              },
              "tooltip",
              "planeBias"
            ),
            e(
              () => {
                Xa()(i.prototype, "maxReceived", f);
              },
              "visible",
              "maxReceived"
            ),
            e(
              () => {
                ao(r)(i.prototype, "maxReceived", f);
              },
              "type",
              "maxReceived"
            ),
            e(
              () => {
                qa()(i.prototype, "maxReceived", f);
              },
              "tooltip",
              "maxReceived"
            ),
            e(
              () => {
                Xa()(i.prototype, "shadowMapSize", g);
              },
              "visible",
              "shadowMapSize"
            ),
            e(
              () => {
                ao(a)(i.prototype, "shadowMapSize", g);
              },
              "type",
              "shadowMapSize"
            ),
            e(
              () => {
                qa()(i.prototype, "shadowMapSize", g);
              },
              "tooltip",
              "shadowMapSize"
            ),
            e(
              () => {
                Na(i.prototype, "_enabled", () => !1);
              },
              "serializable",
              "_enabled"
            ),
            e(
              () => {
                Na(i.prototype, "_type", () => s.Planar);
              },
              "serializable",
              "_type"
            ),
            e(
              () => {
                Na(i.prototype, "_normal", () => new o(0, 1, 0));
              },
              "serializable",
              "_normal"
            ),
            e(
              () => {
                Na(i.prototype, "_distance", () => 0);
              },
              "serializable",
              "_distance"
            ),
            e(
              () => {
                Na(i.prototype, "_planeBias", () => 1);
              },
              "serializable",
              "_planeBias"
            ),
            e(
              () => {
                Na(i.prototype, "_shadowColor", () => new h(0, 0, 0, 76));
              },
              "serializable",
              "_shadowColor"
            ),
            e(
              () => {
                Na(i.prototype, "_maxReceived", () => 4);
              },
              "serializable",
              "_maxReceived"
            ),
            e(
              () => {
                Na(i.prototype, "_size", () => new l(1024, 1024));
              },
              "serializable",
              "_size"
            ),
            e(
              () => {
                Ca("cc.ShadowsInfo")(i);
              },
              "ccclass",
              null
            );
        })({
          ShadowsInfo: dy,
          ShadowType: ly,
          CCFloat: ze,
          CCInteger: ke,
          ShadowSize: hy,
          Vec3: Yi,
          Color: Qi,
          Vec2: Ss,
        }),
        (function (t, e = vd) {
          const { FogInfo: i, FogType: s, CCFloat: n, Color: r } = { ...t },
            a = Object.getOwnPropertyDescriptor(i.prototype, "enabled"),
            o = Object.getOwnPropertyDescriptor(i.prototype, "accurate"),
            h = Object.getOwnPropertyDescriptor(i.prototype, "fogColor"),
            l = Object.getOwnPropertyDescriptor(i.prototype, "type"),
            c = Object.getOwnPropertyDescriptor(i.prototype, "fogDensity"),
            u = Object.getOwnPropertyDescriptor(i.prototype, "fogStart"),
            _ = Object.getOwnPropertyDescriptor(i.prototype, "fogEnd"),
            d = Object.getOwnPropertyDescriptor(i.prototype, "fogAtten"),
            p = Object.getOwnPropertyDescriptor(i.prototype, "fogTop"),
            m = Object.getOwnPropertyDescriptor(i.prototype, "fogRange");
          e(
            () => {
              to()(i.prototype, "enabled", a);
            },
            "displayOrder",
            "enabled"
          ),
            e(
              () => {
                qa()(i.prototype, "enabled", a);
              },
              "tooltip",
              "enabled"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "enabled"
            ),
            e(
              () => {
                to()(i.prototype, "accurate", o);
              },
              "displayOrder",
              "accurate"
            ),
            e(
              () => {
                qa()(i.prototype, "accurate", o);
              },
              "tooltip",
              "accurate"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "accurate"
            ),
            e(
              () => {
                qa()(i.prototype, "fogColor", h);
              },
              "tooltip",
              "fogColor"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "fogColor"
            ),
            e(
              () => {
                qa()(i.prototype, "type", l);
              },
              "tooltip",
              "type"
            ),
            e(
              () => {
                to()(i.prototype, "type", l);
              },
              "displayOrder",
              "type"
            ),
            e(
              () => {
                ao(s)(i.prototype, "type", l);
              },
              "type",
              "type"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "type"
            ),
            e(
              () => {
                qa()(i.prototype, "fogDensity", c);
              },
              "tooltip",
              "fogDensity"
            ),
            e(
              () => {
                Ja(i.prototype);
              },
              "slide",
              "fogDensity"
            ),
            e(
              () => {
                $a()(i.prototype, "fogDensity", c);
              },
              "range",
              "fogDensity"
            ),
            e(
              () => {
                ao(n)(i.prototype, "fogDensity", c);
              },
              "type",
              "fogDensity"
            ),
            e(
              () => {
                Xa()(i.prototype, "fogDensity", c);
              },
              "visible",
              "fogDensity"
            ),
            e(
              () => {
                qa()(i.prototype, "fogStart", u);
              },
              "tooltip",
              "fogStart"
            ),
            e(
              () => {
                Qa()(i.prototype, "fogStart", u);
              },
              "rangeStep",
              "fogStart"
            ),
            e(
              () => {
                ao(n)(i.prototype, "fogStart", u);
              },
              "type",
              "fogStart"
            ),
            e(
              () => {
                Xa()(i.prototype, "fogStart", u);
              },
              "visible",
              "fogStart"
            ),
            e(
              () => {
                qa()(i.prototype, "fogEnd", _);
              },
              "tooltip",
              "fogEnd"
            ),
            e(
              () => {
                Qa()(i.prototype, "fogEnd", _);
              },
              "rangeStep",
              "fogEnd"
            ),
            e(
              () => {
                ao(n)(i.prototype, "fogEnd", _);
              },
              "type",
              "fogEnd"
            ),
            e(
              () => {
                Xa()(i.prototype, "fogEnd", _);
              },
              "visible",
              "fogEnd"
            ),
            e(
              () => {
                qa()(i.prototype, "fogAtten", d);
              },
              "tooltip",
              "fogAtten"
            ),
            e(
              () => {
                Qa()(i.prototype, "fogAtten", d);
              },
              "rangeStep",
              "fogAtten"
            ),
            e(
              () => {
                Za()(i.prototype, "fogAtten", d);
              },
              "rangeMin",
              "fogAtten"
            ),
            e(
              () => {
                ao(n)(i.prototype, "fogAtten", d);
              },
              "type",
              "fogAtten"
            ),
            e(
              () => {
                Xa()(i.prototype, "fogAtten", d);
              },
              "visible",
              "fogAtten"
            ),
            e(
              () => {
                qa()(i.prototype, "fogTop", p);
              },
              "tooltip",
              "fogTop"
            ),
            e(
              () => {
                Qa()(i.prototype, "fogTop", p);
              },
              "rangeStep",
              "fogTop"
            ),
            e(
              () => {
                ao(n)(i.prototype, "fogTop", p);
              },
              "type",
              "fogTop"
            ),
            e(
              () => {
                Xa()(i.prototype, "fogTop", p);
              },
              "visible",
              "fogTop"
            ),
            e(
              () => {
                qa()(i.prototype, "fogRange", m);
              },
              "tooltip",
              "fogRange"
            ),
            e(
              () => {
                Qa()(i.prototype, "fogRange", m);
              },
              "rangeStep",
              "fogRange"
            ),
            e(
              () => {
                ao(n)(i.prototype, "fogRange", m);
              },
              "type",
              "fogRange"
            ),
            e(
              () => {
                Xa()(i.prototype, "fogRange", m);
              },
              "visible",
              "fogRange"
            ),
            e(
              () => {
                Na(i.prototype, "_type", () => s.LINEAR);
              },
              "serializable",
              "_type"
            ),
            e(
              () => {
                Na(i.prototype, "_fogColor", () => new r("#C8C8C8"));
              },
              "serializable",
              "_fogColor"
            ),
            e(
              () => {
                Na(i.prototype, "_enabled", () => !1);
              },
              "serializable",
              "_enabled"
            ),
            e(
              () => {
                Na(i.prototype, "_fogDensity", () => 0.3);
              },
              "serializable",
              "_fogDensity"
            ),
            e(
              () => {
                Na(i.prototype, "_fogStart", () => 0.5);
              },
              "serializable",
              "_fogStart"
            ),
            e(
              () => {
                Na(i.prototype, "_fogEnd", () => 300);
              },
              "serializable",
              "_fogEnd"
            ),
            e(
              () => {
                Na(i.prototype, "_fogAtten", () => 5);
              },
              "serializable",
              "_fogAtten"
            ),
            e(
              () => {
                Na(i.prototype, "_fogTop", () => 1.5);
              },
              "serializable",
              "_fogTop"
            ),
            e(
              () => {
                Na(i.prototype, "_fogRange", () => 1.2);
              },
              "serializable",
              "_fogRange"
            ),
            e(
              () => {
                Na(i.prototype, "_accurate", () => !1);
              },
              "serializable",
              "_accurate"
            ),
            e(
              () => {
                Ca("cc.FogInfo")(i);
              },
              "ccclass",
              null
            );
        })({ FogInfo: _y, FogType: oy, CCFloat: ze, Color: Qi }),
        (function (t, e = vd) {
          const {
              SkyboxInfo: i,
              EnvironmentLightingType: s,
              TextureCube: n,
              CCFloat: r,
              Material: a,
            } = { ...t },
            o = Object.getOwnPropertyDescriptor(i.prototype, "enabled"),
            h = Object.getOwnPropertyDescriptor(i.prototype, "envLightingType"),
            l = Object.getOwnPropertyDescriptor(i.prototype, "useHDR"),
            c = Object.getOwnPropertyDescriptor(i.prototype, "envmap"),
            u = Object.getOwnPropertyDescriptor(i.prototype, "rotationAngle"),
            _ = Object.getOwnPropertyDescriptor(i.prototype, "diffuseMap"),
            d = Object.getOwnPropertyDescriptor(i.prototype, "reflectionMap"),
            p = Object.getOwnPropertyDescriptor(i.prototype, "skyboxMaterial");
          e(
            () => {
              qa()(i.prototype, "enabled", o);
            },
            "tooltip",
            "enabled"
          ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "enabled"
            ),
            e(
              () => {
                qa()(i.prototype, "envLightingType", h);
              },
              "tooltip",
              "envLightingType"
            ),
            e(
              () => {
                ao(s)(i.prototype, "envLightingType", h);
              },
              "type",
              "envLightingType"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "envLightingType"
            ),
            e(
              () => {
                qa()(i.prototype, "useHDR", l);
              },
              "tooltip",
              "useHDR"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "useHDR"
            ),
            e(
              () => {
                qa()(i.prototype, "envmap", c);
              },
              "tooltip",
              "envmap"
            ),
            e(
              () => {
                ao(n)(i.prototype, "envmap", c);
              },
              "type",
              "envmap"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "envmap"
            ),
            e(
              () => {
                qa()(i.prototype, "rotationAngle", u);
              },
              "tooltip",
              "rotationAngle"
            ),
            e(
              () => {
                Ja(i.prototype);
              },
              "slide",
              "rotationAngle"
            ),
            e(
              () => {
                $a()(i.prototype, "rotationAngle", u);
              },
              "range",
              "rotationAngle"
            ),
            e(
              () => {
                ao(r)(i.prototype, "rotationAngle", u);
              },
              "type",
              "rotationAngle"
            ),
            e(
              () => {
                to()(i.prototype, "diffuseMap", _);
              },
              "displayOrder",
              "diffuseMap"
            ),
            e(
              () => {
                ao(n)(i.prototype, "diffuseMap", _);
              },
              "type",
              "diffuseMap"
            ),
            e(
              () => {
                Ya(i.prototype);
              },
              "readOnly",
              "diffuseMap"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "diffuseMap"
            ),
            e(
              () => {
                Xa()(i.prototype, "diffuseMap", _);
              },
              "visible",
              "diffuseMap"
            ),
            e(
              () => {
                to()(i.prototype, "reflectionMap", d);
              },
              "displayOrder",
              "reflectionMap"
            ),
            e(
              () => {
                ao(n)(i.prototype, "reflectionMap", d);
              },
              "type",
              "reflectionMap"
            ),
            e(
              () => {
                Ya(i.prototype);
              },
              "readOnly",
              "reflectionMap"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "reflectionMap"
            ),
            e(
              () => {
                Xa()(i.prototype, "reflectionMap", d);
              },
              "visible",
              "reflectionMap"
            ),
            e(
              () => {
                qa()(i.prototype, "skyboxMaterial", p);
              },
              "tooltip",
              "skyboxMaterial"
            ),
            e(
              () => {
                ao(a)(i.prototype, "skyboxMaterial", p);
              },
              "type",
              "skyboxMaterial"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "skyboxMaterial"
            ),
            e(
              () => {
                Na(i.prototype, "_envLightingType", () => s.HEMISPHERE_DIFFUSE);
              },
              "serializable",
              "_envLightingType"
            ),
            e(
              () => {
                La("_envmap")(i.prototype, "_envmapHDR", () => null);
              },
              "formerlySerializedAs",
              "_envmapHDR"
            ),
            e(
              () => {
                ao(n)(i.prototype, "_envmapHDR", () => null);
              },
              "type",
              "_envmapHDR"
            ),
            e(
              () => {
                Na(i.prototype, "_envmapHDR", () => null);
              },
              "serializable",
              "_envmapHDR"
            ),
            e(
              () => {
                ao(n)(i.prototype, "_envmapLDR", () => null);
              },
              "type",
              "_envmapLDR"
            ),
            e(
              () => {
                Na(i.prototype, "_envmapLDR", () => null);
              },
              "serializable",
              "_envmapLDR"
            ),
            e(
              () => {
                ao(n)(i.prototype, "_diffuseMapHDR", () => null);
              },
              "type",
              "_diffuseMapHDR"
            ),
            e(
              () => {
                Na(i.prototype, "_diffuseMapHDR", () => null);
              },
              "serializable",
              "_diffuseMapHDR"
            ),
            e(
              () => {
                ao(n)(i.prototype, "_diffuseMapLDR", () => null);
              },
              "type",
              "_diffuseMapLDR"
            ),
            e(
              () => {
                Na(i.prototype, "_diffuseMapLDR", () => null);
              },
              "serializable",
              "_diffuseMapLDR"
            ),
            e(
              () => {
                Na(i.prototype, "_enabled", () => !1);
              },
              "serializable",
              "_enabled"
            ),
            e(
              () => {
                Na(i.prototype, "_useHDR", () => !0);
              },
              "serializable",
              "_useHDR"
            ),
            e(
              () => {
                ao(a)(i.prototype, "_editableMaterial", () => null);
              },
              "type",
              "_editableMaterial"
            ),
            e(
              () => {
                Na(i.prototype, "_editableMaterial", () => null);
              },
              "serializable",
              "_editableMaterial"
            ),
            e(
              () => {
                ao(n)(i.prototype, "_reflectionHDR", () => null);
              },
              "type",
              "_reflectionHDR"
            ),
            e(
              () => {
                Na(i.prototype, "_reflectionHDR", () => null);
              },
              "serializable",
              "_reflectionHDR"
            ),
            e(
              () => {
                ao(n)(i.prototype, "_reflectionLDR", () => null);
              },
              "type",
              "_reflectionLDR"
            ),
            e(
              () => {
                Na(i.prototype, "_reflectionLDR", () => null);
              },
              "serializable",
              "_reflectionLDR"
            ),
            e(
              () => {
                Na(i.prototype, "_rotationAngle", () => 0);
              },
              "serializable",
              "_rotationAngle"
            ),
            e(
              () => {
                Ca("cc.SkyboxInfo")(i);
              },
              "ccclass",
              null
            );
        })({
          SkyboxInfo: uy,
          EnvironmentLightingType: Vg,
          TextureCube: Zf,
          CCFloat: ze,
          Material: ey,
        }),
        (function (t, e = vd) {
          const {
              AmbientInfo: i,
              legacyCC: s,
              CCFloat: n,
              Vec4: r,
              Ambient: a,
            } = { ...t },
            o = Object.getOwnPropertyDescriptor(
              i.prototype,
              "skyLightingColor"
            ),
            h = Object.getOwnPropertyDescriptor(i.prototype, "skyIllum"),
            l = Object.getOwnPropertyDescriptor(
              i.prototype,
              "groundLightingColor"
            );
          e(
            () => {
              qa()(i.prototype, "skyLightingColor", o);
            },
            "tooltip",
            "skyLightingColor"
          ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "skyLightingColor"
            ),
            e(
              () => {
                Xa()(i.prototype, "skyLightingColor", o);
              },
              "visible",
              "skyLightingColor"
            ),
            e(
              () => {
                $a()(i.prototype, "skyIllum", h);
              },
              "range",
              "skyIllum"
            ),
            e(
              () => {
                qa()(i.prototype, "skyIllum", h);
              },
              "tooltip",
              "skyIllum"
            ),
            e(
              () => {
                ao(n)(i.prototype, "skyIllum", h);
              },
              "type",
              "skyIllum"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "skyIllum"
            ),
            e(
              () => {
                qa()(i.prototype, "groundLightingColor", l);
              },
              "tooltip",
              "groundLightingColor"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "groundLightingColor"
            ),
            e(
              () => {
                Xa()(i.prototype, "groundLightingColor", l);
              },
              "visible",
              "groundLightingColor"
            ),
            e(
              () => {
                La("_skyColor")(
                  i.prototype,
                  "_skyColorHDR",
                  () => new r(0.2, 0.5, 0.8, 1)
                );
              },
              "formerlySerializedAs",
              "_skyColorHDR"
            ),
            e(
              () => {
                Na(i.prototype, "_skyColorHDR", () => new r(0.2, 0.5, 0.8, 1));
              },
              "serializable",
              "_skyColorHDR"
            ),
            e(
              () => {
                La("_skyIllum")(i.prototype, "_skyIllumHDR", () => a.SKY_ILLUM);
              },
              "formerlySerializedAs",
              "_skyIllumHDR"
            ),
            e(
              () => {
                Na(i.prototype, "_skyIllumHDR", () => a.SKY_ILLUM);
              },
              "serializable",
              "_skyIllumHDR"
            ),
            e(
              () => {
                La("_groundAlbedo")(
                  i.prototype,
                  "_groundAlbedoHDR",
                  () => new r(0.2, 0.2, 0.2, 1)
                );
              },
              "formerlySerializedAs",
              "_groundAlbedoHDR"
            ),
            e(
              () => {
                Na(
                  i.prototype,
                  "_groundAlbedoHDR",
                  () => new r(0.2, 0.2, 0.2, 1)
                );
              },
              "serializable",
              "_groundAlbedoHDR"
            ),
            e(
              () => {
                Na(i.prototype, "_skyColorLDR", () => new r(0.2, 0.5, 0.8, 1));
              },
              "serializable",
              "_skyColorLDR"
            ),
            e(
              () => {
                Na(i.prototype, "_skyIllumLDR", () => a.SKY_ILLUM);
              },
              "serializable",
              "_skyIllumLDR"
            ),
            e(
              () => {
                Na(
                  i.prototype,
                  "_groundAlbedoLDR",
                  () => new r(0.2, 0.2, 0.2, 1)
                );
              },
              "serializable",
              "_groundAlbedoLDR"
            ),
            e(
              () => {
                Ca("cc.AmbientInfo")(i);
              },
              "ccclass",
              null
            );
        })({
          AmbientInfo: cy,
          Vec4: Wi,
          Ambient: Cg,
          CCFloat: ze,
          legacyCC: a,
        }),
        (function (t, e = vd) {
          const { LightProbeInfo: i, CCFloat: s, CCInteger: n } = { ...t },
            r = Object.getOwnPropertyDescriptor(i.prototype, "giScale"),
            a = Object.getOwnPropertyDescriptor(i.prototype, "giSamples"),
            o = Object.getOwnPropertyDescriptor(i.prototype, "bounces"),
            h = Object.getOwnPropertyDescriptor(i.prototype, "reduceRinging"),
            l = Object.getOwnPropertyDescriptor(i.prototype, "showWireframe"),
            c = Object.getOwnPropertyDescriptor(i.prototype, "showConvex"),
            u = Object.getOwnPropertyDescriptor(
              i.prototype,
              "lightProbeSphereVolume"
            );
          e(
            () => {
              Ka()(i.prototype, "giScale", r);
            },
            "displayName",
            "giScale"
          ),
            e(
              () => {
                qa()(i.prototype, "giScale", r);
              },
              "tooltip",
              "giScale"
            ),
            e(
              () => {
                ao(s)(i.prototype, "giScale", r);
              },
              "type",
              "giScale"
            ),
            e(
              () => {
                $a()(i.prototype, "giScale", r);
              },
              "range",
              "giScale"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "giScale"
            ),
            e(
              () => {
                Ka()(i.prototype, "giSamples", a);
              },
              "displayName",
              "giSamples"
            ),
            e(
              () => {
                qa()(i.prototype, "giSamples", a);
              },
              "tooltip",
              "giSamples"
            ),
            e(
              () => {
                ao(n)(i.prototype, "giSamples", a);
              },
              "type",
              "giSamples"
            ),
            e(
              () => {
                $a()(i.prototype, "giSamples", a);
              },
              "range",
              "giSamples"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "giSamples"
            ),
            e(
              () => {
                qa()(i.prototype, "bounces", o);
              },
              "tooltip",
              "bounces"
            ),
            e(
              () => {
                ao(n)(i.prototype, "bounces", o);
              },
              "type",
              "bounces"
            ),
            e(
              () => {
                $a()(i.prototype, "bounces", o);
              },
              "range",
              "bounces"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "bounces"
            ),
            e(
              () => {
                qa()(i.prototype, "reduceRinging", h);
              },
              "tooltip",
              "reduceRinging"
            ),
            e(
              () => {
                ao(s)(i.prototype, "reduceRinging", h);
              },
              "type",
              "reduceRinging"
            ),
            e(
              () => {
                Ja(i.prototype);
              },
              "slide",
              "reduceRinging"
            ),
            e(
              () => {
                $a()(i.prototype, "reduceRinging", h);
              },
              "range",
              "reduceRinging"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "reduceRinging"
            ),
            e(
              () => {
                qa()(i.prototype, "showWireframe", l);
              },
              "tooltip",
              "showWireframe"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "showWireframe"
            ),
            e(
              () => {
                qa()(i.prototype, "showConvex", c);
              },
              "tooltip",
              "showConvex"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "showConvex"
            ),
            e(
              () => {
                qa()(i.prototype, "lightProbeSphereVolume", u);
              },
              "tooltip",
              "lightProbeSphereVolume"
            ),
            e(
              () => {
                ao(s)(i.prototype, "lightProbeSphereVolume", u);
              },
              "type",
              "lightProbeSphereVolume"
            ),
            e(
              () => {
                $a()(i.prototype, "lightProbeSphereVolume", u);
              },
              "range",
              "lightProbeSphereVolume"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "lightProbeSphereVolume"
            ),
            e(
              () => {
                Na(i.prototype, "_giScale", () => 1);
              },
              "serializable",
              "_giScale"
            ),
            e(
              () => {
                Na(i.prototype, "_giSamples", () => 1024);
              },
              "serializable",
              "_giSamples"
            ),
            e(
              () => {
                Na(i.prototype, "_bounces", () => 2);
              },
              "serializable",
              "_bounces"
            ),
            e(
              () => {
                Na(i.prototype, "_reduceRinging", () => 0);
              },
              "serializable",
              "_reduceRinging"
            ),
            e(
              () => {
                Na(i.prototype, "_showProbe", () => !0);
              },
              "serializable",
              "_showProbe"
            ),
            e(
              () => {
                Na(i.prototype, "_showWireframe", () => !0);
              },
              "serializable",
              "_showWireframe"
            ),
            e(
              () => {
                Na(i.prototype, "_showConvex", () => !1);
              },
              "serializable",
              "_showConvex"
            ),
            e(
              () => {
                Na(i.prototype, "_data", () => null);
              },
              "serializable",
              "_data"
            ),
            e(
              () => {
                Na(i.prototype, "_lightProbeSphereVolume", () => 1);
              },
              "serializable",
              "_lightProbeSphereVolume"
            ),
            e(
              () => {
                Ca("cc.LightProbeInfo")(i);
              },
              "ccclass",
              null
            );
        })({ LightProbeInfo: my, CCFloat: ze, CCInteger: ke }),
        (function (t, e = vd) {
          const { SkinInfo: i, CCFloat: s } = { ...t },
            n = Object.getOwnPropertyDescriptor(i.prototype, "enabled"),
            r = Object.getOwnPropertyDescriptor(i.prototype, "blurRadius"),
            a = Object.getOwnPropertyDescriptor(i.prototype, "sssIntensity");
          e(
            () => {
              qa()(i.prototype, "enabled", n);
            },
            "tooltip",
            "enabled"
          ),
            e(
              () => {
                Ya(i.prototype);
              },
              "readOnly",
              "enabled"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "enabled"
            ),
            e(
              () => {
                qa()(i.prototype, "blurRadius", r);
              },
              "tooltip",
              "blurRadius"
            ),
            e(
              () => {
                ao(s)(i.prototype, "blurRadius", r);
              },
              "type",
              "blurRadius"
            ),
            e(
              () => {
                Ja(i.prototype);
              },
              "slide",
              "blurRadius"
            ),
            e(
              () => {
                $a()(i.prototype, "blurRadius", r);
              },
              "range",
              "blurRadius"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "blurRadius"
            ),
            e(
              () => {
                Xa()(i.prototype, "blurRadius", r);
              },
              "visible",
              "blurRadius"
            ),
            e(
              () => {
                qa()(i.prototype, "sssIntensity", a);
              },
              "tooltip",
              "sssIntensity"
            ),
            e(
              () => {
                ao(s)(i.prototype, "sssIntensity", a);
              },
              "type",
              "sssIntensity"
            ),
            e(
              () => {
                Ja(i.prototype);
              },
              "slide",
              "sssIntensity"
            ),
            e(
              () => {
                $a()(i.prototype, "sssIntensity", a);
              },
              "range",
              "sssIntensity"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "sssIntensity"
            ),
            e(
              () => {
                Na(i.prototype, "_enabled", () => !0);
              },
              "serializable",
              "_enabled"
            ),
            e(
              () => {
                Na(i.prototype, "_blurRadius", () => 0.01);
              },
              "serializable",
              "_blurRadius"
            ),
            e(
              () => {
                Na(i.prototype, "_sssIntensity", () => 3);
              },
              "serializable",
              "_sssIntensity"
            ),
            e(
              () => {
                Ca("cc.SkinInfo")(i);
              },
              "ccclass",
              null
            );
        })({ SkinInfo: gy, CCFloat: ze }),
        (function (t, e = vd) {
          const { PostSettingsInfo: i, ToneMappingType: s } = { ...t },
            n = Object.getOwnPropertyDescriptor(i.prototype, "toneMappingType");
          e(
            () => {
              qa()(i.prototype, "toneMappingType", n);
            },
            "tooltip",
            "toneMappingType"
          ),
            e(
              () => {
                ao(s)(i.prototype, "toneMappingType", n);
              },
              "type",
              "toneMappingType"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "toneMappingType"
            ),
            e(
              () => {
                Na(i.prototype, "_toneMappingType", () => s.DEFAULT);
              },
              "serializable",
              "_toneMappingType"
            ),
            e(
              () => {
                Ca("cc.PostSettingsInfo")(i);
              },
              "ccclass",
              null
            );
        })({ PostSettingsInfo: yy, ToneMappingType: jg }),
        $(Pf.prototype, "Node", [
          {
            name: "childrenCount",
            newName: "children.length",
            customGetter() {
              return this.children.length;
            },
          },
        ]),
        $(Pf.prototype, "Node", [
          {
            name: "width",
            targetName: "node.getComponent(UITransform)",
            customGetter() {
              return this._uiProps.uiTransformComp.width;
            },
            customSetter(t) {
              this._uiProps.uiTransformComp.width = t;
            },
          },
          {
            name: "height",
            targetName: "node.getComponent(UITransform)",
            customGetter() {
              return this._uiProps.uiTransformComp.height;
            },
            customSetter(t) {
              this._uiProps.uiTransformComp.height = t;
            },
          },
          {
            name: "anchorX",
            targetName: "node.getComponent(UITransform)",
            customGetter() {
              return this._uiProps.uiTransformComp.anchorX;
            },
            customSetter(t) {
              this._uiProps.uiTransformComp.anchorX = t;
            },
          },
          {
            name: "anchorY",
            targetName: "node.getComponent(UITransform)",
            customGetter() {
              return this._uiProps.uiTransformComp.anchorY;
            },
            customSetter(t) {
              this._uiProps.uiTransformComp.anchorY = t;
            },
          },
          {
            name: "getAnchorPoint",
            targetName: "node.getComponent(UITransform)",
            customFunction(t) {
              return (
                t || (t = new Ss()),
                t.set(this._uiProps.uiTransformComp.anchorPoint),
                t
              );
            },
          },
          {
            name: "setAnchorPoint",
            targetName: "node.getComponent(UITransform)",
            customFunction(t, e) {
              this._uiProps.uiTransformComp.setAnchorPoint(t, e);
            },
          },
          {
            name: "getContentSize",
            targetName: "node.getComponent(UITransform)",
            customFunction(t) {
              return (
                t || (t = new ws()),
                t.set(this._uiProps.uiTransformComp.contentSize),
                t
              );
            },
          },
          {
            name: "setContentSize",
            targetName: "node.getComponent(UITransform)",
            customFunction(t, e) {
              "number" == typeof t
                ? this._uiProps.uiTransformComp.setContentSize(t, e)
                : this._uiProps.uiTransformComp.setContentSize(t);
            },
          },
        ]),
        Z(fy.prototype, "SceneGlobals.prototype", [
          { name: "aspect" },
          { name: "selfShadow" },
          { name: "linear" },
          { name: "packing" },
          { name: "autoAdapt" },
          { name: "fixedArea" },
          { name: "pcf" },
          { name: "bias" },
          { name: "normalBias" },
          { name: "near" },
          { name: "far" },
          { name: "shadowDistance" },
          { name: "invisibleOcclusionRange" },
          { name: "orthoSize" },
          { name: "saturation" },
        ]),
        $(fy.prototype, "SceneGlobals.prototype", [
          { name: "distance", newName: "planeHeight" },
          { name: "normal", newName: "planeDirection" },
          { name: "size", newName: "shadowMapSize" },
        ]),
        Z(Pf.prototype, "Node.prototype", [
          { name: "addLayer" },
          { name: "removeLayer" },
        ]),
        $(Of.prototype, "NodeUIProperties", [
          { name: "opacityDirty", newName: "colorDirty" },
        ]),
        Z(Rf, "Layers", [
          { name: "All" },
          { name: "RaycastMask" },
          { name: "check" },
        ]),
        $(Rf, "Layers", [
          {
            name: "Default",
            newName: "DEFAULT",
            target: Rf.Enum,
            targetName: "Layers.Enum",
          },
          {
            name: "Always",
            newName: "ALWAYS",
            target: Rf.Enum,
            targetName: "Layers.Enum",
          },
          {
            name: "IgnoreRaycast",
            newName: "IGNORE_RAYCAST",
            target: Rf.Enum,
            targetName: "Layers.Enum",
          },
          {
            name: "Gizmos",
            newName: "GIZMOS",
            target: Rf.Enum,
            targetName: "Layers.Enum",
          },
          {
            name: "Editor",
            newName: "EDITOR",
            target: Rf.Enum,
            targetName: "Layers.Enum",
          },
          {
            name: "UI",
            newName: "UI_3D",
            target: Rf.Enum,
            targetName: "Layers.Enum",
          },
          {
            name: "UI2D",
            newName: "UI_2D",
            target: Rf.Enum,
            targetName: "Layers.Enum",
          },
          {
            name: "SceneGizmo",
            newName: "SCENE_GIZMO",
            target: Rf.Enum,
            targetName: "Layers.Enum",
          },
          {
            name: "makeInclusiveMask",
            newName: "makeMaskInclude",
            target: Rf,
            targetName: "Layers",
          },
          {
            name: "makeExclusiveMask",
            newName: "makeMaskExclude",
            target: Rf,
            targetName: "Layers",
          },
        ]),
        Z(Rf.Enum, "Layers.Enum", [{ name: "ALWAYS" }]),
        Z(Rf.BitMask, "Layers.BitMask", [{ name: "ALWAYS" }]);
      const Sy = $n.Flags.HideInHierarchy,
        Ey = $n.Flags.DontSave;
      let vy = t(
        "PrivateNode",
        Ca("cc.PrivateNode")(
          (Ty = class extends Pf {
            constructor(t) {
              super(t), z(12003, this.name), (this.hideFlags |= Ey | Sy);
            }
          })
        ) || Ty
      );
      var by,
        Ay,
        Cy,
        Oy,
        Iy,
        wy,
        Ry,
        Dy,
        xy,
        My,
        Py,
        Ny,
        Ly,
        By,
        Fy,
        Uy,
        ky,
        zy,
        Hy,
        Gy,
        Vy,
        jy,
        Wy,
        Xy,
        Yy,
        Ky,
        qy,
        $y,
        Zy,
        Qy,
        Jy,
        tT,
        eT,
        iT,
        sT,
        nT,
        rT,
        aT,
        oT,
        hT,
        lT,
        cT,
        uT,
        _T,
        dT,
        pT,
        mT,
        fT,
        gT,
        yT,
        TT,
        ST,
        ET,
        vT,
        bT,
        AT,
        CT,
        OT,
        IT,
        wT,
        RT,
        DT,
        xT,
        MT,
        PT,
        NT,
        LT,
        BT,
        FT;
      $(
        cm,
        "SystemEventType",
        [
          "MOUSE_ENTER",
          "MOUSE_LEAVE",
          "TRANSFORM_CHANGED",
          "SCENE_CHANGED_FOR_PERSISTS",
          "SIZE_CHANGED",
          "ANCHOR_CHANGED",
          "COLOR_CHANGED",
          "CHILD_ADDED",
          "CHILD_REMOVED",
          "PARENT_CHANGED",
          "NODE_DESTROYED",
          "LAYER_CHANGED",
          "SIBLING_ORDER_CHANGED",
        ].map((t) => ({
          name: t,
          target: Pf.EventType,
          targetName: "Node.EventType",
        }))
      ),
        $(Pf.EventType, "Node.EventType", [
          {
            name: "DEVICEMOTION",
            target: df.EventType,
            targetName: "SystemEvent.EventType",
          },
          {
            name: "KEY_DOWN",
            target: df.EventType,
            targetName: "SystemEvent.EventType",
          },
          {
            name: "KEY_UP",
            target: df.EventType,
            targetName: "SystemEvent.EventType",
          },
        ]),
        (a.PrivateNode = vy),
        rt({ BaseNode: { newName: "Node", since: "3.7.0", removed: !1 } });
      let UT =
          ((by = Ca("cc.TargetInfo")),
          (Ay = ao([Ge])),
          by(
            ((Oy = class {
              constructor() {
                this.localID = Iy && Iy();
              }
            }),
            (Iy = fa(Oy.prototype, "localID", [Na, Ay], function () {
              return [];
            })),
            (Cy = Oy))
          ) || Cy),
        kT =
          ((wy = Ca("cc.TargetOverrideInfo")),
          (Ry = ao($n)),
          (Dy = ao(UT)),
          (xy = ao([Ge])),
          (My = ao(Pf)),
          (Py = ao(UT)),
          wy(
            ((Ly = class {
              constructor() {
                (this.source = By && By()),
                  (this.sourceInfo = Fy && Fy()),
                  (this.propertyPath = Uy && Uy()),
                  (this.target = ky && ky()),
                  (this.targetInfo = zy && zy());
              }
            }),
            (By = fa(Ly.prototype, "source", [Na, Ry], function () {
              return null;
            })),
            (Fy = fa(Ly.prototype, "sourceInfo", [Na, Dy], function () {
              return null;
            })),
            (Uy = fa(Ly.prototype, "propertyPath", [Na, xy], function () {
              return [];
            })),
            (ky = fa(Ly.prototype, "target", [Na, My], function () {
              return null;
            })),
            (zy = fa(Ly.prototype, "targetInfo", [Na, Py], function () {
              return null;
            })),
            (Ny = Ly))
          ) || Ny),
        zT =
          Ca("cc.CompPrefabInfo")(
            ((Gy = class {
              constructor() {
                this.fileId = Vy && Vy();
              }
            }),
            (Vy = fa(Gy.prototype, "fileId", [Na], function () {
              return "";
            })),
            (Hy = Gy))
          ) || Hy,
        HT =
          ((jy = Ca("CCPropertyOverrideInfo")),
          (Wy = ao(UT)),
          (Xy = ao([Ge])),
          jy(
            ((Ky = class {
              constructor() {
                (this.targetInfo = qy && qy()),
                  (this.propertyPath = $y && $y()),
                  (this.value = Zy && Zy());
              }
              isTarget(t, e) {}
            }),
            (qy = fa(Ky.prototype, "targetInfo", [Na, Wy], function () {
              return null;
            })),
            ($y = fa(Ky.prototype, "propertyPath", [Na, Xy], function () {
              return [];
            })),
            (Zy = fa(Ky.prototype, "value", [Na], null)),
            (Yy = Ky))
          ) || Yy),
        GT =
          ((Qy = Ca("cc.MountedChildrenInfo")),
          (Jy = ao(UT)),
          (tT = ao([Pf])),
          Qy(
            ((iT = class {
              constructor() {
                (this.targetInfo = sT && sT()), (this.nodes = nT && nT());
              }
              isTarget(t) {}
            }),
            (sT = fa(iT.prototype, "targetInfo", [Na, Jy], function () {
              return null;
            })),
            (nT = fa(iT.prototype, "nodes", [Na, tT], function () {
              return [];
            })),
            (eT = iT))
          ) || eT),
        VT =
          ((rT = Ca("cc.MountedComponentsInfo")),
          (aT = ao(UT)),
          (oT = ao([np])),
          rT(
            ((lT = class {
              constructor() {
                (this.targetInfo = cT && cT()), (this.components = uT && uT());
              }
              isTarget(t) {}
            }),
            (cT = fa(lT.prototype, "targetInfo", [Na, aT], function () {
              return null;
            })),
            (uT = fa(lT.prototype, "components", [Na, oT], function () {
              return [];
            })),
            (hT = lT))
          ) || hT),
        jT =
          ((_T = Ca("cc.PrefabInstance")),
          (dT = ao(Pf)),
          (pT = ao([GT])),
          (mT = ao([VT])),
          (fT = ao([HT])),
          (gT = ao([UT])),
          _T(
            ((TT = class {
              constructor() {
                (this.fileId = ST && ST()),
                  (this.prefabRootNode = ET && ET()),
                  (this.mountedChildren = vT && vT()),
                  (this.mountedComponents = bT && bT()),
                  (this.propertyOverrides = AT && AT()),
                  (this.removedComponents = CT && CT()),
                  (this.targetMap = {}),
                  (this.expanded = !1);
              }
              findPropertyOverride(t, e) {}
              removePropertyOverride(t, e) {}
            }),
            (ST = fa(TT.prototype, "fileId", [Na], function () {
              return "";
            })),
            (ET = fa(TT.prototype, "prefabRootNode", [Na, dT], null)),
            (vT = fa(TT.prototype, "mountedChildren", [Na, pT], function () {
              return [];
            })),
            (bT = fa(TT.prototype, "mountedComponents", [Na, mT], function () {
              return [];
            })),
            (AT = fa(TT.prototype, "propertyOverrides", [Na, fT], function () {
              return [];
            })),
            (CT = fa(TT.prototype, "removedComponents", [Na, gT], function () {
              return [];
            })),
            (yT = TT))
          ) || yT),
        WT =
          ((OT = Ca("cc.PrefabInfo")),
          (IT = ao(Pf)),
          (wT = ao(jT)),
          (RT = ao([kT])),
          OT(
            ((xT = class {
              constructor() {
                (this.root = MT && MT()),
                  (this.asset = PT && PT()),
                  (this.fileId = NT && NT()),
                  (this.instance = LT && LT()),
                  (this.targetOverrides = BT && BT()),
                  (this.nestedPrefabInstanceRoots = FT && FT());
              }
            }),
            (MT = fa(xT.prototype, "root", [Na, IT], null)),
            (PT = fa(xT.prototype, "asset", [Na], null)),
            (NT = fa(xT.prototype, "fileId", [Na], function () {
              return "";
            })),
            (LT = fa(xT.prototype, "instance", [Na, wT], null)),
            (BT = fa(xT.prototype, "targetOverrides", [Na, RT], null)),
            (FT = fa(xT.prototype, "nestedPrefabInstanceRoots", [Na], null)),
            (DT = xT))
          ) || DT);
      function XT(t) {
        const e = null == t ? void 0 : t.prefab;
        if (!e) return;
        if (!e.instance) return;
        if (!e.asset) return G(3701, t.name), void (e.instance = void 0);
        const i = t._objFlags,
          s = t.getParent(),
          n = t.uuid;
        t[Kn],
          (a.game._isCloning = !0),
          e.asset._doInstantiate(t),
          (a.game._isCloning = !1),
          (t._objFlags = i),
          t.modifyParent(s),
          (t.id = n),
          t.prefab && (t.prefab.instance = e.instance);
      }
      function YT(t, e, i) {
        var s;
        if (!e) return;
        if (!t) return;
        let n = e;
        const r = null === (s = t.prefab) || void 0 === s ? void 0 : s.instance;
        !i && r && ((e[r.fileId] = {}), (n = e[r.fileId]));
        const a = t.prefab;
        a && (n[a.fileId] = t);
        const o = t.components;
        for (let t = 0; t < o.length; t++) {
          const e = o[t];
          e.__prefab && (n[e.__prefab.fileId] = e);
        }
        for (let e = 0; e < t.children.length; e++) YT(t.children[e], n, !1);
      }
      function KT(t, e) {
        if (!t) return null;
        let i = null,
          s = e;
        for (let e = 0; e < t.length; e++) {
          if (!s) return null;
          s = s[t[e]];
        }
        return (i = s), i;
      }
      function qT(t, e, i) {
        if (e)
          for (let t = 0; t < e.length; t++) {
            const s = e[t];
            if (s && s.targetInfo) {
              const t = KT(s.targetInfo.localID, i);
              if (!t) continue;
              let e = i;
              const n = s.targetInfo.localID;
              if (n.length > 0)
                for (let t = 0; t < n.length - 1; t++) e = e[n[t]];
              if (s.nodes)
                for (let i = 0; i < s.nodes.length; i++) {
                  const n = s.nodes[i];
                  n &&
                    !t.children.includes(n) &&
                    (t.children.push(n),
                    n.modifyParent(t),
                    YT(n, e, !1),
                    (n.siblingIndex = t.children.length - 1),
                    tS(n, !0));
                }
            }
          }
      }
      function $T(t, e, i) {
        if (e)
          for (let t = 0; t < e.length; t++) {
            const s = e[t];
            if (s && s.targetInfo) {
              const t = KT(s.targetInfo.localID, i);
              if (!t) continue;
              if (s.components)
                for (let e = 0; e < s.components.length; e++) {
                  const i = s.components[e];
                  i && ((i.node = t), t.getWritableComponents().push(i));
                }
            }
          }
      }
      function ZT(t, e, i) {
        if (e)
          for (let t = 0; t < e.length; t++) {
            const s = e[t];
            if (s) {
              const t = KT(s.localID, i);
              if (!t || !t.node) continue;
              const e = t.node.components.indexOf(t);
              e >= 0 && t.node.getWritableComponents().splice(e, 1);
            }
          }
      }
      function QT(t, e, i) {
        if (e.length <= 0) return;
        let s = null;
        for (let t = 0; t < e.length; t++) {
          const n = e[t];
          if (n && n.targetInfo) {
            if (((s = KT(n.targetInfo.localID, i)), !s)) continue;
            let t = s;
            const e = n.propertyPath.slice();
            if (e.length > 0) {
              const i = e.pop();
              if (!i) continue;
              for (let i = 0; i < e.length && ((t = t[e[i]]), t); i++);
              if (!t) continue;
              if (Array.isArray(t))
                if ("length" === i) t[i] = n.value;
                else {
                  const e = Number.parseInt(i);
                  Number.isInteger(e) && e < t.length && (t[i] = n.value);
                }
              else t[i] instanceof pe ? t[i].set(n.value) : (t[i] = n.value);
            }
          }
        }
      }
      function JT(t) {
        var e;
        const i =
          null === (e = t.prefab) || void 0 === e ? void 0 : e.targetOverrides;
        if (i)
          for (let t = 0; t < i.length; t++) {
            var s;
            const e = i[t];
            let r = e.source;
            const a = e.sourceInfo;
            if (a) {
              var n;
              const t = e.source,
                i =
                  null == t || null === (n = t.prefab) || void 0 === n
                    ? void 0
                    : n.instance;
              i && i.targetMap && (r = KT(a.localID, i.targetMap));
            }
            if (!r) continue;
            let o = null;
            const h = e.targetInfo;
            if (!h) continue;
            const l = e.target,
              c =
                null == l || null === (s = l.prefab) || void 0 === s
                  ? void 0
                  : s.instance;
            if (!c || !c.targetMap) continue;
            if (((o = KT(h.localID, c.targetMap)), !o)) continue;
            const u = e.propertyPath.slice();
            let _ = r;
            if (u.length > 0) {
              const t = u.pop();
              if (!t) return;
              for (let t = 0; t < u.length && ((_ = _[u[t]]), _); t++);
              if (!_) continue;
              _[t] = o;
            }
          }
      }
      function tS(t, e = !1) {
        var i;
        const s =
          null == t || null === (i = t.prefab) || void 0 === i
            ? void 0
            : i.instance;
        if (s && !s.expanded) {
          XT(t),
            e &&
              t &&
              t.children &&
              t.children.forEach((t) => {
                tS(t, !0);
              });
          const i = {};
          (s.targetMap = i),
            YT(t, i, !0),
            qT(0, s.mountedChildren, i),
            ZT(0, s.removedComponents, i),
            $T(0, s.mountedComponents, i),
            QT(0, s.propertyOverrides, i),
            (s.expanded = !0);
        } else
          e &&
            t &&
            t.children &&
            t.children.forEach((t) => {
              tS(t, !0);
            });
      }
      function eS(t) {
        const e = t.prefab;
        e &&
          e.nestedPrefabInstanceRoots &&
          e.nestedPrefabInstanceRoots.forEach((t) => {
            tS(t);
          });
      }
      a._PrefabInfo = WT;
      var iS = Object.freeze({
        __proto__: null,
        createNodeWithPrefab: XT,
        generateTargetMap: YT,
        getTarget: KT,
        applyMountedChildren: qT,
        applyMountedComponents: $T,
        applyRemovedComponents: ZT,
        applyPropertyOverrides: QT,
        applyTargetOverrides: JT,
        expandPrefabInstanceNode: tS,
        expandNestedPrefabInstanceNode: eS,
        applyNodeAndComponentId: function t(e, i) {
          const { components: s, children: n } = e;
          for (let t = 0; t < s.length; t++) {
            var r, a;
            const e = s[t],
              n =
                null !==
                  (r =
                    null === (a = e.__prefab) || void 0 === a
                      ? void 0
                      : a.fileId) && void 0 !== r
                  ? r
                  : "";
            e._id = `${i}${n}`;
          }
          for (let e = 0; e < n.length; e++) {
            const s = n[e],
              r = s.prefab,
              a =
                null != r && r.instance
                  ? r.instance.fileId
                  : null == r
                  ? void 0
                  : r.fileId;
            a && ((s.id = `${i}${a}`), (null != r && r.instance) || t(s, i));
          }
        },
        TargetInfo: UT,
        TargetOverrideInfo: kT,
        CompPrefabInfo: zT,
        PropertyOverrideInfo: HT,
        MountedChildrenInfo: GT,
        MountedComponentsInfo: VT,
        PrefabInstance: jT,
        PrefabInfo: WT,
      });
      const sS = t("Scene", jsb.Scene);
      a.Scene = sS;
      const nS = sS.prototype;
      Object.defineProperty(nS, "_globals", {
        enumerable: !0,
        configurable: !0,
        get() {
          return this.getSceneGlobals();
        },
        set(t) {
          (this._globalRef = t), this.setSceneGlobals(t);
        },
      }),
        Object.defineProperty(nS, "globals", {
          enumerable: !0,
          configurable: !0,
          get() {
            return this.getSceneGlobals();
          },
        }),
        Object.defineProperty(nS, "_renderScene", {
          enumerable: !0,
          configurable: !0,
          get() {
            return (
              this._renderSceneInternal ||
                (this._renderSceneInternal = this.getRenderScene()),
              this._renderSceneInternal
            );
          },
        }),
        Object.defineProperty(nS, "renderScene", {
          enumerable: !0,
          configurable: !0,
          get() {
            return (
              this._renderSceneInternal ||
                (this._renderSceneInternal = this.getRenderScene()),
              this._renderSceneInternal
            );
          },
        }),
        (nS._ctor = function () {
          Pf.prototype._ctor.apply(this, arguments),
            (this._inited = !1),
            (this._renderSceneInternal = null),
            (this._globalRef = null),
            (this._prefabSyncedInLiveReload = !1);
        }),
        (nS._onBatchCreated = function (t) {
          this._parent &&
            (this._siblingIndex = this._parent.children.indexOf(this));
          const e = this._children,
            i = e.length;
          let s;
          for (let n = 0; n < i; ++n)
            (s = e[n]), (s._siblingIndex = n), s._onBatchCreated(t);
        });
      const rS = nS._load;
      function aS(t, e) {
        if (!e) {
          const t = a.director.getScene();
          if (!t) return null;
          e = t;
        }
        return e.getChildByPath(t);
      }
      (nS._load = function () {
        (this._scene = this),
          this._inited ||
            (eS(this),
            JT(this),
            this._onBatchCreated(false),
            (this._inited = !0)),
          ic(this),
          rS.call(this);
      }),
        (nS._activate = function (t) {
          (t = !1 !== t),
            a.director._nodeActivator.activateNode(this, t),
            this._globals.activate(this),
            this._renderScene && this._renderScene.activate();
        }),
        (nS._instantiate = function () {}),
        (function (t, e = vd) {
          const { Scene: i, SceneGlobals: s } = { ...t };
          Object.getOwnPropertyDescriptor(i.prototype, "globals"),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "globals"
            ),
            e(
              () => {
                Wa(i.prototype);
              },
              "editable",
              "autoReleaseAssets"
            ),
            e(
              () => {
                Na(i.prototype, "autoReleaseAssets", () => !1);
              },
              "serializable",
              "autoReleaseAssets"
            ),
            e(
              () => {
                Na(i.prototype, "_globals", () => new s());
              },
              "serializable",
              "_globals"
            ),
            e(
              () => {
                Ca("cc.Scene")(i);
              },
              "ccclass",
              null
            );
        })({ Scene: sS, SceneGlobals: fy }),
        (a.find = aS);
      const oS = Jt,
        hS = $n.Flags.IsStartCalled,
        lS = $n.Flags.IsOnEnableCalled;
      function cS(t, e) {
        const i = e.constructor._executionOrder,
          s = e._id;
        let n = 0;
        for (let e = t.length - 1, r = e >>> 1; n <= e; r = (n + e) >>> 1) {
          const a = t[r],
            o = a.constructor._executionOrder;
          if (o > i) e = r - 1;
          else if (o < i) n = r + 1;
          else {
            const t = a._id;
            if (t > s) e = r - 1;
            else {
              if (!(t < s)) return r;
              n = r + 1;
            }
          }
        }
        return ~n;
      }
      function uS(t, e) {
        const i = t.array;
        let s = t.i + 1;
        for (; s < i.length; ) {
          const n = i[s];
          Qn(n.node, !0) && n.node._activeInHierarchy
            ? ++s
            : (t.removeAt(s), e && (n._objFlags &= ~e));
        }
      }
      $n.Flags.IsEditorOnEnableCalled;
      class _S {
        get zero() {
          return this._zero;
        }
        get neg() {
          return this._neg;
        }
        get pos() {
          return this._pos;
        }
        constructor(t) {
          const e = Zt;
          (this._zero = new e([])),
            (this._neg = new e([])),
            (this._pos = new e([])),
            (this._invoke = t);
        }
      }
      function dS(t, e) {
        return t.constructor._executionOrder - e.constructor._executionOrder;
      }
      _S.stableRemoveInactive = uS;
      class pS extends _S {
        add(t) {
          const e = t.constructor._executionOrder;
          (0 === e ? this._zero : e < 0 ? this._neg : this._pos).array.push(t);
        }
        remove(t) {
          const e = t.constructor._executionOrder;
          (0 === e ? this._zero : e < 0 ? this._neg : this._pos).fastRemove(t);
        }
        cancelInactive(t) {
          uS(this._zero, t), uS(this._neg, t), uS(this._pos, t);
        }
        invoke() {
          const t = this._neg;
          t.array.length > 0 &&
            (t.array.sort(dS), this._invoke(t), (t.array.length = 0)),
            this._invoke(this._zero),
            (this._zero.array.length = 0);
          const e = this._pos;
          e.array.length > 0 &&
            (e.array.sort(dS), this._invoke(e), (e.array.length = 0));
        }
      }
      class mS extends _S {
        add(t) {
          const e = t.constructor._executionOrder;
          if (0 === e) this._zero.array.push(t);
          else {
            const i = e < 0 ? this._neg.array : this._pos.array,
              s = cS(i, t);
            s < 0 && i.splice(~s, 0, t);
          }
        }
        remove(t) {
          const e = t.constructor._executionOrder;
          if (0 === e) this._zero.fastRemove(t);
          else {
            const i = e < 0 ? this._neg : this._pos,
              s = cS(i.array, t);
            s >= 0 && i.removeAt(s);
          }
        }
        invoke(t) {
          this._neg.array.length > 0 && this._invoke(this._neg, t),
            this._invoke(this._zero, t),
            this._pos.array.length > 0 && this._invoke(this._pos, t);
        }
      }
      function fS(t, e, i) {
        const s = `var a=it.array;for(it.i=0;it.i<a.length;++it.i){var c=a[it.i];${t}}`,
          n = e ? Function("it", "dt", s) : Function("it", s);
        return (function (t, e, i) {
          return (s, n) => {
            try {
              e(s, n);
            } catch (e) {
              a._throw(e);
              const r = s.array;
              for (i && (r[s.i]._objFlags |= i), ++s.i; s.i < r.length; ++s.i)
                try {
                  t(r[s.i], n);
                } catch (t) {
                  a._throw(t), i && (r[s.i]._objFlags |= i);
                }
            }
          };
        })(Function("c", "dt", t), n, i);
      }
      const gS = fS(`c.start();c._objFlags|=${hS}`, !1, hS),
        yS = fS("c.update(dt)", !0),
        TS = fS("c.lateUpdate(dt)", !0),
        SS = (t) => {
          const e = a.director._compScheduler,
            i = t.array;
          for (t.i = 0; t.i < i.length; ++t.i) {
            const s = i[t.i];
            s._enabled &&
              (s.onEnable(), !s.node._activeInHierarchy || e._onEnabled(s));
          }
        };
      class ES {
        constructor() {
          (this._deferredComps = []), this.unscheduleAll();
        }
        unscheduleAll() {
          (this.startInvoker = new pS(gS)),
            (this.updateInvoker = new mS(yS)),
            (this.lateUpdateInvoker = new mS(TS)),
            (this._updating = !1);
        }
        _onEnabled(t) {
          a.director.getScheduler().resumeTarget(t),
            (t._objFlags |= lS),
            this._updating
              ? this._deferredComps.push(t)
              : this._scheduleImmediate(t);
        }
        _onDisabled(t) {
          a.director.getScheduler().pauseTarget(t), (t._objFlags &= ~lS);
          const e = this._deferredComps.indexOf(t);
          e >= 0
            ? oS(this._deferredComps, e)
            : (!t.internalStart ||
                t._objFlags & hS ||
                this.startInvoker.remove(t),
              t.internalUpdate && this.updateInvoker.remove(t),
              t.internalLateUpdate && this.lateUpdateInvoker.remove(t));
        }
        enableComp(t, e) {
          if (!(t._objFlags & lS)) {
            if (t.internalOnEnable) {
              if (e) return void e.add(t);
              if ((t.internalOnEnable(), !t.node.activeInHierarchy)) return;
            }
            this._onEnabled(t);
          }
        }
        disableComp(t) {
          t._objFlags & lS &&
            (t.internalOnDisable && t.internalOnDisable(), this._onDisabled(t));
        }
        startPhase() {
          (this._updating = !0),
            this.startInvoker.invoke(),
            this._startForNewComps();
        }
        updatePhase(t) {
          this.updateInvoker.invoke(t);
        }
        lateUpdatePhase(t) {
          this.lateUpdateInvoker.invoke(t),
            (this._updating = !1),
            this._startForNewComps();
        }
        _startForNewComps() {
          this._deferredComps.length > 0 &&
            (this._deferredSchedule(), this.startInvoker.invoke());
        }
        _scheduleImmediate(t) {
          "function" != typeof t.internalStart ||
            t._objFlags & hS ||
            this.startInvoker.add(t),
            "function" == typeof t.internalUpdate && this.updateInvoker.add(t),
            "function" == typeof t.internalLateUpdate &&
              this.lateUpdateInvoker.add(t);
        }
        _deferredSchedule() {
          const t = this._deferredComps;
          for (let e = 0, i = t.length; e < i; e++)
            this._scheduleImmediate(t[e]);
          t.length = 0;
        }
      }
      const vS = $n.Flags.IsPreloadStarted,
        bS = $n.Flags.IsOnLoadStarted,
        AS = $n.Flags.IsOnLoadCalled,
        CS = $n.Flags.IsOnEnableCalled,
        OS = $n.Flags.Deactivating;
      class IS extends _S {
        add(t) {
          this._zero.array.push(t);
        }
        remove(t) {
          this._zero.fastRemove(t);
        }
        cancelInactive(t) {
          _S.stableRemoveInactive(this._zero, t);
        }
        invoke() {
          this._invoke(this._zero), (this._zero.array.length = 0);
        }
      }
      const wS = fS("c.__preload();"),
        RS = fS(`c.onLoad();c._objFlags|=${AS}`, !1, AS),
        DS = new $t(4);
      function xS(t, e, i) {
        G(3817, t.name, i),
          console.log("Corrupted component value:", e),
          e ? t._removeComponent(e) : Qt(t.getWritableComponents(), i);
      }
      DS.get = function () {
        const t = this._get() || {
          preload: new IS(wS),
          onLoad: new pS(RS),
          onEnable: new pS(SS),
        };
        t.preload.zero.i = -1;
        let e = t.onLoad;
        return (
          (e.zero.i = -1),
          (e.neg.i = -1),
          (e.pos.i = -1),
          (e = t.onEnable),
          (e.zero.i = -1),
          (e.neg.i = -1),
          (e.pos.i = -1),
          t
        );
      };
      class MS {
        constructor() {
          this.reset();
        }
        reset() {
          this._activatingStack = [];
        }
        activateNode(t, e) {
          if (e) {
            const e = DS.get();
            e &&
              (this._activatingStack.push(e),
              this._activateNodeRecursively(t, e.preload, e.onLoad, e.onEnable),
              e.preload.invoke(),
              e.onLoad.invoke(),
              e.onEnable.invoke(),
              this._activatingStack.pop(),
              DS.put(e));
          } else {
            this._deactivateNodeRecursively(t);
            const e = this._activatingStack;
            for (const t of e)
              t.preload.cancelInactive(vS),
                t.onLoad.cancelInactive(bS),
                t.onEnable.cancelInactive(CS);
          }
          t.emit(bf.ACTIVE_IN_HIERARCHY_CHANGED, t);
        }
        activateComp(t, e, i, s) {
          if (
            Qn(t, !0) &&
            (t._objFlags & vS ||
              ((t._objFlags |= vS),
              t.internalPreload && (e ? e.add(t) : t.internalPreload())),
            t._objFlags & bS ||
              ((t._objFlags |= bS),
              t.internalOnLoad
                ? i
                  ? i.add(t)
                  : (t.internalOnLoad(), (t._objFlags |= AS))
                : (t._objFlags |= AS)),
            t._enabled)
          ) {
            if (!t.node.activeInHierarchy) return;
            a.director._compScheduler.enableComp(t, s);
          }
        }
        destroyComp(t) {
          a.director._compScheduler.disableComp(t),
            t.internalOnDestroy && t._objFlags & AS && t.internalOnDestroy();
        }
        _activateNodeRecursively(t, e, i, s) {
          if (t._objFlags & OS) return void G(3816, t.name);
          t._setActiveInHierarchy(!0);
          let n = t.components.length;
          for (let r = 0; r < n; ++r) {
            const o = t.components[r];
            o instanceof a.Component
              ? this.activateComp(o, e, i, s)
              : (xS(t, o, r), --r, --n);
          }
          for (let n = 0, r = t.children.length; n < r; ++n) {
            const r = t.children[n];
            r.active && this._activateNodeRecursively(r, e, i, s);
          }
          t._onPostActivated(!0);
        }
        _deactivateNodeRecursively(t) {
          (t._objFlags |= OS), t._setActiveInHierarchy(!1);
          const e = t.components.length;
          for (let i = 0; i < e; ++i) {
            const e = t.components[i];
            if (
              e._enabled &&
              (a.director._compScheduler.disableComp(e), t.activeInHierarchy)
            )
              return void (t._objFlags &= ~OS);
          }
          for (let e = 0, i = t.children.length; e < i; ++e) {
            const i = t.children[e];
            if (
              i.activeInHierarchy &&
              (this._deactivateNodeRecursively(i), t.activeInHierarchy)
            )
              return void (t._objFlags &= ~OS);
          }
          t._onPostActivated(!1), (t._objFlags &= ~OS);
        }
      }
      t("NodeActivator", MS);
      const PS = $n.Flags.Destroyed,
        NS = $n.Flags.PersistentMask,
        LS = `${hi.Attr.DELIMETER}default`,
        BS = hi.IDENTIFIER_RE,
        FS = "var ",
        US = "o",
        kS = { "cc.ClickEvent": !1, "cc.PrefabInfo": !1 },
        zS = hi.escapeForJS;
      class HS {
        constructor(t, e) {
          (this.varName = t), (this.expression = e);
        }
        toString() {
          return `${FS + this.varName}=${this.expression};`;
        }
      }
      function GS(t, e) {
        return e instanceof HS ? new HS(e.varName, t + e.expression) : t + e;
      }
      function VS(t, e, i) {
        Array.isArray(i)
          ? ((i[0] = GS(e, i[0])), t.push(i))
          : t.push(`${GS(e, i)};`);
      }
      class jS {
        constructor(t) {
          (this._exps = []), (this._targetExp = t);
        }
        append(t, e) {
          this._exps.push([t, e]);
        }
        writeCode(t) {
          let e;
          if (this._exps.length > 1) t.push(`t=${this._targetExp};`), (e = "t");
          else {
            if (1 !== this._exps.length) return;
            e = this._targetExp;
          }
          for (let i = 0; i < this._exps.length; i++) {
            const s = this._exps[i];
            VS(t, `${e + WS(s[0])}=`, s[1]);
          }
        }
      }
      function WS(t) {
        return BS.test(t) ? `.${t}` : `[${zS(t)}]`;
      }
      (jS.pool = void 0),
        (jS.pool = new $t((t) => {
          (t._exps.length = 0), (t._targetExp = null);
        }, 1)),
        (jS.pool.get = function (t) {
          const e = this._get() || new jS();
          return (e._targetExp = t), e;
        });
      class XS {
        constructor(t, e) {
          let i;
          (this.objsToClear_iN$t = []),
            (this.codeArray = []),
            (this.objs = []),
            (this.funcs = []),
            (this.globalVariables = []),
            (this.globalVariableId = 0),
            (this.localVariableId = 0),
            (this.parent = e),
            (this.funcModuleCache = St()),
            Mt(this.funcModuleCache, kS),
            this.codeArray.push(
              "var o,t;",
              "if(R){",
              "o=R;",
              "}else{",
              `o=R=new ${this.getFuncModule(t.constructor, !0)}();`,
              "}"
            ),
            (t._iN$t = { globalVar: "R" }),
            this.objsToClear_iN$t.push(t),
            this.enumerateObject(this.codeArray, t),
            this.globalVariables.length > 0 &&
              (i = `${FS + this.globalVariables.join(",")};`);
          const s = hc([
            "return (function(R){",
            i || [],
            this.codeArray,
            "return o;",
            "})",
          ]);
          this.result = Function("O", "F", s)(this.objs, this.funcs);
          for (let t = 0, e = this.objsToClear_iN$t.length; t < e; ++t)
            this.objsToClear_iN$t[t]._iN$t = null;
          this.objsToClear_iN$t.length = 0;
        }
        getFuncModule(t, e) {
          const i = Et(t);
          if (i) {
            const e = this.funcModuleCache[i];
            if (e) return e;
            if (void 0 === e) {
              let e = -1 !== i.indexOf(".");
              if (e)
                try {
                  if (((e = t === Function(`return ${i}`)()), e))
                    return (this.funcModuleCache[i] = i), i;
                } catch (t) {}
            }
          }
          let s = this.funcs.indexOf(t);
          s < 0 && ((s = this.funcs.length), this.funcs.push(t));
          let n = `F[${s}]`;
          return e && (n = `(${n})`), (this.funcModuleCache[i] = n), n;
        }
        getObjRef(t) {
          let e = this.objs.indexOf(t);
          return (
            e < 0 && ((e = this.objs.length), this.objs.push(t)), `O[${e}]`
          );
        }
        setValueType(t, e, i, s) {
          const n = jS.pool.get(s);
          let r = e.constructor.__props__;
          r || (r = Object.keys(e));
          for (let t = 0; t < r.length; t++) {
            const s = r[t],
              a = i[s];
            if (e[s] === a) continue;
            const o = this.enumerateField(i, s, a);
            n.append(s, o);
          }
          n.writeCode(t), jS.pool.put(n);
        }
        enumerateCCClass(t, e, i) {
          const s = i.__values__,
            n = hi.Attr.getClassAttrs(i);
          for (let i = 0; i < s.length; i++) {
            const r = s[i],
              o = e[r];
            let h = n[r + LS];
            if (!YS(h, o))
              if (
                "object" == typeof o &&
                o instanceof a.ValueType &&
                ((h = hi.getDefault(h)), h && h.constructor === o.constructor)
              ) {
                const e = US + WS(r);
                this.setValueType(t, h, o, e);
              } else this.setObjProp(t, e, r, o);
          }
        }
        instantiateArray(t) {
          if (0 === t.length) return "[]";
          const e = "a" + ++this.localVariableId,
            i = [new HS(e, `new Array(${t.length})`)];
          (t._iN$t = { globalVar: "", source: i }),
            this.objsToClear_iN$t.push(t);
          for (let s = 0; s < t.length; ++s)
            VS(i, `${e}[${s}]=`, this.enumerateField(t, s, t[s]));
          return i;
        }
        instantiateTypedArray(t) {
          const e = t.constructor.name;
          if (0 === t.length) return `new ${e}`;
          const i = "a" + ++this.localVariableId,
            s = [new HS(i, `new ${e}(${t.length})`)];
          (t._iN$t = { globalVar: "", source: s }),
            this.objsToClear_iN$t.push(t);
          for (let e = 0; e < t.length; ++e)
            0 !== t[e] && VS(s, `${i}[${e}]=`, t[e]);
          return s;
        }
        enumerateField(t, e, i) {
          if ("object" == typeof i && i) {
            const t = i._iN$t;
            if (t) {
              let e = t.globalVar;
              if (!e) {
                (e = t.globalVar = "v" + ++this.globalVariableId),
                  this.globalVariables.push(e);
                const i = t.source[0];
                t.source[0] = GS(`${e}=`, i);
              }
              return e;
            }
            return ArrayBuffer.isView(i)
              ? this.instantiateTypedArray(i)
              : Array.isArray(i)
              ? this.instantiateArray(i)
              : this.instantiateObj(i);
          }
          return "function" == typeof i
            ? this.getFuncModule(i)
            : "string" == typeof i
            ? zS(i)
            : ("_objFlags" === e && Zn(t) && (i &= NS), i);
        }
        setObjProp(t, e, i, s) {
          VS(t, `${US + WS(i)}=`, this.enumerateField(e, i, s));
        }
        enumerateObject(t, e) {
          const i = e.constructor;
          if (li(i)) this.enumerateCCClass(t, e, i);
          else
            for (const i in e) {
              if (
                !e.hasOwnProperty(i) ||
                (95 === i.charCodeAt(0) &&
                  95 === i.charCodeAt(1) &&
                  "__type__" !== i)
              )
                continue;
              const s = e[i];
              ("object" == typeof s && s && s === e._iN$t) ||
                this.setObjProp(t, e, i, s);
            }
        }
        instantiateObj(t) {
          if (t instanceof a.ValueType) return hi.getNewValueTypeCode(t);
          if (t instanceof a.Asset) return this.getObjRef(t);
          if (t._objFlags & PS) return null;
          let e;
          const i = t.constructor;
          if (li(i)) {
            if (this.parent)
              if (this.parent instanceof a.Component) {
                if (t instanceof a.Node || t instanceof a.Component)
                  return this.getObjRef(t);
              } else if (this.parent instanceof a.Node)
                if (t instanceof a.Node) {
                  if (!t.isChildOf(this.parent)) return this.getObjRef(t);
                } else if (t instanceof a.Component) {
                  var s;
                  if (
                    null === (s = t.node) ||
                    void 0 === s ||
                    !s.isChildOf(this.parent)
                  )
                    return this.getObjRef(t);
                }
            e = new HS(US, `new ${this.getFuncModule(i, !0)}()`);
          } else if (i === Object) e = new HS(US, "{}");
          else {
            if (i) return this.getObjRef(t);
            e = new HS(US, "Object.create(null)");
          }
          const n = [e];
          return (
            (t._iN$t = { globalVar: "", source: n }),
            this.objsToClear_iN$t.push(t),
            this.enumerateObject(n, t),
            ["(function(){", n, "return o;})();"]
          );
        }
      }
      function YS(t, e) {
        if ("function" == typeof t)
          try {
            t = t();
          } catch (t) {
            return !1;
          }
        if (t === e) return !0;
        if (
          t &&
          e &&
          "object" == typeof t &&
          "object" == typeof e &&
          t.constructor === e.constructor
        )
          if (t instanceof a.ValueType) {
            if (t.equals(e)) return !0;
          } else {
            if (Array.isArray(t)) return 0 === t.length && 0 === e.length;
            if (t.constructor === Object) return mt(t) && mt(e);
          }
        return !1;
      }
      var KS, qS, $S, ZS, QS, JS;
      const tE = ce({ AUTO: 0, SINGLE_INSTANCE: 1, MULTI_INSTANCE: 2 });
      let eE = t(
        "Prefab",
        Ca("cc.Prefab")(
          (((JS = class t extends Ad {
            constructor() {
              super(),
                (this.data = $S && $S()),
                (this.optimizationPolicy = ZS && ZS()),
                (this.persistent = QS && QS()),
                (this._createFunction = null),
                (this._instantiatedTimes = 0);
            }
            createNode(t) {
              const e = a.instantiate(this);
              (e.name = this.name), t(null, e);
            }
            compileCreateFunction() {
              this._createFunction = (function (t) {
                const e = t instanceof a.Node && t;
                return new XS(t, e).result;
              })(this.data);
            }
            _doInstantiate(t) {
              return (
                this.data._prefab || z(3700),
                this._createFunction || this.compileCreateFunction(),
                this._createFunction(t)
              );
            }
            _instantiate() {
              let e,
                i = !1;
              if (
                ((i =
                  this.optimizationPolicy !== tE.SINGLE_INSTANCE &&
                  (this.optimizationPolicy === tE.MULTI_INSTANCE ||
                    this._instantiatedTimes + 1 >=
                      t.OptimizationPolicyThreshold)),
                i)
              )
                (e = this._doInstantiate()), this.data._instantiate(e);
              else {
                if (!this.data) return null;
                e = this.data._instantiate();
              }
              return ++this._instantiatedTimes, e;
            }
            initDefault(t) {
              super.initDefault(t),
                (this.data = new Pf()),
                (this.data.name = "(Missing Node)");
              const e = new a._PrefabInfo();
              (e.asset = this), (e.root = this.data), (this.data._prefab = e);
            }
            validate() {
              return !!this.data;
            }
            onLoaded() {
              const t = this.data;
              eS(t), JT(t), ic(t);
            }
          }).OptimizationPolicy = tE),
          (JS.OptimizationPolicyThreshold = 3),
          ($S = fa((qS = JS).prototype, "data", [Na], function () {
            return null;
          })),
          (ZS = fa(qS.prototype, "optimizationPolicy", [Na], function () {
            return tE.AUTO;
          })),
          (QS = fa(qS.prototype, "persistent", [Na], function () {
            return !1;
          })),
          (KS = qS))
        ) || KS
      );
      ft(eE, "_utils", iS), (a.Prefab = eE), vt(a, "cc._Prefab", "Prefab");
      const iE = new (class {
        constructor() {
          (this._allRenderers = []),
            (this._dirtyRenderers = []),
            (this._dirtyVersion = 0);
        }
        addRenderer(t) {
          -1 === t._internalId &&
            ((t._internalId = this._allRenderers.length),
            this._allRenderers.push(t));
        }
        removeRenderer(t) {
          if (-1 !== t._internalId) {
            const e = t._internalId;
            (this._allRenderers[this._allRenderers.length - 1]._internalId = e),
              Jt(this._allRenderers, e),
              (t._internalId = -1),
              t._dirtyVersion === this._dirtyVersion &&
                (ee(this._dirtyRenderers, t), (t._dirtyVersion = -1));
          }
        }
        markDirtyRenderer(t) {
          t._dirtyVersion !== this._dirtyVersion &&
            -1 !== t._internalId &&
            (this._dirtyRenderers.push(t),
            (t._dirtyVersion = this._dirtyVersion));
        }
        updateAllDirtyRenderers() {
          const t = this._dirtyRenderers;
          for (let e = 0; e < this._dirtyRenderers.length; e++)
            t[e].updateRenderer();
          (this._dirtyRenderers.length = 0), this._dirtyVersion++;
        }
      })();
      class sE {
        constructor() {
          (this.name = ""),
            (this.base = ""),
            (this.importBase = ""),
            (this.nativeBase = ""),
            (this.deps = null),
            (this.assetInfos = new $_()),
            (this.scenes = new $_()),
            (this.paths = new $_());
        }
        init(t) {
          ((t) => {
            let e = t.uuids;
            const i = t.paths,
              s = t.types,
              n = t.deps,
              r = (t.paths = Object.create(null));
            if (!1 === t.debug) {
              for (let t = 0, i = e.length; t < i; t++) e[t] = pd(e[t]);
              for (const t in i) {
                const e = i[t],
                  n = e[1];
                e[1] = s[n];
              }
            } else {
              const t = Object.create(null);
              for (let i = 0, s = e.length; i < s; i++) {
                const s = e[i];
                e[i] = t[s] = pd(s);
              }
              e = t;
            }
            for (const t in i) {
              const s = i[t];
              r[e[t]] = s;
            }
            const a = t.scenes;
            for (const t in a) {
              const i = a[t];
              a[t] = e[i];
            }
            const o = t.packs;
            for (const t in o) {
              const i = o[t];
              for (let t = 0; t < i.length; ++t) i[t] = e[i[t]];
            }
            const h = t.versions;
            if (h)
              for (const t in h) {
                const i = h[t];
                for (let t = 0; t < i.length; t += 2) {
                  const s = i[t];
                  i[t] = e[s] || s;
                }
              }
            const l = t.redirect;
            if (l)
              for (let t = 0; t < l.length; t += 2)
                (l[t] = e[l[t]]), (l[t + 1] = n[l[t + 1]]);
            if (t.extensionMap)
              for (const i in t.extensionMap)
                Object.prototype.hasOwnProperty.call(t.extensionMap, i) &&
                  t.extensionMap[i].forEach((s, n) => {
                    t.extensionMap[i][n] = e[s] || s;
                  });
          })(t),
            (this.importBase = t.importBase || ""),
            (this.nativeBase = t.nativeBase || ""),
            (this.base = t.base || ""),
            (this.name = t.name || ""),
            (this.deps = t.deps || []),
            this._initUuid(t.uuids),
            this._initPath(t.paths),
            this._initScene(t.scenes),
            this._initPackage(t.packs),
            this._initVersion(t.versions),
            this._initRedirect(t.redirect);
          for (const e in t.extensionMap)
            Object.prototype.hasOwnProperty.call(t.extensionMap, e) &&
              t.extensionMap[e].forEach((t) => {
                const i = this.assetInfos.get(t);
                i && (i.extension = e);
              });
        }
        getInfoWithPath(t, e) {
          if (!t) return null;
          t = Td(t);
          const i = this.paths.get(t);
          if (i) {
            if (!e) return i[0];
            for (let t = 0, s = i.length; t < s; t++) {
              const s = i[t];
              if (Lt(s.ctor, e)) return s;
            }
          }
          return null;
        }
        getDirWithPath(t, e, i) {
          "/" === (t = Td(t))[t.length - 1] && (t = t.slice(0, -1));
          const s = i || [];
          return (
            this.paths.forEach((i, n) => {
              if (
                (n.startsWith(t) &&
                  ((t, e) =>
                    !(t.length > e.length) || 47 === t.charCodeAt(e.length))(
                    n,
                    t
                  )) ||
                !t
              )
                for (let t = 0, n = i.length; t < n; t++) {
                  const n = i[t];
                  (e && !Lt(n.ctor, e)) || s.push(n);
                }
            }),
            s
          );
        }
        getAssetInfo(t) {
          return this.assetInfos.get(t) || null;
        }
        getSceneInfo(t) {
          return (
            t.endsWith(".scene") || (t += ".scene"),
            "/" === t[0] || t.startsWith("db://") || (t = `/${t}`),
            this.scenes.find((e, i) => i.endsWith(t))
          );
        }
        destroy() {
          this.paths.destroy(),
            this.scenes.destroy(),
            this.assetInfos.destroy();
        }
        _initUuid(t) {
          if (t) {
            this.assetInfos.clear();
            for (let e = 0, i = t.length; e < i; e++) {
              const i = t[e];
              this.assetInfos.add(i, { uuid: i });
            }
          }
        }
        _initPath(t) {
          if (!t) return;
          const e = this.paths;
          e.clear();
          for (const i in t) {
            const s = t[i],
              n = s[0],
              r = s[1],
              a = 3 === s.length,
              o = this.assetInfos.get(i);
            (o.path = n),
              (o.ctor = Xt(r)),
              e.has(n)
                ? a
                  ? e.get(n).push(o)
                  : e.get(n).unshift(o)
                : e.add(n, [o]);
          }
        }
        _initScene(t) {
          if (!t) return;
          const e = this.scenes;
          e.clear();
          const i = this.assetInfos;
          for (const s in t) {
            const n = t[s],
              r = i.get(n);
            (r.url = s), e.add(s, r);
          }
        }
        _initPackage(t) {
          if (!t) return;
          const e = this.assetInfos;
          for (const i in t) {
            const s = t[i],
              n = { uuid: i, packedUuids: s, ext: ".json" };
            e.add(i, n);
            for (let t = 0, i = s.length; t < i; t++) {
              const r = s[t],
                a = e.get(r),
                o = a.packs;
              o ? (1 === i ? o.unshift(n) : o.push(n)) : (a.packs = [n]);
            }
          }
        }
        _initVersion(t) {
          if (!t) return;
          const e = this.assetInfos;
          let i = t.import;
          if (i)
            for (let t = 0, s = i.length; t < s; t += 2) {
              const s = i[t];
              e.get(s).ver = i[t + 1];
            }
          if (((i = t.native), i))
            for (let t = 0, s = i.length; t < s; t += 2) {
              const s = i[t];
              e.get(s).nativeVer = i[t + 1];
            }
        }
        _initRedirect(t) {
          if (!t) return;
          const e = this.assetInfos;
          for (let i = 0, s = t.length; i < s; i += 2) {
            const s = t[i];
            e.get(s).redirect = t[i + 1];
          }
        }
      }
      function nE(t, e) {
        t._uuid && e.push(t._uuid);
      }
      function rE(t, e) {
        const i = Object.getOwnPropertyNames(t);
        for (let s = 0; s < i.length; s++) {
          const n = i[s];
          if ("node" === n || "__eventTargets" === n) continue;
          const r = t[n];
          if ("object" == typeof r && r)
            if (Array.isArray(r))
              for (let t = 0; t < r.length; t++) {
                const i = r[t];
                i instanceof Ad && nE(i, e);
              }
            else if (r.constructor && r.constructor !== Object)
              r instanceof Ad && nE(r, e);
            else {
              const t = Object.getOwnPropertyNames(r);
              for (let i = 0; i < t.length; i++) {
                const s = r[t[i]];
                s instanceof Ad && nE(s, e);
              }
            }
        }
      }
      function aE(t, e) {
        for (let i = 0; i < t._components.length; i++) rE(t._components[i], e);
        for (let i = 0; i < t._children.length; i++) aE(t._children[i], e);
      }
      function oE(t, e, i, s) {
        i.push(t._uuid);
        const n = jp.getDeps(t._uuid);
        for (let t = 0, r = n.length; t < r; t++) {
          const r = Q_.get(n[t]);
          if (!r) continue;
          const a = r._uuid;
          a in e ? (e[a] += s) : (e[a] = r.refCount + s),
            i.includes(a) || oE(r, e, i, s);
        }
      }
      const hE = [],
        lE = new (class {
          constructor() {
            (this._persistNodeDeps = new $_()),
              (this._toDelete = new $_()),
              (this._eventListener = !1),
              (this._dontDestroyAssets = []);
          }
          addIgnoredAsset(t) {
            this._dontDestroyAssets.push(t._uuid);
          }
          init() {
            this._persistNodeDeps.clear(), this._toDelete.clear();
          }
          _addPersistNodeRef(t) {
            const e = [];
            aE(t, e);
            for (let t = 0, i = e.length; t < i; t++) {
              const i = Q_.get(e[t]);
              i && i.addRef();
            }
            this._persistNodeDeps.add(t.uuid, e);
          }
          _removePersistNodeRef(t) {
            if (!this._persistNodeDeps.has(t.uuid)) return;
            const e = this._persistNodeDeps.get(t.uuid);
            for (let t = 0, i = e.length; t < i; t++) {
              const i = Q_.get(e[t]);
              i && i.decRef();
            }
            this._persistNodeDeps.remove(t.uuid);
          }
          _autoRelease(t, e, i) {
            if (t) {
              const i = jp.getDeps(t.uuid);
              for (let e = 0, s = i.length; e < s; e++) {
                const s = Q_.get(i[e]);
                s && s.decRef(t.autoReleaseAssets);
              }
              const s = jp._depends.get(t.uuid);
              if (s && s.persistDeps) {
                const e = s.persistDeps;
                for (let i = 0, s = e.length; i < s; i++) {
                  const s = Q_.get(e[i]);
                  s && s.decRef(t.autoReleaseAssets);
                }
              }
              t.uuid !== e.uuid && jp.remove(t.uuid);
            }
            const s = jp._depends.get(e.uuid);
            s && (s.persistDeps = []);
            for (const t in i) {
              const e = i[t],
                n = this._persistNodeDeps.get(e.uuid);
              for (const t of n) {
                const e = Q_.get(t);
                e && e.addRef();
              }
              s && s.persistDeps.push(...n);
            }
          }
          _autoReleaseScene(t) {
            if (t) {
              const e = jp.getDeps(t.uuid);
              for (let t = 0, i = e.length; t < i; t++) {
                const i = Q_.get(e[t]);
                i && i.decRef(!0);
              }
              const i = jp._depends.get(t.uuid);
              if (i && i.persistDeps) {
                const t = i.persistDeps;
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = Q_.get(t[e]);
                  i && i.decRef(!0);
                }
              }
              jp.remove(t.uuid);
            }
          }
          tryRelease(t, e = !1) {
            t instanceof Ad &&
              (e
                ? this._free(t, e)
                : (this._toDelete.add(t._uuid, t),
                  this._eventListener ||
                    ((this._eventListener = !0),
                    Ie(this._freeAssets.bind(this)))));
          }
          _freeAssets() {
            (this._eventListener = !1),
              this._toDelete.forEach((t) => {
                this._free(t);
              }),
              this._toDelete.clear();
          }
          _free(t, e = !1) {
            const i = t._uuid;
            if (
              (this._toDelete.remove(i),
              !Qn(t, !0) || -1 !== this._dontDestroyAssets.indexOf(i))
            )
              return;
            if (
              !e &&
              t.refCount > 0 &&
              (function (t) {
                const e = Object.create(null);
                if (
                  ((e[t._uuid] = t.refCount),
                  oE(t, e, hE, -1),
                  (hE.length = 0),
                  0 !== e[t._uuid])
                )
                  return e[t._uuid];
                for (const t in e) 0 !== e[t] && oE(Q_.get(t), e, hE, 1);
                return (hE.length = 0), e[t._uuid];
              })(t) > 0
            )
              return;
            Q_.remove(i);
            const s = jp.getDeps(i);
            for (let t = 0, e = s.length; t < e; t++) {
              const e = Q_.get(s[t]);
              e && (e.decRef(!1), this._free(e, !1));
            }
            t.destroy(), jp.remove(i);
          }
        })();
      let cE = null;
      function uE(t, e) {
        for (let i = 0, s = t.input.length; i < s; i++) {
          const s = t.input[i];
          e && !s.isNative && s.content instanceof Ad && s.content.decRef(!1),
            s.recycle();
        }
        t.input = null;
      }
      function _E(t, e) {
        return e
          ? /\?/.test(t)
            ? `${t}&_t=${Date.now()}`
            : `${t}?_t=${Date.now()}`
          : t;
      }
      function dE(t, e, i, s, n = 0) {
        t(n, (r, a) => {
          n++,
            !r || n > e
              ? s && s(r, a)
              : setTimeout(() => {
                  dE(t, e, i, s, n);
                }, i);
        });
      }
      function pE(t, e, i, s, n) {
        try {
          const r = jp.parse(t, e);
          for (let t = 0, e = r.deps.length; t < e; t++) {
            const e = r.deps[t];
            e in i || ((i[e] = !0), s.push({ uuid: e, bundle: n && n.name }));
          }
          r.nativeDep &&
            (n && (r.nativeDep.bundle = n.name), s.push({ ...r.nativeDep }));
        } catch (t) {
          R(t.message, t.stack);
        }
      }
      function mE(t, e, i) {
        e &&
          ((i = void 0 !== i ? i : a.assetManager.cacheAsset),
          yd(e) || !i || e.isDefault || Q_.add(t, e));
      }
      function fE(t, e, i) {
        let s = 0;
        const n = [],
          r = t.length;
        0 === r && i && i(n);
        const a = (t) => {
          t && n.push(t), s++, s === r && i && i(n);
        };
        for (let i = 0; i < r; i++) e(t[i], a);
      }
      function gE(t, e, i) {
        let s = t,
          n = e,
          r = i;
        if (void 0 === i) {
          const i = "function" == typeof t;
          e
            ? ((r = e), i || (n = null))
            : void 0 === e && i && ((r = t), (s = null), (n = null)),
            void 0 !== e && i && ((n = t), (s = null));
        }
        return {
          options: s || Object.create(null),
          onProgress: n,
          onComplete: r,
        };
      }
      function yE(t, e, i) {
        let s = t,
          n = e,
          r = i;
        if (void 0 === i) {
          const i = Lt(t, Ad);
          e
            ? ((r = e), i && (n = null))
            : void 0 !== e || i || ((r = t), (n = null), (s = null)),
            void 0 === e || i || ((n = t), (s = null));
        }
        return { type: s, onProgress: n || cE, onComplete: r };
      }
      function TE(t, e, i, s = {}) {
        if (!i[e] || s[e]) return !1;
        s[e] = !0;
        let n = !1;
        const r = jp.getDeps(e);
        if (r)
          for (let e = 0, a = r.length; e < a; e++) {
            const a = r[e];
            if (a === t || TE(t, a, i, s)) {
              n = !0;
              break;
            }
          }
        return n;
      }
      function SE(t) {
        return (e, i) => {
          if (!t) return;
          const s = [];
          Array.isArray(i)
            ? i.forEach((t) => t instanceof Ad && s.push(t.addRef()))
            : i instanceof Ad && s.push(i.addRef()),
            Ie(() => {
              s.forEach((t) => t.decRef(!1)), t(e, i);
            });
        };
      }
      class EE {
        constructor() {
          this._config = new sE();
        }
        get config() {
          return this._config;
        }
        get name() {
          return this._config.name;
        }
        get deps() {
          return this._config.deps;
        }
        get base() {
          return this._config.base;
        }
        getInfoWithPath(t, e) {
          return this._config.getInfoWithPath(t, e);
        }
        getDirWithPath(t, e, i) {
          return this._config.getDirWithPath(t, e, i);
        }
        getAssetInfo(t) {
          return this._config.getAssetInfo(t);
        }
        getSceneInfo(t) {
          return this._config.getSceneInfo(t);
        }
        init(t) {
          this._config.init(t), ed.add(t.name, this);
        }
        load(t, e, i, s) {
          const { type: n, onProgress: r, onComplete: o } = yE(e, i, s),
            h = {
              __requestType__: ad.PATH,
              type: n,
              bundle: this.name,
              __outputAsArray__: Array.isArray(t),
            };
          a.assetManager.loadAny(t, h, r, o);
        }
        preload(t, e, i, s) {
          const { type: n, onProgress: r, onComplete: o } = yE(e, i, s);
          a.assetManager.preloadAny(
            t,
            { __requestType__: ad.PATH, type: n, bundle: this.name },
            r,
            o
          );
        }
        loadDir(t, e, i, s) {
          const { type: n, onProgress: r, onComplete: o } = yE(e, i, s);
          a.assetManager.loadAny(
            t,
            {
              __requestType__: ad.DIR,
              type: n,
              bundle: this.name,
              __outputAsArray__: !0,
            },
            r,
            o
          );
        }
        preloadDir(t, e, i, s) {
          const { type: n, onProgress: r, onComplete: o } = yE(e, i, s);
          a.assetManager.preloadAny(
            t,
            { __requestType__: ad.DIR, type: n, bundle: this.name },
            r,
            o
          );
        }
        loadScene(t, e, i, s) {
          const { options: n, onProgress: r, onComplete: o } = gE(e, i, s);
          (n.preset = n.preset || "scene"),
            (n.bundle = this.name),
            a.assetManager.loadAny({ scene: t }, n, r, (t, e) => {
              if (t) R(t.message, t.stack);
              else if (e.scene) {
                const t = e.scene;
                (t._id = e._uuid), (t.name = e.name);
              } else t = new Error(`The asset ${e._uuid} is not a scene`);
              o && o(t, e);
            });
        }
        preloadScene(t, e, i, s) {
          const { options: n, onProgress: r, onComplete: o } = gE(e, i, s);
          (n.bundle = this.name),
            a.assetManager.preloadAny({ scene: t }, n, r, (e) => {
              e && G(1210, t, e.message), o && o(e);
            });
        }
        get(t, e) {
          const i = this.getInfoWithPath(t, e);
          return (i && Q_.get(i.uuid)) || null;
        }
        release(t, e) {
          const i = this.get(t, e);
          i && lE.tryRelease(i, !0);
        }
        releaseUnusedAssets() {
          Q_.forEach((t) => {
            const e = this.getAssetInfo(t._uuid);
            e && !e.redirect && lE.tryRelease(t);
          });
        }
        releaseAll() {
          Q_.forEach((t) => {
            const e = this.getAssetInfo(t._uuid);
            e && !e.redirect && lE.tryRelease(t, !0);
          });
        }
        _destroy() {
          this._config.destroy();
        }
      }
      const vE = t("resources", new EE());
      function bE(t, e, i) {
        const s = new h.Image();
        function n() {
          s.removeEventListener("load", n),
            s.removeEventListener("error", r),
            i && i(null, s);
        }
        function r() {
          s.removeEventListener("load", n),
            s.removeEventListener("error", r),
            i && i(new Error(X(4930, t)));
        }
        return (
          "file:" !== h.location.protocol && (s.crossOrigin = "anonymous"),
          s.addEventListener("load", n),
          s.addEventListener("error", r),
          (s.src = t),
          s
        );
      }
      function AE(t, e, i, s) {
        const n = new XMLHttpRequest(),
          r = `download failed: ${t}, status: `;
        if (
          (n.open("GET", t, !0),
          void 0 !== e.xhrResponseType && (n.responseType = e.xhrResponseType),
          void 0 !== e.xhrWithCredentials &&
            (n.withCredentials = e.xhrWithCredentials),
          void 0 !== e.xhrMimeType &&
            n.overrideMimeType &&
            n.overrideMimeType(e.xhrMimeType),
          void 0 !== e.xhrTimeout && (n.timeout = e.xhrTimeout),
          e.xhrHeader)
        )
          for (const t in e.xhrHeader) n.setRequestHeader(t, e.xhrHeader[t]);
        return (
          (n.onload = () => {
            200 === n.status || 0 === n.status
              ? s && s(null, n.response)
              : s && s(new Error(`${r}${n.status}(no response)`));
          }),
          i &&
            (n.onprogress = (t) => {
              t.lengthComputable && i(t.loaded, t.total);
            }),
          (n.onerror = () => {
            s && s(new Error(`${r}${n.status}(error)`));
          }),
          (n.ontimeout = () => {
            s && s(new Error(`${r}${n.status}(time out)`));
          }),
          (n.onabort = () => {
            s && s(new Error(`${r}${n.status}(abort)`));
          }),
          n.send(null),
          n
        );
      }
      a.resources = vE;
      const CE = h.document,
        OE = {};
      function IE(t, e, i) {
        if (OE[t]) return i && i(null), null;
        const s = CE.createElement("script");
        function n() {
          s.parentNode.removeChild(s),
            s.removeEventListener("load", n, !1),
            s.removeEventListener("error", r, !1),
            (OE[t] = !0),
            i && i(null);
        }
        function r() {
          s.parentNode.removeChild(s),
            s.removeEventListener("load", n, !1),
            s.removeEventListener("error", r, !1),
            i && i(new Error(X(4928, t)));
        }
        return (
          "file:" !== h.location.protocol && (s.crossOrigin = "anonymous"),
          (s.async = e.scriptAsyncLoading || !1),
          (s.src = t),
          s.addEventListener("load", n, !1),
          s.addEventListener("error", r, !1),
          CE.body.appendChild(s),
          s
        );
      }
      const wE = /^(?:\w+:\/\/|\.+\/).+/,
        RE = (t, e, i) => {
          (zr.hasFeature(zr.Feature.IMAGE_BITMAP) &&
            a.assetManager.allowImageBitmap
            ? DE
            : bE)(t, e, i);
        },
        DE = (t, e, i) => {
          (e.xhrResponseType = "blob"), AE(t, e, e.onFileProgress, i);
        },
        xE = (t, e, i) => {
          (e.xhrResponseType = "json"), AE(t, e, e.onFileProgress, i);
        },
        ME = (t, e, i) => {
          (e.xhrResponseType = "arraybuffer"), AE(t, e, e.onFileProgress, i);
        },
        PE = (t, e, i) => {
          UE._downloadJson(t, e, (e, s) => {
            if (e) return void i(e);
            const n = cp(s);
            Promise.all(
              n.chunks.map(
                (i) =>
                  new Promise((s, n) => {
                    UE._downloadArrayBuffer(`${Ar(t)}${i}`, {}, (t, i) => {
                      e ? n(e) : s(new Uint8Array(i));
                    });
                  })
              )
            )
              .then((t) => {
                const e = new lp(n.document, t);
                i(null, e);
              })
              .catch((t) => {
                i(t);
              });
          });
        },
        NE = (t, e, i) => {
          UE._downloadArrayBuffer(t, e, (t, e) => {
            if (t) i(t);
            else
              try {
                const t = up(new Uint8Array(e));
                i(null, t);
              } catch (t) {
                i(t);
              }
          });
        },
        LE = (t, e, i) => {
          (e.xhrResponseType = "text"), AE(t, e, e.onFileProgress, i);
        },
        BE = (t, e, i) => {
          const s = Cr(t);
          let n = t;
          wE.test(n) ||
            (n =
              -1 !== UE.remoteBundles.indexOf(s)
                ? `${UE.remoteServerAddress}remote/${s}`
                : `assets/${s}`);
          const r = e.version || UE.bundleVers[s];
          let a = 0,
            o = null,
            h = null;
          xE(`${n}/config.${r ? `${r}.` : ""}json`, e, (t, e) => {
            (h = t || h), (o = e), o && (o.base = `${n}/`), 2 == ++a && i(h, o);
          }),
            IE(`${n}/index.${r ? `${r}.` : ""}js`, e, (t) => {
              (h = t || h), 2 == ++a && i(h, o);
            });
        };
      class FE {
        static get instance() {
          return FE._instance || (FE._instance = new FE()), FE._instance;
        }
        get remoteServerAddress() {
          return this._remoteServerAddress;
        }
        init(t = "", e = {}, i = []) {
          this._downloading.clear(),
            (this._queue.length = 0),
            (this._remoteServerAddress = t),
            (this.bundleVers = e),
            (this.remoteBundles = i);
        }
        register(t, e) {
          "object" == typeof t
            ? Mt(this._downloaders, t)
            : (this._downloaders[t] = e);
        }
        download(t, e, i, s, n) {
          const r = J_.get(t);
          if (r) return void n(null, r);
          const a = this._downloading.get(t);
          if (a) {
            a.push(n);
            const e = this._queue.find((e) => e.id === t);
            if (!e) return;
            const i = s.priority || 0;
            return void (
              e.priority < i && ((e.priority = i), (this._queueDirty = !0))
            );
          }
          const o =
              void 0 !== s.maxRetryCount ? s.maxRetryCount : this.maxRetryCount,
            h =
              void 0 !== s.maxConcurrency
                ? s.maxConcurrency
                : this.maxConcurrency,
            l =
              void 0 !== s.maxRequestsPerFrame
                ? s.maxRequestsPerFrame
                : this.maxRequestsPerFrame,
            c = this._downloaders[i] || this._downloaders.default;
          dE(
            (i, r) => {
              if ((0 === i && this._downloading.add(t, [n]), !this.limited))
                return void c(_E(e, this.appendTimeStamp), s, r);
              this._updateTime();
              const a = (t, e) => {
                this._totalNum--, this._handleQueueInNextFrame(h, l), r(t, e);
              };
              this._totalNum < h && this._totalNumThisPeriod < l
                ? (c(_E(e, this.appendTimeStamp), s, a),
                  this._totalNum++,
                  this._totalNumThisPeriod++)
                : (this._queue.push({
                    id: t,
                    priority: s.priority || 0,
                    url: e,
                    options: s,
                    done: a,
                    handler: c,
                  }),
                  (this._queueDirty = !0),
                  this._totalNum < h && this._handleQueueInNextFrame(h, l));
            },
            o,
            this.retryInterval,
            (e, i) => {
              e || J_.add(t, i);
              const s = this._downloading.remove(t);
              for (let t = 0, n = s.length; t < n; t++) s[t](e, i);
            }
          );
        }
        loadSubpackage(t, e) {
          a.assetManager.loadBundle(t, null, e);
        }
        constructor() {
          (this.maxConcurrency = 15),
            (this.maxRequestsPerFrame = 15),
            (this.maxRetryCount = 3),
            (this.appendTimeStamp = !1),
            (this.limited = !0),
            (this.retryInterval = 2e3),
            (this.bundleVers = {}),
            (this.remoteBundles = []),
            (this.downloadDomImage = bE),
            (this.downloadDomAudio = null),
            (this.downloadFile = AE),
            (this.downloadScript = IE),
            (this._downloadArrayBuffer = ME),
            (this._downloadJson = xE),
            (this._downloaders = {
              ".png": RE,
              ".jpg": RE,
              ".bmp": RE,
              ".jpeg": RE,
              ".gif": RE,
              ".ico": RE,
              ".tiff": RE,
              ".webp": RE,
              ".image": RE,
              ".pvr": ME,
              ".pkm": ME,
              ".astc": ME,
              ".txt": LE,
              ".xml": LE,
              ".vsh": LE,
              ".fsh": LE,
              ".atlas": LE,
              ".tmx": LE,
              ".tsx": LE,
              ".json": xE,
              ".ExportJson": xE,
              ".plist": LE,
              ".ccon": PE,
              ".cconb": NE,
              ".fnt": LE,
              ".binary": ME,
              ".bin": ME,
              ".dbbin": ME,
              ".skel": ME,
              ".js": IE,
              bundle: BE,
              default: LE,
            }),
            (this._downloading = new $_()),
            (this._queue = []),
            (this._queueDirty = !1),
            (this._totalNum = 0),
            (this._totalNumThisPeriod = 0),
            (this._lastDate = -1),
            (this._checkNextPeriod = !1),
            (this._remoteServerAddress = ""),
            (this._maxInterval = 1 / 30);
        }
        _updateTime() {
          const t = performance.now(),
            e = a.game.deltaTime,
            i = e > this._maxInterval ? this._maxInterval : e;
          t - this._lastDate > 1e3 * i &&
            ((this._totalNumThisPeriod = 0), (this._lastDate = t));
        }
        _handleQueue(t, e) {
          for (
            this._checkNextPeriod = !1, this._updateTime();
            this._queue.length > 0 &&
            this._totalNum < t &&
            this._totalNumThisPeriod < e;

          ) {
            this._queueDirty &&
              (this._queue.sort((t, e) => t.priority - e.priority),
              (this._queueDirty = !1));
            const t = this._queue.pop();
            if (!t) break;
            this._totalNum++,
              this._totalNumThisPeriod++,
              t.handler(_E(t.url, this.appendTimeStamp), t.options, t.done);
          }
          this._handleQueueInNextFrame(t, e);
        }
        _handleQueueInNextFrame(t, e) {
          !this._checkNextPeriod &&
            this._queue.length > 0 &&
            (Ie(this._handleQueue.bind(this), t, e),
            (this._checkNextPeriod = !0));
        }
      }
      FE._instance = void 0;
      const UE = FE.instance;
      var kE,
        zE,
        HE,
        GE = FE.instance;
      let VE = t(
        "JsonAsset",
        Ca("cc.JsonAsset")(
          ((zE = class extends Ad {
            constructor() {
              super(), (this.json = HE && HE());
            }
          }),
          (HE = fa(zE.prototype, "json", [Na], function () {
            return null;
          })),
          (kE = zE))
        ) || kE
      );
      var jE, WE, XE;
      a.JsonAsset = VE;
      let YE = t(
        "TextAsset",
        Ca("cc.TextAsset")(
          ((WE = class extends Ad {
            toString() {
              return this.text;
            }
            constructor() {
              super(), (this.text = XE && XE());
            }
          }),
          (XE = fa(WE.prototype, "text", [Na], function () {
            return "";
          })),
          (jE = WE))
        ) || jE
      );
      a.TextAsset = YE;
      const KE = t("BufferAsset", jsb.BufferAsset);
      function qE(t, e, i, s) {
        let n = null,
          r = null;
        try {
          (n = new wd()), (n._nativeUrl = t), (n._nativeAsset = e);
        } catch (t) {
          r = t;
        }
        s(r, n);
      }
      function $E(t, e, i, s) {
        const n = new VE();
        (n.json = e), s(null, n);
      }
      function ZE(t, e, i, s) {
        const n = new YE();
        (n.text = e), s(null, n);
      }
      function QE(t, e, i, s) {
        const n = new KE();
        (n._nativeUrl = t), (n._nativeAsset = e), s(null, n);
      }
      function JE(t, e, i, s) {
        const n = new Ad();
        (n._nativeUrl = t), (n._nativeAsset = e), s(null, n);
      }
      function tv(t, i, s, n) {
        let r = ed.get(i.name);
        r ||
          ((r = i.name === hd.RESOURCES ? vE : new EE()),
          (i.base = i.base || `${t}/`),
          r.init(i)),
          e
            .import(`virtual:///prerequisite-imports/${r.name}`)
            .then(() => {
              n(null, r);
            })
            .catch(n);
      }
      (a.BufferAsset = jsb.BufferAsset),
        (function (t, e = vd) {
          const { BufferAsset: i } = { ...t },
            s = Object.getOwnPropertyDescriptor(i.prototype, "_nativeAsset");
          e(
            () => {
              oo(i.prototype, "_nativeAsset", s);
            },
            "override",
            "_nativeAsset"
          ),
            e(
              () => {
                Ca("cc.BufferAsset")(i);
              },
              "ccclass",
              null
            );
        })({ BufferAsset: KE });
      var ev = new (class {
          constructor() {
            (this._creating = new $_()),
              (this._producers = {
                ".png": qE,
                ".jpg": qE,
                ".bmp": qE,
                ".jpeg": qE,
                ".gif": qE,
                ".ico": qE,
                ".tiff": qE,
                ".webp": qE,
                ".image": qE,
                ".pvr": qE,
                ".pkm": qE,
                ".astc": qE,
                ".txt": ZE,
                ".xml": ZE,
                ".vsh": ZE,
                ".fsh": ZE,
                ".atlas": ZE,
                ".tmx": ZE,
                ".tsx": ZE,
                ".fnt": ZE,
                ".json": $E,
                ".ExportJson": $E,
                ".binary": QE,
                ".bin": QE,
                ".dbbin": QE,
                ".skel": QE,
                bundle: tv,
                default: JE,
              });
          }
          register(t, e) {
            "object" == typeof t
              ? Mt(this._producers, t)
              : (this._producers[t] = e);
          }
          create(t, e, i, s, n) {
            const r = this._producers[i] || this._producers.default,
              a = Q_.get(t);
            if (!s.reloadAsset && a) return void n(null, a);
            const o = this._creating.get(t);
            o
              ? o.push(n)
              : (this._creating.add(t, [n]),
                r(t, e, s, (e, i) => {
                  !e &&
                    i instanceof Ad &&
                    ((i._uuid = t), mE(t, i, s.cacheAsset));
                  const n = this._creating.remove(t);
                  for (let t = 0, s = n.length; t < s; t++) n[t](e, i);
                }));
          }
        })(),
        iv = new (class {
          constructor() {
            (this._loading = new $_()),
              (this._unpackers = { ".json": this.unpackJson });
          }
          unpackJson(t, e, i, s) {
            const n = St(!0);
            let r = null;
            if (Array.isArray(e)) {
              (e = (function (t) {
                if (t[0] < 1) throw new Error(X(5304, t[0]));
                Np(t, !0, void 0, Bp.reportMissingClass), Lp(t);
                const e = new Fp(t[0]),
                  i = t[1],
                  s = t[2],
                  n = t[3],
                  r = t[4],
                  a = t[5];
                for (let t = 0; t < a.length; ++t) a[t].unshift(e, i, s, n, r);
                return a;
              })(e)).length !== t.length && G(4915);
              for (let i = 0; i < t.length; i++) n[`${t[i]}@import`] = e[i];
            } else {
              const i = qt(sm),
                a = qt(wd);
              if (e.type === i && e.data) {
                const s = e.data;
                s.length !== t.length && G(4915);
                for (let e = 0; e < t.length; e++)
                  n[`${t[e]}@import`] = Up(i, {
                    base: s[e][0],
                    mipmaps: s[e][1],
                  });
              } else {
                if (e.type !== a || !e.data)
                  return (
                    (r = new Error("unmatched type pack!")), void s(r, null)
                  );
                {
                  const i = e.data;
                  i.length !== t.length && G(4915);
                  for (let e = 0; e < t.length; e++) n[`${t[e]}@import`] = i[e];
                }
              }
            }
            s(r, n);
          }
          init() {
            this._loading.clear();
          }
          register(t, e) {
            "object" == typeof t
              ? Mt(this._unpackers, t)
              : (this._unpackers[t] = e);
          }
          unpack(t, e, i, s, n) {
            e
              ? (0, this._unpackers[i])(t, e, s, n)
              : n(new Error("package data is wrong!"));
          }
          load(t, e, i) {
            if (t.isNative || !t.info || !t.info.packs)
              return void GE.download(t.id, t.url, t.ext, t.options, i);
            if (J_.has(t.id)) return void i(null, J_.get(t.id));
            const s = t.info.packs,
              n = s.find((t) => this._loading.has(t.uuid));
            if (n)
              return void this._loading
                .get(n.uuid)
                .push({ onComplete: i, id: t.id });
            const r = s[0];
            this._loading.add(r.uuid, [{ onComplete: i, id: t.id }]), t.config;
            const a = Sd(r.uuid, { ext: r.ext, bundle: t.config.name });
            GE.download(r.uuid, a, r.ext, t.options, (e, i) => {
              J_.remove(r.uuid),
                e && R(e.message, e.stack),
                this.unpack(r.packedUuids, i, r.ext, t.options, (t, i) => {
                  if (!t) for (const t in i) J_.add(t, i[t]);
                  const s = this._loading.remove(r.uuid);
                  for (let n = 0, r = s.length; n < r; n++) {
                    const r = s[n];
                    if (e || t) {
                      r.onComplete(e || t);
                      continue;
                    }
                    const a = i[r.id];
                    a
                      ? r.onComplete(null, a)
                      : r.onComplete(
                          new Error("can not retrieve data from package")
                        );
                  }
                });
            });
          }
        })();
      function sv(t, e) {
        let i = !1;
        t.progress ||
          ((t.progress = { finish: 0, total: t.input.length, canInvoke: !0 }),
          (i = !0));
        const { options: s, progress: n } = t,
          r = [],
          o = n.total,
          h = (s.__exclude__ = s.__exclude__ || Object.create(null));
        (t.output = []),
          fE(
            t.input,
            (s, l) => {
              if (!s.isNative && Q_.has(s.uuid)) {
                const e = Q_.get(s.uuid);
                return (
                  e.addRef instanceof Function && (s.content = e.addRef()),
                  t.output.push(s),
                  n.canInvoke && t.dispatch("progress", ++n.finish, n.total, s),
                  void l()
                );
              }
              iv.load(s, t.options, (c, u) => {
                c
                  ? t.isFinished ||
                    (!a.assetManager.force || i
                      ? (R(c.message, c.stack), (n.canInvoke = !1), e(c))
                      : (t.output.push(s),
                        n.canInvoke &&
                          t.dispatch("progress", ++n.finish, n.total, s)))
                  : t.isFinished ||
                    ((s.file = u),
                    t.output.push(s),
                    s.isNative ||
                      ((h[s.uuid] = !0),
                      pE(s.uuid, u, h, r, s.config),
                      (n.total = o + r.length)),
                    n.canInvoke &&
                      t.dispatch("progress", ++n.finish, n.total, s)),
                  l();
              });
            },
            () => {
              if (t.isFinished) return uE(t, !0), void t.dispatch("error");
              if (r.length > 0) {
                const a = ld.create({
                  input: r,
                  progress: n,
                  options: s,
                  onProgress: t.onProgress,
                  onError: ld.prototype.recycle,
                  onComplete: (s) => {
                    s || (t.output.push(...a.output), a.recycle()),
                      i && nv(t),
                      e(s);
                  },
                });
                sd.async(a);
              } else i && nv(t), e();
            }
          );
      }
      function nv(t) {
        const e = t.output;
        for (let t = 0, i = e.length; t < i; t++)
          e[t].content && e[t].content.decRef(!1);
      }
      class rv {
        constructor() {
          (this._parser = null),
            globalThis.DOMParser && (this._parser = new DOMParser());
        }
        parse(t) {
          return this._parseXML(t);
        }
        _parseXML(t) {
          if (this._parser) return this._parser.parseFromString(t, "text/xml");
          throw new Error("Dom parser is not supported in this platform!");
        }
      }
      const av = new (class extends rv {
        parse(t) {
          const e = this._parseXML(t).documentElement;
          if ("plist" !== e.tagName) return z(5100), {};
          let i = null;
          for (
            let t = 0, s = e.childNodes.length;
            t < s && ((i = e.childNodes[t]), 1 !== i.nodeType);
            t++
          );
          return this._parseNode(i);
        }
        _parseNode(t) {
          let e = null;
          const i = t.tagName;
          if ("dict" === i) e = this._parseDict(t);
          else if ("array" === i) e = this._parseArray(t);
          else if ("string" === i)
            if (1 === t.childNodes.length) e = t.firstChild.nodeValue;
            else {
              e = "";
              for (let i = 0; i < t.childNodes.length; i++)
                e += t.childNodes[i].nodeValue;
            }
          else
            "false" === i
              ? (e = !1)
              : "true" === i
              ? (e = !0)
              : "real" === i
              ? (e = parseFloat(t.firstChild.nodeValue))
              : "integer" === i && (e = parseInt(t.firstChild.nodeValue, 10));
          return e;
        }
        _parseArray(t) {
          const e = [];
          for (let i = 0, s = t.childNodes.length; i < s; i++) {
            const s = t.childNodes[i];
            1 === s.nodeType && e.push(this._parseNode(s));
          }
          return e;
        }
        _parseDict(t) {
          const e = {};
          let i = "";
          for (let s = 0, n = t.childNodes.length; s < n; s++) {
            const n = t.childNodes[s];
            1 === n.nodeType &&
              ("key" === n.tagName
                ? (i = n.firstChild.nodeValue)
                : (e[i] = this._parseNode(n)));
          }
          return e;
        }
      })();
      class ov {
        static get instance() {
          return this._instance || (this._instance = new ov()), this._instance;
        }
        constructor() {
          (this._parsing = new $_()),
            (this._parsers = {
              ".png": this.parseImage,
              ".jpg": this.parseImage,
              ".bmp": this.parseImage,
              ".jpeg": this.parseImage,
              ".gif": this.parseImage,
              ".ico": this.parseImage,
              ".tiff": this.parseImage,
              ".webp": this.parseImage,
              ".image": this.parseImage,
              ".pvr": this.parsePVRTex,
              ".pkm": this.parsePKMTex,
              ".astc": this.parseASTCTex,
              ".plist": this.parsePlist,
              import: this.parseImport,
              ".ccon": this.parseImport,
              ".cconb": this.parseImport,
            });
        }
        parseImage(t, e, i) {
          t instanceof HTMLImageElement
            ? i(null, t)
            : createImageBitmap(t, { premultiplyAlpha: "none" }).then(
                (t) => {
                  i(null, t);
                },
                (t) => {
                  i(t, null);
                }
              );
        }
        parsePVRTex(t, e, i) {
          let s = null,
            n = null;
          try {
            n = wd.parseCompressedTextures(t, 0);
          } catch (t) {
            (s = t), w(s);
          }
          i(s, n);
        }
        parsePKMTex(t, e, i) {
          let s = null,
            n = null;
          try {
            n = wd.parseCompressedTextures(t, 1);
          } catch (t) {
            (s = t), w(s);
          }
          i(s, n);
        }
        parseASTCTex(t, e, i) {
          let s = null,
            n = null;
          try {
            n = wd.parseCompressedTextures(t, 2);
          } catch (t) {
            (s = t), w(s);
          }
          i(s, n);
        }
        parsePlist(t, e, i) {
          let s = null;
          const n = av.parse(t);
          n || (s = new Error("parse failed")), i(s, n);
        }
        parseImport(t, e, i) {
          if (!t)
            return void i(
              new Error(
                `The json file of asset ${e.__uuid__} is empty or missing`
              )
            );
          let s = null,
            n = null;
          try {
            s = Gp(t, e);
          } catch (t) {
            n = t;
          }
          i(n, s);
        }
        init() {
          this._parsing.clear();
        }
        register(t, e) {
          "object" == typeof t ? Mt(this._parsers, t) : (this._parsers[t] = e);
        }
        parse(t, e, i, s, n) {
          const r = td.get(t);
          if (r) return void n(null, r);
          const a = this._parsing.get(t);
          if (a) return void a.push(n);
          const o = this._parsers[i];
          o
            ? (this._parsing.add(t, [n]),
              o(e, s, (e, i) => {
                e ? J_.remove(t) : yd(i) || td.add(t, i);
                const s = this._parsing.remove(t);
                for (let t = 0, n = s.length; t < n; t++) s[t](e, i);
              }))
            : n(null, e);
        }
      }
      ov._instance = void 0;
      var hv = ov.instance;
      function lv(t, e) {
        let i = !1;
        t.progress ||
          ((t.progress = { finish: 0, total: t.input.length, canInvoke: !0 }),
          (i = !0));
        const { options: s, progress: n } = t;
        (s.__exclude__ = s.__exclude__ || Object.create(null)),
          (t.output = []),
          fE(
            t.input,
            (r, o) => {
              const h = ld.create({
                input: r,
                onProgress: t.onProgress,
                options: s,
                progress: n,
                onComplete: (s, l) => {
                  s &&
                    !t.isFinished &&
                    (!a.assetManager.force || i
                      ? (R(s.message, s.stack), (n.canInvoke = !1), e(s))
                      : n.canInvoke &&
                        t.dispatch("progress", ++n.finish, n.total, r)),
                    t.output.push(l),
                    h.recycle(),
                    o(null);
                },
              });
              cv.async(h);
            },
            () => {
              if (((s.__exclude__ = null), t.isFinished))
                return uE(t, !0), void t.dispatch("error");
              !(function (t) {
                const e = t.source;
                if (t.options.__outputAsArray__ || 1 !== e.length) {
                  const i = (t.output = []);
                  for (let t = 0, s = e.length; t < s; t++)
                    i.push(e[t].content);
                } else t.output = e[0].content;
              })(t),
                uE(t, !0),
                e();
            }
          );
      }
      const cv = new Z_("loadOneAsset", [
        function (t, e) {
          const i = (t.output = t.input),
            { options: s, isNative: n, uuid: r, file: a } = i,
            { reloadAsset: o } = s;
          a || (!o && !n && Q_.has(r))
            ? e()
            : iv.load(i, t.options, (t, s) => {
                (i.file = s), e(t);
              });
        },
        function (t, e) {
          const i = (t.output = t.input),
            s = t.progress,
            n = t.options.__exclude__,
            { id: r, file: o, options: h } = i;
          if (i.isNative)
            hv.parse(r, o, i.ext, h, (n, a) => {
              n
                ? e(n)
                : ((i.content = a),
                  s.canInvoke && t.dispatch("progress", ++s.finish, s.total, i),
                  J_.remove(r),
                  td.remove(r),
                  e());
            });
          else {
            const { uuid: l } = i;
            if (l in n) {
              const { finish: r, content: a, err: o, callbacks: h } = n[l];
              s.canInvoke && t.dispatch("progress", ++s.finish, s.total, i),
                r || TE(l, l, n)
                  ? (a && a.addRef(), (i.content = a), e(o))
                  : h.push({ done: e, item: i });
            } else if (!h.reloadAsset && Q_.has(l)) {
              const n = Q_.get(l);
              (i.content = n.addRef()),
                s.canInvoke && t.dispatch("progress", ++s.finish, s.total, i),
                e();
            } else
              (h.__uuid__ = l),
                hv.parse(r, o, "import", h, (i, s) => {
                  i
                    ? e(i)
                    : (function (t, e, i) {
                        const { input: s, progress: n } = t,
                          { uuid: r, id: o, options: h, config: l } = s,
                          { cacheAsset: c } = h,
                          u = [];
                        e.addRef && e.addRef(),
                          pE(r, e, Object.create(null), u, l),
                          n.canInvoke &&
                            t.dispatch(
                              "progress",
                              ++n.finish,
                              (n.total += u.length),
                              s
                            );
                        const _ = (t.options.__exclude__[r] = {
                            content: e,
                            finish: !1,
                            callbacks: [{ done: i, item: s }],
                          }),
                          d = ld.create({
                            input: u,
                            options: t.options,
                            onProgress: t.onProgress,
                            onError: ld.prototype.recycle,
                            progress: n,
                            onComplete: (t) => {
                              if (
                                (e.decRef && e.decRef(!1),
                                (_.finish = !0),
                                (_.err = t),
                                !t)
                              ) {
                                const t = Array.isArray(d.output)
                                    ? d.output
                                    : [d.output],
                                  i = Object.create(null);
                                for (const e of t)
                                  e &&
                                    (i[
                                      e instanceof Ad
                                        ? `${e._uuid}@import`
                                        : `${r}@native`
                                    ] = e);
                                !(function (t, e, i) {
                                  let s = !1;
                                  const n = kp.get(e);
                                  if (n) {
                                    for (let t = 0, r = n.length; t < r; t++) {
                                      const r = n[t],
                                        o = i[`${r.uuid}@import`];
                                      if (o) r.owner[r.prop] = o.addRef();
                                      else {
                                        if (
                                          (G(16350, r.uuid),
                                          a.assetManager.dispatchAssetMissing(
                                            e,
                                            r.owner,
                                            r.prop,
                                            r.uuid
                                          ),
                                          r.type && r.type !== Ad)
                                        ) {
                                          const t = new r.type();
                                          t.initDefault(r.uuid),
                                            (r.owner[r.prop] = t);
                                        }
                                        s = !0;
                                      }
                                    }
                                    kp.delete(e);
                                  }
                                  zp.has(e) &&
                                    (i[`${t}@native`]
                                      ? (e._nativeAsset = i[`${t}@native`])
                                      : ((s = !0), G(16351, t)),
                                    zp.delete(e));
                                })(r, e, i);
                                try {
                                  "function" != typeof e.onLoaded ||
                                    Hp.has(e) ||
                                    zp.has(e) ||
                                    (e.onLoaded(), Hp.add(e));
                                } catch (t) {
                                  G(16352, r, t.message, t.stack);
                                }
                                J_.remove(o),
                                  td.remove(o),
                                  mE(r, e, c),
                                  d.recycle();
                              }
                              const i = _.callbacks;
                              for (let s = 0, n = i.length; s < n; s++) {
                                const n = i[s];
                                e.addRef && e.addRef(),
                                  (n.item.content = e),
                                  n.done(t);
                              }
                              i.length = 0;
                            },
                          });
                        id.async(d);
                      })(t, s, e);
                });
          }
        },
      ]);
      function uv(t, e) {
        const i = t.options,
          s = Object.create(null),
          n = Object.create(null);
        for (const t in i)
          switch (t) {
            case ad.PATH:
            case ad.UUID:
            case ad.DIR:
            case ad.SCENE:
            case ad.URL:
              break;
            case "__requestType__":
            case "__isNative__":
            case "ext":
            case "type":
            case "__nativeName__":
            case "audioLoadMode":
            case "bundle":
              s[t] = i[t];
              break;
            case "__exclude__":
            case "__outputAsArray__":
              n[t] = i[t];
              break;
            default:
              (s[t] = i[t]), (n[t] = i[t]);
          }
        t.options = n;
        const r = ld.create({ input: t.input, options: s });
        let a = null;
        try {
          t.output = t.source = nd.sync(r);
        } catch (t) {
          a = t;
          for (let t = 0, e = r.output.length; t < e; t++)
            r.output[t].recycle();
        }
        r.recycle(), e(a);
      }
      class _v {
        constructor() {
          (this.uuid = ""),
            (this.overrideUuid = ""),
            (this.url = ""),
            (this.ext = ".json"),
            (this.content = null),
            (this.file = null),
            (this.info = null),
            (this.config = null),
            (this.isNative = !1),
            (this.options = Object.create(null)),
            (this._id = "");
        }
        get id() {
          return (
            this._id ||
              (this._id = `${this.overrideUuid || this.uuid}@${
                this.isNative ? "native" : "import"
              }`),
            this._id
          );
        }
        static create() {
          let t;
          return (
            (t = 0 !== _v._deadPool.length ? _v._deadPool.pop() : new _v()), t
          );
        }
        recycle() {
          _v._deadPool.length !== _v.MAX_DEAD_NUM &&
            ((this._id = ""),
            (this.uuid = ""),
            (this.overrideUuid = ""),
            (this.url = ""),
            (this.ext = ".json"),
            (this.content = null),
            (this.file = null),
            (this.info = null),
            (this.config = null),
            (this.isNative = !1),
            (this.options = Object.create(null)),
            _v._deadPool.push(this));
        }
      }
      (_v.MAX_DEAD_NUM = 500), (_v._deadPool = []);
      const dv = [];
      function pv(t) {
        var e;
        const i = t.options,
          s = Array.isArray(t.input) ? t.input : [t.input];
        t.output = [];
        for (let r = 0; r < s.length; r++) {
          let a = s[r],
            o = _v.create(),
            h = null,
            l = null;
          if (
            ("string" == typeof a &&
              ((a = Object.create(null)),
              (a[i.__requestType__ || ad.UUID] = s[r])),
            "object" == typeof a)
          ) {
            xt(a, i), a.preset && xt(a, od[a.preset]);
            for (const t in a) {
              switch (t) {
                case ad.UUID: {
                  var n;
                  const t = (o.uuid = pd(a.uuid));
                  if (!a.bundle) {
                    const e = ed.find((e) => !!e.getAssetInfo(t));
                    a.bundle = e && e.name;
                  }
                  if (ed.has(a.bundle)) {
                    if (
                      ((h = ed.get(a.bundle).config),
                      (l = h.getAssetInfo(t)),
                      l && l.redirect)
                    ) {
                      if (!ed.has(l.redirect))
                        throw new Error(
                          `Please load bundle ${l.redirect} first`
                        );
                      (h = ed.get(l.redirect).config), (l = h.getAssetInfo(t));
                    }
                    (o.config = h), (o.info = l);
                  }
                  o.ext =
                    a.ext ||
                    (null === (n = l) || void 0 === n ? void 0 : n.extension) ||
                    ".json";
                  break;
                }
                case "__requestType__":
                case "ext":
                case "bundle":
                case "preset":
                case "type":
                  break;
                case ad.DIR:
                  if (ed.has(a.bundle)) {
                    ed.get(a.bundle).config.getDirWithPath(a.dir, a.type, dv);
                    for (const t of dv)
                      s.push({
                        uuid: t.uuid,
                        __isNative__: !1,
                        ext: t.extension || ".json",
                        bundle: a.bundle,
                      });
                    dv.length = 0;
                  }
                  o.recycle(), (o = null);
                  break;
                case ad.PATH:
                  if (ed.has(a.bundle)) {
                    if (
                      ((h = ed.get(a.bundle).config),
                      (l = h.getInfoWithPath(a.path, a.type)),
                      l && l.redirect)
                    ) {
                      if (!ed.has(l.redirect))
                        throw new Error(
                          `you need to load bundle ${l.redirect} first`
                        );
                      (h = ed.get(l.redirect).config),
                        (l = h.getAssetInfo(l.uuid));
                    }
                    if (!l)
                      throw (
                        (o.recycle(),
                        new Error(
                          `Bundle ${a.bundle} doesn't contain ${a.path}`
                        ))
                      );
                    (o.config = h), (o.uuid = l.uuid), (o.info = l);
                  }
                  o.ext =
                    a.ext ||
                    (null === (e = l) || void 0 === e ? void 0 : e.extension) ||
                    ".json";
                  break;
                case ad.SCENE:
                  if (!a.bundle) {
                    const t = ed.find((t) => !!t.getSceneInfo(a.scene));
                    a.bundle = t && t.name;
                  }
                  if (ed.has(a.bundle)) {
                    if (
                      ((h = ed.get(a.bundle).config),
                      (l = h.getSceneInfo(a.scene)),
                      l && l.redirect)
                    ) {
                      if (!ed.has(l.redirect))
                        throw new Error(
                          `you need to load bundle ${l.redirect} first`
                        );
                      (h = ed.get(l.redirect).config),
                        (l = h.getAssetInfo(l.uuid));
                    }
                    if (!l)
                      throw (
                        (o.recycle(),
                        new Error(
                          `Bundle ${h.name} doesn't contain scene ${a.scene}`
                        ))
                      );
                    (o.config = h), (o.uuid = l.uuid), (o.info = l);
                  }
                  break;
                case "__isNative__":
                  o.isNative = a.__isNative__;
                  break;
                case ad.URL:
                  (o.url = a.url),
                    (o.uuid = a.uuid || a.url),
                    (o.ext = a.ext || br(a.url)),
                    (o.isNative = void 0 === a.__isNative__ || a.__isNative__);
                  break;
                default:
                  o.options[t] = a[t];
              }
              if (!o) break;
            }
          }
          if (o && (t.output.push(o), !o.uuid && !o.url))
            throw new Error(`Can not parse this input:${JSON.stringify(a)}`);
        }
        return null;
      }
      function mv(t) {
        const e = (t.output = t.input);
        for (let t = 0; t < e.length; t++) {
          const s = e[t];
          if (rd.has(s.uuid)) {
            const t = rd.get(s.uuid),
              e = ed.find((e) => !!e.getAssetInfo(t));
            if (e) {
              var i;
              s.overrideUuid = t;
              let n = e.config,
                r = n.getAssetInfo(t);
              if (r && r.redirect) {
                if (!ed.has(r.redirect))
                  throw new Error(`Please load bundle ${r.redirect} first`);
                (n = ed.get(r.redirect).config), (r = n.getAssetInfo(t));
              }
              (s.config = n),
                (s.info = r),
                (s.ext = s.isNative
                  ? s.ext
                  : (null === (i = r) || void 0 === i ? void 0 : i.extension) ||
                    ".json");
            } else z(16201, t, s.uuid);
          }
        }
      }
      function fv(t) {
        const e = (t.output = t.input);
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          if (i.url) continue;
          let s = "",
            n = "";
          const r = i.config;
          n = i.isNative
            ? r && r.nativeBase
              ? r.base + r.nativeBase
              : a.assetManager.generalNativeBase
            : r && r.importBase
            ? r.base + r.importBase
            : a.assetManager.generalImportBase;
          const o = i.overrideUuid || i.uuid;
          let h = "";
          i.info &&
            (h = i.isNative
              ? i.info.nativeVer
                ? `.${i.info.nativeVer}`
                : ""
              : i.info.ver
              ? `.${i.info.ver}`
              : ""),
            (s =
              ".ttf" === i.ext
                ? `${n}/${o.slice(0, 2)}/${o}${h}/${i.options.__nativeName__}`
                : `${n}/${o.slice(0, 2)}/${o}${h}${i.ext}`),
            (i.url = s);
        }
        return null;
      }
      const gv = "asset-missing";
      class yv {
        static get instance() {
          return this._instance || (this._instance = new yv()), this._instance;
        }
        constructor() {
          (this.pipeline = id.append(uv).append(lv)),
            (this.fetchPipeline = sd.append(uv).append(sv)),
            (this.transformPipeline = nd.append(pv).append(mv).append(fv)),
            (this.bundles = ed),
            (this.assets = Q_),
            (this.assetsOverrideMap = rd),
            (this.generalImportBase = ""),
            (this.generalNativeBase = ""),
            (this.dependUtil = jp),
            (this.force = !1),
            (this.allowImageBitmap = !1),
            (this.utils = Ed),
            (this.downloader = GE),
            (this.parser = hv),
            (this.packManager = iv),
            (this.cacheAsset = !0),
            (this.cacheManager = null),
            (this.presets = od),
            (this.factory = ev),
            (this.preprocessPipe = uv),
            (this.fetchPipe = sv),
            (this.loadPipe = lv),
            (this.references = null),
            (this._releaseManager = lE),
            (this._files = J_),
            (this._parsed = td),
            (this._parsePipeline = null),
            (this._projectBundles = []),
            (this._eventTarget = new hr());
        }
        get main() {
          return ed.get(hd.MAIN) || null;
        }
        get resources() {
          return ed.get(hd.RESOURCES) || null;
        }
        onAssetMissing(t, e) {
          this._eventTarget.on(gv, t, e);
        }
        offAssetMissing(t, e) {
          this._eventTarget.off(gv, t, e);
        }
        dispatchAssetMissing(t, e, i, s) {
          this._eventTarget.emit(gv, t, e, i, s);
        }
        init(t = {}) {
          const e =
              t.server || ge.querySettings(fe.Category.ASSETS, "server") || "",
            i =
              t.bundleVers ||
              ge.querySettings(fe.Category.ASSETS, "bundleVers") ||
              {},
            s =
              t.remoteBundles ||
              ge.querySettings(fe.Category.ASSETS, "remoteBundles") ||
              [],
            n =
              t.downloadMaxConcurrency ||
              ge.querySettings(fe.Category.ASSETS, "downloadMaxConcurrency");
          n && n > 0 && (this.downloader.maxConcurrency = n),
            a.sys.os === a.sys.OS.IOS &&
              (this.downloader.maxConcurrency = 1500),
            this._files.clear(),
            this._parsed.clear(),
            this._releaseManager.init(),
            this.assets.clear(),
            this.bundles.clear(),
            this.packManager.init(),
            this.downloader.init(e, i, s),
            this.parser.init(),
            this.dependUtil.init();
          let r =
            t.importBase ||
            ge.querySettings(fe.Category.ASSETS, "importBase") ||
            "";
          r && r.endsWith("/") && (r = r.substr(0, r.length - 1));
          let o =
            t.nativeBase ||
            ge.querySettings(fe.Category.ASSETS, "nativeBase") ||
            "";
          o && o.endsWith("/") && (o = o.substr(0, o.length - 1)),
            (this.generalImportBase = r),
            (this.generalNativeBase = o),
            (this._projectBundles =
              ge.querySettings(fe.Category.ASSETS, "projectBundles") || []);
          const h =
            ge.querySettings(fe.Category.ASSETS, "assetsOverrides") || {};
          for (const t in h) this.assetsOverrideMap.set(t, h[t]);
        }
        getBundle(t) {
          return ed.get(t) || null;
        }
        removeBundle(t) {
          t._destroy(), ed.remove(t.name);
        }
        loadAny(t, e, i, s) {
          const { options: n, onProgress: r, onComplete: a } = gE(e, i, s);
          (n.preset = n.preset || "default"),
            (t = Array.isArray(t) ? t.slice() : t);
          const o = ld.create({
            input: t,
            onProgress: r,
            onComplete: SE(a),
            options: n,
          });
          id.async(o);
        }
        preloadAny(t, e, i, s) {
          const { options: n, onProgress: r, onComplete: a } = gE(e, i, s);
          (n.preset = n.preset || "preload"),
            (t = Array.isArray(t) ? t.slice() : t);
          const o = ld.create({
            input: t,
            onProgress: r,
            onComplete: SE(a),
            options: n,
          });
          sd.async(o);
        }
        loadRemote(t, e, i) {
          const { options: s, onComplete: n } = gE(e, void 0, i);
          s.reloadAsset || !this.assets.has(t)
            ? ((s.__isNative__ = !0),
              (s.preset = s.preset || "remote"),
              this.loadAny({ url: t }, s, null, (e, i) => {
                e
                  ? (R(e.message, e.stack), n && n(e, i))
                  : ev.create(t, i, s.ext || br(t), s, (t, e) => {
                      n && n(t, e);
                    });
              }))
            : SE(n)(null, this.assets.get(t));
        }
        loadBundle(t, e, i) {
          const { options: s, onComplete: n } = gE(e, void 0, i),
            r = Cr(t);
          this.bundles.has(r)
            ? SE(n)(null, this.getBundle(r))
            : ((s.preset = s.preset || "bundle"),
              (s.ext = "bundle"),
              (s.__isNative__ = !0),
              this.loadAny({ url: t }, s, null, (e, i) => {
                e
                  ? (R(e.message, e.stack), n && n(e, i))
                  : ev.create(t, i, "bundle", s, (t, e) => {
                      n && n(t, e);
                    });
              }));
        }
        releaseAsset(t) {
          lE.tryRelease(t, !0);
        }
        releaseUnusedAssets() {
          Q_.forEach((t) => {
            lE.tryRelease(t);
          });
        }
        releaseAll() {
          Q_.forEach((t) => {
            lE.tryRelease(t, !0);
          });
        }
        loadWithJson(t, e, i, s) {
          throw new Error("Only valid in Editor");
        }
      }
      t("AssetManager", yv),
        (yv._instance = void 0),
        (yv.Pipeline = Z_),
        (yv.Task = ld),
        (yv.Cache = $_),
        (yv.RequestItem = _v),
        (yv.Bundle = EE),
        (yv.BuiltinBundleName = hd),
        (yv.CacheManager = class {
          constructor() {
            (this.cacheDir = void 0),
              (this.cacheEnabled = void 0),
              (this.autoClear = void 0),
              (this.cacheInterval = void 0),
              (this.deleteInterval = void 0),
              (this.cachedFiles = void 0);
          }
        }),
        (yv.Downloader = FE),
        (yv.Parser = ov),
        (yv.DependUtil = Vp);
      const Tv = t("assetManager", (a.assetManager = yv.instance));
      a.AssetManager = yv;
      const Sv = [
          ".png",
          ".jpg",
          ".bmp",
          ".jpeg",
          ".gif",
          ".ico",
          ".tiff",
          ".webp",
          ".image",
          ".pvr",
          ".pkm",
          ".astc",
        ],
        Ev = [".mp3", ".ogg", ".wav", ".m4a"];
      function vv() {
        return !0;
      }
      const bv = {
        transformURL(t) {
          const e = fd(t);
          if (!e) return t;
          const i = ed.find((t) => !!t.getAssetInfo(e));
          if (!i) return t;
          let s = "";
          const n = i.getAssetInfo(e);
          if (
            ((s = t.startsWith(i.base + i.config.nativeBase)
              ? n.nativeVer || ""
              : n.ver || ""),
            !s || -1 !== t.indexOf(s))
          )
            return t;
          let r = !1;
          if ((".ttf" === br(t) && (r = !0), r)) {
            const e = Or(t),
              i = Cr(t);
            t = `${e}.${s}/${i}`;
          } else
            t = t.replace(
              /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,})/,
              (t) => `${t}.${s}`
            );
          return t;
        },
      };
      class Av {
        constructor() {
          (this._autoReleaseSetting = Object.create(null)),
            (this._parseLoadResArgs = yE);
        }
        set onProgress(t) {
          cE = t;
        }
        get _cache() {
          if (Q_ instanceof $_) return Q_.map;
          {
            const t = {};
            return (
              Q_.forEach((e, i) => {
                t[i] = e;
              }),
              t
            );
          }
        }
        load(t, e, i) {
          void 0 === i && void 0 !== e && ((i = e), (e = null));
          const s = Array.isArray(t) ? t : [t];
          for (let t = 0; t < s.length; t++) {
            const e = s[t];
            "string" == typeof e
              ? (s[t] = { url: e, __isNative__: !0 })
              : (e.type && ((e.ext = `.${e.type}`), (e.type = void 0)),
                e.url && (e.__isNative__ = !0));
          }
          const n = [],
            r = [];
          Tv.loadAny(
            s,
            null,
            (t, i, s) => {
              s.content &&
                (Sv.includes(s.ext)
                  ? n.push(s.content)
                  : Ev.includes(s.ext) && r.push(s.content)),
                e && e(t, i, s);
            },
            (t, e) => {
              let a = null;
              if (!t) {
                e = Array.isArray(e) ? e : [e];
                for (let t = 0; t < e.length; t++) {
                  const i = e[t];
                  if (!(i instanceof Ad)) {
                    let a = i;
                    const o = s[t].url;
                    n.includes(a)
                      ? ev.create(o, i, ".png", {}, (i, s) => {
                          a = e[t] = s;
                        })
                      : r.includes(a) &&
                        ev.create(o, i, ".mp3", {}, (i, s) => {
                          a = e[t] = s;
                        }),
                      Q_.add(o, a);
                  }
                }
                if (e.length > 1) {
                  const t = Object.create(null);
                  e.forEach((e) => {
                    t[e._uuid] = e;
                  }),
                    (a = { isCompleted: vv, _map: t });
                } else a = e[0];
              }
              i && i(t, a);
            }
          );
        }
        getXMLHttpRequest() {
          return new XMLHttpRequest();
        }
        getItem(t) {
          return Tv.assets.has(t) ? { content: Tv.assets.get(t) } : null;
        }
        loadRes(t, e, i, s) {
          const {
              type: n,
              onProgress: r,
              onComplete: a,
            } = this._parseLoadResArgs(e, i, s),
            o = br(t);
          o && !vE.getInfoWithPath(t, n) && (t = t.slice(0, -o.length)),
            vE.load(t, n, r, a);
        }
        loadResArray(t, e, i, s) {
          const {
            type: n,
            onProgress: r,
            onComplete: a,
          } = this._parseLoadResArgs(e, i, s);
          t.forEach((e, i) => {
            const s = br(e);
            s && !vE.getInfoWithPath(e, n) && (t[i] = e.slice(0, -s.length));
          }),
            vE.load(t, n, r, a);
        }
        loadResDir(t, e, i, s) {
          const {
            type: n,
            onProgress: r,
            onComplete: a,
          } = this._parseLoadResArgs(e, i, s);
          vE.loadDir(t, n, r, (e, i) => {
            let s = [];
            e || (s = vE.getDirWithPath(t, n).map((t) => t.path)),
              a && a(e, i, s);
          });
        }
        getRes(t, e) {
          return Q_.has(t) ? Q_.get(t) : vE.get(t, e);
        }
        getResCount() {
          return Q_.count;
        }
        getDependsRecursively(t) {
          if (!t) return [];
          const e = "string" == typeof t ? t : t._uuid;
          return jp.getDepsRecursively(e).concat([e]);
        }
        get md5Pipe() {
          return bv;
        }
        get downloader() {
          return GE;
        }
        get loader() {
          return Tv.parser;
        }
        addDownloadHandlers(t) {
          const e = Object.create(null);
          for (const i in t) {
            const s = t[i];
            e[`.${i}`] = (t, e, i) => {
              s({ url: t }, i);
            };
          }
          GE.register(e);
        }
        addLoadHandlers(t) {
          const e = Object.create(null);
          for (const i in t) {
            const s = t[i];
            e[`.${i}`] = (t, e, i) => {
              s({ content: t }, i);
            };
          }
          hv.register(e);
        }
        release(t) {
          if (Array.isArray(t))
            for (let e = 0; e < t.length; e++) {
              let i = t[e];
              "string" == typeof i && (i = Q_.get(i)), Tv.releaseAsset(i);
            }
          else
            t && ("string" == typeof t && (t = Q_.get(t)), Tv.releaseAsset(t));
        }
        releaseAsset(t) {
          Tv.releaseAsset(t);
        }
        releaseRes(t, e) {
          vE.release(t, e);
        }
        releaseAll() {
          Tv.releaseAll(), Q_.clear();
        }
        removeItem(t) {
          return !!Q_.remove(t);
        }
        setAutoRelease(t, e) {
          "object" == typeof t && (t = t._uuid),
            (this._autoReleaseSetting[t] = !!e);
        }
        setAutoReleaseRecursively(t, e) {
          "object" == typeof t && (t = t._uuid),
            (e = !!e),
            (this._autoReleaseSetting[t] = e);
          const i = jp.getDepsRecursively(t);
          for (let t = 0; t < i.length; t++) this._autoReleaseSetting[i[t]] = e;
        }
        isAutoRelease(t) {
          return (
            "object" == typeof t && (t = t._uuid), !!this._autoReleaseSetting[t]
          );
        }
      }
      t("CCLoader", Av);
      const Cv = t("loader", new Av()),
        Ov = t("AssetLibrary", {
          init(t) {
            (t.importBase = t.libraryPath),
              (t.nativeBase = t.rawAssetsBase),
              Tv.init(t),
              t.rawAssets &&
                vE.init({
                  base: "",
                  deps: [],
                  scenes: {},
                  redirect: [],
                  debug: !0,
                  packs: {},
                  types: [],
                  versions: { import: [], native: [] },
                  name: hd.RESOURCES,
                  importBase: t.importBase,
                  nativeBase: t.nativeBase,
                  paths: t.rawAssets.assets,
                  uuids: Object.keys(t.rawAssets.assets),
                  extensionMap: {},
                });
          },
          loadAsset(t, e, i) {
            Tv.loadAny(t, e);
          },
        }),
        Iv = t("url", {});
      $(Iv, "url", [
        {
          name: "normalize",
          target: Tv.utils,
          targetName: "assetManager.utils",
          newName: "normalize",
        },
        {
          name: "raw",
          targetName: "Asset.prototype",
          newName: "nativeUrl",
          customFunction: (t) =>
            t.startsWith("resources/")
              ? Sd({
                  path: Ir(t.substr(10)),
                  bundle: hd.RESOURCES,
                  __isNative__: !0,
                  ext: br(t),
                })
              : "",
        },
      ]),
        Z(Ov, "AssetLibrary", [
          {
            name: "getLibUrlNoExt",
            suggest:
              "AssetLibrary.getLibUrlNoExt was removed, if you want to transform url, please use assetManager.utils.getUrlWithUuid instead",
          },
          {
            name: "queryAssetInfo",
            suggest: "AssetLibrary.queryAssetInfo was removed",
          },
        ]),
        Z(Cv, "loader", [
          {
            name: "releaseResDir",
            suggest:
              "loader.releaseResDir was removed, please use assetManager.releaseAsset instead",
          },
          { name: "flowInDeps", suggest: "loader.flowInDeps was removed" },
          {
            name: "assetLoader",
            suggest:
              "loader.assetLoader was removed, assetLoader and md5Pipe were merged into assetManager.transformPipeline",
          },
        ]),
        $(a, "cc", [
          {
            name: "loader",
            newName: "assetManager",
            logTimes: 1,
            customGetter: () => Cv,
          },
          {
            name: "AssetLibrary",
            newName: "assetManager",
            logTimes: 1,
            customGetter: () => Ov,
          },
          {
            name: "Pipeline",
            target: yv,
            targetName: "AssetManager",
            newName: "Pipeline",
            logTimes: 1,
          },
          {
            name: "url",
            targetName: "assetManager",
            newName: "utils",
            logTimes: 1,
            customGetter: () => Iv,
          },
        ]),
        Z(a, "cc", [
          {
            name: "LoadingItems",
            suggest: X(1400, "LoadingItems", "AssetManager.Task"),
          },
        ]),
        $(Te, "macro", [
          {
            name: "DOWNLOAD_MAX_CONCURRENT",
            target: GE,
            targetName: "assetManager.downloader",
            newName: "maxConcurrency",
          },
        ]);
      const wv = lE._autoRelease;
      lE._autoRelease = function (t, e, i) {
        wv.call(lE, t, e, i);
        const s = Cv._autoReleaseSetting,
          n = Object.keys(s);
        for (let t = 0; t < n.length; t++) {
          const e = n[t];
          if (!0 === s[e]) {
            const t = Q_.get(e);
            t && lE.tryRelease(t);
          }
        }
      };
      const Rv = jsb.Texture2D,
        Dv = jsb.ImageAsset,
        xv = jsb.BuiltinResMgr,
        Mv = xv.prototype;
      (Mv.init = function () {
        (this._resources = {}), (this._materialsToBeCompiled = []);
        const t = this._resources,
          e = new Uint8Array(16);
        for (let t = 0; t < 4; t++) {
          const i = 4 * t;
          (e[i] = 0), (e[i + 1] = 0), (e[i + 2] = 0), (e[i + 3] = 255);
        }
        const i = {
            width: 2,
            height: 2,
            _data: e,
            _compressed: !1,
            format: Rv.PixelFormat.RGBA8888,
          },
          s = new Dv(i),
          n = new Rv();
        if (
          ((n._uuid = "black-texture"),
          (n.image = s),
          (t[n._uuid] = n),
          a.SpriteFrame)
        ) {
          const e = new a.SpriteFrame(),
            i = s,
            n = new Rv();
          (n.image = i),
            (e.texture = n),
            (e._uuid = "default-spriteframe"),
            (t[e._uuid] = e);
        }
        this.initBuiltinRes();
      }),
        (Mv.get = function (t) {
          return this._resources[t] || this.getAsset(t);
        }),
        (Mv.compileBuiltinMaterial = function () {
          for (let t = 0; t < this._materialsToBeCompiled.length; ++t) {
            const e = this._materialsToBeCompiled[t];
            for (let t = 0; t < e.passes.length; ++t) e.passes[t].tryCompile();
          }
          this._materialsToBeCompiled.length = 0;
        }),
        (Mv.loadBuiltinAssets = function () {
          const t = ge.querySettings(fe.Category.ENGINE, "builtinAssets");
          if (!t) return Promise.resolve();
          const e = this._resources;
          return new Promise((i, s) => {
            Tv.loadBundle(hd.INTERNAL, (n) => {
              n
                ? s(n)
                : Tv.loadAny(t, (t, n) => {
                    t
                      ? s(t)
                      : (n.forEach((t) => {
                          (e[t.name] = t),
                            t.nativeUrl,
                            lE.addIgnoredAsset(t),
                            this.addAsset(t.name, t),
                            t instanceof a.Material &&
                              this._materialsToBeCompiled.push(t);
                        }),
                        i());
                  });
            });
          });
        });
      const Pv = t("builtinResMgr", (a.builtinResMgr = xv.getInstance()));
      class Nv extends hr {
        constructor() {
          super(),
            (this._compScheduler = new ES()),
            (this._nodeActivator = new MS()),
            (this._invalid = !1),
            (this._paused = !1),
            (this._root = null),
            (this._loadingScene = ""),
            (this._scene = null),
            (this._totalFrames = 0),
            (this._scheduler = new $l()),
            (this._systems = []),
            (this._persistRootNodes = {}),
            (this.scenes = new Map());
        }
        end() {
          this.once(Nv.EVENT_END_FRAME, () => {
            this.purgeDirector();
          });
        }
        pause() {
          this._paused = !0;
        }
        purgeDirector() {
          this._scheduler.unscheduleAll(),
            this._compScheduler.unscheduleAll(),
            this._nodeActivator.reset(),
            Qn(this._scene) && this._scene.destroy(),
            (this._scene = null),
            this.stopAnimation(),
            Tv.releaseAll(),
            zr.garbageCollect();
        }
        reset() {
          var t;
          this.purgeDirector();
          for (const t in this._persistRootNodes)
            this.removePersistRootNode(this._persistRootNodes[t]);
          null === (t = this.getScene()) || void 0 === t || t.destroy(),
            this.emit(Nv.EVENT_RESET),
            this.startAnimation();
        }
        focusWindow(t) {
          this.root.focusWindow(t);
        }
        setWindowTitle(t, e) {
          this.root.setWindowTitle(t, e);
        }
        hideMainLoadingWindow() {
          this.root.hideMainLoadingWindow();
        }
        getFocusedWindowID() {
          return this.root.getFocusedWindowID();
        }
        closeWindow(t) {
          if (this.scenes.has(t)) {
            let i = this.scenes.get(t);
            var e;
            null != i &&
              (null === (e = i.renderWindow) || void 0 === e || e.destroy(),
              i.destroy(),
              lE._autoReleaseScene(i)),
              this.scenes.delete(t);
          }
          this.root.closeWindow(t), $n._deferredDestroy();
        }
        createWindow(t, e, i, s = !1, n = !1) {
          zr.garbageCollect();
          const r = Tv.bundles.find((e) => !!e.getSceneInfo(t));
          r
            ? r.loadScene(t, (t, r) => {
                if (t) R(t);
                else {
                  let t = r.scene;
                  this.emit(Nv.EVENT_BEFORE_SCENE_LAUNCH, t);
                  let o = this.root.createRenderWindowAndSystemWindow(e, n);
                  (t.renderWindow = o),
                    (t.windowID = this.root.getWindowID(o)),
                    s
                      ? this.root.restrictResizingToHeight(t.windowID)
                      : this.root.lockAspectRatio(t.windowID),
                    this.scenes.set(t.windowID, t),
                    (t.windowSize = new ws(
                      null == o ? void 0 : o.width,
                      null == o ? void 0 : o.height
                    )),
                    (t.visibleRect = { ...Hr }),
                    (t.viewportRect = new Ds(a.view.getViewportRect())),
                    (t.designResolutionSize = new ws(
                      a.view._designResolutionSize
                    )),
                    (t.designResolutionScaleX = a.view.getScaleX()),
                    (t.designResolutionScaleY = a.view.getScaleY()),
                    Ur.emit(
                      "window-resize",
                      null == o ? void 0 : o.width,
                      null == o ? void 0 : o.height,
                      t.windowID
                    ),
                    t._load(),
                    t._activate(),
                    i(t);
                }
              })
            : G(1209, t);
        }
        runSceneImmediate(t, e, i) {
          t instanceof om && (t = t.scene), this.scenes.set(1, t);
          let s = { ...Hr };
          (t.visibleRect = s),
            Hr.copyVisibleRect(t.visibleRect, Hr),
            (t.windowSize = new ws(Ur.windowSize.width, Ur.windowSize.height)),
            (t.viewportRect = new Ds(a.view.getViewportRect())),
            (t.designResolutionSize = new ws(a.view._designResolutionSize)),
            (t.designResolutionScaleX = a.view.getScaleX()),
            (t.designResolutionScaleY = a.view.getScaleY()),
            (t.windowID = 1),
            this._scene &&
              ((t.designResolutionScaleX = this._scene.designResolutionScaleX),
              (t.designResolutionScaleY = this._scene.designResolutionScaleY),
              (t.windowSize = new ws(this._scene.windowSize)),
              Ur.emit(
                "window-resize",
                t.windowSize.width,
                t.windowSize.height,
                t.windowID
              )),
            j(t instanceof sS, 1216),
            t._load();
          const n = Object.keys(this._persistRootNodes).map(
            (t) => this._persistRootNodes[t]
          );
          for (let e = 0; e < n.length; e++) {
            const i = n[e];
            i.emit(Pf.EventType.SCENE_CHANGED_FOR_PERSISTS, t.renderScene);
            const s = t.uuid === i._originalSceneId && t.getChildByUuid(i.uuid);
            if (s) {
              const e = s.getSiblingIndex();
              (i.hideFlags &= ~$n.Flags.DontSave),
                (i.hideFlags |= $n.Flags.DontSave & s.hideFlags),
                s._destroyImmediate(),
                t.insertChild(i, e);
            } else (i.hideFlags |= $n.Flags.DontSave), (i.parent = t);
          }
          const r = this._scene;
          Qn(r) && r.destroy(),
            lE._autoRelease(r, t, this._persistRootNodes),
            (this._scene = null),
            $n._deferredDestroy(),
            e && e(),
            this.emit(Nv.EVENT_BEFORE_SCENE_LAUNCH, t),
            (this._scene = t),
            t._activate(),
            this._root && this._root.resetCumulativeTime(),
            this.startAnimation(),
            i && i(null, t),
            this.emit(Nv.EVENT_AFTER_SCENE_LAUNCH, t);
        }
        runScene(t, e, i) {
          t instanceof om && (t = t.scene),
            j(Boolean(t), 1205),
            j(t instanceof sS, 1216),
            this.once(Nv.EVENT_END_FRAME, () => {
              this.runSceneImmediate(t, e, i);
            });
        }
        loadScene(t, e, i) {
          if (this._loadingScene) return z(1208, t, this._loadingScene), !1;
          const s = Tv.bundles.find((e) => !!e.getSceneInfo(t));
          return s
            ? (this.emit(Nv.EVENT_BEFORE_SCENE_LOADING, t),
              (this._loadingScene = t),
              console.time(`LoadScene ${t}`),
              s.loadScene(t, (s, n) => {
                console.timeEnd(`LoadScene ${t}`),
                  (this._loadingScene = ""),
                  s ? (R(s), e && e(s)) : this.runSceneImmediate(n, i, e);
              }),
              !0)
            : (G(1209, t), !1);
        }
        preloadScene(t, e, i) {
          const s = Tv.bundles.find((e) => !!e.getSceneInfo(t));
          if (s) s.preloadScene(t, null, e, i);
          else {
            const e = `Can not preload the scene "${t}" because it is not in the build settings.`;
            i && i(new Error(e)), R(`preloadScene: ${e}`);
          }
        }
        resume() {
          this._paused = !1;
        }
        get root() {
          return this._root;
        }
        getScene() {
          return this._scene;
        }
        getDeltaTime() {
          return a.game.deltaTime;
        }
        getTotalTime() {
          return a.game.totalTime;
        }
        getCurrentTime() {
          return a.game.frameStartTime;
        }
        getTotalFrames() {
          return this._totalFrames;
        }
        isPaused() {
          return this._paused;
        }
        getScheduler() {
          return this._scheduler;
        }
        setScheduler(t) {
          this._scheduler !== t &&
            (this.unregisterSystem(this._scheduler),
            (this._scheduler = t),
            this.registerSystem($l.ID, t, 200));
        }
        registerSystem(t, e, i) {
          (e.id = t),
            (e.priority = i),
            this._systems.push(e),
            this._systems.sort(jl.sortByPriority);
        }
        unregisterSystem(t) {
          ee(this._systems, t), this._systems.sort(jl.sortByPriority);
        }
        getSystem(t) {
          return this._systems.find((e) => e.id === t);
        }
        getAnimationManager() {
          return this.getSystem(a.AnimationManager.ID);
        }
        startAnimation() {
          this._invalid = !1;
        }
        stopAnimation() {
          this._invalid = !0;
        }
        mainLoop(t) {
          let e;
          (e = a.game._calculateDT(t)), this.tick(e);
        }
        tick(t) {
          if (!this._invalid) {
            if (
              (this.emit(Nv.EVENT_BEGIN_FRAME),
              _f._frameDispatchEvents(),
              !this._paused)
            ) {
              this.emit(Nv.EVENT_BEFORE_UPDATE),
                this._compScheduler.startPhase(),
                this._compScheduler.updatePhase(t);
              for (let e = 0; e < this._systems.length; ++e)
                this._systems[e].update(t);
              this._compScheduler.lateUpdatePhase(t),
                this.emit(Nv.EVENT_AFTER_UPDATE),
                $n._deferredDestroy();
              for (let e = 0; e < this._systems.length; ++e)
                this._systems[e].postUpdate(t);
            }
            this.emit(Nv.EVENT_BEFORE_DRAW),
              iE.updateAllDirtyRenderers(),
              this._root.frameMove(t),
              this.emit(Nv.EVENT_AFTER_DRAW),
              Pf.resetHasChangedFlags(),
              Pf.clearNodeArray(),
              jn.update(t),
              this.emit(Nv.EVENT_END_FRAME),
              this._totalFrames++;
          }
        }
        buildRenderPipeline() {
          if (!this._root) return;
          const t = this._root.customPipeline,
            e = this._root.cameraList;
          t.beginSetup();
          const i = a.rendering.getCustomPipeline(Te.CUSTOM_PIPELINE_NAME);
          a.rendering.dispatchResizeEvents(e, i, t),
            i.setup(e, t),
            t.endSetup();
        }
        setupRenderPipelineBuilder() {
          "" !== Te.CUSTOM_PIPELINE_NAME &&
            a.rendering &&
            this._root &&
            this._root.usesCustomPipeline &&
            (this.on(Nv.EVENT_BEFORE_RENDER, this.buildRenderPipeline, this),
            this.on(
              Nv.EVENT_BEFORE_SCENE_LAUNCH,
              a.rendering.forceResizeAllWindows,
              a.rendering
            ));
        }
        init() {
          (this._totalFrames = 0),
            (this._paused = !1),
            this.registerSystem($l.ID, this._scheduler, 200),
            (this._root = new gf(I_.gfxDevice)),
            this._root.initialize({}),
            this.setupRenderPipelineBuilder();
          for (let t = 0; t < this._systems.length; t++)
            this._systems[t].init();
          this.emit(Nv.EVENT_INIT);
        }
        addPersistRootNode(t) {
          if (!Pf.isNode(t) || !t.uuid) return void z(3800);
          const e = t.uuid;
          if (!this._persistRootNodes[e]) {
            const i = this._scene;
            if (Qn(i))
              if (t.parent) {
                if (!(t.parent instanceof sS)) return void z(3801);
                if (t.parent !== i) return void z(3802);
                t._originalSceneId = i.uuid;
              } else (t.parent = i), (t._originalSceneId = i.uuid);
            (this._persistRootNodes[e] = t),
              (t._persistNode = !0),
              lE._addPersistNodeRef(t);
          }
        }
        removePersistRootNode(t) {
          const e = t.uuid || "";
          t === this._persistRootNodes[e] &&
            (delete this._persistRootNodes[e],
            (t._persistNode = !1),
            (t._originalSceneId = ""),
            lE._removePersistNodeRef(t));
        }
        isPersistRootNode(t) {
          return !!t._persistNode;
        }
      }
      t("Director", Nv),
        (Nv.EVENT_INIT = "director_init"),
        (Nv.EVENT_RESET = "director_reset"),
        (Nv.EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading"),
        (Nv.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch"),
        (Nv.EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch"),
        (Nv.EVENT_BEFORE_UPDATE = "director_before_update"),
        (Nv.EVENT_AFTER_UPDATE = "director_after_update"),
        (Nv.EVENT_BEFORE_DRAW = "director_before_draw"),
        (Nv.EVENT_AFTER_DRAW = "director_after_draw"),
        (Nv.EVENT_BEFORE_COMMIT = "director_before_commit"),
        (Nv.EVENT_BEFORE_RENDER = "director_before_render"),
        (Nv.EVENT_AFTER_RENDER = "director_after_render"),
        (Nv.EVENT_BEFORE_PHYSICS = "director_before_physics"),
        (Nv.EVENT_AFTER_PHYSICS = "director_after_physics"),
        (Nv.EVENT_BEGIN_FRAME = "director_begin_frame"),
        (Nv.EVENT_END_FRAME = "director_end_frame"),
        (Nv.instance = void 0),
        (a.Director = Nv);
      const Lv = t("director", (Nv.instance = a.director = new Nv())),
        Bv =
          void 0 !== globalThis.jsb && void 0 !== jsb.window
            ? jsb.window
            : window,
        Fv = Bv.document;
      class Uv {
        constructor() {
          (this._rafHandle = 0),
            (this._onTick = null),
            (this._targetFrameRate = 60),
            (this._isPlaying = !1),
            (this._updateCallback = () => {
              this._isPlaying &&
                (this._rafHandle = requestAnimationFrame(this._updateCallback)),
                this._onTick && this._onTick();
            });
        }
        get targetFrameRate() {
          return this._targetFrameRate;
        }
        set targetFrameRate(t) {
          this._targetFrameRate !== t &&
            ((this._targetFrameRate = t),
            jsb.setPreferredFramesPerSecond(this._targetFrameRate),
            this._isPlaying && (this.stop(), this.start()));
        }
        set onTick(t) {
          this._onTick = t;
        }
        get onTick() {
          return this._onTick;
        }
        start() {
          this._isPlaying ||
            ((this._rafHandle = requestAnimationFrame(this._updateCallback)),
            (this._isPlaying = !0));
        }
        stop() {
          this._isPlaying &&
            (cancelAnimationFrame(this._rafHandle),
            (this._rafHandle = 0),
            (this._isPlaying = !1));
        }
      }
      var kv, zv, Hv, Gv, Vv, jv, Wv, Xv, Yv, Kv, qv, $v, Zv, Qv;
      let Jv, tb;
      !(function (t) {
        (t[(t.DEFAULT = 100)] = "DEFAULT"), (t[(t.UI = 200)] = "UI");
      })(Jv || (Jv = {})),
        (a.RenderPassStage = Jv),
        (function (t) {
          (t[(t.MIN = 0)] = "MIN"),
            (t[(t.MAX = 255)] = "MAX"),
            (t[(t.DEFAULT = 128)] = "DEFAULT");
        })(tb || (tb = {}));
      const eb = { bindings: [], layouts: {} },
        ib = { bindings: [], layouts: {} };
      let sb;
      !(function (t) {
        (t[(t.UBO_GLOBAL = 0)] = "UBO_GLOBAL"),
          (t[(t.UBO_CAMERA = 1)] = "UBO_CAMERA"),
          (t[(t.UBO_SHADOW = 2)] = "UBO_SHADOW"),
          (t[(t.UBO_CSM = 3)] = "UBO_CSM"),
          (t[(t.SAMPLER_SHADOWMAP = 4)] = "SAMPLER_SHADOWMAP"),
          (t[(t.SAMPLER_ENVIRONMENT = 5)] = "SAMPLER_ENVIRONMENT"),
          (t[(t.SAMPLER_SPOT_SHADOW_MAP = 6)] = "SAMPLER_SPOT_SHADOW_MAP"),
          (t[(t.SAMPLER_DIFFUSEMAP = 7)] = "SAMPLER_DIFFUSEMAP"),
          (t[(t.COUNT = 8)] = "COUNT");
      })(sb || (sb = {}));
      const nb = sb.SAMPLER_SHADOWMAP,
        rb = sb.COUNT - nb;
      let ab;
      !(function (t) {
        (t[(t.UBO_LOCAL = 0)] = "UBO_LOCAL"),
          (t[(t.UBO_FORWARD_LIGHTS = 1)] = "UBO_FORWARD_LIGHTS"),
          (t[(t.UBO_SKINNING_ANIMATION = 2)] = "UBO_SKINNING_ANIMATION"),
          (t[(t.UBO_SKINNING_TEXTURE = 3)] = "UBO_SKINNING_TEXTURE"),
          (t[(t.UBO_MORPH = 4)] = "UBO_MORPH"),
          (t[(t.UBO_UI_LOCAL = 5)] = "UBO_UI_LOCAL"),
          (t[(t.UBO_SH = 6)] = "UBO_SH"),
          (t[(t.SAMPLER_JOINTS = 7)] = "SAMPLER_JOINTS"),
          (t[(t.SAMPLER_MORPH_POSITION = 8)] = "SAMPLER_MORPH_POSITION"),
          (t[(t.SAMPLER_MORPH_NORMAL = 9)] = "SAMPLER_MORPH_NORMAL"),
          (t[(t.SAMPLER_MORPH_TANGENT = 10)] = "SAMPLER_MORPH_TANGENT"),
          (t[(t.SAMPLER_LIGHTMAP = 11)] = "SAMPLER_LIGHTMAP"),
          (t[(t.SAMPLER_SPRITE = 12)] = "SAMPLER_SPRITE"),
          (t[(t.SAMPLER_REFLECTION = 13)] = "SAMPLER_REFLECTION"),
          (t[(t.STORAGE_REFLECTION = 14)] = "STORAGE_REFLECTION"),
          (t[(t.SAMPLER_REFLECTION_PROBE_CUBE = 15)] =
            "SAMPLER_REFLECTION_PROBE_CUBE"),
          (t[(t.SAMPLER_REFLECTION_PROBE_PLANAR = 16)] =
            "SAMPLER_REFLECTION_PROBE_PLANAR"),
          (t[(t.SAMPLER_REFLECTION_PROBE_DATA_MAP = 17)] =
            "SAMPLER_REFLECTION_PROBE_DATA_MAP"),
          (t[(t.SAMPLER_REFLECTION_PROBE_BLEND_CUBE = 18)] =
            "SAMPLER_REFLECTION_PROBE_BLEND_CUBE"),
          (t[(t.COUNT = 19)] = "COUNT");
      })(ab || (ab = {}));
      const ob = ab.SAMPLER_JOINTS,
        hb = ab.STORAGE_REFLECTION - ob,
        lb = ab.COUNT - ob - hb;
      let cb;
      !(function (t) {
        (t[(t.GLOBAL = 0)] = "GLOBAL"),
          (t[(t.MATERIAL = 1)] = "MATERIAL"),
          (t[(t.LOCAL = 2)] = "LOCAL"),
          (t[(t.COUNT = 3)] = "COUNT");
      })(cb || (cb = {}));
      const ub = new mu(
        [nb, 0, ob, 0],
        [rb, 0, hb, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, lb, 0],
        [0, 0, 0, 0],
        [0, 2, 1, 3]
      );
      class _b {}
      (kv = _b),
        (_b.TIME_OFFSET = 0),
        (_b.SCREEN_SIZE_OFFSET = kv.TIME_OFFSET + 4),
        (_b.NATIVE_SIZE_OFFSET = kv.SCREEN_SIZE_OFFSET + 4),
        (_b.PROBE_INFO_OFFSET = kv.NATIVE_SIZE_OFFSET + 4),
        (_b.DEBUG_VIEW_MODE_OFFSET = kv.PROBE_INFO_OFFSET + 4),
        (_b.COUNT = kv.DEBUG_VIEW_MODE_OFFSET + 4),
        (_b.SIZE = 4 * kv.COUNT),
        (_b.NAME = "CCGlobal"),
        (_b.BINDING = sb.UBO_GLOBAL),
        (_b.DESCRIPTOR = new Yu(kv.BINDING, Kc.UNIFORM_BUFFER, 1, Bc.ALL)),
        (_b.LAYOUT = new Iu(
          cb.GLOBAL,
          kv.BINDING,
          kv.NAME,
          [
            new Ou("cc_time", yc.FLOAT4, 1),
            new Ou("cc_screenSize", yc.FLOAT4, 1),
            new Ou("cc_nativeSize", yc.FLOAT4, 1),
            new Ou("cc_probeInfo", yc.FLOAT4, 1),
            new Ou("cc_debug_view_mode", yc.FLOAT4, 1),
          ],
          1
        )),
        (eb.layouts[_b.NAME] = _b.LAYOUT),
        (eb.bindings[_b.BINDING] = _b.DESCRIPTOR);
      class db {}
      (zv = db),
        (db.MAT_VIEW_OFFSET = 0),
        (db.MAT_VIEW_INV_OFFSET = zv.MAT_VIEW_OFFSET + 16),
        (db.MAT_PROJ_OFFSET = zv.MAT_VIEW_INV_OFFSET + 16),
        (db.MAT_PROJ_INV_OFFSET = zv.MAT_PROJ_OFFSET + 16),
        (db.MAT_VIEW_PROJ_OFFSET = zv.MAT_PROJ_INV_OFFSET + 16),
        (db.MAT_VIEW_PROJ_INV_OFFSET = zv.MAT_VIEW_PROJ_OFFSET + 16),
        (db.CAMERA_POS_OFFSET = zv.MAT_VIEW_PROJ_INV_OFFSET + 16),
        (db.SURFACE_TRANSFORM_OFFSET = zv.CAMERA_POS_OFFSET + 4),
        (db.SCREEN_SCALE_OFFSET = zv.SURFACE_TRANSFORM_OFFSET + 4),
        (db.EXPOSURE_OFFSET = zv.SCREEN_SCALE_OFFSET + 4),
        (db.MAIN_LIT_DIR_OFFSET = zv.EXPOSURE_OFFSET + 4),
        (db.MAIN_LIT_COLOR_OFFSET = zv.MAIN_LIT_DIR_OFFSET + 4),
        (db.AMBIENT_SKY_OFFSET = zv.MAIN_LIT_COLOR_OFFSET + 4),
        (db.AMBIENT_GROUND_OFFSET = zv.AMBIENT_SKY_OFFSET + 4),
        (db.GLOBAL_FOG_COLOR_OFFSET = zv.AMBIENT_GROUND_OFFSET + 4),
        (db.GLOBAL_FOG_BASE_OFFSET = zv.GLOBAL_FOG_COLOR_OFFSET + 4),
        (db.GLOBAL_FOG_ADD_OFFSET = zv.GLOBAL_FOG_BASE_OFFSET + 4),
        (db.NEAR_FAR_OFFSET = zv.GLOBAL_FOG_ADD_OFFSET + 4),
        (db.VIEW_PORT_OFFSET = zv.NEAR_FAR_OFFSET + 4),
        (db.COUNT = zv.VIEW_PORT_OFFSET + 4),
        (db.SIZE = 4 * zv.COUNT),
        (db.NAME = "CCCamera"),
        (db.BINDING = sb.UBO_CAMERA),
        (db.DESCRIPTOR = new Yu(zv.BINDING, Kc.UNIFORM_BUFFER, 1, Bc.ALL)),
        (db.LAYOUT = new Iu(
          cb.GLOBAL,
          zv.BINDING,
          zv.NAME,
          [
            new Ou("cc_matView", yc.MAT4, 1),
            new Ou("cc_matViewInv", yc.MAT4, 1),
            new Ou("cc_matProj", yc.MAT4, 1),
            new Ou("cc_matProjInv", yc.MAT4, 1),
            new Ou("cc_matViewProj", yc.MAT4, 1),
            new Ou("cc_matViewProjInv", yc.MAT4, 1),
            new Ou("cc_cameraPos", yc.FLOAT4, 1),
            new Ou("cc_surfaceTransform", yc.FLOAT4, 1),
            new Ou("cc_screenScale", yc.FLOAT4, 1),
            new Ou("cc_exposure", yc.FLOAT4, 1),
            new Ou("cc_mainLitDir", yc.FLOAT4, 1),
            new Ou("cc_mainLitColor", yc.FLOAT4, 1),
            new Ou("cc_ambientSky", yc.FLOAT4, 1),
            new Ou("cc_ambientGround", yc.FLOAT4, 1),
            new Ou("cc_fogColor", yc.FLOAT4, 1),
            new Ou("cc_fogBase", yc.FLOAT4, 1),
            new Ou("cc_fogAdd", yc.FLOAT4, 1),
            new Ou("cc_nearFar", yc.FLOAT4, 1),
            new Ou("cc_viewPort", yc.FLOAT4, 1),
          ],
          1
        )),
        (eb.layouts[db.NAME] = db.LAYOUT),
        (eb.bindings[db.BINDING] = db.DESCRIPTOR);
      class pb {}
      (Hv = pb),
        (pb.MAT_LIGHT_VIEW_OFFSET = 0),
        (pb.MAT_LIGHT_VIEW_PROJ_OFFSET = Hv.MAT_LIGHT_VIEW_OFFSET + 16),
        (pb.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET =
          Hv.MAT_LIGHT_VIEW_PROJ_OFFSET + 16),
        (pb.SHADOW_PROJ_DEPTH_INFO_OFFSET =
          Hv.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET + 4),
        (pb.SHADOW_PROJ_INFO_OFFSET = Hv.SHADOW_PROJ_DEPTH_INFO_OFFSET + 4),
        (pb.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET =
          Hv.SHADOW_PROJ_INFO_OFFSET + 4),
        (pb.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET =
          Hv.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 4),
        (pb.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET =
          Hv.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 4),
        (pb.SHADOW_COLOR_OFFSET =
          Hv.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 4),
        (pb.PLANAR_NORMAL_DISTANCE_INFO_OFFSET = Hv.SHADOW_COLOR_OFFSET + 4),
        (pb.COUNT = Hv.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 4),
        (pb.SIZE = 4 * Hv.COUNT),
        (pb.NAME = "CCShadow"),
        (pb.BINDING = sb.UBO_SHADOW),
        (pb.DESCRIPTOR = new Yu(Hv.BINDING, Kc.UNIFORM_BUFFER, 1, Bc.ALL)),
        (pb.LAYOUT = new Iu(
          cb.GLOBAL,
          Hv.BINDING,
          Hv.NAME,
          [
            new Ou("cc_matLightView", yc.MAT4, 1),
            new Ou("cc_matLightViewProj", yc.MAT4, 1),
            new Ou("cc_shadowInvProjDepthInfo", yc.FLOAT4, 1),
            new Ou("cc_shadowProjDepthInfo", yc.FLOAT4, 1),
            new Ou("cc_shadowProjInfo", yc.FLOAT4, 1),
            new Ou("cc_shadowNFLSInfo", yc.FLOAT4, 1),
            new Ou("cc_shadowWHPBInfo", yc.FLOAT4, 1),
            new Ou("cc_shadowLPNNInfo", yc.FLOAT4, 1),
            new Ou("cc_shadowColor", yc.FLOAT4, 1),
            new Ou("cc_planarNDInfo", yc.FLOAT4, 1),
          ],
          1
        )),
        (eb.layouts[pb.NAME] = pb.LAYOUT),
        (eb.bindings[pb.BINDING] = pb.DESCRIPTOR);
      class mb {}
      (Gv = mb),
        (mb.CSM_LEVEL_COUNT = 4),
        (mb.CSM_VIEW_DIR_0_OFFSET = 0),
        (mb.CSM_VIEW_DIR_1_OFFSET =
          Gv.CSM_VIEW_DIR_0_OFFSET + 4 * Gv.CSM_LEVEL_COUNT),
        (mb.CSM_VIEW_DIR_2_OFFSET =
          Gv.CSM_VIEW_DIR_1_OFFSET + 4 * Gv.CSM_LEVEL_COUNT),
        (mb.CSM_ATLAS_OFFSET =
          Gv.CSM_VIEW_DIR_2_OFFSET + 4 * Gv.CSM_LEVEL_COUNT),
        (mb.MAT_CSM_VIEW_PROJ_OFFSET =
          Gv.CSM_ATLAS_OFFSET + 4 * Gv.CSM_LEVEL_COUNT),
        (mb.CSM_PROJ_DEPTH_INFO_OFFSET =
          Gv.MAT_CSM_VIEW_PROJ_OFFSET + 16 * Gv.CSM_LEVEL_COUNT),
        (mb.CSM_PROJ_INFO_OFFSET =
          Gv.CSM_PROJ_DEPTH_INFO_OFFSET + 4 * Gv.CSM_LEVEL_COUNT),
        (mb.CSM_SPLITS_INFO_OFFSET =
          Gv.CSM_PROJ_INFO_OFFSET + 4 * Gv.CSM_LEVEL_COUNT),
        (mb.COUNT = Gv.CSM_SPLITS_INFO_OFFSET + 4),
        (mb.SIZE = 4 * Gv.COUNT),
        (mb.NAME = "CCCSM"),
        (mb.BINDING = sb.UBO_CSM),
        (mb.DESCRIPTOR = new Yu(Gv.BINDING, Kc.UNIFORM_BUFFER, 1, Bc.FRAGMENT)),
        (mb.LAYOUT = new Iu(
          cb.GLOBAL,
          Gv.BINDING,
          Gv.NAME,
          [
            new Ou("cc_csmViewDir0", yc.FLOAT4, Gv.CSM_LEVEL_COUNT),
            new Ou("cc_csmViewDir1", yc.FLOAT4, Gv.CSM_LEVEL_COUNT),
            new Ou("cc_csmViewDir2", yc.FLOAT4, Gv.CSM_LEVEL_COUNT),
            new Ou("cc_csmAtlas", yc.FLOAT4, Gv.CSM_LEVEL_COUNT),
            new Ou("cc_matCSMViewProj", yc.MAT4, Gv.CSM_LEVEL_COUNT),
            new Ou("cc_csmProjDepthInfo", yc.FLOAT4, Gv.CSM_LEVEL_COUNT),
            new Ou("cc_csmProjInfo", yc.FLOAT4, Gv.CSM_LEVEL_COUNT),
            new Ou("cc_csmSplitsInfo", yc.FLOAT4, 1),
          ],
          1
        )),
        (eb.layouts[mb.NAME] = mb.LAYOUT),
        (eb.bindings[mb.BINDING] = mb.DESCRIPTOR);
      const fb = sb.SAMPLER_SHADOWMAP,
        gb = new Yu(fb, Kc.SAMPLER_TEXTURE, 1, Bc.FRAGMENT),
        yb = new wu(cb.GLOBAL, fb, "cc_shadowMap", yc.SAMPLER2D, 1);
      (eb.layouts.cc_shadowMap = yb), (eb.bindings[fb] = gb);
      const Tb = sb.SAMPLER_ENVIRONMENT,
        Sb = new Yu(Tb, Kc.SAMPLER_TEXTURE, 1, Bc.FRAGMENT),
        Eb = new wu(cb.GLOBAL, Tb, "cc_environment", yc.SAMPLER_CUBE, 1);
      (eb.layouts.cc_environment = Eb), (eb.bindings[Tb] = Sb);
      const vb = sb.SAMPLER_DIFFUSEMAP,
        bb = new Yu(vb, Kc.SAMPLER_TEXTURE, 1, Bc.FRAGMENT),
        Ab = new wu(cb.GLOBAL, vb, "cc_diffuseMap", yc.SAMPLER_CUBE, 1);
      (eb.layouts.cc_diffuseMap = Ab), (eb.bindings[vb] = bb);
      const Cb = sb.SAMPLER_SPOT_SHADOW_MAP,
        Ob = new Yu(Cb, Kc.SAMPLER_TEXTURE, 1, Bc.FRAGMENT),
        Ib = new wu(cb.GLOBAL, Cb, "cc_spotShadowMap", yc.SAMPLER2D, 1);
      (eb.layouts.cc_spotShadowMap = Ib), (eb.bindings[Cb] = Ob);
      class wb {}
      (Vv = wb),
        (wb.MAT_WORLD_OFFSET = 0),
        (wb.MAT_WORLD_IT_OFFSET = Vv.MAT_WORLD_OFFSET + 16),
        (wb.LIGHTINGMAP_UVPARAM = Vv.MAT_WORLD_IT_OFFSET + 16),
        (wb.LOCAL_SHADOW_BIAS = Vv.LIGHTINGMAP_UVPARAM + 4),
        (wb.REFLECTION_PROBE_DATA1 = Vv.LOCAL_SHADOW_BIAS + 4),
        (wb.REFLECTION_PROBE_DATA2 = Vv.REFLECTION_PROBE_DATA1 + 4),
        (wb.REFLECTION_PROBE_BLEND_DATA1 = Vv.REFLECTION_PROBE_DATA2 + 4),
        (wb.REFLECTION_PROBE_BLEND_DATA2 = Vv.REFLECTION_PROBE_BLEND_DATA1 + 4),
        (wb.COUNT = Vv.REFLECTION_PROBE_BLEND_DATA2 + 4),
        (wb.SIZE = 4 * Vv.COUNT),
        (wb.NAME = "CCLocal"),
        (wb.BINDING = ab.UBO_LOCAL),
        (wb.DESCRIPTOR = new Yu(
          Vv.BINDING,
          Kc.UNIFORM_BUFFER,
          1,
          Bc.VERTEX | Bc.FRAGMENT | Bc.COMPUTE
        )),
        (wb.LAYOUT = new Iu(
          cb.LOCAL,
          Vv.BINDING,
          Vv.NAME,
          [
            new Ou("cc_matWorld", yc.MAT4, 1),
            new Ou("cc_matWorldIT", yc.MAT4, 1),
            new Ou("cc_lightingMapUVParam", yc.FLOAT4, 1),
            new Ou("cc_localShadowBias", yc.FLOAT4, 1),
            new Ou("cc_reflectionProbeData1", yc.FLOAT4, 1),
            new Ou("cc_reflectionProbeData2", yc.FLOAT4, 1),
            new Ou("cc_reflectionProbeBlendData1", yc.FLOAT4, 1),
            new Ou("cc_reflectionProbeBlendData2", yc.FLOAT4, 1),
          ],
          1
        )),
        (ib.layouts[wb.NAME] = wb.LAYOUT),
        (ib.bindings[wb.BINDING] = wb.DESCRIPTOR);
      class Rb {}
      (jv = Rb),
        (Rb.WORLD_BOUND_CENTER = 0),
        (Rb.WORLD_BOUND_HALF_EXTENTS = jv.WORLD_BOUND_CENTER + 4),
        (Rb.COUNT = jv.WORLD_BOUND_HALF_EXTENTS + 4),
        (Rb.SIZE = 4 * jv.COUNT),
        (Rb.NAME = "CCWorldBound"),
        (Rb.BINDING = ab.UBO_LOCAL),
        (Rb.DESCRIPTOR = new Yu(
          jv.BINDING,
          Kc.UNIFORM_BUFFER,
          1,
          Bc.VERTEX | Bc.COMPUTE
        )),
        (Rb.LAYOUT = new Iu(
          cb.LOCAL,
          jv.BINDING,
          jv.NAME,
          [
            new Ou("cc_worldBoundCenter", yc.FLOAT4, 1),
            new Ou("cc_worldBoundHalfExtents", yc.FLOAT4, 1),
          ],
          1
        )),
        (ib.layouts[Rb.NAME] = Rb.LAYOUT),
        (ib.bindings[Rb.BINDING] = Rb.DESCRIPTOR);
      class Db {}
      (Wv = Db),
        (Db.BATCHING_COUNT = 10),
        (Db.MAT_WORLDS_OFFSET = 0),
        (Db.COUNT = 16 * Wv.BATCHING_COUNT),
        (Db.SIZE = 4 * Wv.COUNT),
        (Db.NAME = "CCLocalBatched"),
        (Db.BINDING = ab.UBO_LOCAL),
        (Db.DESCRIPTOR = new Yu(
          Wv.BINDING,
          Kc.UNIFORM_BUFFER,
          1,
          Bc.VERTEX | Bc.COMPUTE
        )),
        (Db.LAYOUT = new Iu(
          cb.LOCAL,
          Wv.BINDING,
          Wv.NAME,
          [new Ou("cc_matWorlds", yc.MAT4, Wv.BATCHING_COUNT)],
          1
        )),
        (ib.layouts[Db.NAME] = Db.LAYOUT),
        (ib.bindings[Db.BINDING] = Db.DESCRIPTOR);
      class xb {}
      (Xv = xb),
        (xb.LIGHTS_PER_PASS = 1),
        (xb.LIGHT_POS_OFFSET = 0),
        (xb.LIGHT_COLOR_OFFSET = Xv.LIGHT_POS_OFFSET + 4 * Xv.LIGHTS_PER_PASS),
        (xb.LIGHT_SIZE_RANGE_ANGLE_OFFSET =
          Xv.LIGHT_COLOR_OFFSET + 4 * Xv.LIGHTS_PER_PASS),
        (xb.LIGHT_DIR_OFFSET =
          Xv.LIGHT_SIZE_RANGE_ANGLE_OFFSET + 4 * Xv.LIGHTS_PER_PASS),
        (xb.LIGHT_BOUNDING_SIZE_VS_OFFSET =
          Xv.LIGHT_DIR_OFFSET + 4 * Xv.LIGHTS_PER_PASS),
        (xb.COUNT = Xv.LIGHT_BOUNDING_SIZE_VS_OFFSET + 4 * Xv.LIGHTS_PER_PASS),
        (xb.SIZE = 4 * Xv.COUNT),
        (xb.NAME = "CCForwardLight"),
        (xb.BINDING = ab.UBO_FORWARD_LIGHTS),
        (xb.DESCRIPTOR = new Yu(
          Xv.BINDING,
          Kc.DYNAMIC_UNIFORM_BUFFER,
          1,
          Bc.FRAGMENT
        )),
        (xb.LAYOUT = new Iu(
          cb.LOCAL,
          Xv.BINDING,
          Xv.NAME,
          [
            new Ou("cc_lightPos", yc.FLOAT4, Xv.LIGHTS_PER_PASS),
            new Ou("cc_lightColor", yc.FLOAT4, Xv.LIGHTS_PER_PASS),
            new Ou("cc_lightSizeRangeAngle", yc.FLOAT4, Xv.LIGHTS_PER_PASS),
            new Ou("cc_lightDir", yc.FLOAT4, Xv.LIGHTS_PER_PASS),
            new Ou("cc_lightBoundingSizeVS", yc.FLOAT4, Xv.LIGHTS_PER_PASS),
          ],
          1
        )),
        (ib.layouts[xb.NAME] = xb.LAYOUT),
        (ib.bindings[xb.BINDING] = xb.DESCRIPTOR);
      class Mb {}
      Mb.LIGHTS_PER_PASS = 10;
      class Pb {}
      (Yv = Pb),
        (Pb.JOINTS_TEXTURE_INFO_OFFSET = 0),
        (Pb.COUNT = Yv.JOINTS_TEXTURE_INFO_OFFSET + 4),
        (Pb.SIZE = 4 * Yv.COUNT),
        (Pb.NAME = "CCSkinningTexture"),
        (Pb.BINDING = ab.UBO_SKINNING_TEXTURE),
        (Pb.DESCRIPTOR = new Yu(Yv.BINDING, Kc.UNIFORM_BUFFER, 1, Bc.VERTEX)),
        (Pb.LAYOUT = new Iu(
          cb.LOCAL,
          Yv.BINDING,
          Yv.NAME,
          [new Ou("cc_jointTextureInfo", yc.FLOAT4, 1)],
          1
        )),
        (ib.layouts[Pb.NAME] = Pb.LAYOUT),
        (ib.bindings[Pb.BINDING] = Pb.DESCRIPTOR);
      class Nb {}
      (Kv = Nb),
        (Nb.JOINTS_ANIM_INFO_OFFSET = 0),
        (Nb.COUNT = Kv.JOINTS_ANIM_INFO_OFFSET + 4),
        (Nb.SIZE = 4 * Kv.COUNT),
        (Nb.NAME = "CCSkinningAnimation"),
        (Nb.BINDING = ab.UBO_SKINNING_ANIMATION),
        (Nb.DESCRIPTOR = new Yu(Kv.BINDING, Kc.UNIFORM_BUFFER, 1, Bc.VERTEX)),
        (Nb.LAYOUT = new Iu(
          cb.LOCAL,
          Kv.BINDING,
          Kv.NAME,
          [new Ou("cc_jointAnimInfo", yc.FLOAT4, 1)],
          1
        )),
        (ib.layouts[Nb.NAME] = Nb.LAYOUT),
        (ib.bindings[Nb.BINDING] = Nb.DESCRIPTOR);
      class Lb {
        static get JOINT_UNIFORM_CAPACITY() {
          return Lb._jointUniformCapacity;
        }
        static get COUNT() {
          return Lb._count;
        }
        static get SIZE() {
          return Lb._size;
        }
        static initLayout(t) {
          (Lb._jointUniformCapacity = t),
            (Lb._count = 12 * t),
            (Lb._size = 4 * Lb._count),
            (Lb.LAYOUT.members[0].count = 3 * t);
        }
      }
      (qv = Lb),
        (Lb._jointUniformCapacity = 0),
        (Lb._count = 0),
        (Lb._size = 0),
        (Lb.NAME = "CCSkinning"),
        (Lb.BINDING = ab.UBO_SKINNING_TEXTURE),
        (Lb.DESCRIPTOR = new Yu(qv.BINDING, Kc.UNIFORM_BUFFER, 1, Bc.VERTEX)),
        (Lb.LAYOUT = new Iu(
          cb.LOCAL,
          qv.BINDING,
          qv.NAME,
          [new Ou("cc_joints", yc.FLOAT4, 1)],
          1
        ));
      class Bb {}
      ($v = Bb),
        (Bb.MAX_MORPH_TARGET_COUNT = 60),
        (Bb.OFFSET_OF_WEIGHTS = 0),
        (Bb.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH =
          4 * $v.MAX_MORPH_TARGET_COUNT),
        (Bb.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT =
          $v.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH + 4),
        (Bb.OFFSET_OF_VERTICES_COUNT =
          $v.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT + 4),
        (Bb.COUNT_BASE_4_BYTES =
          4 * Math.ceil($v.MAX_MORPH_TARGET_COUNT / 4) + 4),
        (Bb.SIZE = 4 * $v.COUNT_BASE_4_BYTES),
        (Bb.NAME = "CCMorph"),
        (Bb.BINDING = ab.UBO_MORPH),
        (Bb.DESCRIPTOR = new Yu($v.BINDING, Kc.UNIFORM_BUFFER, 1, Bc.VERTEX)),
        (Bb.LAYOUT = new Iu(
          cb.LOCAL,
          $v.BINDING,
          $v.NAME,
          [
            new Ou(
              "cc_displacementWeights",
              yc.FLOAT4,
              $v.MAX_MORPH_TARGET_COUNT / 4
            ),
            new Ou("cc_displacementTextureInfo", yc.FLOAT4, 1),
          ],
          1
        )),
        (ib.layouts[Bb.NAME] = Bb.LAYOUT),
        (ib.bindings[Bb.BINDING] = Bb.DESCRIPTOR);
      class Fb {}
      (Zv = Fb),
        (Fb.NAME = "CCUILocal"),
        (Fb.BINDING = ab.UBO_UI_LOCAL),
        (Fb.DESCRIPTOR = new Yu(
          Zv.BINDING,
          Kc.DYNAMIC_UNIFORM_BUFFER,
          1,
          Bc.VERTEX
        )),
        (Fb.LAYOUT = new Iu(
          cb.LOCAL,
          Zv.BINDING,
          Zv.NAME,
          [new Ou("cc_local_data", yc.FLOAT4, 1)],
          1
        )),
        (ib.layouts[Fb.NAME] = Fb.LAYOUT),
        (ib.bindings[Fb.BINDING] = Fb.DESCRIPTOR);
      class Ub {}
      (Qv = Ub),
        (Ub.SH_LINEAR_CONST_R_OFFSET = 0),
        (Ub.SH_LINEAR_CONST_G_OFFSET = Qv.SH_LINEAR_CONST_R_OFFSET + 4),
        (Ub.SH_LINEAR_CONST_B_OFFSET = Qv.SH_LINEAR_CONST_G_OFFSET + 4),
        (Ub.SH_QUADRATIC_R_OFFSET = Qv.SH_LINEAR_CONST_B_OFFSET + 4),
        (Ub.SH_QUADRATIC_G_OFFSET = Qv.SH_QUADRATIC_R_OFFSET + 4),
        (Ub.SH_QUADRATIC_B_OFFSET = Qv.SH_QUADRATIC_G_OFFSET + 4),
        (Ub.SH_QUADRATIC_A_OFFSET = Qv.SH_QUADRATIC_B_OFFSET + 4),
        (Ub.COUNT = Qv.SH_QUADRATIC_A_OFFSET + 4),
        (Ub.SIZE = 4 * Qv.COUNT),
        (Ub.NAME = "CCSH"),
        (Ub.BINDING = ab.UBO_SH),
        (Ub.DESCRIPTOR = new Yu(Qv.BINDING, Kc.UNIFORM_BUFFER, 1, Bc.FRAGMENT)),
        (Ub.LAYOUT = new Iu(
          cb.LOCAL,
          Qv.BINDING,
          Qv.NAME,
          [
            new Ou("cc_sh_linear_const_r", yc.FLOAT4, 1),
            new Ou("cc_sh_linear_const_g", yc.FLOAT4, 1),
            new Ou("cc_sh_linear_const_b", yc.FLOAT4, 1),
            new Ou("cc_sh_quadratic_r", yc.FLOAT4, 1),
            new Ou("cc_sh_quadratic_g", yc.FLOAT4, 1),
            new Ou("cc_sh_quadratic_b", yc.FLOAT4, 1),
            new Ou("cc_sh_quadratic_a", yc.FLOAT4, 1),
          ],
          1
        )),
        (ib.layouts[Ub.NAME] = Ub.LAYOUT),
        (ib.bindings[Ub.BINDING] = Ub.DESCRIPTOR);
      const kb = ab.SAMPLER_JOINTS,
        zb = new Yu(kb, Kc.SAMPLER_TEXTURE, 1, Bc.VERTEX),
        Hb = new wu(cb.LOCAL, kb, "cc_jointTexture", yc.SAMPLER2D, 1);
      (ib.layouts.cc_jointTexture = Hb), (ib.bindings[kb] = zb);
      const Gb = ab.SAMPLER_JOINTS,
        Vb = new Yu(Gb, Kc.SAMPLER_TEXTURE, 1, Bc.VERTEX),
        jb = new wu(cb.LOCAL, Gb, "cc_realtimeJoint", yc.SAMPLER2D, 1);
      (ib.layouts.cc_realtimeJoint = jb), (ib.bindings[Gb] = Vb);
      const Wb = ab.SAMPLER_MORPH_POSITION,
        Xb = new Yu(Wb, Kc.SAMPLER_TEXTURE, 1, Bc.VERTEX),
        Yb = new wu(cb.LOCAL, Wb, "cc_PositionDisplacements", yc.SAMPLER2D, 1);
      (ib.layouts.cc_PositionDisplacements = Yb), (ib.bindings[Wb] = Xb);
      const Kb = ab.SAMPLER_MORPH_NORMAL,
        qb = new Yu(Kb, Kc.SAMPLER_TEXTURE, 1, Bc.VERTEX),
        $b = new wu(cb.LOCAL, Kb, "cc_NormalDisplacements", yc.SAMPLER2D, 1);
      (ib.layouts.cc_NormalDisplacements = $b), (ib.bindings[Kb] = qb);
      const Zb = ab.SAMPLER_MORPH_TANGENT,
        Qb = new Yu(Zb, Kc.SAMPLER_TEXTURE, 1, Bc.VERTEX),
        Jb = new wu(cb.LOCAL, Zb, "cc_TangentDisplacements", yc.SAMPLER2D, 1);
      (ib.layouts.cc_TangentDisplacements = Jb), (ib.bindings[Zb] = Qb);
      const tA = ab.SAMPLER_LIGHTMAP,
        eA = new Yu(tA, Kc.SAMPLER_TEXTURE, 1, Bc.FRAGMENT),
        iA = new wu(cb.LOCAL, tA, "cc_lightingMap", yc.SAMPLER2D, 1);
      (ib.layouts.cc_lightingMap = iA), (ib.bindings[tA] = eA);
      const sA = ab.SAMPLER_SPRITE,
        nA = new Yu(sA, Kc.SAMPLER_TEXTURE, 1, Bc.FRAGMENT),
        rA = new wu(cb.LOCAL, sA, "cc_spriteTexture", yc.SAMPLER2D, 1);
      (ib.layouts.cc_spriteTexture = rA), (ib.bindings[sA] = nA);
      const aA = ab.SAMPLER_REFLECTION,
        oA = new Yu(aA, Kc.SAMPLER_TEXTURE, 1, Bc.FRAGMENT),
        hA = new wu(cb.LOCAL, aA, "cc_reflectionTexture", yc.SAMPLER2D, 1);
      (ib.layouts.cc_reflectionTexture = hA), (ib.bindings[aA] = oA);
      const lA = ab.STORAGE_REFLECTION,
        cA = new Yu(lA, Kc.STORAGE_IMAGE, 1, Bc.COMPUTE),
        uA = new xu(cb.LOCAL, lA, "cc_reflectionStorage", yc.IMAGE2D, 1);
      (ib.layouts.cc_reflectionStorage = uA), (ib.bindings[lA] = cA);
      const _A = ab.SAMPLER_REFLECTION_PROBE_CUBE,
        dA = new Yu(_A, Kc.SAMPLER_TEXTURE, 1, Bc.FRAGMENT),
        pA = new wu(
          cb.LOCAL,
          _A,
          "cc_reflectionProbeCubemap",
          yc.SAMPLER_CUBE,
          1
        );
      (ib.layouts.cc_reflectionProbeCubemap = pA), (ib.bindings[_A] = dA);
      const mA = ab.SAMPLER_REFLECTION_PROBE_PLANAR,
        fA = new Yu(mA, Kc.SAMPLER_TEXTURE, 1, Bc.FRAGMENT),
        gA = new wu(
          cb.LOCAL,
          mA,
          "cc_reflectionProbePlanarMap",
          yc.SAMPLER2D,
          1
        );
      (ib.layouts.cc_reflectionProbePlanarMap = gA), (ib.bindings[mA] = fA);
      const yA = ab.SAMPLER_REFLECTION_PROBE_DATA_MAP,
        TA = new Yu(yA, Kc.SAMPLER_TEXTURE, 1, Bc.FRAGMENT),
        SA = new wu(cb.LOCAL, yA, "cc_reflectionProbeDataMap", yc.SAMPLER2D, 1);
      (ib.layouts.cc_reflectionProbeDataMap = SA), (ib.bindings[yA] = TA);
      const EA = ab.SAMPLER_REFLECTION_PROBE_BLEND_CUBE,
        vA = new Yu(EA, Kc.SAMPLER_TEXTURE, 1, Bc.FRAGMENT),
        bA = new wu(
          cb.LOCAL,
          EA,
          "cc_reflectionProbeBlendCubemap",
          yc.SAMPLER_CUBE,
          1
        );
      (ib.layouts.cc_reflectionProbeBlendCubemap = bA), (ib.bindings[EA] = vA);
      const AA = Rf.makeMaskExclude([
          Rf.BitMask.UI_2D,
          Rf.BitMask.GIZMOS,
          Rf.BitMask.EDITOR,
          Rf.BitMask.SCENE_GIZMO,
          Rf.BitMask.PROFILER,
        ]),
        CA = Rf.makeMaskExclude([Rf.BitMask.UI_2D, Rf.BitMask.PROFILER]),
        OA = Rf.Enum.ALL;
      let IA;
      function wA(t) {
        return (
          (t.getFormatFeatures(fc.R32F) &
            (Oc.RENDER_TARGET | Oc.SAMPLED_TEXTURE)) ==
            (Oc.RENDER_TARGET | Oc.SAMPLED_TEXTURE) && !(t.gfxAPI === dc.WEBGL)
        );
      }
      function RA() {
        return !(!a.rendering || !a.rendering.enableEffectImport);
      }
      t(
        "pipeline",
        Object.freeze({
          __proto__: null,
          PIPELINE_FLOW_MAIN: "MainFlow",
          PIPELINE_FLOW_FORWARD: "ForwardFlow",
          PIPELINE_FLOW_SHADOW: "ShadowFlow",
          PIPELINE_FLOW_SMAA: "SMAAFlow",
          PIPELINE_FLOW_TONEMAP: "ToneMapFlow",
          get RenderPassStage() {
            return Jv;
          },
          get RenderPriority() {
            return tb;
          },
          globalDescriptorSetLayout: eb,
          localDescriptorSetLayout: ib,
          get PipelineGlobalBindings() {
            return sb;
          },
          get ModelLocalBindings() {
            return ab;
          },
          get SetIndex() {
            return cb;
          },
          bindingMappingInfo: ub,
          UBOGlobal: _b,
          UBOCamera: db,
          UBOShadow: pb,
          UBOCSM: mb,
          UNIFORM_SHADOWMAP_BINDING: fb,
          UNIFORM_ENVIRONMENT_BINDING: Tb,
          UNIFORM_DIFFUSEMAP_BINDING: vb,
          UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING: Cb,
          UBOLocal: wb,
          UBOWorldBound: Rb,
          INST_MAT_WORLD: "a_matWorld0",
          INST_SH: "a_sh_linear_const_r",
          UBOLocalBatched: Db,
          UBOForwardLight: xb,
          UBODeferredLight: Mb,
          JOINT_UNIFORM_CAPACITY: 30,
          UBOSkinningTexture: Pb,
          UBOSkinningAnimation: Nb,
          INST_JOINT_ANIM_INFO: "a_jointAnimInfo",
          UBOSkinning: Lb,
          localDescriptorSetLayout_ResizeMaxJoints: function (t) {
            Lb.initLayout(t),
              (ib.layouts[Lb.NAME] = Lb.LAYOUT),
              (ib.bindings[Lb.BINDING] = Lb.DESCRIPTOR);
          },
          UBOMorph: Bb,
          UBOUILocal: Fb,
          UBOSH: Ub,
          UNIFORM_JOINT_TEXTURE_BINDING: kb,
          UNIFORM_REALTIME_JOINT_TEXTURE_BINDING: Gb,
          UNIFORM_POSITION_MORPH_TEXTURE_BINDING: Wb,
          UNIFORM_NORMAL_MORPH_TEXTURE_BINDING: Kb,
          UNIFORM_TANGENT_MORPH_TEXTURE_BINDING: Zb,
          UNIFORM_LIGHTMAP_TEXTURE_BINDING: tA,
          UNIFORM_SPRITE_TEXTURE_BINDING: sA,
          UNIFORM_REFLECTION_TEXTURE_BINDING: aA,
          UNIFORM_REFLECTION_STORAGE_BINDING: lA,
          UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING: _A,
          UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING: mA,
          UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING: yA,
          UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING: EA,
          CAMERA_DEFAULT_MASK: AA,
          CAMERA_EDITOR_MASK: CA,
          MODEL_ALWAYS_MASK: OA,
          supportsR16HalfFloatTexture: function (t) {
            return (
              (t.getFormatFeatures(fc.R16F) &
                (Oc.RENDER_TARGET | Oc.SAMPLED_TEXTURE)) ==
              (Oc.RENDER_TARGET | Oc.SAMPLED_TEXTURE)
            );
          },
          getDefaultShadowTexture: function (t) {
            if (IA) return IA;
            const e = new bu(
              bc.TEX2D,
              Ac.NONE,
              wA(t) ? fc.R32F : fc.RGBA8,
              16,
              16,
              Cc.NONE,
              1,
              1,
              Ic.X1,
              1
            );
            return (IA = t.createTexture(e)), IA;
          },
          supportsR32FloatTexture: wA,
          supportsRGBA16HalfFloatTexture: function (t) {
            return (
              (t.getFormatFeatures(fc.RGBA16F) &
                (Oc.RENDER_TARGET | Oc.SAMPLED_TEXTURE)) ==
              (Oc.RENDER_TARGET | Oc.SAMPLED_TEXTURE)
            );
          },
          supportsRGBA32FloatTexture: function (t) {
            return (
              (t.getFormatFeatures(fc.RGBA32F) &
                (Oc.RENDER_TARGET | Oc.SAMPLED_TEXTURE)) ==
              (Oc.RENDER_TARGET | Oc.SAMPLED_TEXTURE)
            );
          },
          isEnableEffect: RA,
        })
      );
      const DA = t(
        "getPhaseID",
        (() => {
          const t = new Map();
          let e = 0;
          return (i) =>
            "number" == typeof i
              ? i
              : (t.has(i) || (t.set(i, 1 << e), e++), t.get(i));
        })()
      );
      t(
        "PipelineInputAssemblerData",
        class {
          constructor() {
            (this.quadIB = null), (this.quadVB = null), (this.quadIA = null);
          }
        }
      ),
        t("InstancedBuffer", nr.InstancedBuffer);
      const xA = t("PipelineStateManager", nr.PipelineStateManager);
      let MA,
        PA,
        NA,
        LA = nr.PipelineStateManager.getOrCreatePipelineState;
      (nr.PipelineStateManager.getOrCreatePipelineState = function (
        t,
        e,
        i,
        s,
        n
      ) {
        return LA(e, i, s, n);
      }),
        (function (t) {
          (t[(t.NONE = -1)] = "NONE"),
            (t[(t.LEFT = 0)] = "LEFT"),
            (t[(t.RIGHT = 1)] = "RIGHT");
        })(MA || (MA = {})),
        (function (t) {
          (t[(t.SESSION_RUNNING = 2)] = "SESSION_RUNNING"),
            (t[(t.VIEW_COUNT = 6)] = "VIEW_COUNT"),
            (t[(t.SWAPCHAIN_WIDTH = 7)] = "SWAPCHAIN_WIDTH"),
            (t[(t.SWAPCHAIN_HEIGHT = 8)] = "SWAPCHAIN_HEIGHT"),
            (t[(t.DEVICE_IPD = 37)] = "DEVICE_IPD"),
            (t[(t.SPLIT_AR_GLASSES = 42)] = "SPLIT_AR_GLASSES");
        })(PA || (PA = {})),
        (function (t) {
          (t[(t.VIEW_LEFT = 0)] = "VIEW_LEFT"),
            (t[(t.HAND_LEFT = 1)] = "HAND_LEFT"),
            (t[(t.AIM_LEFT = 2)] = "AIM_LEFT"),
            (t[(t.VIEW_RIGHT = 3)] = "VIEW_RIGHT"),
            (t[(t.HAND_RIGHT = 4)] = "HAND_RIGHT"),
            (t[(t.AIM_RIGHT = 5)] = "AIM_RIGHT"),
            (t[(t.HEAD_MIDDLE = 6)] = "HEAD_MIDDLE");
        })(NA || (NA = {}));
      const BA = Rs(),
        FA = {
          [Te.ORIENTATION_AUTO]: ye.AUTO,
          [Te.ORIENTATION_LANDSCAPE]: ye.LANDSCAPE,
          [Te.ORIENTATION_PORTRAIT]: ye.PORTRAIT,
        };
      class UA extends or(jl) {
        get originalDesignResolutionSize() {
          return this._originalDesignResolutionSize;
        }
        get originalResolutionPolicy() {
          return this._originalResolutionPolicy;
        }
        constructor() {
          super(),
            (this._designResolutionSize = Rs(0, 0)),
            (this._scaleX = 1),
            (this._scaleY = 1),
            (this._viewportRect = xs()),
            (this._visibleRect = xs()),
            (this._autoFullScreen = !1),
            (this._retinaEnabled = !1),
            (this._resizeCallback = null),
            (this._currentWindowId = 1),
            (this._originalDesignResolutionSize = null),
            (this._originalResolutionPolicy = null);
          const t = kA,
            e = zA;
          (this._rpExactFit = new HA(t.EQUAL_TO_FRAME, e.EXACT_FIT)),
            (this._rpShowAll = new HA(t.EQUAL_TO_FRAME, e.SHOW_ALL)),
            (this._rpNoBorder = new HA(t.EQUAL_TO_FRAME, e.NO_BORDER)),
            (this._rpFixedHeight = new HA(t.EQUAL_TO_FRAME, e.FIXED_HEIGHT)),
            (this._rpFixedWidth = new HA(t.EQUAL_TO_FRAME, e.FIXED_WIDTH)),
            (this._resolutionPolicy = this._rpShowAll);
        }
        init() {
          const t = kr.windowSize,
            e = t.width,
            i = t.height;
          if (
            ((this._designResolutionSize.width = e),
            (this._designResolutionSize.height = i),
            (this._viewportRect.width = e),
            (this._viewportRect.height = i),
            (this._visibleRect.width = e),
            (this._visibleRect.height = i),
            (BA.width = this._visibleRect.width),
            (BA.height = this._visibleRect.height),
            Hr)
          ) {
            Hr.init(this._visibleRect);
            let t = Lv.getScene();
            t && Hr.copyVisibleRect(t.visibleRect, Hr);
          }
          {
            this.resizeWithBrowserSize(!0);
            const t = ge.querySettings(fe.Category.SCREEN, "designResolution");
            t &&
              this.setDesignResolutionSize(
                Number(t.width),
                Number(t.height),
                t.policy || HA.FIXED_HEIGHT
              );
          }
          kr.on("window-resize", this._updateAdaptResult, this),
            kr.on("fullscreen-change", this._updateAdaptResult, this);
        }
        resizeWithBrowserSize(t) {
          Ur.handleResizeEvent = t;
        }
        setResizeCallback(t) {
          ("function" != typeof t && null != t) || (this._resizeCallback = t);
        }
        setOrientation(t) {
          Ur.orientation = FA[t];
        }
        adjustViewportMeta(t) {}
        enableRetina(t) {
          this._retinaEnabled = !!t;
        }
        isRetinaEnabled() {
          return this._retinaEnabled;
        }
        enableAutoFullScreen(t) {
          t !== this._autoFullScreen &&
            ((this._autoFullScreen = t),
            t && kr.requestFullScreen().catch(() => {}));
        }
        isAutoFullScreenEnabled() {
          return this._autoFullScreen;
        }
        setCanvasSize(t, e) {
          Ur.resolutionScale = 1;
          const i = Ur.devicePixelRatio,
            s = new ws(t * i, e * i);
          kr.windowSize = s;
        }
        getCanvasSize() {
          return kr.windowSize;
        }
        getFrameSize() {
          const t = Ur.devicePixelRatio,
            e = kr.windowSize;
          return (e.width /= t), (e.height /= t), e;
        }
        setFrameSize(t, e) {
          const i = Ur.devicePixelRatio;
          kr.windowSize = new ws(t * i, e * i);
        }
        getVisibleSize() {
          return new ws(this._visibleRect.width, this._visibleRect.height);
        }
        getVisibleSizeInPixel() {
          return new ws(
            this._visibleRect.width * this._scaleX,
            this._visibleRect.height * this._scaleY
          );
        }
        getVisibleOrigin() {
          return new Ss(this._visibleRect.x, this._visibleRect.y);
        }
        getVisibleOriginInPixel() {
          return new Ss(
            this._visibleRect.x * this._scaleX,
            this._visibleRect.y * this._scaleY
          );
        }
        getResolutionPolicy() {
          return this._resolutionPolicy;
        }
        _updateResolutionPolicy(t) {
          if (t instanceof HA) this._resolutionPolicy = t;
          else {
            const e = HA;
            t === e.EXACT_FIT && (this._resolutionPolicy = this._rpExactFit),
              t === e.SHOW_ALL && (this._resolutionPolicy = this._rpShowAll),
              t === e.NO_BORDER && (this._resolutionPolicy = this._rpNoBorder),
              t === e.FIXED_HEIGHT &&
                (this._resolutionPolicy = this._rpFixedHeight),
              t === e.FIXED_WIDTH &&
                (this._resolutionPolicy = this._rpFixedWidth);
          }
        }
        setResolutionPolicy(t) {
          this._updateResolutionPolicy(t);
          const e = GA.getDesignResolutionSize();
          GA.setDesignResolutionSize(e.width, e.height, t);
        }
        setDesignResolutionSize(t, e, i, s = 1) {
          var n, r;
          if (!(t > 0 && e > 0)) return void G(2200);
          (null !== (n = this._originalDesignResolutionSize) && void 0 !== n) ||
            (this._originalDesignResolutionSize = new ws(t, e)),
            (null !== (r = this._originalResolutionPolicy) && void 0 !== r) ||
              (this._originalResolutionPolicy = i);
          let a = Lv.scenes.get(s);
          if (a) {
            let s = a.getComponentInChildren("cc.Canvas");
            s &&
              (s.overrideDesignResolution &&
                ((t = s.designResolution.width),
                (e = s.designResolution.height)),
              s.overrideResolutionPolicy && (i = s.resolutionPolicy));
          }
          a &&
            a.windowSize &&
            ((jsb.window.innerWidth = a.windowSize.width / Ur.devicePixelRatio),
            (jsb.window.innerHeight =
              a.windowSize.height / Ur.devicePixelRatio),
            (this._currentWindowId = s)),
            this._updateResolutionPolicy(i);
          const o = this._resolutionPolicy;
          o && o.preApply(this),
            (this._designResolutionSize.width = t),
            (this._designResolutionSize.height = e);
          const h = o.apply(this, this._designResolutionSize);
          if (
            (h.scale &&
              2 === h.scale.length &&
              ((this._scaleX = h.scale[0]),
              (this._scaleY = h.scale[1]),
              a &&
                ((a.designResolutionScaleX = this._scaleX),
                (a.designResolutionScaleY = this._scaleY),
                (a.designResolutionSize.width = t),
                (a.designResolutionSize.height = t))),
            h.viewport)
          ) {
            const t = this._viewportRect,
              e = this._visibleRect,
              i = h.viewport;
            (t.x = i.x),
              (t.y = i.y),
              (t.width = i.width),
              (t.height = i.height),
              (e.x = 0),
              (e.y = 0),
              (e.width = i.width / this._scaleX),
              (e.height = i.height / this._scaleY);
          }
          o.postApply(this),
            (BA.width = this._visibleRect.width),
            (BA.height = this._visibleRect.height),
            Hr &&
              (Hr.init(this._visibleRect),
              a &&
                (Hr.copyVisibleRect(a.visibleRect, Hr),
                (a.viewportRect = new Ds(this._viewportRect)))),
            this.emit("design-resolution-changed", s);
        }
        getDesignResolutionSize() {
          return new ws(
            this._designResolutionSize.width,
            this._designResolutionSize.height
          );
        }
        setRealPixelResolution(t, e, i) {
          this.setDesignResolutionSize(t, e, i);
        }
        getViewportRect() {
          return this._viewportRect;
        }
        getScaleX() {
          return this._scaleX;
        }
        getScaleY() {
          return this._scaleY;
        }
        getDevicePixelRatio() {
          return Ur.devicePixelRatio;
        }
        convertToLocationInView(t, e, i, s = new Ss()) {
          const n = Ur.devicePixelRatio * (t - i.left),
            r = Ur.devicePixelRatio * (i.top + i.height - e);
          return (
            Ur.isFrameRotated
              ? ((s.x = kr.windowSize.width - r), (s.y = n))
              : ((s.x = n), (s.y = r)),
            s
          );
        }
        _convertToUISpace(t, e) {
          const i = e || 1,
            s = Lv.scenes.get(i),
            n = s && s.viewportRect ? s.viewportRect : this._viewportRect,
            r = s ? s.designResolutionScaleX : this._scaleX,
            a = s ? s.designResolutionScaleY : this._scaleY;
          (t.x = (t.x - n.x) / r), (t.y = (t.y - n.y) / a);
        }
        _updateAdaptResult(t, e, i) {
          var s;
          a.director.root.resize(t, e, void 0 === i || 0 === i ? 1 : i),
            ((t > e &&
              this._originalDesignResolutionSize.width <
                this._originalDesignResolutionSize.height) ||
              (t < e &&
                this._originalDesignResolutionSize.width >
                  this._originalDesignResolutionSize.height)) &&
              ([
                this._originalDesignResolutionSize.width,
                this._originalDesignResolutionSize.height,
              ] = [
                this._originalDesignResolutionSize.height,
                this._originalDesignResolutionSize.width,
              ]);
          let n = this._originalDesignResolutionSize.width,
            r = this._originalDesignResolutionSize.height,
            o = this._originalResolutionPolicy;
          t > 0 && e > 0
            ? this.setDesignResolutionSize(n, r, this._resolutionPolicy, i)
            : D(!1, "_updateAdaptResult Invalid size.");
          let h = i || 1,
            l = Lv.scenes.get(h);
          l && ((l.windowSize.width = t), (l.windowSize.height = e)),
            t > 0 && this.setDesignResolutionSize(n, r, o, i),
            this.emit("canvas-resize", i),
            null === (s = this._resizeCallback) || void 0 === s || s.call(this);
        }
      }
      t("View", UA), (UA.instance = void 0);
      class kA {
        constructor() {
          this.name = "ContainerStrategy";
        }
        preApply(t) {}
        apply(t, e) {}
        postApply(t) {}
        _setupCanvas() {
          const t = a.game.canvas;
          if (t) {
            const e = kr.windowSize;
            t.width !== e.width && (t.width = e.width),
              t.height !== e.height && (t.height = e.height);
          }
        }
      }
      (kA.EQUAL_TO_FRAME = void 0), (kA.PROPORTION_TO_FRAME = void 0);
      class zA {
        get strategy() {
          return this._strategy;
        }
        constructor() {
          (this.name = "ContentStrategy"),
            (this._result = { scale: [1, 1], viewport: null }),
            (this._strategy = HA.UNKNOWN);
        }
        preApply(t) {}
        apply(t, e) {
          return { scale: [1, 1] };
        }
        postApply(t) {}
        _buildResult(t, e, i, s, n, r) {
          Math.abs(t - i) < 2 && (i = t), Math.abs(e - s) < 2 && (s = e);
          const a = new Ds(
            Math.round((t - i) / 2),
            Math.round((e - s) / 2),
            i,
            s
          );
          return (
            (this._result.scale = [n, r]),
            (this._result.viewport = a),
            this._result
          );
        }
      }
      t("ContentStrategy", zA),
        (kA.EQUAL_TO_FRAME = new (class extends kA {
          constructor() {
            super(), (this.name = "EqualToFrame");
          }
          apply(t, e) {
            (Ur.isProportionalToFrame = !1), this._setupCanvas();
          }
        })()),
        (kA.PROPORTION_TO_FRAME = new (class extends kA {
          constructor() {
            super(), (this.name = "ProportionalToFrame");
          }
          apply(t, e) {
            (Ur.isProportionalToFrame = !0), this._setupCanvas();
          }
        })());
      class HA {
        constructor(t, e) {
          (this.name = "ResolutionPolicy"),
            (this._containerStrategy = t),
            (this._contentStrategy = e);
        }
        get canvasSize() {
          return kr.windowSize;
        }
        preApply(t) {
          this._contentStrategy.preApply(t);
        }
        apply(t, e) {
          return (
            this._containerStrategy.apply(t, e),
            this._contentStrategy.apply(t, e)
          );
        }
        postApply(t) {
          this._contentStrategy.postApply(t);
        }
        setContainerStrategy(t) {
          this._containerStrategy = t;
        }
        setContentStrategy(t) {
          this._contentStrategy = t;
        }
        getContentStrategy() {
          return this._contentStrategy;
        }
      }
      t("ResolutionPolicy", HA),
        (HA.EXACT_FIT = 0),
        (HA.NO_BORDER = 1),
        (HA.SHOW_ALL = 2),
        (HA.FIXED_HEIGHT = 3),
        (HA.FIXED_WIDTH = 4),
        (HA.UNKNOWN = 5),
        (HA.ContainerStrategy = kA),
        (HA.ContentStrategy = zA),
        (a.ResolutionPolicy = HA),
        (zA.EXACT_FIT = new (class extends zA {
          constructor() {
            super(), (this.name = "ExactFit"), (this._strategy = HA.EXACT_FIT);
          }
          apply(t, e) {
            let i = Lv.scenes.get(GA._currentWindowId);
            const s = null != i && i.windowSize ? i.windowSize : kr.windowSize,
              n = s.width,
              r = s.height,
              a = n / e.width,
              o = r / e.height;
            return this._buildResult(n, r, n, r, a, o);
          }
        })()),
        (zA.SHOW_ALL = new (class extends zA {
          constructor() {
            super(), (this.name = "ShowAll"), (this._strategy = HA.SHOW_ALL);
          }
          apply(t, e) {
            let i = Lv.scenes.get(GA._currentWindowId);
            const s = null != i && i.windowSize ? i.windowSize : kr.windowSize,
              n = s.width,
              r = s.height,
              a = e.width,
              o = e.height,
              h = n / a,
              l = r / o;
            let c,
              u,
              _ = 0;
            return (
              h < l
                ? ((_ = h), (c = n), (u = o * _))
                : ((_ = l), (c = a * _), (u = r)),
              this._buildResult(n, r, c, u, _, _)
            );
          }
        })()),
        (zA.NO_BORDER = new (class extends zA {
          constructor() {
            super(), (this.name = "NoBorder"), (this._strategy = HA.NO_BORDER);
          }
          apply(t, e) {
            let i = Lv.scenes.get(GA._currentWindowId);
            const s = null != i && i.windowSize ? i.windowSize : kr.windowSize,
              n = s.width,
              r = s.height,
              a = e.width,
              o = e.height,
              h = n / a,
              l = r / o;
            let c, u, _;
            return (
              h < l
                ? ((c = l), (u = a * c), (_ = r))
                : ((c = h), (u = n), (_ = o * c)),
              this._buildResult(n, r, u, _, c, c)
            );
          }
        })()),
        (zA.FIXED_HEIGHT = new (class extends zA {
          constructor() {
            super(),
              (this.name = "FixedHeight"),
              (this._strategy = HA.FIXED_HEIGHT);
          }
          apply(t, e) {
            let i = Lv.scenes.get(GA._currentWindowId);
            const s = null != i && i.windowSize ? i.windowSize : kr.windowSize,
              n = s.width,
              r = s.height,
              a = r / e.height,
              o = n,
              h = r;
            return this._buildResult(n, r, o, h, a, a);
          }
        })()),
        (zA.FIXED_WIDTH = new (class extends zA {
          constructor() {
            super(),
              (this.name = "FixedWidth"),
              (this._strategy = HA.FIXED_WIDTH);
          }
          apply(t, e) {
            let i = Lv.scenes.get(GA._currentWindowId);
            const s = null != i && i.windowSize ? i.windowSize : kr.windowSize,
              n = s.width,
              r = s.height,
              a = n / e.width,
              o = n,
              h = r;
            return this._buildResult(n, r, o, h, a, a);
          }
        })());
      const GA = t("view", (UA.instance = a.view = new UA()));
      Lv.registerSystem("view", GA, 0), (a.winSize = BA);
      const VA = new Ss();
      new qu(null);
      class jA {
        get isFinished() {
          return this._curTime >= this.settings.totalTime;
        }
        set curTime(t) {
          this._curTime = t;
        }
        get curTime() {
          return this._curTime;
        }
        init() {
          var t, e, i, s, n, r, o;
          let l = HA.SHOW_ALL;
          {
            const t = ge.querySettings(fe.Category.SCREEN, "designResolution");
            null !== t && (l = t.policy);
          }
          if (
            ((this.settings = {
              policy: null !== (t = l) && void 0 !== t ? t : HA.SHOW_ALL,
              displayRatio:
                null !==
                  (e = ge.querySettings(
                    fe.Category.SPLASH_SCREEN,
                    "displayRatio"
                  )) && void 0 !== e
                  ? e
                  : 0.4,
              totalTime:
                null !==
                  (i = ge.querySettings(
                    fe.Category.SPLASH_SCREEN,
                    "totalTime"
                  )) && void 0 !== i
                  ? i
                  : 3e3,
              watermarkLocation:
                null !==
                  (s = ge.querySettings(
                    fe.Category.SPLASH_SCREEN,
                    "watermarkLocation"
                  )) && void 0 !== s
                  ? s
                  : "default",
              autoFit:
                null ===
                  (n = ge.querySettings(
                    fe.Category.SPLASH_SCREEN,
                    "autoFit"
                  )) ||
                void 0 === n ||
                n,
              logo:
                null !==
                  (r = ge.querySettings(fe.Category.SPLASH_SCREEN, "logo")) &&
                void 0 !== r
                  ? r
                  : void 0,
              background:
                null !==
                  (o = ge.querySettings(
                    fe.Category.SPLASH_SCREEN,
                    "background"
                  )) && void 0 !== o
                  ? o
                  : void 0,
            }),
            (this._curTime = 0),
            !(
              this.settings.totalTime <= 0 ||
              void 0 === this.settings.logo ||
              void 0 === this.settings.background
            ))
          ) {
            (this.device = a.director.root.device),
              (this.swapchain = a.director.root.mainWindow.swapchain),
              this.preInit(),
              this.initLayout(),
              "default" === this.settings.logo.type && this.initWaterMark();
            let t = Promise.resolve(),
              e = Promise.resolve();
            return (
              "custom" === this.settings.background.type &&
                (t = new Promise((t, e) => {
                  (this.bgImage = new h.Image()),
                    (this.bgImage.onload = () => {
                      this.initBG(), t();
                    }),
                    (this.bgImage.onerror = () => {
                      e();
                    }),
                    (this.bgImage.src = this.settings.background.base64);
                })),
              "none" !== this.settings.logo.type &&
                (e = new Promise((t, e) => {
                  (this.logoImage = new h.Image()),
                    (this.logoImage.onload = () => {
                      this.initLogo(), t();
                    }),
                    (this.logoImage.onerror = () => {
                      e();
                    }),
                    (this.logoImage.src = this.settings.logo.base64);
                })),
              Promise.all([t, e])
            );
          }
          return (this.settings.totalTime = 0), Promise.resolve([]);
        }
        preInit() {
          var t;
          const e =
            null === (t = this.settings.background) || void 0 === t
              ? void 0
              : t.color;
          this.clearColors = e
            ? [new pu(e.x, e.y, e.z, e.w)]
            : [new pu(0, 0, 0, 1)];
          const { device: i, swapchain: s } = this;
          (this.renderArea = new au(0, 0, s.width, s.height)),
            (this.cmdBuff = i.commandBuffer);
          const n = new Float32Array([
              0.5, 0.5, 1, 0, -0.5, 0.5, 0, 0, 0.5, -0.5, 1, 1, -0.5, -0.5, 0,
              1,
            ]),
            r = 4 * Float32Array.BYTES_PER_ELEMENT,
            a = 4 * r;
          (this.vertexBuffers = i.createBuffer(
            new yu(Tc.VERTEX | Tc.TRANSFER_DST, vc.DEVICE, a, r)
          )),
            this.vertexBuffers.update(n);
          const o = new Uint16Array([0, 1, 2, 1, 3, 2]),
            h = Uint16Array.BYTES_PER_ELEMENT,
            l = 6 * h;
          (this.indicesBuffers = i.createBuffer(
            new yu(Tc.INDEX | Tc.TRANSFER_DST, vc.DEVICE, l, h)
          )),
            this.indicesBuffers.update(o);
          const c = [
              new Lu("a_position", fc.RG32F),
              new Lu("a_texCoord", fc.RG32F),
            ],
            u = new Fu(c, [this.vertexBuffers], this.indicesBuffers);
          (this.quadAssmebler = i.createInputAssembler(u)),
            (this.projection = new ms()),
            ms.ortho(
              this.projection,
              -1,
              1,
              -1,
              1,
              -1,
              1,
              i.capabilities.clipSpaceMinZ,
              i.capabilities.clipSpaceSignY,
              s.surfaceTransform
            ),
            (this.isMobile = zr.isMobile);
        }
        initLayout() {
          this.isMobile
            ? ((this.bgWidth = 812),
              (this.bgHeight = 375),
              (this.logoWidthTemp = 70),
              (this.logoHeightTemp = 100),
              (this.textSize = 12),
              (this.textHeight = this.textSize + this.textExpandSize),
              (this.textXTrans = 0.5),
              (this.textYExtraTrans = 16))
            : ((this.bgWidth = 1920),
              (this.bgHeight = 1080),
              (this.logoWidthTemp = 140),
              (this.logoHeightTemp = 200),
              (this.textSize = 24),
              (this.textHeight = this.textSize + this.textExpandSize),
              (this.textXTrans = 0.5),
              (this.textYExtraTrans = 32)),
            (this.logoXTrans = 0.5),
            (this.logoYTrans = 1 / 6 + 2.5 / 6),
            this.initScale();
        }
        initScale() {
          const t = this.swapchain.width,
            e = this.swapchain.height;
          let i = this.isMobile ? 375 : 1080,
            s = this.isMobile ? 812 : 1920;
          if (t > e) {
            const t = s;
            (s = i), (i = t);
          }
          this.scaleSize = t / e > 16 / 9 ? e / s : t / i;
        }
        update(t) {
          const e = this.settings,
            { device: i, swapchain: s } = this;
          ms.ortho(
            this.projection,
            -1,
            1,
            -1,
            1,
            -1,
            1,
            i.capabilities.clipSpaceMinZ,
            i.capabilities.clipSpaceSignY,
            s.surfaceTransform
          );
          const n = s.width,
            r = s.height;
          this.initScale(), (this._curTime += 1e3 * t);
          const a = Mo(Ei(this._curTime / e.totalTime));
          let o = 1,
            h = 1;
          "custom" === this.settings.background.type &&
            (this.settings.policy === HA.FIXED_WIDTH
              ? ((o = n), (h = (n / this.bgImage.width) * this.bgImage.height))
              : this.settings.policy === HA.FIXED_HEIGHT
              ? ((o = (r / this.bgImage.height) * this.bgImage.width), (h = r))
              : this.settings.policy === HA.SHOW_ALL
              ? this.bgImage.width / this.bgHeight > n / r
                ? ((o = n),
                  (h = (n / this.bgImage.width) * this.bgImage.height))
                : ((o = (r / this.bgImage.height) * this.bgImage.width),
                  (h = r))
              : this.settings.policy === HA.NO_BORDER
              ? this.bgImage.width / this.bgImage.height > n / r
                ? ((o = (r / this.bgImage.height) * this.bgImage.width),
                  (h = r))
                : ((o = n),
                  (h = (n / this.bgImage.width) * this.bgImage.height))
              : ((o = n), (h = r)),
            this.bgMat.setProperty("resolution", VA.set(n, r), 0),
            this.bgMat.setProperty("scale", VA.set(o, h), 0),
            this.bgMat.setProperty("translate", VA.set(0.5 * n, 0.5 * r), 0),
            this.bgMat.setProperty("percent", 1),
            this.bgMat.setProperty("u_projection", this.projection),
            this.bgMat.passes[0].update());
          const l = r * this.logoYTrans;
          if (
            ("none" !== this.settings.logo.type &&
              ((h = 0.185 * r * e.displayRatio),
              (o =
                this.logoWidth *
                ((0.185 * r) / this.logoHeight) *
                e.displayRatio),
              this.logoMat.setProperty("resolution", VA.set(n, r), 0),
              this.logoMat.setProperty("scale", VA.set(o, h), 0),
              this.logoMat.setProperty(
                "translate",
                VA.set(n * this.logoXTrans, l),
                0
              ),
              this.logoMat.setProperty("percent", a),
              this.logoMat.setProperty("u_projection", this.projection),
              this.logoMat.passes[0].update()),
            "default" === this.settings.logo.type && this.watermarkMat)
          ) {
            const t = this.watermarkTexture.width,
              i = this.watermarkTexture.height;
            (o = t), (h = i);
            const s =
              l -
              (0.5 * this.logoHeight * e.displayRatio + this.textYExtraTrans) *
                this.scaleSize -
              0.5 * i;
            this.watermarkMat.setProperty("resolution", VA.set(n, r), 0),
              this.watermarkMat.setProperty("scale", VA.set(o, h), 0),
              this.watermarkMat.setProperty(
                "translate",
                VA.set(n * this.textXTrans, s),
                0
              ),
              this.watermarkMat.setProperty("percent", a),
              this.watermarkMat.setProperty("u_projection", this.projection),
              this.watermarkMat.passes[0].update();
          }
          this.frame();
        }
        initBG() {
          const t = this.device;
          (this.bgMat = new ey()),
            this.bgMat.initialize({ effectName: "util/splash-screen" });
          const e = new Cu();
          (e.addressU = Dc.CLAMP),
            (e.addressV = Dc.CLAMP),
            (e.addressW = Dc.CLAMP),
            (this.sampler = t.getSampler(e)),
            (this.bgTexture = t.createTexture(
              new bu(
                bc.TEX2D,
                Ac.SAMPLED | Ac.TRANSFER_DST,
                fc.RGBA8,
                this.bgImage.width,
                this.bgImage.height
              )
            ));
          const i = this.bgMat.passes[0],
            s = i.getBinding("mainTexture");
          i.bindTexture(s, this.bgTexture),
            (this.shader = i.getShaderVariant());
          const n = i.descriptorSet;
          n.bindSampler(s, this.sampler), n.update();
          const r = new _u();
          (r.texExtent.width = this.bgImage.width),
            (r.texExtent.height = this.bgImage.height),
            (r.texExtent.depth = 1),
            t.copyTexImagesToTexture([this.bgImage], this.bgTexture, [r]);
        }
        initLogo() {
          const t = this.device;
          (this.logoMat = new ey()),
            this.logoMat.initialize({ effectName: "util/splash-screen" });
          const e = new Cu();
          (e.addressU = Dc.CLAMP),
            (e.addressV = Dc.CLAMP),
            (e.addressW = Dc.CLAMP),
            (this.sampler = t.getSampler(e)),
            (this.logoTexture = t.createTexture(
              new bu(
                bc.TEX2D,
                Ac.SAMPLED | Ac.TRANSFER_DST,
                fc.RGBA8,
                this.logoImage.width,
                this.logoImage.height
              )
            ));
          const i = this.logoMat.passes[0],
            s = i.getBinding("mainTexture");
          i.bindTexture(s, this.logoTexture),
            (this.shader = i.getShaderVariant());
          const n = i.descriptorSet;
          n.bindSampler(s, this.sampler), n.update();
          const r = new _u();
          (r.texExtent.width = this.logoImage.width),
            (r.texExtent.height = this.logoImage.height),
            (r.texExtent.depth = 1),
            t.copyTexImagesToTexture([this.logoImage], this.logoTexture, [r]);
          const a = this.logoImage.width / this.logoImage.height;
          a < 1
            ? ((this.logoWidth = this.logoWidthTemp),
              (this.logoHeight = this.logoWidthTemp / a))
            : ((this.logoWidth = this.logoHeightTemp * a),
              (this.logoHeight = this.logoHeightTemp));
        }
        initWaterMark() {
          const t = h.document.createElement("canvas");
          (t.height = this.textHeight * this.scaleSize),
            (t.style.width = `${t.width}`),
            (t.style.height = `${t.height}`);
          const e = "Created with Cocos",
            i = t.getContext("2d");
          (i.font = this.textSize * this.scaleSize + "px Arial"),
            (i.textBaseline = "top"),
            (i.textAlign = "center"),
            (i.fillStyle = "#707070");
          const s = i.measureText(e).width + 10;
          (t.width = s),
            (i.font = this.textSize * this.scaleSize + "px Arial"),
            (i.textBaseline = "top"),
            (i.textAlign = "center"),
            (i.fillStyle = "#707070"),
            i.fillText(e, t.width / 2, 0);
          const n = new _u();
          (n.texExtent.width = t.width),
            (n.texExtent.height = t.height),
            (n.texExtent.depth = 1),
            (this.watermarkTexture = this.device.createTexture(
              new bu(
                bc.TEX2D,
                Ac.SAMPLED | Ac.TRANSFER_DST,
                fc.RGBA8,
                t.width,
                t.height
              )
            )),
            this.device.copyTexImagesToTexture([t], this.watermarkTexture, [n]),
            (this.watermarkMat = new ey()),
            this.watermarkMat.initialize({ effectName: "util/splash-screen" });
          const r = this.watermarkMat.passes[0],
            a = r.getBinding("mainTexture");
          r.bindTexture(a, this.watermarkTexture), r.descriptorSet.update();
        }
        frame() {
          const { device: t, swapchain: e } = this;
          if (!zr.isXR || xr.entry.isRenderAllowable()) {
            const i = zr.isXR ? 2 : 1;
            for (let s = 0; s < i; s++) {
              if (zr.isXR) {
                xr.entry.renderLoopStart(s);
                const i = xr.entry.getEyeFov(s);
                let n = 1,
                  r = 1;
                s === MA.LEFT
                  ? (n = Math.abs(Math.tan(i[0])) / Math.abs(Math.tan(i[1])))
                  : s === MA.RIGHT &&
                    (r = Math.abs(Math.tan(i[1])) / Math.abs(Math.tan(i[0]))),
                  ms.ortho(
                    this.projection,
                    -n,
                    r,
                    -1,
                    1,
                    -1,
                    1,
                    t.capabilities.clipSpaceMinZ,
                    t.capabilities.clipSpaceSignY,
                    e.surfaceTransform
                  ),
                  (this.projection.m00 = ps[e.surfaceTransform][0]),
                  (this.projection.m05 =
                    ps[e.surfaceTransform][3] * t.capabilities.clipSpaceSignY),
                  "custom" === this.settings.background.type &&
                    (this.bgMat.setProperty("u_projection", this.projection),
                    this.bgMat.passes[0].update()),
                  "none" !== this.settings.logo.type &&
                    (this.logoMat.setProperty("u_projection", this.projection),
                    this.logoMat.passes[0].update()),
                  "default" === this.settings.logo.type &&
                    this.watermarkMat &&
                    (this.watermarkMat.setProperty(
                      "u_projection",
                      this.projection
                    ),
                    this.watermarkMat.passes[0].update());
              }
              t.enableAutoBarrier(!0), t.acquire([e]);
              const i = this.cmdBuff,
                n = a.director.root.mainWindow.framebuffer,
                r = this.renderArea;
              (r.width = e.width),
                (r.height = e.height),
                i.begin(),
                i.beginRenderPass(n.renderPass, n, r, this.clearColors, 1, 0);
              const o = a.director.root.pipeline;
              if ("custom" === this.settings.background.type) {
                const e = this.bgMat.passes[0],
                  s = xA.getOrCreatePipelineState(
                    t,
                    e,
                    this.shader,
                    n.renderPass,
                    this.quadAssmebler
                  );
                i.bindPipelineState(s),
                  i.bindDescriptorSet(cb.GLOBAL, o.descriptorSet),
                  i.bindDescriptorSet(cb.MATERIAL, e.descriptorSet),
                  i.bindInputAssembler(this.quadAssmebler),
                  i.draw(this.quadAssmebler);
              }
              if ("none" !== this.settings.logo.type) {
                const e = this.logoMat.passes[0],
                  s = xA.getOrCreatePipelineState(
                    t,
                    e,
                    this.shader,
                    n.renderPass,
                    this.quadAssmebler
                  );
                i.bindPipelineState(s),
                  i.bindDescriptorSet(cb.GLOBAL, o.descriptorSet),
                  i.bindDescriptorSet(cb.MATERIAL, e.descriptorSet),
                  i.bindInputAssembler(this.quadAssmebler),
                  i.draw(this.quadAssmebler);
              }
              if ("default" === this.settings.logo.type && this.watermarkMat) {
                const e = this.watermarkMat.passes[0],
                  s = xA.getOrCreatePipelineState(
                    t,
                    e,
                    this.shader,
                    n.renderPass,
                    this.quadAssmebler
                  );
                i.bindPipelineState(s),
                  i.bindDescriptorSet(cb.GLOBAL, o.descriptorSet),
                  i.bindDescriptorSet(cb.MATERIAL, e.descriptorSet),
                  i.bindInputAssembler(this.quadAssmebler),
                  i.draw(this.quadAssmebler);
              }
              i.endRenderPass(),
                i.end(),
                t.flushCommands([i]),
                t.queue.submit([i]),
                t.present(),
                t.enableAutoBarrier(!a.rendering),
                zr.isXR && xr.entry.renderLoopEnd(s);
            }
          }
        }
        destroy() {
          (this.device = null),
            (this.swapchain = null),
            (this.clearColors = null),
            "custom" === this.settings.background.type &&
              (this.bgImage.destroy && this.bgImage.destroy(),
              (this.bgImage = null),
              this.bgMat.destroy(),
              (this.bgMat = null),
              this.bgTexture.destroy(),
              (this.bgTexture = null)),
            "none" !== this.settings.logo.type &&
              (this.logoImage.destroy && this.logoImage.destroy(),
              (this.logoImage = null),
              this.logoMat.destroy(),
              (this.logoMat = null),
              this.logoTexture.destroy(),
              (this.logoTexture = null)),
            (this.renderArea = null),
            (this.cmdBuff = null),
            (this.shader = null),
            this.quadAssmebler.destroy(),
            (this.quadAssmebler = null),
            this.vertexBuffers.destroy(),
            (this.vertexBuffers = null),
            this.indicesBuffers.destroy(),
            (this.indicesBuffers = null),
            (this.sampler = null),
            "default" === this.settings.logo.type &&
              this.watermarkTexture &&
              (this.watermarkMat.destroy(),
              (this.watermarkMat = null),
              this.watermarkTexture.destroy(),
              (this.watermarkTexture = null)),
            (this.settings = null);
        }
        static get instance() {
          return jA._ins || (jA._ins = new jA()), jA._ins;
        }
        constructor() {
          (this.settings = void 0),
            (this._curTime = 0),
            (this.device = void 0),
            (this.swapchain = void 0),
            (this.shader = void 0),
            (this.sampler = void 0),
            (this.cmdBuff = void 0),
            (this.quadAssmebler = void 0),
            (this.vertexBuffers = void 0),
            (this.indicesBuffers = void 0),
            (this.renderArea = void 0),
            (this.clearColors = void 0),
            (this.projection = void 0),
            (this.isMobile = !1),
            (this.bgMat = void 0),
            (this.bgImage = void 0),
            (this.bgTexture = void 0),
            (this.logoMat = void 0),
            (this.logoImage = void 0),
            (this.logoTexture = void 0),
            (this.watermarkMat = void 0),
            (this.watermarkTexture = void 0),
            (this.bgWidth = 1920),
            (this.bgHeight = 1080),
            (this.logoWidthTemp = 140),
            (this.logoHeightTemp = 200),
            (this.logoWidth = 0),
            (this.logoHeight = 0),
            (this.logoXTrans = 0.5),
            (this.logoYTrans = 1 / 6 + 2.5 / 6),
            (this.textSize = 24),
            (this.textHeight = 24),
            (this.textXTrans = 0.5),
            (this.textYExtraTrans = 32),
            (this.textExpandSize = 4),
            (this.scaleSize = 1);
        }
      }
      (jA._ins = void 0), (a.internal.SplashScreen = jA);
      const WA = new (class {
        constructor() {
          this._data = null;
        }
        init(t = "") {
          return a.rendering && a.rendering.enableEffectImport && t
            ? new Promise((e, i) => {
                if (t.startsWith("http")) {
                  const s = new XMLHttpRequest();
                  s.open("GET", t),
                    (s.responseType = "arraybuffer"),
                    (s.onload = () => {
                      (this._data = s.response), e();
                    }),
                    (s.onerror = () => {
                      i(new Error("request effect settings failed!"));
                    }),
                    s.send(null);
                } else
                  globalThis.fsUtils.readArrayBuffer(t, (t, s) => {
                    t ? i(t) : ((this._data = s), e());
                  });
              })
            : Promise.resolve();
        }
        get data() {
          return this._data;
        }
      })();
      a.effectSettings = WA;
      class XA extends hr {
        constructor() {
          super(),
            (this.frame = null),
            (this.container = null),
            (this.canvas = null),
            (this.renderType = -1),
            (this.eventTargetOn = super.on),
            (this.eventTargetOnce = super.once),
            (this.config = {}),
            (this.onStart = null),
            (this.frameTime = 1e3 / 60),
            (this._isCloning = !1),
            (this._inited = !1),
            (this._engineInited = !1),
            (this._rendererInitialized = !1),
            (this._paused = !0),
            (this._pausedByEngine = !1),
            (this._frameRate = 60),
            (this._pacer = null),
            (this._initTime = 0),
            (this._startTime = 0),
            (this._deltaTime = 0),
            (this._useFixedDeltaTime = !1),
            (this._shouldLoadLaunchScene = !0),
            (this.onPreBaseInitDelegate = new lr()),
            (this.onPostBaseInitDelegate = new lr()),
            (this.onPreInfrastructureInitDelegate = new lr()),
            (this.onPostInfrastructureInitDelegate = new lr()),
            (this.onPreSubsystemInitDelegate = new lr()),
            (this.onPostSubsystemInitDelegate = new lr()),
            (this.onPreProjectInitDelegate = new lr()),
            (this.onPostProjectInitDelegate = new lr());
        }
        get inited() {
          return this._inited;
        }
        get frameRate() {
          return this._frameRate;
        }
        set frameRate(t) {
          "number" != typeof t &&
            ((t = parseInt(t, 10)), Number.isNaN(t) && (t = 60)),
            (this._frameRate = t),
            (this.frameTime = 1e3 / t),
            this._pacer && (this._pacer.targetFrameRate = this._frameRate);
        }
        get deltaTime() {
          return this._useFixedDeltaTime
            ? this.frameTime / 1e3
            : this._deltaTime;
        }
        get totalTime() {
          return performance.now() - this._initTime;
        }
        get frameStartTime() {
          return this._startTime;
        }
        setFrameRate(t) {
          this.frameRate = t;
        }
        getFrameRate() {
          return this.frameRate;
        }
        step() {
          Lv.tick(this._calculateDT(!0));
        }
        pauseByEngine() {
          this._paused || ((this._pausedByEngine = !0), this.pause());
        }
        resumeByEngine() {
          this._pausedByEngine && (this.resume(), (this._pausedByEngine = !1));
        }
        pause() {
          var t;
          this._paused ||
            ((this._paused = !0),
            null === (t = this._pacer) || void 0 === t || t.stop(),
            this.emit(XA.EVENT_PAUSE));
        }
        resume() {
          var t;
          this._paused &&
            (_f._clearEvents(),
            (this._paused = !1),
            null === (t = this._pacer) || void 0 === t || t.start(),
            this.emit(XA.EVENT_RESUME));
        }
        isPaused() {
          return this._paused;
        }
        restart() {
          return new Promise((t) => {
            Lv.once(Nv.EVENT_END_FRAME, () => t());
          }).then(() => {
            Lv.reset(),
              a.Object._deferredDestroy(),
              this.pause(),
              this.resume(),
              (this._shouldLoadLaunchScene = !0),
              (jA.instance.curTime = 0),
              this._safeEmit(XA.EVENT_RESTART);
          });
        }
        end() {
          yr.close();
        }
        on(t, e, i, s) {
          return (
            this.canRegisterEvent(t) && e.call(i),
            this.eventTargetOn(t, e, i, s)
          );
        }
        once(t, e, i) {
          return this.canRegisterEvent(t)
            ? e.call(i)
            : this.eventTargetOnce(t, e, i);
        }
        canRegisterEvent(t) {
          return (
            (this._engineInited && t === XA.EVENT_ENGINE_INITED) ||
            (this._inited && t === XA.EVENT_GAME_INITED) ||
            (this._rendererInitialized && t === XA.EVENT_RENDERER_INITED)
          );
        }
        init(t) {
          return (
            this._compatibleWithOldParams(t),
            Promise.resolve()
              .then(
                () => (
                  this.emit(XA.EVENT_PRE_BASE_INIT),
                  this.onPreBaseInitDelegate.dispatch()
                )
              )
              .then(() => {
                M(t.debugMode || W.NONE);
              })
              .then(() => zr.init())
              .then(() => {
                this._initEvents();
              })
              .then(() => ge.init(t.settingsPath, t.overrideSettings))
              .then(
                () => (
                  this.emit(XA.EVENT_POST_BASE_INIT),
                  this.onPostBaseInitDelegate.dispatch()
                )
              )
              .then(
                () => (
                  this.emit(XA.EVENT_PRE_INFRASTRUCTURE_INIT),
                  this.onPreInfrastructureInitDelegate.dispatch()
                )
              )
              .then(() => {
                Te.init(), this._initXR();
                const t = (function () {
                  const t = Fv.createElement("div");
                  return {
                    frame: Fv.documentElement,
                    canvas: Bv.__canvas,
                    container: t,
                  };
                })();
                return (
                  t &&
                    ((this.canvas = t.canvas),
                    (this.frame = t.frame),
                    (this.container = t.container)),
                  kr.init(),
                  rc.init(),
                  I_.init(this.canvas, ub)
                );
              })
              .then(() => {
                if (ge.querySettings(fe.Category.RENDERING, "customPipeline")) {
                  if (!a.rendering) return void G(12109);
                  Te.CUSTOM_PIPELINE_NAME ||
                    (Te.CUSTOM_PIPELINE_NAME = "Builtin");
                } else a.rendering = void 0;
                Tv.init(), Pv.init(), Rf.init(), this.initPacer();
              })
              .then(
                () => (
                  this.emit(XA.EVENT_POST_INFRASTRUCTURE_INIT),
                  this.onPostInfrastructureInitDelegate.dispatch()
                )
              )
              .then(
                () => (
                  this.emit(XA.EVENT_PRE_SUBSYSTEM_INIT),
                  this.onPreSubsystemInitDelegate.dispatch()
                )
              )
              .then(() =>
                WA.init(
                  ge.querySettings(fe.Category.RENDERING, "effectSettingsPath")
                )
              )
              .then(() => {
                if (!a.rendering || !a.rendering.enableEffectImport) return;
                if (
                  ge.querySettings(fe.Category.RENDERING, "renderMode") ===
                  A_.HEADLESS
                )
                  return void a.rendering.init(I_.gfxDevice, null);
                const t = WA.data;
                null !== t ? a.rendering.init(I_.gfxDevice, t) : G(1102);
              })
              .then(() => {
                const t = ge.querySettings(
                  fe.Category.SCRIPTING,
                  "scriptPackages"
                );
                return t
                  ? Promise.all(t.map((t) => e.import(t)))
                  : Promise.resolve([]);
              })
              .then(() => (Lv.init(), Pv.loadBuiltinAssets()))
              .then(
                () => (
                  this.emit(XA.EVENT_POST_SUBSYSTEM_INIT),
                  this.onPostSubsystemInitDelegate.dispatch()
                )
              )
              .then(() => {
                I(`Cocos Creator v${o}`),
                  this.emit(XA.EVENT_ENGINE_INITED),
                  (this._engineInited = !0);
              })
              .then(
                () => (
                  this.emit(XA.EVENT_PRE_PROJECT_INIT),
                  this.onPreProjectInitDelegate.dispatch()
                )
              )
              .then(() => {
                const t = ge.querySettings(fe.Category.PLUGINS, "jsList");
                let e = Promise.resolve();
                return (
                  t &&
                    t.forEach((t) => {
                      e = e.then(() => {
                        return (
                          (e = `src/${t}`),
                          window.oh && "napi" === window.scriptEngineType
                            ? (window.oh.loadModule(e), Promise.resolve())
                            : require(`${e}`)
                        );
                        var e;
                      });
                    }),
                  e
                );
              })
              .then(() => this._loadProjectBundles())
              .then(() => this._loadCCEScripts())
              .then(() => this._setupRenderPipeline())
              .then(() => this._loadPreloadAssets())
              .then(() => (Pv.compileBuiltinMaterial(), jA.instance.init()))
              .then(
                () => (
                  this.emit(XA.EVENT_POST_PROJECT_INIT),
                  this.onPostProjectInitDelegate.dispatch()
                )
              )
              .then(() => {
                (this._inited = !0), this._safeEmit(XA.EVENT_GAME_INITED);
              })
          );
        }
        _initXR() {
          var t;
          if (
            (void 0 === globalThis.__globalXR && (globalThis.__globalXR = {}),
            (globalThis.__globalXR.webxrCompatible =
              null !==
                (t = ge.querySettings(fe.Category.XR, "webxrCompatible")) &&
              void 0 !== t &&
              t),
            zr.isXR)
          ) {
            var e, i;
            xr.entry = xr.XrEntry.getInstance();
            const t =
                null !==
                  (e = ge.querySettings(fe.Category.RENDERING, "msaa")) &&
                void 0 !== e
                  ? e
                  : 1,
              s =
                null !==
                  (i = ge.querySettings(
                    fe.Category.RENDERING,
                    "renderingScale"
                  )) && void 0 !== i
                  ? i
                  : 1;
            xr.entry.setMultisamplesRTT(t), xr.entry.setRenderingScale(s);
          }
        }
        _compatibleWithOldParams(t) {
          const e = (t.overrideSettings = t.overrideSettings || {});
          "showFPS" in t &&
            ((e.profiling = e.profiling || {}),
            (e.profiling.showFPS = t.showFPS)),
            "frameRate" in t &&
              ((e.screen = e.screen || {}), (e.screen.frameRate = t.frameRate)),
            "renderMode" in t &&
              ((e.rendering = e.rendering || {}),
              (e.rendering.renderMode = t.renderMode)),
            "renderPipeline" in t &&
              ((e.rendering = e.rendering || {}),
              (e.rendering.renderPipeline = t.renderPipeline)),
            "assetOptions" in t &&
              ((e.assets = e.assets || {}),
              Object.assign(e.assets, t.assetOptions)),
            "customJointTextureLayouts" in t &&
              ((e.animation = e.animation || {}),
              (e.animation.customJointTextureLayouts =
                t.customJointTextureLayouts)),
            "physics" in t &&
              ((e.physics = e.physics || {}),
              Object.assign(e.physics, t.physics)),
            "orientation" in t &&
              ((e.screen = e.screen || {}),
              (e.screen.orientation = t.orientation)),
            "exactFitScreen" in t &&
              ((e.screen = e.screen || {}),
              (e.screen.exactFitScreen = t.exactFitScreen));
        }
        _loadPreloadAssets() {
          const t = ge.querySettings(fe.Category.ASSETS, "preloadAssets");
          return t
            ? Promise.all(
                t.map(
                  (t) =>
                    new Promise((e, i) => {
                      Tv.loadAny(t, (t) => {
                        t ? i(t) : e();
                      });
                    })
                )
              )
            : Promise.resolve([]);
        }
        _loadCCEScripts() {
          return new Promise((t) => {
            t();
          });
        }
        _loadProjectBundles() {
          const t = ge.querySettings(fe.Category.ASSETS, "preloadBundles");
          return t
            ? Promise.all(
                t.map(
                  ({ bundle: t, version: e }) =>
                    new Promise((i, s) => {
                      const n = {};
                      e && (n.version = e),
                        Tv.loadBundle(t, n, (t) => {
                          t ? s(t) : i();
                        });
                    })
                )
              )
            : Promise.resolve([]);
        }
        run(t) {
          t && (this.onStart = t), this._inited && this.resume();
        }
        _calculateDT(t) {
          if (((this._useFixedDeltaTime = t), t))
            return (this._startTime = performance.now()), this.frameTime / 1e3;
          const e = performance.now();
          return (
            (this._deltaTime =
              e > this._startTime ? (e - this._startTime) / 1e3 : 0),
            this._deltaTime > XA.DEBUG_DT_THRESHOLD &&
              (this._deltaTime = this.frameTime / 1e3),
            (this._startTime = e),
            this._deltaTime
          );
        }
        _updateCallback() {
          if (this._inited)
            if (jA.instance.isFinished)
              if (this._shouldLoadLaunchScene) {
                this._shouldLoadLaunchScene = !1;
                const e = ge.querySettings(fe.Category.LAUNCH, "launchScene");
                var t;
                e
                  ? Lv.loadScene(e, () => {
                      var t;
                      B(1103, e),
                        (this._initTime = performance.now()),
                        Lv.startAnimation(),
                        null === (t = this.onStart) ||
                          void 0 === t ||
                          t.call(this);
                    })
                  : ((this._initTime = performance.now()),
                    Lv.startAnimation(),
                    null === (t = this.onStart) ||
                      void 0 === t ||
                      t.call(this));
              } else Lv.tick(this._calculateDT(!1));
            else jA.instance.update(this._calculateDT(!1));
        }
        initPacer() {
          var t;
          const e =
            null !== (t = ge.querySettings(fe.Category.SCREEN, "frameRate")) &&
            void 0 !== t
              ? t
              : 60;
          D("number" == typeof e),
            (this._pacer = new Uv()),
            (this._pacer.onTick = this._updateCallback.bind(this)),
            (this.frameRate = e);
        }
        _initEvents() {
          yr.on("show", this._onShow, this),
            yr.on("hide", this._onHide, this),
            yr.on("close", this._onClose, this),
            yr.on("onWindowWillClose", this._onWindowWillClose, this);
        }
        _onHide() {
          this.emit(XA.EVENT_HIDE), this.pauseByEngine();
        }
        _onShow() {
          this.emit(XA.EVENT_SHOW), this.resumeByEngine();
        }
        _onClose() {
          this.emit(XA.EVENT_CLOSE), yr.exit();
        }
        _onWindowWillClose(t) {
          this.emit(XA.EVENT_WINDOW_CLOSE, t);
        }
        addPersistRootNode(t) {
          Lv.addPersistRootNode(t);
        }
        removePersistRootNode(t) {
          Lv.removePersistRootNode(t);
        }
        isPersistRootNode(t) {
          return Lv.isPersistRootNode(t);
        }
        _setupRenderPipeline() {
          const t = ge.querySettings(fe.Category.RENDERING, "customPipeline");
          return this._setRenderPipeline(!!t);
        }
        _setRenderPipeline(t) {
          Lv.root.setRenderPipeline(t)
            ? ((this._rendererInitialized = !0),
              this._safeEmit(XA.EVENT_RENDERER_INITED))
            : G(1222);
        }
        _safeEmit(t) {
          this.emit(t);
        }
      }
      t("Game", XA),
        (XA.EVENT_HIDE = "game_on_hide"),
        (XA.EVENT_SHOW = "game_on_show"),
        (XA.EVENT_LOW_MEMORY = "game_on_low_memory"),
        (XA.EVENT_GAME_INITED = "game_inited"),
        (XA.EVENT_ENGINE_INITED = "engine_inited"),
        (XA.EVENT_RENDERER_INITED = "renderer_inited"),
        (XA.EVENT_PRE_BASE_INIT = "pre_base_init"),
        (XA.EVENT_POST_BASE_INIT = "post_base_init"),
        (XA.EVENT_PRE_INFRASTRUCTURE_INIT = "pre_infrastructure_init"),
        (XA.EVENT_POST_INFRASTRUCTURE_INIT = "post_infrastructure_init"),
        (XA.EVENT_PRE_SUBSYSTEM_INIT = "pre_subsystem_init"),
        (XA.EVENT_POST_SUBSYSTEM_INIT = "post_subsystem_init"),
        (XA.EVENT_PRE_PROJECT_INIT = "pre_project_init"),
        (XA.EVENT_POST_PROJECT_INIT = "post_project_init"),
        (XA.EVENT_RESTART = "game_on_restart"),
        (XA.EVENT_PAUSE = "game_on_pause"),
        (XA.EVENT_RESUME = "game_on_resume"),
        (XA.EVENT_CLOSE = "game_on_close"),
        (XA.EVENT_WINDOW_CLOSE = "window_close"),
        (XA.EVENT_WINDOW_ICONIFY = "window_iconify"),
        (XA.RENDER_TYPE_CANVAS = 0),
        (XA.RENDER_TYPE_WEBGL = 1),
        (XA.RENDER_TYPE_OPENGL = 2),
        (XA.RENDER_TYPE_HEADLESS = 3),
        (XA.DEBUG_DT_THRESHOLD = 1),
        (a.Game = XA);
      const YA = t("game", (a.game = new XA()));
      Q(Nv.prototype, "director", [
        { name: "calculateDeltaTime" },
        { name: "getDeltaTime", suggest: "Use game.deltaTime instead" },
        { name: "getTotalTime", suggest: "Use game.totalTime instead" },
        { name: "getCurrentTime", suggest: "Use game.frameStartTime instead" },
      ]),
        Z(Nv.prototype, "director", [
          {
            name: "setAnimationInterval",
            suggest: "please use game.frameRate instead",
          },
          {
            name: "getAnimationInterval",
            suggest: "please use game.frameRate instead",
          },
          { name: "getRunningScene", suggest: "please use getScene instead" },
          { name: "setDepthTest", suggest: "please use camera API instead" },
          { name: "setClearColor", suggest: "please use camera API instead" },
          {
            name: "getWinSize",
            suggest: "please use view.getVisibleSize instead",
          },
          { name: "getWinSizeInPixels" },
          {
            name: "purgeCachedData",
            suggest: "please use assetManager.releaseAll instead",
          },
          { name: "convertToGL" },
          { name: "convertToUI" },
        ]),
        $(Lv, "director", [
          {
            name: "_getSceneUuid",
            targetName: "assetManager.main",
            newName: "getSceneInfo",
            customFunction: (t) => {
              var e;
              return Tv.main
                ? null === (e = Tv.main.getSceneInfo(t)) || void 0 === e
                  ? void 0
                  : e.uuid
                : "";
            },
          },
        ]),
        Q(YA, "game", [{ name: "collisionMatrix" }, { name: "groupList" }]),
        $(YA, "game", [
          {
            name: "_sceneInfos",
            targetName: "assetManager.main",
            newName: "getSceneInfo",
            customGetter: () => {
              const t = [];
              return (
                Tv.main &&
                  Tv.main.config.scenes.forEach((e) => {
                    t.push(e);
                  }),
                t
              );
            },
          },
        ]);
      class KA extends jl {
        constructor() {
          super(),
            (this._atlases = []),
            (this._atlasIndex = -1),
            (this._maxAtlasCount = 5),
            (this._textureSize = 2048),
            (this._maxFrameSize = 512),
            (this._textureBleeding = !0),
            (this._enabled = !1);
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(t) {
          this._enabled !== t &&
            (t
              ? (this.reset(),
                a.director.on(
                  a.Director.EVENT_BEFORE_SCENE_LAUNCH,
                  this.beforeSceneLoad,
                  this
                ))
              : (this.reset(),
                a.director.off(
                  a.Director.EVENT_BEFORE_SCENE_LAUNCH,
                  this.beforeSceneLoad,
                  this
                )),
            (this._enabled = t));
        }
        get maxAtlasCount() {
          return this._maxAtlasCount;
        }
        set maxAtlasCount(t) {
          this._maxAtlasCount = t;
        }
        get atlasCount() {
          return this._atlases.length;
        }
        get textureBleeding() {
          return this._textureBleeding;
        }
        set textureBleeding(t) {
          this._textureBleeding = t;
        }
        get textureSize() {
          return this._textureSize;
        }
        set textureSize(t) {
          this._textureSize = t;
        }
        get maxFrameSize() {
          return this._maxFrameSize;
        }
        set maxFrameSize(t) {
          this._maxFrameSize = t;
        }
        newAtlas() {
          let t = this._atlases[++this._atlasIndex];
          return (
            !t &&
              this._atlasIndex < this.maxAtlasCount &&
              ((t = new rm(this._textureSize, this._textureSize)),
              this._atlases.push(t)),
            t
          );
        }
        beforeSceneLoad() {
          this.reset();
        }
        init() {
          this.enabled = !Te.CLEANUP_IMAGE_CACHE;
        }
        insertSpriteFrame(t) {
          if (
            !this._enabled ||
            this._atlasIndex >= this._maxAtlasCount ||
            !t ||
            t.original
          )
            return null;
          if (!t.packable) return null;
          const e = t.texture.getSamplerInfo();
          if (
            e.minFilter !== Rc.LINEAR ||
            e.magFilter !== Rc.LINEAR ||
            e.mipFilter !== Rc.NONE
          )
            return null;
          let i = this._atlases[this._atlasIndex];
          i || (i = this.newAtlas());
          const s = i ? i.insertSpriteFrame(t) : null;
          return !s && this._atlasIndex < this._maxAtlasCount
            ? ((i = this.newAtlas()), i ? i.insertSpriteFrame(t) : null)
            : s;
        }
        reset() {
          for (let t = 0, e = this._atlases.length; t < e; t++)
            this._atlases[t].destroy();
          (this._atlases.length = 0), (this._atlasIndex = -1);
        }
        deleteAtlasSpriteFrame(t) {
          if (!t.original) return;
          let e;
          for (let i = this._atlases.length - 1; i >= 0; i--)
            (e = this._atlases[i]), e.removeSpriteFrame(t);
          const i = t.original._texture;
          this.deleteAtlasTexture(i);
        }
        deleteAtlasTexture(t) {
          if (t)
            for (let e = this._atlases.length - 1; e >= 0; e--)
              this._atlases[e].deleteInnerTexture(t),
                this._atlases[e].isEmpty() &&
                  (this._atlases[e].destroy(),
                  this._atlases.splice(e, 1),
                  this._atlasIndex--);
        }
        packToDynamicAtlas(t, e) {
          if (
            this._enabled &&
            e &&
            !e.original &&
            e.packable &&
            e.texture &&
            e.texture.width > 0 &&
            e.texture.height > 0
          ) {
            const t = this.insertSpriteFrame(e);
            t && e._setDynamicAtlasFrame(t);
          }
        }
      }
      t("DynamicAtlasManager", KA), (KA.instance = void 0);
      const qA = t("dynamicAtlasManager", (KA.instance = new KA()));
      Lv.registerSystem("dynamicAtlasManager", qA, 0),
        (a.internal.dynamicAtlasManager = qA);
      const $A = {
        [gc.UNORM]: "Uint",
        [gc.SNORM]: "Int",
        [gc.UINT]: "Uint",
        [gc.INT]: "Int",
        [gc.UFLOAT]: "Float",
        [gc.FLOAT]: "Float",
        default: "Uint",
      };
      function ZA(t) {
        return `${$A[t.type] || $A.default}${(t.size / t.count) * 8}`;
      }
      function QA(t, e, i = fc.R32F, s = 0, n = 0) {
        const r = a_[i];
        n || (n = r.size);
        const a = `set${ZA(r)}`,
          o = r.size / r.count,
          h = Math.floor(e.length / r.count),
          l = zr.isLittleEndian;
        for (let i = 0; i < h; ++i) {
          const h = s + n * i;
          for (let s = 0; s < r.count; ++s) {
            const n = h + o * s;
            t[a](n, e[r.count * i + s], l);
          }
        }
      }
      function JA(t, e = fc.R32F, i = 0, s = t.byteLength - i, n = 0, r = []) {
        const a = a_[e];
        n || (n = a.size);
        const o = `get${ZA(a)}`,
          h = a.size / a.count,
          l = Math.floor(s / n),
          c = zr.isLittleEndian;
        for (let e = 0; e < l; ++e) {
          const s = i + n * e;
          for (let i = 0; i < a.count; ++i) {
            const n = s + h * i;
            r[a.count * e + i] = t[o](n, c);
          }
        }
        return r;
      }
      function tC(t, e, i = fc.R32F, s = 0, n = t.byteLength - s, r = 0, a) {
        a ||
          (a = new DataView(
            t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength)
          ));
        const o = a_[i];
        r || (r = o.size);
        const h = `set${ZA(o)}`,
          l = `get${ZA(o)}`,
          c = o.size / o.count,
          u = Math.floor(n / r),
          _ = zr.isLittleEndian;
        for (let i = 0; i < u; ++i) {
          const n = s + r * i;
          for (let i = 0; i < o.count; ++i) {
            const s = n + c * i,
              r = t[l](s, _);
            a[h](s, e(r, i, t), _);
          }
        }
        return a;
      }
      var eC;
      !(function (t) {
        (t[(t.positions = eu.ATTR_POSITION)] = "positions"),
          (t[(t.normals = eu.ATTR_NORMAL)] = "normals"),
          (t[(t.uvs = eu.ATTR_TEX_COORD)] = "uvs"),
          (t[(t.colors = eu.ATTR_COLOR)] = "colors");
      })(eC || (eC = {}));
      const iC = jsb.MeshUtils,
        sC = iC.createMesh;
      iC.createDynamicMesh, (a.MeshUtils = jsb.MeshUtils);
      var nC,
        rC,
        aC = Object.freeze({
          __proto__: null,
          find: aS,
          toPPM: function (t, e, i) {
            return `P3 ${e} ${i} 255\n${t
              .filter((t, e) => e % 4 < 3)
              .toString()}\n`;
          },
          readMesh: function (t, e = 0) {
            const i = { positions: [] },
              s = new DataView(
                t.data.buffer,
                t.data.byteOffset,
                t.data.byteLength
              ),
              n = t.struct,
              r = n.primitives[e];
            for (const t of r.vertexBundelIndices) {
              const e = n.vertexBundles[t];
              let r = e.view.offset;
              const { length: a, stride: o } = e.view;
              for (const t of e.attributes) {
                const e = eC[t.name];
                e && (i[e] = (i[e] || []).concat(JA(s, t.format, r, a, o))),
                  (r += a_[t.format].size);
              }
            }
            const a = r.indexView;
            return (
              (i.indices = JA(s, fc[`R${8 * a.stride}UI`], a.offset, a.length)),
              i
            );
          },
          createMesh: sC,
          MeshUtils: iC,
          readBuffer: JA,
          writeBuffer: QA,
          mapBuffer: tC,
        });
      t("utils", aC);
      const oC = Ki(),
        hC = ys();
      var lC;
      !(function (t) {
        (t[(t.RECT = 0)] = "RECT"), (t[(t.POLYGON = 1)] = "POLYGON");
      })(lC || (lC = {}));
      const cC = [
        { u: 0, v: 0 },
        { u: 0, v: 0 },
        { u: 0, v: 0 },
        { u: 0, v: 0 },
      ];
      let uC = t(
        "SpriteFrame",
        Ca("cc.SpriteFrame")(
          (((rC = class t extends Ad {
            static createWithImage(e) {
              const i = e instanceof wd ? e : new wd(e),
                s = new sm();
              s.image = i;
              const n = new t();
              return (n.texture = s), n;
            }
            get insetTop() {
              return this._capInsets[1];
            }
            set insetTop(t) {
              this._capInsets[1] !== t &&
                ((this._capInsets[1] = t),
                this._texture && this._calculateSlicedUV());
            }
            get insetBottom() {
              return this._capInsets[3];
            }
            set insetBottom(t) {
              this._capInsets[3] !== t &&
                ((this._capInsets[3] = t),
                this._texture && this._calculateSlicedUV());
            }
            get insetLeft() {
              return this._capInsets[0];
            }
            set insetLeft(t) {
              this._capInsets[0] !== t &&
                ((this._capInsets[0] = t),
                this._texture && this._calculateSlicedUV());
            }
            get insetRight() {
              return this._capInsets[2];
            }
            set insetRight(t) {
              this._capInsets[2] !== t &&
                ((this._capInsets[2] = t),
                this._texture && this._calculateSlicedUV());
            }
            get rect() {
              return this._rect;
            }
            set rect(t) {
              this._rect.equals(t) ||
                (this._rect.set(t),
                this._texture && this._calculateUV(),
                this._calcTrimmedBorder());
            }
            get originalSize() {
              return this._originalSize;
            }
            set originalSize(t) {
              this._originalSize.equals(t) ||
                (this._originalSize.set(t),
                this._texture && this._calculateUV(),
                this._calcTrimmedBorder());
            }
            get offset() {
              return this._offset;
            }
            set offset(t) {
              this._offset.set(t), this._calcTrimmedBorder();
            }
            get rotated() {
              return this._rotated;
            }
            set rotated(t) {
              this._rotated !== t &&
                ((this._rotated = t), this._texture && this._calculateUV());
            }
            get texture() {
              return this._texture;
            }
            set texture(t) {
              t
                ? t !== this._texture && this.reset({ texture: t }, !0)
                : z(3122, this.name);
            }
            get atlasUuid() {
              return this._atlasUuid;
            }
            set atlasUuid(t) {
              this._atlasUuid = t;
            }
            get width() {
              return this._texture.width;
            }
            get height() {
              return this._texture.height;
            }
            set _textureSource(t) {
              globalThis.Build
                ? (this._texture = t)
                : t && (this._refreshTexture(t), this._calculateUV());
            }
            get flipUVX() {
              return this._isFlipUVX;
            }
            set flipUVX(t) {
              (this._isFlipUVX = t), this._calculateUV();
            }
            get flipUVY() {
              return this._isFlipUVY;
            }
            set flipUVY(t) {
              (this._isFlipUVY = t), this._calculateUV();
            }
            get packable() {
              return this._packable;
            }
            set packable(t) {
              this._packable = t;
            }
            get original() {
              return this._original;
            }
            get pixelsToUnit() {
              return this._pixelsToUnit;
            }
            get pivot() {
              return this._pivot;
            }
            get mesh() {
              return this._mesh;
            }
            get trimmedBorder() {
              return this._trimmedBorder;
            }
            constructor() {
              super(),
                (this.vertices = null),
                (this.uv = []),
                (this.unbiasUV = []),
                (this.uvSliced = []),
                (this._rect = xs()),
                (this._trimmedBorder = Xi()),
                (this._offset = Es()),
                (this._originalSize = Rs()),
                (this._rotated = !1),
                (this._capInsets = [0, 0, 0, 0]),
                (this._atlasUuid = ""),
                (this._texture = void 0),
                (this._isFlipUVY = !1),
                (this._isFlipUVX = !1),
                (this._original = null),
                (this._packable = !0),
                (this._pixelsToUnit = 100),
                (this._pivot = Es(0.5, 0.5)),
                (this._meshType = lC.RECT),
                (this._extrude = 0),
                (this._customOutLine = []),
                (this._mesh = null),
                (this._minPos = Ki()),
                (this._maxPos = Ki());
            }
            textureLoaded() {
              return !!this.texture;
            }
            isRotated() {
              return this._rotated;
            }
            setRotated(t) {
              this.rotated = t;
            }
            getRect(t) {
              return t ? (t.set(this._rect), t) : this._rect.clone();
            }
            setRect(t) {
              this.rect = t;
            }
            getOriginalSize(t) {
              return t
                ? (t.set(this._originalSize), t)
                : this._originalSize.clone();
            }
            setOriginalSize(t) {
              this.originalSize = t;
            }
            getOffset(t) {
              return t ? (t.set(this._offset), t) : this._offset.clone();
            }
            setOffset(t) {
              this.offset = t;
            }
            getGFXTexture() {
              return this._texture.getGFXTexture();
            }
            getGFXSampler() {
              return this._texture.getGFXSampler();
            }
            getHash() {
              return this._texture.getHash();
            }
            getSamplerInfo() {
              return this._texture.getSamplerInfo();
            }
            reset(t, e = !1) {
              let i = !1;
              e &&
                (this._originalSize.set(0, 0),
                this._rect.set(0, 0, 0, 0),
                this._offset.set(0, 0),
                (this._capInsets = [0, 0, 0, 0]),
                (this._rotated = !1),
                (i = !0)),
                t &&
                  (t.texture &&
                    ((this._rect.x = this._rect.y = 0),
                    (this._rect.width = t.texture.width),
                    (this._rect.height = t.texture.height),
                    this._refreshTexture(t.texture),
                    this.checkRect(this._texture)),
                  t.originalSize && this._originalSize.set(t.originalSize),
                  t.rect && this._rect.set(t.rect),
                  t.offset && this._offset.set(t.offset),
                  void 0 !== t.borderTop && (this._capInsets[1] = t.borderTop),
                  void 0 !== t.borderBottom &&
                    (this._capInsets[3] = t.borderBottom),
                  void 0 !== t.borderLeft &&
                    (this._capInsets[0] = t.borderLeft),
                  void 0 !== t.borderRight &&
                    (this._capInsets[2] = t.borderRight),
                  void 0 !== t.isRotate && (this._rotated = !!t.isRotate),
                  void 0 !== t.isFlipUv && (this._isFlipUVY = !!t.isFlipUv),
                  (i = !0)),
                i && this.texture && this._calculateUV(),
                this._calcTrimmedBorder();
            }
            checkRect(t) {
              const e = this._rect;
              let i = e.x,
                s = e.y;
              return (
                this._rotated
                  ? ((i += e.height), (s += e.width))
                  : ((i += e.width), (s += e.height)),
                i > t.width
                  ? (G(3300, `${this.name}/${t.name}`, i, t.width), !1)
                  : !(
                      s > t.height &&
                      (G(3301, `${this.name}/${t.name}`, s, t.height), 1)
                    )
              );
            }
            _calcTrimmedBorder() {
              const t = this._originalSize.width,
                e = this._originalSize.height,
                i = 0.5 * (t - this._rect.width),
                s = 0.5 * (e - this._rect.height);
              (this._trimmedBorder.x = this._offset.x + i),
                (this._trimmedBorder.y = this._offset.x - i),
                (this._trimmedBorder.z = this._offset.y + s),
                (this._trimmedBorder.w = this._offset.y - s);
            }
            ensureMeshData() {
              this._mesh || (this._initVertices(), this._createMesh());
            }
            destroy() {
              return (
                this._packable && qA && qA.deleteAtlasSpriteFrame(this),
                super.destroy()
              );
            }
            _calculateSlicedUV() {
              const e = this._rect,
                i = this.texture,
                s = i.width,
                n = i.height,
                r = this._capInsets[0],
                a = this._capInsets[2],
                o = e.width - r - a,
                h = this._capInsets[1],
                l = this._capInsets[3],
                c = e.height - h - l,
                u = this.uvSliced;
              if (((u.length = 0), this._rotated)) {
                (cC[0].u = e.x / s),
                  (cC[1].u = (e.x + l) / s),
                  (cC[2].u = (e.x + l + c) / s),
                  (cC[3].u = (e.x + e.height) / s),
                  (cC[3].v = e.y / n),
                  (cC[2].v = (e.y + r) / n),
                  (cC[1].v = (e.y + r + o) / n),
                  (cC[0].v = (e.y + e.width) / n);
                for (let t = 0; t < 4; ++t) {
                  const e = cC[t];
                  for (let t = 0; t < 4; ++t) {
                    const i = cC[3 - t];
                    u.push({ u: e.u, v: i.v });
                  }
                }
              } else {
                (cC[0].u = e.x / s),
                  (cC[1].u = (e.x + r) / s),
                  (cC[2].u = (e.x + r + o) / s),
                  (cC[3].u = (e.x + e.width) / s),
                  (cC[3].v = e.y / n),
                  (cC[2].v = (e.y + h) / n),
                  (cC[1].v = (e.y + h + c) / n),
                  (cC[0].v = (e.y + e.height) / n);
                for (let t = 0; t < 4; ++t) {
                  const e = cC[t];
                  for (let t = 0; t < 4; ++t) {
                    const i = cC[t];
                    u.push({ u: i.u, v: e.v });
                  }
                }
              }
              this.emit(t.EVENT_UV_UPDATED, this);
            }
            _calculateUV() {
              const t = this._rect,
                e = this.uv,
                i = this.unbiasUV,
                s = this.texture,
                n = s.width,
                r = s.height;
              if (this._rotated) {
                const s = 0 === n ? 0 : t.x / n,
                  a = 0 === n ? 1 : (t.x + t.height) / n,
                  o = 0 === r ? 0 : t.y / r,
                  h = 0 === r ? 1 : (t.y + t.width) / r;
                this._isFlipUVX && this._isFlipUVY
                  ? ((e[0] = a),
                    (e[1] = h),
                    (e[2] = a),
                    (e[3] = o),
                    (e[4] = s),
                    (e[5] = h),
                    (e[6] = s),
                    (e[7] = o))
                  : this._isFlipUVX
                  ? ((e[0] = a),
                    (e[1] = o),
                    (e[2] = a),
                    (e[3] = h),
                    (e[4] = s),
                    (e[5] = o),
                    (e[6] = s),
                    (e[7] = h))
                  : this._isFlipUVY
                  ? ((e[0] = s),
                    (e[1] = h),
                    (e[2] = s),
                    (e[3] = o),
                    (e[4] = a),
                    (e[5] = h),
                    (e[6] = a),
                    (e[7] = o))
                  : ((e[0] = s),
                    (e[1] = o),
                    (e[2] = s),
                    (e[3] = h),
                    (e[4] = a),
                    (e[5] = o),
                    (e[6] = a),
                    (e[7] = h));
                const l = 0 === n ? 0 : t.x / n,
                  c = 0 === n ? 1 : (t.x + t.height) / n,
                  u = 0 === r ? 0 : t.y / r,
                  _ = 0 === r ? 1 : (t.y + t.width) / r;
                this._isFlipUVX && this._isFlipUVY
                  ? ((i[0] = c),
                    (i[1] = _),
                    (i[2] = c),
                    (i[3] = u),
                    (i[4] = l),
                    (i[5] = _),
                    (i[6] = l),
                    (i[7] = u))
                  : this._isFlipUVX
                  ? ((i[0] = c),
                    (i[1] = u),
                    (i[2] = c),
                    (i[3] = _),
                    (i[4] = l),
                    (i[5] = u),
                    (i[6] = l),
                    (i[7] = _))
                  : this._isFlipUVY
                  ? ((i[0] = l),
                    (i[1] = _),
                    (i[2] = l),
                    (i[3] = u),
                    (i[4] = c),
                    (i[5] = _),
                    (i[6] = c),
                    (i[7] = u))
                  : ((i[0] = l),
                    (i[1] = u),
                    (i[2] = l),
                    (i[3] = _),
                    (i[4] = c),
                    (i[5] = u),
                    (i[6] = c),
                    (i[7] = _));
              } else {
                const s = 0 === n ? 0 : t.x / n,
                  a = 0 === n ? 1 : (t.x + t.width) / n,
                  o = 0 === r ? 1 : (t.y + t.height) / r,
                  h = 0 === r ? 0 : t.y / r;
                this._isFlipUVX && this._isFlipUVY
                  ? ((e[0] = a),
                    (e[1] = h),
                    (e[2] = s),
                    (e[3] = h),
                    (e[4] = a),
                    (e[5] = o),
                    (e[6] = s),
                    (e[7] = o))
                  : this._isFlipUVX
                  ? ((e[0] = a),
                    (e[1] = o),
                    (e[2] = s),
                    (e[3] = o),
                    (e[4] = a),
                    (e[5] = h),
                    (e[6] = s),
                    (e[7] = h))
                  : this._isFlipUVY
                  ? ((e[0] = s),
                    (e[1] = h),
                    (e[2] = a),
                    (e[3] = h),
                    (e[4] = s),
                    (e[5] = o),
                    (e[6] = a),
                    (e[7] = o))
                  : ((e[0] = s),
                    (e[1] = o),
                    (e[2] = a),
                    (e[3] = o),
                    (e[4] = s),
                    (e[5] = h),
                    (e[6] = a),
                    (e[7] = h));
                const l = 0 === n ? 0 : t.x / n,
                  c = 0 === n ? 1 : (t.x + t.width) / n,
                  u = 0 === r ? 1 : (t.y + t.height) / r,
                  _ = 0 === r ? 0 : t.y / r;
                this._isFlipUVX && this._isFlipUVY
                  ? ((i[0] = c),
                    (i[1] = _),
                    (i[2] = l),
                    (i[3] = _),
                    (i[4] = c),
                    (i[5] = u),
                    (i[6] = l),
                    (i[7] = u))
                  : this._isFlipUVX
                  ? ((i[0] = c),
                    (i[1] = u),
                    (i[2] = l),
                    (i[3] = u),
                    (i[4] = c),
                    (i[5] = _),
                    (i[6] = l),
                    (i[7] = _))
                  : this._isFlipUVY
                  ? ((i[0] = l),
                    (i[1] = _),
                    (i[2] = c),
                    (i[3] = _),
                    (i[4] = l),
                    (i[5] = u),
                    (i[6] = c),
                    (i[7] = u))
                  : ((i[0] = l),
                    (i[1] = u),
                    (i[2] = c),
                    (i[3] = u),
                    (i[4] = l),
                    (i[5] = _),
                    (i[6] = c),
                    (i[7] = _));
              }
              this._calculateSlicedUV();
            }
            _setDynamicAtlasFrame(t) {
              t &&
                ((this._original = {
                  _texture: this._texture,
                  _x: this._rect.x,
                  _y: this._rect.y,
                }),
                (this._texture = t.texture),
                (this._rect.x = t.x),
                (this._rect.y = t.y),
                this._calculateUV());
            }
            _resetDynamicAtlasFrame() {
              this._original &&
                ((this._rect.x = this._original._x),
                (this._rect.y = this._original._y),
                (this._texture = this._original._texture),
                (this._original = null),
                this._calculateUV());
            }
            _checkPackable() {
              const t = qA;
              if (!t) return;
              const e = this._texture;
              if (!(e instanceof sm) || e.isCompressed)
                return void (this._packable = !1);
              const i = this.width,
                s = this.height;
              if (!e.image || i > t.maxFrameSize || s > t.maxFrameSize)
                return void (this._packable = !1);
              const n = h.HTMLCanvasElement;
              e.image && e.image instanceof n && (this._packable = !0);
            }
            _serialize(t) {
              return null;
            }
            _deserialize(t, e) {
              const i = t,
                s = i.rect;
              s && (this._rect = new Ds(s.x, s.y, s.width, s.height));
              const n = i.offset;
              i.offset && (this._offset = Es(n.x, n.y));
              const r = i.originalSize;
              i.originalSize && (this._originalSize = Rs(r.width, r.height)),
                (this._rotated = !!i.rotated),
                (this._name = i.name),
                (this._packable = !!i.packable),
                (this._pixelsToUnit = i.pixelsToUnit);
              const a = i.pivot;
              a && (this._pivot = Es(a.x, a.y)), (this._meshType = i.meshType);
              const o = i.capInsets;
              o &&
                ((this._capInsets[0] = o[0]),
                (this._capInsets[1] = o[1]),
                (this._capInsets[2] = o[2]),
                (this._capInsets[3] = o[3]));
              const h = i.vertices;
              if (h) {
                this.vertices ||
                  (this.vertices = {
                    rawPosition: [],
                    positions: [],
                    indexes: h.indexes,
                    uv: h.uv,
                    nuv: h.nuv,
                    minPos: Ki(h.minPos.x, h.minPos.y, h.minPos.z),
                    maxPos: Ki(h.maxPos.x, h.maxPos.y, h.maxPos.z),
                  }),
                  (this.vertices.rawPosition.length = 0);
                const t = h.rawPosition;
                for (let e = 0; e < t.length; e += 3)
                  this.vertices.rawPosition.push(Ki(t[e], t[e + 1], t[e + 2]));
                this._updateMeshVertices();
              }
            }
            clone() {
              const e = new t(),
                i = this.vertices;
              return (
                (e.vertices = i
                  ? {
                      rawPosition: i.rawPosition.slice(0),
                      positions: i.positions.slice(0),
                      indexes: i.indexes.slice(0),
                      uv: i.uv.slice(0),
                      nuv: i.nuv.slice(0),
                      minPos: i.minPos.clone(),
                      maxPos: i.maxPos.clone(),
                    }
                  : null),
                e.uv.splice(0, e.uv.length, ...this.uv),
                e.unbiasUV.splice(0, e.unbiasUV.length, ...this.unbiasUV),
                e.uvSliced.splice(0, e.uvSliced.length, ...this.uvSliced),
                e._rect.set(this._rect),
                e._trimmedBorder.set(this._trimmedBorder),
                e._offset.set(this._offset),
                e._originalSize.set(this._originalSize),
                (e._rotated = this._rotated),
                e._capInsets.splice(0, e._capInsets.length, ...this._capInsets),
                (e._atlasUuid = this._atlasUuid),
                (e._texture = this._texture),
                (e._isFlipUVX = this._isFlipUVX),
                (e._isFlipUVY = this._isFlipUVY),
                this._original
                  ? (e._original = {
                      _texture: this._original._texture,
                      _x: this._original._x,
                      _y: this._original._y,
                    })
                  : (e._original = null),
                (e._packable = this._packable),
                (e._pixelsToUnit = this._pixelsToUnit),
                e._pivot.set(this._pivot),
                (e._meshType = this._meshType),
                (e._extrude = this._extrude),
                e._customOutLine.splice(
                  0,
                  e._customOutLine.length,
                  ...this._customOutLine
                ),
                (e._minPos = this._minPos),
                (e._maxPos = this._maxPos),
                this._mesh && e._createMesh(),
                e
              );
            }
            _refreshTexture(t) {
              this._texture = t;
              const e = this._texture,
                i = {};
              let s = !1;
              (0 !== this._rect.width &&
                0 !== this._rect.height &&
                this.checkRect(e)) ||
                ((i.rect = xs(0, 0, e.width, e.height)), (s = !0)),
                (0 === this._originalSize.width ||
                  0 === this._originalSize.height ||
                  s) &&
                  ((i.originalSize = Rs(e.width, e.height)), (s = !0)),
                s && this.reset(i),
                this._checkPackable(),
                this._mesh && this._updateMesh();
            }
            onLoaded() {
              this._calcTrimmedBorder();
            }
            initDefault(t) {
              super.initDefault(t);
              const e = new sm();
              e.initDefault(), this._refreshTexture(e), this._calculateUV();
            }
            validate() {
              return (
                this._texture &&
                this._rect &&
                0 !== this._rect.width &&
                0 !== this._rect.height
              );
            }
            _initVertices() {
              if (
                (this.vertices
                  ? ((this.vertices.rawPosition.length = 0),
                    (this.vertices.positions.length = 0),
                    (this.vertices.indexes.length = 0),
                    (this.vertices.uv.length = 0),
                    (this.vertices.nuv.length = 0),
                    this.vertices.minPos.set(0, 0, 0),
                    this.vertices.maxPos.set(0, 0, 0))
                  : (this.vertices = {
                      rawPosition: [],
                      positions: [],
                      indexes: [],
                      uv: [],
                      nuv: [],
                      minPos: Ki(),
                      maxPos: Ki(),
                    }),
                this._meshType === lC.POLYGON)
              );
              else {
                const t = this.texture,
                  e = t.width,
                  i = t.height,
                  s = this.rect,
                  n = s.width,
                  r = s.height,
                  a = s.x,
                  o = i - s.y - r,
                  h = n / 2,
                  l = r / 2,
                  c = 0 === e ? 0 : a / e,
                  u = 0 === e ? 1 : (a + n) / e,
                  _ = 0 === i ? 1 : (o + r) / i,
                  d = 0 === i ? 0 : o / i;
                oC.set(-h, -l, 0),
                  this.vertices.rawPosition.push(oC.clone()),
                  this.vertices.uv.push(a),
                  this.vertices.uv.push(o + r),
                  this.vertices.nuv.push(c),
                  this.vertices.nuv.push(d),
                  this.vertices.minPos.set(oC),
                  oC.set(h, -l, 0),
                  this.vertices.rawPosition.push(oC.clone()),
                  this.vertices.uv.push(a + n),
                  this.vertices.uv.push(o + r),
                  this.vertices.nuv.push(u),
                  this.vertices.nuv.push(d),
                  oC.set(-h, l, 0),
                  this.vertices.rawPosition.push(oC.clone()),
                  this.vertices.uv.push(a),
                  this.vertices.uv.push(o),
                  this.vertices.nuv.push(c),
                  this.vertices.nuv.push(_),
                  oC.set(h, l, 0),
                  this.vertices.rawPosition.push(oC.clone()),
                  this.vertices.uv.push(a + n),
                  this.vertices.uv.push(o),
                  this.vertices.nuv.push(u),
                  this.vertices.nuv.push(_),
                  this.vertices.maxPos.set(oC),
                  this.vertices.indexes.push(0),
                  this.vertices.indexes.push(1),
                  this.vertices.indexes.push(2),
                  this.vertices.indexes.push(2),
                  this.vertices.indexes.push(1),
                  this.vertices.indexes.push(3);
              }
              this._updateMeshVertices();
            }
            _updateMeshVertices() {
              hC.identity();
              const t = 1 / this._pixelsToUnit,
                e = Ki(
                  -(this._pivot.x - 0.5) * this.rect.width * t,
                  -(this._pivot.y - 0.5) * this.rect.height * t,
                  0
                );
              hC.transform(e), e.set(t, t, 1), hC.scale(e);
              const i = this.vertices;
              for (let t = 0; t < i.rawPosition.length; t++) {
                const s = i.rawPosition[t];
                Yi.transformMat4(e, s, hC), Yi.toArray(i.positions, e, 3 * t);
              }
              Yi.transformMat4(this._minPos, i.minPos, hC),
                Yi.transformMat4(this._maxPos, i.maxPos, hC);
            }
            _createMesh() {
              this._mesh = sC({
                primitiveMode: Gc.TRIANGLE_LIST,
                positions: this.vertices.positions,
                uvs: this.vertices.nuv,
                indices: this.vertices.indexes,
                minPos: this._minPos,
                maxPos: this._maxPos,
                attributes: [
                  new Lu(eu.ATTR_POSITION, fc.RGB32F),
                  new Lu(eu.ATTR_TEX_COORD, fc.RG32F),
                ],
              });
            }
            _updateMesh() {
              this._mesh && this._mesh.destroy(),
                this._initVertices(),
                this._createMesh();
            }
          }).EVENT_UV_UPDATED = "uv_updated"),
          (rC.MeshType = lC),
          (nC = rC))
        ) || nC
      );
      a.SpriteFrame = uC;
      const _C = jsb.RenderTexture.prototype,
        dC = jsb.TextureBase.prototype;
      _C.createNode = null;
      const pC = t("RenderTexture", jsb.RenderTexture);
      (pC.Filter = Id),
        (pC.PixelFormat = Cd),
        (pC.WrapMode = Od),
        (_C._serialize = function () {
          return {};
        }),
        (_C._deserialize = function (t, e) {
          const i = t;
          (this._width = i.w),
            (this._height = i.h),
            (this._name = i.n),
            dC._deserialize.call(this, i.base, e);
        });
      const mC = _C.readPixels;
      (_C.readPixels = function (t, e, i, s) {
        (t = t || 0),
          (e = e || 0),
          (i = i || this.width),
          (s = s || this.height);
        let n = mC.call(this, t, e, i, s);
        return 0 == n.length ? null : n;
      }),
        (a.RenderTexture = jsb.RenderTexture),
        (function (t, e = vd) {
          const { RenderTexture: i } = { ...t };
          e(
            () => {
              Ca("cc.RenderTexture")(i);
            },
            "ccclass",
            null
          );
        })({ RenderTexture: pC }),
        Z(Xp.prototype, "TextureBase.prototype", [
          { name: "hasPremultipliedAlpha" },
          { name: "setPremultiplyAlpha" },
          { name: "setFlipY" },
        ]),
        $(pC.prototype, "RenderTexture.prototype", [
          {
            name: "getGFXWindow",
            customFunction() {
              return this.window;
            },
          },
        ]);
      const fC = t("RenderingSubMesh", jsb.RenderingSubMesh),
        gC = fC.prototype;
      var yC, TC, SC;
      (gC._ctor = function (t, e, i, s = null, n = null) {
        jsb.Asset.prototype._ctor.apply(this, arguments),
          (this._attributes = e),
          (this._vertexBuffers = t),
          (this._indexBuffer = s),
          (this._indirectBuffer = n);
      }),
        Object.defineProperty(gC, "geometricInfo", {
          configurable: !0,
          enumerable: !0,
          get() {
            let t = this.getGeometricInfo();
            return (
              t.positions ||
                t.indices ||
                ((t.positions = new Float32Array()),
                (t.indices = new Uint8Array())),
              t
            );
          },
        }),
        Object.defineProperty(gC, "attributes", {
          configurable: !0,
          enumerable: !0,
          get() {
            return (
              this._attributes || (this._attributes = this.getAttributes()),
              this._attributes
            );
          },
        }),
        Object.defineProperty(gC, "vertexBuffers", {
          configurable: !0,
          enumerable: !0,
          get() {
            return (
              this._vertexBuffers ||
                (this._vertexBuffers = this.getVertexBuffers()),
              this._vertexBuffers
            );
          },
        }),
        Object.defineProperty(gC, "indexBuffer", {
          configurable: !0,
          enumerable: !0,
          get() {
            return (
              this._indexBuffer || (this._indexBuffer = this.getIndexBuffer()),
              this._indexBuffer
            );
          },
        }),
        Object.defineProperty(gC, "indirectBuffer", {
          configurable: !0,
          enumerable: !0,
          get() {
            return (
              this._indirectBuffer ||
                (this._indirectBuffer = this.getIndexBuffer()),
              this._indirectBuffer
            );
          },
        });
      let EC = t(
        "SpriteAtlas",
        Ca("cc.SpriteAtlas")(
          ((TC = class extends Ad {
            constructor() {
              super(), (this.spriteFrames = SC && SC());
            }
            getTexture() {
              const t = Object.keys(this.spriteFrames);
              if (t.length > 0) {
                const e = this.spriteFrames[t[0]];
                return e && e.texture;
              }
              return null;
            }
            getSpriteFrame(t) {
              const e = this.spriteFrames[t];
              return e ? (e.name || (e.name = t), e) : null;
            }
            getSpriteFrames() {
              const t = [],
                e = this.spriteFrames;
              for (const i of Object.keys(e)) t.push(e[i]);
              return t;
            }
            _serialize(t) {
              return null;
            }
            _deserialize(t, e) {
              const i = t;
              this._name = i.name;
              const s = i.spriteFrames;
              this.spriteFrames = St();
              for (let t = 0; t < s.length; t += 2)
                e.result.push(this.spriteFrames, s[t], s[t + 1], qt(uC));
            }
          }),
          (SC = fa(TC.prototype, "spriteFrames", [Na], function () {
            return St();
          })),
          (yC = TC))
        ) || yC
      );
      var vC;
      a.SpriteAtlas = EC;
      let bC = t("Font", Ca("cc.Font")((vC = class extends Ad {})) || vC);
      var AC, CC, OC;
      a.Font = bC;
      let IC = t(
        "TTFFont",
        Ca("cc.TTFFont")(
          ((CC = class extends bC {
            constructor() {
              super(), (this._fontFamily = OC && OC());
            }
            get _nativeAsset() {
              return this._fontFamily;
            }
            set _nativeAsset(t) {
              this._fontFamily = t || "Arial";
            }
            get _nativeDep() {
              return {
                uuid: this._uuid,
                __nativeName__: this._native,
                ext: br(this._native),
                __isNative__: !0,
              };
            }
            initDefault(t) {
              (this._fontFamily = "Arial"), super.initDefault(t);
            }
          }),
          (OC = fa(CC.prototype, "_fontFamily", [Na], function () {
            return null;
          })),
          s(
            CC.prototype,
            "_nativeAsset",
            [oo, ro],
            Object.getOwnPropertyDescriptor(CC.prototype, "_nativeAsset"),
            CC.prototype
          ),
          s(
            CC.prototype,
            "_nativeDep",
            [oo],
            Object.getOwnPropertyDescriptor(CC.prototype, "_nativeDep"),
            CC.prototype
          ),
          (AC = CC))
        ) || AC
      );
      a.TTFFont = IC;
      const wC = t("BASELINE_RATIO", 0.26),
        RC = t("MIDDLE_RATIO", (wC + 1) / 2 - wC);
      const DC = new $t(2);
      DC.get = function () {
        return this._get() || { key: "", value: 0, prev: null, next: null };
      };
      class xC {
        constructor(t) {
          (this.count = 0),
            (this.limit = 0),
            (this.datas = {}),
            (this.limit = t);
        }
        moveToHead(t) {
          (t.next = this.head),
            (t.prev = null),
            this.head && (this.head.prev = t),
            (this.head = t),
            this.tail || (this.tail = t),
            this.count++,
            (this.datas[t.key] = t);
        }
        put(t, e) {
          const i = DC.get();
          if (((i.key = t), (i.value = e), this.count >= this.limit)) {
            const t = this.tail;
            delete this.datas[t.key],
              this.count--,
              (this.tail = t.prev),
              (this.tail.next = null),
              (t.prev = null),
              (t.next = null),
              DC.put(t);
          }
          this.moveToHead(i);
        }
        remove(t) {
          t.prev ? (t.prev.next = t.next) : (this.head = t.next),
            t.next ? (t.next.prev = t.prev) : (this.tail = t.prev),
            delete this.datas[t.key],
            this.count--;
        }
        get(t) {
          const e = this.datas[t];
          return e ? (this.remove(e), this.moveToHead(e), e.value) : null;
        }
        clear() {
          (this.count = 0),
            (this.datas = {}),
            (this.head = null),
            (this.tail = null);
        }
        has(t) {
          return !!this.datas[t];
        }
        delete(t) {
          const e = this.datas[t];
          this.remove(e);
        }
      }
      t("LRUCache", xC);
      const MC = new xC(100),
        PC = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûа-яА-ЯЁё]+|\S)/,
        NC = /^[!\-,.:;'"{}\[\]%\?<>、–‘’“”()&》？。，！\/]/,
        LC =
          /([a-zA-Z0-9-–‘’“”'"{}<>()\[\]\/&ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁёáàảạãăắằẳẵặâấầẩẫậéèẻẽẹêếềểễệiíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵđÁÀẢẠÃĂẮẰẲẴẶÂẤẦẨẪẬÉÈẺẼẸÊẾỀỂỄỆIÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴĐ]+|\S)$/,
        BC =
          /[a-zA-Z0-9-–‘’“”'"{}<>()\[\]\/&ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁёáàảạãăắằẳẵặâấầẩẫậéèẻẽẹêếềểễệiíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵđÁÀẢẠÃĂẮẰẲẴẶÂẤẦẨẪẬÉÈẺẼẸÊẾỀỂỄỆIÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴĐ]+$/,
        FC =
          /^[a-zA-Z0-9-–‘’“”'"{}<>()\[\]\/&ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁёáàảạãăắằẳẵặâấầẩẫậéèẻẽẹêếềểễệiíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵđÁÀẢẠÃĂẮẰẲẴẶÂẤẦẨẪẬÉÈẺẼẸÊẾỀỂỄỆIÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴĐ]/;
      function UC(t) {
        return (
          /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/.test(t) ||
          /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g.test(
            t
          ) ||
          /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/.test(
            t
          )
        );
      }
      function kC(t) {
        const e = t.charCodeAt(0);
        return (
          (e >= 9 && e <= 13) ||
          32 === e ||
          133 === e ||
          160 === e ||
          5760 === e ||
          (e >= 8192 && e <= 8202) ||
          8232 === e ||
          8233 === e ||
          8239 === e ||
          8287 === e ||
          12288 === e
        );
      }
      function zC(t, e, i) {
        const s = `${i || t.font}🎮${e}`,
          n = MC.get(s);
        if (null !== n) return n;
        const r = t.measureText(e),
          a = (r && r.width) || 0;
        return MC.put(s, a), a;
      }
      function HC(t) {
        const e = t.length;
        let i = 0,
          s = 0;
        for (let n = 0; n < e; n++)
          (s = t.charCodeAt(n)),
            8205 !== s &&
              (s >= 55296 &&
              s <= 56319 &&
              ((s = t.charCodeAt(n + 1)), s >= 56320 && s <= 57343)
                ? ((n + 2 >= e || 8205 !== t.charCodeAt(n + 2)) && i++, n++)
                : i++);
        return i;
      }
      function GC(t, e) {
        const i = t.length;
        let s = 0,
          n = 0,
          r = 0,
          a = 0;
        for (let o = 0; o < i; o++)
          if (((a = t.charCodeAt(o)), 8205 !== a))
            if (
              a >= 55296 &&
              a <= 56319 &&
              (s++, (a = t.charCodeAt(o + 1)), a >= 56320 && a <= 57343)
            ) {
              if ((s++, o + 2 >= i || 8205 !== t.charCodeAt(o + 2))) {
                if (e === n) return t.slice(r, r + s);
                (r += s), n++, (s = 0);
              }
              o++;
            } else {
              if (e === n) return t.charAt(o);
              (r = o + 1), n++, (s = 0);
            }
          else s++;
        return "";
      }
      function VC(t, e) {
        const i = GC(t, e);
        if (1 === i.length) return `${i.charCodeAt(0)}`;
        let s = "";
        for (let t = 0; t < i.length; t++) s += `${i.charCodeAt(t)}`;
        return `${s}`;
      }
      function jC(t, e) {
        if (e >= t.length) return t.length;
        let i = e,
          s = t[i];
        for (
          ;
          i >= 0 &&
          ("‍" === s && (i--, (s = t[i])),
          s >= "\udc00" && s <= "\udfff" && i - 1 >= 0 && (i--, (s = t[i])),
          s >= "\ud800" && s <= "\udbff") &&
          i - 1 >= 0 &&
          "‍" === t[i - 1];

        )
          i--, (s = t[i]);
        return i;
      }
      function WC(t, e) {
        let i = e,
          s = e,
          n = t[s];
        for (; s < t.length; )
          if (
            ("‍" === n &&
              (s++,
              i++,
              (n = t[s]),
              n >= "\ud800" && n <= "\udbff" && (s++, i++, (n = t[s]))),
            n >= "\ud800" && n <= "\udbff")
          )
            s++, i++, (n = t[s]);
          else {
            if (!(n >= "\udc00" && n <= "\udfff")) break;
            if ((s++, (n = t[s]), !(s < t.length && "‍" === t[s]))) break;
            i++, (n = t[s]);
          }
        return i;
      }
      function XC(t, e, i) {
        let s = jC(t, e);
        s < e && (s = WC(t, e) + 1);
        let n = i;
        if (void 0 !== i) {
          n = WC(t, (i = Math.max(0, i - 1)));
          const r = jC(t, i);
          r < s || (r === s && e > s) ? (n = s) : (n += 1);
        }
        return t.substring(s, n);
      }
      function YC(t) {
        return FC.exec(t);
      }
      function KC(t) {
        return BC.exec(t);
      }
      function qC(t, e, i, s) {
        const n = [];
        if (0 === t.length || i < 0) return n.push(""), n;
        let r = t;
        for (; e > i && r.length > 1; ) {
          let t = (r.length * (i / e)) | 0,
            a = XC(r, t),
            o = e - s(a),
            h = a,
            l = 0,
            c = 0;
          const u = 100;
          for (; o > i && c++ < u; )
            (t *= i / o), (t |= 0), (a = XC(r, t)), (o = e - s(a));
          for (c = 0; a && o <= i && c++ < u; ) {
            const i = PC.exec(a);
            (l = i ? i[0].length : 1),
              (h = a),
              (t += l),
              (a = XC(r, t)),
              (o = e - s(a));
          }
          (t -= l),
            0 === t
              ? ((t = 1), (h = XC(r, 1)))
              : 1 === t &&
                r[0] >= "\ud800" &&
                r[0] <= "\udbff" &&
                ((t = 2), (h = XC(r, 2)));
          let _,
            d = XC(r, 0, t);
          NC.test(h || a) &&
            ((_ = LC.exec(d)),
            (t -= _ ? _[0].length : 0),
            0 === t && (t = 1),
            (h = XC(r, t)),
            (d = XC(r, 0, t))),
            FC.test(h) &&
              ((_ = BC.exec(d)),
              _ &&
                d !== _[0] &&
                ((t -= _[0].length), (h = XC(r, t)), (d = XC(r, 0, t)))),
            (0 === n.length || d.trim().length > 0) && n.push(d),
            (r = h || a),
            (e = s(r));
        }
        return (0 === n.length || r.trim().length > 0) && n.push(r), n;
      }
      const $C = h.document;
      let ZC = null,
        QC = -1;
      const JC = "BES bswy:->@123丁ぁᄁ",
        tO = Object.create(null),
        eO = [],
        iO = 3e3,
        sO = (() => {
          let t;
          return () => {
            if (void 0 === t)
              if ("FontFace" in h) {
                const e = /Gecko.*Firefox\/(\d+)/.exec(h.navigator.userAgent),
                  i =
                    /OS X.*Version\/10\..*Safari/.exec(h.navigator.userAgent) &&
                    /Apple/.exec(h.navigator.vendor);
                t = e ? parseInt(e[1], 10) > 42 : !i;
              } else t = !1;
            return t;
          };
        })();
      function nO() {
        let t = !0;
        const e = Date.now();
        for (let i = eO.length - 1; i >= 0; i--) {
          const s = eO[i],
            n = s.fontFamilyName;
          if (e - s.startTime > iO) {
            z(4933, n), s.onComplete(null, n), eO.splice(i, 1);
            continue;
          }
          const r = s.refWidth,
            a = `40px ${n}`;
          (ZC.font = a),
            r !== zC(ZC, JC, a)
              ? (eO.splice(i, 1), s.onComplete(null, n))
              : (t = !1);
        }
        t && (clearInterval(QC), (QC = -1));
      }
      function rO(t, e, i) {
        const s = (function (t) {
          const e = t.lastIndexOf(".ttf");
          if (-1 === e) return t;
          const i = t.lastIndexOf("/");
          let s;
          return (
            (s =
              -1 === i
                ? `${t.substring(0, e)}_LABEL`
                : `${t.substring(i + 1, e)}_LABEL`),
            -1 !== s.indexOf(" ") && (s = `"${s}"`),
            s
          );
        })(t);
        if (tO[s]) return void i(null, s);
        if (!ZC) {
          const t = $C.createElement("canvas");
          (t.width = 100), (t.height = 100), (ZC = t.getContext("2d"));
        }
        const n = `40px ${s}`,
          r = $C.createElement("style");
        r.type = "text/css";
        let a = "";
        Number.isNaN(s)
          ? (a += `@font-face { font-family:${s}; src:`)
          : (a += `@font-face { font-family:"${s}"; src:`),
          (a += `url("${t}");`),
          (r.textContent = `${a}}`),
          $C.body.appendChild(r);
        const o = $C.createElement("div"),
          h = o.style;
        if (
          ((h.fontFamily = s),
          (o.innerHTML = "."),
          (h.position = "absolute"),
          (h.left = "-100px"),
          (h.top = "-100px"),
          $C.body.appendChild(o),
          sO())
        )
          !(function (t, e, i) {
            const s = new Promise((i, s) => {
              const n = () => {
                Date.now() - t >= iO
                  ? s()
                  : $C.fonts.load(`40px ${e}`).then(
                      (t) => {
                        t.length >= 1 ? i() : setTimeout(n, 100);
                      },
                      () => {
                        s();
                      }
                    );
              };
              n();
            });
            let n = null;
            const r = new Promise((t, e) => {
              n = setTimeout(e, iO);
            });
            Promise.race([r, s]).then(
              () => {
                n && (clearTimeout(n), (n = null)), i(null, e);
              },
              () => {
                z(4933, e), i(null, e);
              }
            );
          })(Date.now(), s, i);
        else {
          const t = {
            fontFamilyName: s,
            refWidth: zC(ZC, JC, n),
            onComplete: i,
            startTime: Date.now(),
          };
          eO.push(t), -1 === QC && (QC = setInterval(nO, 100));
        }
        tO[s] = r;
      }
      function aO(t, e, i, s) {
        const n = new IC();
        (n._nativeUrl = t), (n._nativeAsset = e), s(null, n);
      }
      GE.register({
        ".font": rO,
        ".eot": rO,
        ".ttf": rO,
        ".woff": rO,
        ".svg": rO,
        ".ttc": rO,
      }),
        ev.register({
          ".font": aO,
          ".eot": aO,
          ".ttf": aO,
          ".woff": aO,
          ".svg": aO,
          ".ttc": aO,
        });
      const oO = /^(click)(\s)*=|(param)(\s)*=/,
        hO =
          /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*align(\s)*=|(\s)*offset(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
      class lO {
        constructor() {
          (this._specialSymbolArray = []),
            (this._stack = []),
            (this._resultObjectArray = []),
            this._specialSymbolArray.push([/&lt;/g, "<"]),
            this._specialSymbolArray.push([/&gt;/g, ">"]),
            this._specialSymbolArray.push([/&amp;/g, "&"]),
            this._specialSymbolArray.push([/&quot;/g, '"']),
            this._specialSymbolArray.push([/&apos;/g, "'"]);
        }
        parse(t) {
          (this._resultObjectArray.length = 0), (this._stack.length = 0);
          let e = 0;
          const i = t.length;
          for (; e < i; ) {
            let s = t.indexOf(">", e),
              n = -1;
            if (
              (s >= 0 &&
                ((n = t.lastIndexOf("<", s)),
                n < e - 1 &&
                  ((n = t.indexOf("<", s + 1)), (s = t.indexOf(">", n + 1)))),
              n < 0)
            )
              this._stack.pop(), this._processResult(t.substring(e)), (e = i);
            else {
              let i = t.substring(e, n);
              const r = t.substring(n + 1, s);
              "" === r && (i = t.substring(e, s + 1)),
                this._processResult(i),
                -1 === s
                  ? (s = n)
                  : "/" === t.charAt(n + 1)
                  ? this._stack.pop()
                  : this._addToStack(r),
                (e = s + 1);
            }
          }
          return this._resultObjectArray;
        }
        _attributeToObject(t) {
          t = t.trim();
          const e = {};
          let i = /^(color|size)(\s)*=/.exec(t),
            s = "",
            n = 0,
            r = "";
          if (i) {
            if (((s = i[0]), "" === (t = t.substring(s.length).trim())))
              return e;
            switch (((n = t.indexOf(" ")), s[0])) {
              case "c":
                e.color = n > -1 ? t.substring(0, n).trim() : t;
                break;
              case "s":
                e.size = parseInt(t);
            }
            return (
              n > -1 &&
                ((r = t.substring(n + 1).trim()),
                (e.event = this._processEventHandler(r))),
              e
            );
          }
          if (
            ((i = /^(br(\s)*\/)/.exec(t)),
            i &&
              i[0].length > 0 &&
              ((s = i[0].trim()),
              s.startsWith("br") && "/" === s[s.length - 1]))
          )
            return (
              (e.isNewLine = !0),
              this._resultObjectArray.push({
                text: "",
                style: { isNewLine: !0 },
              }),
              e
            );
          i = /^(img(\s)*src(\s)*=[^>]+\/)/.exec(t);
          let a = "",
            o = -1;
          if (
            i &&
            i[0].length > 0 &&
            ((s = i[0].trim()), s.startsWith("img") && "/" === s[s.length - 1])
          ) {
            let r;
            i = hO.exec(t);
            let h = !1;
            for (; i; ) {
              s = (t = t.substring(t.indexOf(i[0]))).substr(0, i[0].length);
              const l = s.length;
              if (
                ((s = s.replace(/[^a-zA-Z]/g, "").trim()),
                (s = s.toLowerCase()),
                (a = t.substring(l).trim()),
                (o = "src" === s ? this.getRightQuotationIndex(a) : -1),
                (n = a.indexOf(" ", o + 1 >= a.length ? -1 : o + 1)),
                (r = n > -1 ? a.substr(0, n) : a),
                (t = a.substring(n).trim()),
                r.endsWith("/") && (r = r.slice(0, -1)),
                "src" === s)
              ) {
                switch (r.charCodeAt(0)) {
                  case 34:
                  case 39:
                    (h = !0), (r = r.slice(1, -1));
                }
                (e.isImage = !0), (e.src = r);
              } else if ("height" === s) e.imageHeight = parseInt(r);
              else if ("width" === s) e.imageWidth = parseInt(r);
              else if ("align" === s) {
                switch (r.charCodeAt(0)) {
                  case 34:
                  case 39:
                    r = r.slice(1, -1);
                }
                e.imageAlign = r.toLowerCase();
              } else
                "offset" === s
                  ? (e.imageOffset = r)
                  : "click" === s &&
                    (e.event = this._processEventHandler(`${s}=${r}`));
              e.event &&
                "param" === s &&
                (e.event[s] = r.replace(/^"|"$/g, "")),
                (i = hO.exec(t));
            }
            return (
              h &&
                e.isImage &&
                this._resultObjectArray.push({ text: "", style: e }),
              {}
            );
          }
          if (((i = /^(outline(\s)*[^>]*)/.exec(t)), i)) {
            const r = { color: "#ffffff", width: 1 };
            if ((t = i[0].substring("outline".length).trim())) {
              const o =
                /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
              let h;
              for (i = o.exec(t); i; )
                (s = (t = t.substring(t.indexOf(i[0]))).substr(0, i[0].length)),
                  (a = t.substring(s.length).trim()),
                  (n = a.indexOf(" ")),
                  (h = n > -1 ? a.substr(0, n) : a),
                  (s = s.replace(/[^a-zA-Z]/g, "").trim()),
                  (s = s.toLowerCase()),
                  (t = a.substring(n).trim()),
                  "click" === s
                    ? (e.event = this._processEventHandler(`${s}=${h}`))
                    : "color" === s
                    ? (r.color = h)
                    : "width" === s && (r.width = parseInt(h)),
                  e.event &&
                    "param" === s &&
                    (e.event[s] = h.replace(/^"|"$/g, "")),
                  (i = o.exec(t));
            }
            e.outline = r;
          }
          if (((i = /^(on|u|b|i)(\s)*/.exec(t)), i && i[0].length > 0)) {
            switch (((s = i[0]), (t = t.substring(s.length).trim()), s[0])) {
              case "u":
                e.underline = !0;
                break;
              case "i":
                e.italic = !0;
                break;
              case "b":
                e.bold = !0;
            }
            if ("" === t) return e;
            e.event = this._processEventHandler(t);
          }
          return e;
        }
        getRightQuotationIndex(t) {
          let e = -1,
            i = -1;
          const s = t.indexOf("'"),
            n = t.indexOf('"'),
            r = n > -1 && (n < s || -1 === s);
          return (
            s > -1 && (s < n || -1 === n)
              ? ((e = s), (i = t.indexOf("'", e + 1 >= t.length ? -1 : e + 1)))
              : r &&
                ((e = n), (i = t.indexOf('"', e + 1 >= t.length ? -1 : e + 1))),
            i
          );
        }
        _processEventHandler(t) {
          const e = {};
          let i = 0,
            s = !1,
            n = oO.exec(t);
          for (; n; ) {
            let r = n[0],
              a = "";
            if (
              ((s = !1), '"' === (t = t.substring(r.length).trim()).charAt(0))
            )
              (i = t.indexOf('"', 1)),
                i > -1 && ((a = t.substring(1, i).trim()), (s = !0)),
                i++;
            else if ("'" === t.charAt(0))
              (i = t.indexOf("'", 1)),
                i > -1 && ((a = t.substring(1, i).trim()), (s = !0)),
                i++;
            else {
              const e = /(\S)+/.exec(t);
              (a = e ? e[0] : ""), (i = a.length);
            }
            s && ((r = r.substring(0, r.length - 1).trim()), (e[r] = a)),
              (t = t.substring(i).trim()),
              (n = oO.exec(t));
          }
          return e;
        }
        _addToStack(t) {
          const e = this._attributeToObject(t);
          if (0 === this._stack.length) this._stack.push(e);
          else {
            if (e.isNewLine || e.isImage) return;
            const t = this._stack[this._stack.length - 1];
            for (const i in t) e[i] || (e[i] = t[i]);
            this._stack.push(e);
          }
        }
        _processResult(t) {
          0 !== t.length &&
            ((t = this._escapeSpecialSymbol(t)),
            this._stack.length > 0
              ? this._resultObjectArray.push({
                  text: t,
                  style: this._stack[this._stack.length - 1],
                })
              : this._resultObjectArray.push({ text: t }));
        }
        _escapeSpecialSymbol(t) {
          for (const e of this._specialSymbolArray) {
            const i = e[0],
              s = e[1];
            t = t.replace(i, s);
          }
          return t;
        }
      }
      var cO, uO, _O, dO, pO, mO, fO, gO;
      t("HtmlTextParser", lO);
      class yO {
        constructor() {
          (this.u = 0),
            (this.v = 0),
            (this.w = 0),
            (this.h = 0),
            (this.offsetX = 0),
            (this.offsetY = 0),
            (this.valid = !1),
            (this.xAdvance = 0);
        }
      }
      class TO {
        constructor(t) {
          (this.letterDefinitions = {}), (this.texture = t);
        }
        addLetterDefinitions(t, e) {
          this.letterDefinitions[t] = e;
        }
        cloneLetterDefinition() {
          const t = {};
          for (const e of Object.keys(this.letterDefinitions)) {
            const i = new yO();
            Mt(i, this.letterDefinitions[e]), (t[e] = i);
          }
          return t;
        }
        getTexture() {
          return this.texture;
        }
        getLetter(t) {
          return this.letterDefinitions[t];
        }
        getLetterDefinitionForChar(t, e) {
          const i = VC(t, 0);
          let s = null;
          return (
            Object.prototype.hasOwnProperty.call(this.letterDefinitions, i) &&
              (s = this.letterDefinitions[i]),
            s
          );
        }
        clear() {
          this.letterDefinitions = {};
        }
      }
      let SO = t(
        "BitmapFont",
        ((cO = Ca("cc.BitmapFont")),
        (uO = ao(uC)),
        cO(
          ((dO = class extends bC {
            constructor() {
              super(),
                (this.fntDataStr = pO && pO()),
                (this.spriteFrame = mO && mO()),
                (this.fontSize = fO && fO()),
                (this.fntConfig = gO && gO());
            }
            onLoaded() {
              const t = this.spriteFrame;
              !this.fontDefDictionary &&
                t &&
                (this.fontDefDictionary = new TO(t.texture));
              const e = this.fntConfig;
              if (!e) return void z(16376);
              const i = e.fontDefDictionary;
              for (const t in i) {
                const e = i[t],
                  s = new yO(),
                  n = e.rect;
                (s.offsetX = e.xOffset),
                  (s.offsetY = e.yOffset),
                  (s.w = n.width),
                  (s.h = n.height),
                  (s.u = n.x),
                  (s.v = n.y),
                  (s.valid = !0),
                  (s.xAdvance = e.xAdvance),
                  this.fontDefDictionary.addLetterDefinitions(t, s);
              }
            }
          }),
          (pO = fa(dO.prototype, "fntDataStr", [Na], function () {
            return "";
          })),
          (mO = fa(dO.prototype, "spriteFrame", [uO], function () {
            return null;
          })),
          (fO = fa(dO.prototype, "fontSize", [Na], function () {
            return -1;
          })),
          (gO = fa(dO.prototype, "fntConfig", [Na], function () {
            return null;
          })),
          (_O = dO))
        ) || _O)
      );
      var EO;
      a.BitmapFont = SO;
      let vO,
        bO = t(
          "LabelAtlas",
          Ca("cc.LabelAtlas")((EO = class extends SO {})) || EO
        );
      a.LabelAtlas = bO;
      class AO {
        constructor() {
          this.pool = [];
        }
        static getInstance() {
          return vO || (vO = new AO()), vO;
        }
        get() {
          let t = this.pool.pop();
          if (!t) {
            const e = h.document.createElement("canvas"),
              i = e.getContext("2d");
            t = { canvas: e, context: i };
          }
          return t;
        }
        put(t) {
          this.pool.length >= Te.MAX_LABEL_CANVAS_POOL_SIZE ||
            this.pool.push(t);
        }
      }
      const CO = Qi.WHITE.clone(),
        OO = `rgba(255, 255, 255, ${(1 / 255).toFixed(3)})`;
      class IO {
        constructor(t, e) {
          (this.image = null),
            (this.data = null),
            (this.canvas = null),
            (this.context = null),
            (this.width = 0),
            (this.height = 0),
            (this.offsetY = 0),
            (this.char = t),
            (this.labelInfo = e),
            (this.hash = `${VC(t, 0)}${e.hash}`);
        }
        updateRenderData() {
          this._updateProperties(), this._updateTexture();
        }
        destroy() {
          (this.image = null), AO.getInstance().put(this.data);
        }
        _updateProperties() {
          if (
            ((this.data = AO.getInstance().get()),
            (this.canvas = this.data.canvas),
            (this.context = this.data.context),
            this.context)
          ) {
            const t = this.labelInfo.fontScale;
            this.context.font = this.labelInfo.fontDesc;
            const e = zC(this.context, this.char, this.labelInfo.fontDesc),
              i = 2 * this.labelInfo.margin + 2;
            (this.width = parseFloat(e.toFixed(2)) * t + i),
              (this.height = (1 + wC) * this.labelInfo.fontSize * t + i),
              (this.offsetY = (-this.labelInfo.fontSize * wC * t) / 2);
          }
          this.canvas.width !== this.width && (this.canvas.width = this.width),
            this.canvas.height !== this.height &&
              (this.canvas.height = this.height),
            this.image || (this.image = new wd()),
            this.image.reset(this.canvas);
        }
        _updateTexture() {
          if (!this.context || !this.canvas) return;
          const t = this.context,
            e = this.labelInfo,
            i = this.canvas.width,
            s = this.canvas.height,
            n = e.fontScale;
          (t.textAlign = "center"),
            (t.textBaseline = "alphabetic"),
            t.clearRect(0, 0, i, s),
            (t.fillStyle = OO),
            t.fillRect(0, 0, i, s),
            (t.font = e.fontDesc.replace(
              /(\d+)(\.\d+)?(px|em|rem|pt)/g,
              (t, e, i, s) => (+e * n + (+i || 0) * n).toString() + s
            ));
          const r = e.fontSize * n,
            a = i / 2,
            o = s / 2 + r * RC + 0 * r,
            h = e.color;
          if (
            ((t.lineJoin = "round"),
            (t.fillStyle = `rgba(${h.r}, ${h.g}, ${h.b}, 1)`),
            e.isOutlined)
          ) {
            const i = e.out || CO;
            (t.strokeStyle = `rgba(${i.r}, ${i.g}, ${i.b}, ${i.a / 255})`),
              (t.lineWidth = 2 * e.margin * n),
              t.strokeText(this.char, a, o);
          }
          t.fillText(this.char, a, o);
        }
      }
      class wO extends sm {
        initWithSize(t, e, i = Cd.RGBA8888) {
          this.reset({ width: t, height: e, format: i });
        }
        drawTextureAt(t, e, i) {
          const s = this.getGFXTexture();
          if (!t || !s) return;
          const n = this._getGFXDevice();
          if (!n) return void z(16363);
          const r = new _u();
          (r.texOffset.x = e),
            (r.texOffset.y = i),
            (r.texExtent.width = t.width),
            (r.texExtent.height = t.height),
            n.copyTexImagesToTexture([t.data], s, [r]);
        }
      }
      class RO {
        get width() {
          return this._width;
        }
        get height() {
          return this._height;
        }
        constructor(t, e) {
          (this._x = 0),
            (this._y = 0),
            (this._nextY = 0),
            (this._width = 0),
            (this._height = 0),
            (this._halfBleed = 0),
            (this._dirty = !1);
          const i = new wO();
          i.initWithSize(t, e),
            (this.fontDefDictionary = new TO(i)),
            (this._halfBleed = 1),
            (this._width = t),
            (this._height = e),
            Lv.on(Nv.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
        }
        insertLetterTexture(t) {
          const e = t.image,
            i = Lv.root.device;
          if (!e || !this.fontDefDictionary || !i) return null;
          const s = e.width,
            n = e.height;
          if (
            (this._x + s + 0 > this._width &&
              ((this._x = 0), (this._y = this._nextY)),
            this._y + n > this._nextY && (this._nextY = this._y + n + 0),
            this._nextY > this._height)
          )
            return z(12100), null;
          if (!this.fontDefDictionary.texture) return null;
          this.fontDefDictionary.texture.drawTextureAt(e, this._x, this._y),
            (this._dirty = !0);
          const r = new yO();
          return (
            (r.u = this._x + this._halfBleed),
            (r.v = this._y + this._halfBleed),
            (r.valid = !0),
            (r.w = t.width - 2),
            (r.h = t.height - 2),
            (r.xAdvance = r.w),
            (r.offsetY = t.offsetY),
            (this._x += s + 0),
            this.fontDefDictionary.addLetterDefinitions(t.hash, r),
            r
          );
        }
        update() {
          this._dirty && (this._dirty = !1);
        }
        reset() {
          (this._x = 0),
            (this._y = 0),
            (this._nextY = 0),
            this.fontDefDictionary.clear();
        }
        destroy() {
          this.reset();
          const t = this.fontDefDictionary;
          t && t.texture && (t.texture.destroy(), (t.texture = null));
        }
        getTexture() {
          return this.fontDefDictionary.getTexture();
        }
        beforeSceneLoad() {
          this.clearAllCache();
        }
        clearAllCache() {
          this.destroy();
          const t = new wO();
          t.initWithSize(this._width, this._height),
            (this.fontDefDictionary.texture = t);
        }
        getLetter(t) {
          return this.fontDefDictionary.letterDefinitions[t];
        }
        getLetterDefinitionForChar(t, e) {
          const i = VC(t, 0) + e.hash;
          let s = this.fontDefDictionary.letterDefinitions[i];
          if (!s) {
            const i = new IO(t, e);
            i.updateRenderData(),
              (s = this.insertLetterTexture(i)),
              i.destroy();
          }
          return s;
        }
      }
      const DO = {
          fontAtlas: null,
          fontSize: 0,
          lineHeight: 0,
          hAlign: 0,
          vAlign: 0,
          hash: "",
          fontFamily: "",
          fontDesc: "Arial",
          color: Qi.WHITE.clone(),
          isOutlined: !1,
          out: Qi.WHITE.clone(),
          margin: 0,
          fontScale: 1,
        },
        xO = [new Lu(eu.ATTR_POSITION, fc.RGB32F)],
        MO = [
          new Lu(eu.ATTR_POSITION, fc.RGB32F),
          new Lu(eu.ATTR_COLOR, fc.RGBA32F),
        ],
        PO = [
          new Lu(eu.ATTR_POSITION, fc.RGB32F),
          new Lu(eu.ATTR_TEX_COORD, fc.RG32F),
          new Lu(eu.ATTR_COLOR, fc.RGBA32F),
        ],
        NO = [
          new Lu(eu.ATTR_POSITION, fc.RGB32F),
          new Lu(eu.ATTR_TEX_COORD, fc.RG32F),
          new Lu(eu.ATTR_COLOR, fc.RGBA8, !0),
        ],
        LO = [
          new Lu(eu.ATTR_POSITION, fc.RGB32F),
          new Lu(eu.ATTR_TEX_COORD, fc.RG32F),
          new Lu(eu.ATTR_COLOR, fc.RGBA32F),
          new Lu(eu.ATTR_COLOR2, fc.RGBA32F),
        ],
        BO = [
          new Lu(eu.ATTR_POSITION, fc.RGB32F),
          new Lu(eu.ATTR_TEX_COORD, fc.RG32F),
          new Lu(eu.ATTR_COLOR, fc.RGBA8, !0),
          new Lu(eu.ATTR_COLOR2, fc.RGBA8, !0),
        ];
      function FO(t) {
        let e = 0;
        for (let i = 0; i < t.length; i++) {
          const s = t[i];
          e += a_[s.format].count;
        }
        return e;
      }
      function UO(t) {
        let e = 0;
        for (let i = 0; i < t.length; i++) {
          const s = t[i];
          e += a_[s.format].size;
        }
        return e;
      }
      (a.internal.vfmtPosUvColor = PO),
        (a.internal.vfmtPosUvTwoColor = LO),
        (a.internal.vfmtPosUvColor4B = NO),
        (a.internal.vfmtPosUvTwoColor4B = BO),
        t(
          "UIVertexFormat",
          Object.freeze({
            __proto__: null,
            vfmt: xO,
            vfmtPosColor: MO,
            vfmtPosUvColor: PO,
            vfmtPosUvColor4B: NO,
            vfmtPosUvTwoColor: LO,
            vfmtPosUvTwoColor4B: BO,
            getComponentPerVertex: FO,
            getAttributeStride: UO,
          })
        );
      const kO = n2d.RenderDrawInfo;
      n2d.Batcher2d;
      const zO = n2d.UIMeshBuffer,
        HO = n2d.RenderEntity,
        GO = n2d.UIModelProxy;
      var VO;
      n2d.StencilManager,
        (function (t) {
          (t[(t.byteOffset = 0)] = "byteOffset"),
            (t[(t.vertexOffset = 1)] = "vertexOffset"),
            (t[(t.indexOffset = 2)] = "indexOffset"),
            (t[(t.dirty = 3)] = "dirty"),
            (t[(t.count = 4)] = "count");
        })(VO || (VO = {}));
      class jO {
        get attributes() {
          return this._attributes;
        }
        get vertexFormatBytes() {
          return this._vertexFormatBytes;
        }
        get byteOffset() {
          return this._byteOffset;
        }
        set byteOffset(t) {
          (this._byteOffset = t), (this._sharedBuffer[VO.byteOffset] = t);
        }
        get vertexOffset() {
          return this._vertexOffset;
        }
        set vertexOffset(t) {
          (this._vertexOffset = t), (this._sharedBuffer[VO.vertexOffset] = t);
        }
        get indexOffset() {
          return this._indexOffset;
        }
        set indexOffset(t) {
          (this._indexOffset = t), (this._sharedBuffer[VO.indexOffset] = t);
        }
        get dirty() {
          return this._dirty;
        }
        set dirty(t) {
          (this._dirty = t), (this._sharedBuffer[VO.dirty] = t ? 1 : 0);
        }
        get floatsPerVertex() {
          return this._floatsPerVertex;
        }
        set floatsPerVertex(t) {
          this._floatsPerVertex = t;
        }
        get vData() {
          return this._vData;
        }
        set vData(t) {
          (this._vData = t), (this._nativeObj.vData = t);
        }
        get iData() {
          return this._iData;
        }
        set iData(t) {
          (this._iData = t), (this._nativeObj.iData = t);
        }
        get nativeObj() {
          return this._nativeObj;
        }
        get sharedBuffer() {
          return this._sharedBuffer;
        }
        initSharedBuffer() {
          this._sharedBuffer = new Uint32Array(VO.count);
        }
        syncSharedBufferToNative() {
          this._nativeObj.syncSharedBufferToNative(this._sharedBuffer);
        }
        constructor() {
          (this._byteOffset = 0),
            (this._vertexOffset = 0),
            (this._indexOffset = 0),
            (this._dirty = !1),
            (this._floatsPerVertex = 0),
            (this._vData = null),
            (this._iData = null),
            (this._vertexFormatBytes = 0),
            (this._initVDataCount = 0),
            (this._initIDataCount = 0),
            (this._attributes = null),
            (this._iaPool = []),
            (this._iaInfo = null),
            (this._nextFreeIAHandle = 0),
            (this._nativeObj = new zO()),
            this.initSharedBuffer(),
            this.syncSharedBufferToNative();
        }
        initialize(t, e, i, s) {
          (this._initVDataCount = i),
            (this._initIDataCount = s),
            (this._attributes = e),
            (this.floatsPerVertex = UO(e) >> 2),
            this._initVDataCount,
            this._floatsPerVertex,
            X(9005),
            (this.vData && this.iData) ||
              ((this.vData = new Float32Array(this._initVDataCount)),
              (this.iData = new Uint16Array(this._initIDataCount))),
            this._iaPool.push(this.createNewIA(t)),
            this._nativeObj.initialize(e);
        }
        reset() {
          (this._nextFreeIAHandle = 0), (this.dirty = !1);
        }
        destroy() {
          this.reset(),
            (this._attributes = null),
            (this._iaInfo = null),
            (this.vData = null),
            (this.iData = null);
          for (let t = 0; t < this._iaPool.length; ++t) {
            const e = this._iaPool[t];
            e.vertexBuffers[0] && e.vertexBuffers[0].destroy(),
              e.indexBuffer && e.indexBuffer.destroy(),
              e.ia.destroy();
          }
          this._iaPool.length = 0;
        }
        setDirty() {
          this.dirty = !0;
        }
        request(t, e) {
          return z(9002), !1;
        }
        requireFreeIA(t) {
          return (
            this._iaPool.length <= this._nextFreeIAHandle &&
              this._iaPool.push(this.createNewIA(t)),
            this._iaPool[this._nextFreeIAHandle++].ia
          );
        }
        recycleIA(t) {
          const e = this._iaPool;
          for (let i = 0; i < this._nextFreeIAHandle; ++i)
            if (t === e[i].ia) {
              const t = e[i];
              return (
                (e[i] = e[--this._nextFreeIAHandle]),
                void (e[this._nextFreeIAHandle] = t)
              );
            }
        }
        checkCapacity(t, e) {
          const i = (this.vertexOffset + t) * this._floatsPerVertex,
            s = this.indexOffset + e;
          return !(i > this._initVDataCount || s > this._initIDataCount);
        }
        uploadBuffers() {
          if (0 === this.byteOffset || !this._dirty) return;
          const t = zr.__isWebIOS14OrIPadOS14Env,
            e = t ? this._nextFreeIAHandle : 1;
          if (t && e / this._iaPool.length < 0.5) {
            const t = e / 0.5;
            for (let e = this._iaPool.length - 1; e >= t; e--) {
              const t = this._iaPool[e];
              t.vertexBuffers[0] && t.vertexBuffers[0].destroy(),
                t.indexBuffer && t.indexBuffer.destroy(),
                t.ia.destroy();
            }
            this._iaPool.length = t;
          }
          const i = this.byteOffset,
            s = this.indexOffset;
          for (let t = 0; t < e; ++t) {
            const e = this._iaPool[t],
              n = new Float32Array(this.vData.buffer, 0, i >> 2),
              r = new Uint16Array(this.iData.buffer, 0, s),
              a = e.vertexBuffers[0];
            i > a.size && a.resize(i),
              a.update(n),
              2 * s > e.indexBuffer.size && e.indexBuffer.resize(2 * s),
              e.indexBuffer.update(r);
          }
          this.dirty = !1;
        }
        createNewIA(t) {
          let e, i, s;
          if (zr.__isWebIOS14OrIPadOS14Env || !this._iaPool[0]) {
            const n = (this._vertexFormatBytes =
                this._floatsPerVertex * Float32Array.BYTES_PER_ELEMENT),
              r = Uint16Array.BYTES_PER_ELEMENT,
              a = t.createBuffer(
                new yu(Tc.VERTEX | Tc.TRANSFER_DST, vc.HOST | vc.DEVICE, n, n)
              );
            (s = t.createBuffer(
              new yu(Tc.INDEX | Tc.TRANSFER_DST, vc.HOST | vc.DEVICE, r, r)
            )),
              (i = [a]),
              (this._iaInfo = new Fu(this._attributes, i, s)),
              (e = t.createInputAssembler(this._iaInfo));
          } else
            (e = t.createInputAssembler(this._iaInfo)),
              (i = this._iaInfo.vertexBuffers),
              (s = this._iaInfo.indexBuffer);
          return { ia: e, vertexBuffers: i, indexBuffer: s };
        }
      }
      t("MeshBuffer", jO);
      const WO = new Wn(() => ({ offset: 0, length: 0 }), 32);
      class XO {
        get ib() {
          return this._ib;
        }
        constructor(t, e, i, s, n, r) {
          (this.vertexAccessor = t),
            (this.bufferId = e),
            (this.meshBuffer = i),
            (this.vertexOffset = s),
            (this.vb = n),
            (this.indexCount = r),
            (this._ib = new Uint16Array(r)),
            t.getMeshBuffer(e);
        }
        setIndexBuffer(t) {
          t.length, this.ib.length;
          for (let e = 0; e < t.length; ++e) {
            const i = t[e];
            this._ib[e] = this.vertexOffset + i;
          }
        }
      }
      class YO extends class {
        get attributes() {
          return this._attributes;
        }
        get vertexFormatBytes() {
          return this._vertexFormatBytes;
        }
        get floatsPerVertex() {
          return this._floatsPerVertex;
        }
        constructor(t, e) {
          (this._buffers = []),
            (this._device = t),
            (this._attributes = e),
            (this._floatsPerVertex = UO(e) >> 2),
            (this._vertexFormatBytes =
              this._floatsPerVertex * Float32Array.BYTES_PER_ELEMENT);
        }
        initialize() {}
        reset() {}
        request(t = 4, e = 6) {}
        appendBuffers(t, e) {}
        uploadBuffers() {}
        destroy() {
          this._attributes.length = 0;
        }
      } {
        get id() {
          return this._id;
        }
        constructor(t, e, i, s) {
          super(t, e),
            (this._freeLists = []),
            (this._vCount = 0),
            (this._iCount = 0),
            (this._id = 0),
            (this._vCount =
              i ||
              Math.floor(
                (1024 * Te.BATCHER2D_MEM_INCREMENT) / this._vertexFormatBytes
              )),
            (this._iCount = s || this._vCount * YO.IB_SCALE),
            (this._id = YO.generateID()),
            this._allocateBuffer();
        }
        destroy() {
          for (let t = 0; t < this._buffers.length; ++t) {
            this._buffers[t].destroy();
            const e = this._freeLists[t];
            for (let t = 0; t < e.length; ++t) WO.free(e[t]);
          }
          (this._buffers.length = 0),
            (this._freeLists.length = 0),
            super.destroy();
        }
        reset() {
          for (let t = 0; t < this._buffers.length; ++t) {
            const e = this._buffers[t];
            (e.indexOffset = 0), e.reset();
          }
        }
        getVertexBuffer(t) {
          return this._buffers[t].vData;
        }
        getIndexBuffer(t) {
          return this._buffers[t].iData;
        }
        getMeshBuffer(t) {
          return this._buffers[t];
        }
        uploadBuffers() {
          for (let t = 0; t < this._buffers.length; ++t) {
            const e = this._freeLists[t][0],
              i = this._buffers[t];
            (!e || e.length < i.vData.byteLength) && i.uploadBuffers();
          }
        }
        appendIndices(t, e) {
          const i = this._buffers[t];
          if (e.length) {
            const t = i.indexOffset + e.length;
            if (i.iData.length < t) {
              const e = Math.floor(1.25 * t),
                s = new Uint16Array(e);
              s.set(i.iData), (i.iData = s);
            }
            i.iData.set(e, i.indexOffset), (i.indexOffset += e.length);
          }
        }
        allocateChunk(t, e) {
          const i = t * this.vertexFormatBytes;
          if (t > this._vCount || e > this._iCount) return G(9004, i), null;
          let s,
            n = null,
            r = 0,
            a = -1,
            o = null;
          for (let t = 0; t < this._buffers.length; ++t) {
            (n = this._buffers[t]), (s = this._freeLists[t]);
            for (let e = 0; e < s.length; ++e)
              if (s[e].length >= i) {
                (o = s[e]), (r = t), (a = e);
                break;
              }
            if (o) break;
          }
          if (
            (o ||
              ((r = this._allocateBuffer()),
              (n = this._buffers[r]),
              n && ((a = 0), (o = this._freeLists[r][a]))),
            o)
          ) {
            const t = o.offset / this.vertexFormatBytes,
              s = new Float32Array(n.vData.buffer, o.offset, i >> 2).fill(0);
            return (
              this._allocateChunkFromEntry(r, a, o, i),
              new XO(this, r, n, t, s, e)
            );
          }
          return null;
        }
        recycleChunk(t) {
          const e = this._freeLists[t.bufferId],
            i = this._buffers[t.bufferId];
          let s = t.vertexOffset * this.vertexFormatBytes,
            n = t.vb.byteLength;
          if (0 === n) return;
          let r = !1,
            a = 0,
            o = null,
            h = e[a];
          for (; h && h.offset < s; ) (o = h), (h = e[++a]);
          if (
            (o &&
              0 == s - (o.offset + o.length) &&
              ((o.length += n),
              (s = o.offset),
              (n = o.length),
              h &&
                h.offset - (s + n) == 0 &&
                ((o.length += h.length),
                e.splice(a, 1),
                WO.free(h),
                (h = null)),
              (r = !0)),
            !r && h)
          ) {
            if (0 == h.offset - (s + n)) (h.offset = s), (h.length += n);
            else {
              const t = WO.alloc();
              (t.offset = s), (t.length = n), e.splice(a, 0, t);
            }
            r = !0;
          }
          if (r) s + n === i.byteOffset && (i.byteOffset = s);
          else {
            const t = WO.alloc();
            (t.offset = s), (t.length = n), e.push(t);
          }
        }
        _allocateChunkFromEntry(t, e, i, s) {
          const n = i.length - s,
            r = i.offset + s,
            a = this._buffers[t];
          a.byteOffset < r && (a.byteOffset = r),
            j(n >= 0, 9004, t, i.offset, i.length),
            0 === n
              ? (this._freeLists[t].splice(e, 1), WO.free(i))
              : ((i.offset += s), (i.length = n));
        }
        _allocateBuffer() {
          j(this._buffers.length === this._freeLists.length, 9003);
          const t = new jO(),
            e = this._vCount * this._floatsPerVertex;
          t.initialize(this._device, this._attributes, e, this._iCount),
            this._buffers.push(t);
          const i = WO.alloc();
          (i.offset = 0), (i.length = t.vData.byteLength);
          const s = [i];
          return (
            this._freeLists.push(s),
            Lv.root.batcher2D.syncMeshBuffersToNative(this.id, this._buffers),
            this._buffers.length - 1
          );
        }
        static generateID() {
          return YO.ID_COUNT++;
        }
      }
      let KO, qO, $O, ZO, QO, JO, tI, eI, iI, sI, nI;
      (YO.IB_SCALE = 4),
        (YO.ID_COUNT = 0),
        (function (t) {
          (t[(t.DrawInfoType = 0)] = "DrawInfoType"),
            (t[(t.VertDirty = 1)] = "VertDirty"),
            (t[(t.IsMeshBuffer = 2)] = "IsMeshBuffer"),
            (t[(t.Stride = 3)] = "Stride"),
            (t[(t.Count = 4)] = "Count");
        })(KO || (KO = {})),
        (function (t) {
          (t[(t.BufferID = 0)] = "BufferID"),
            (t[(t.AccessorID = 1)] = "AccessorID"),
            (t[(t.Count = 2)] = "Count");
        })(qO || (qO = {})),
        (function (t) {
          (t[(t.VertexOffset = 0)] = "VertexOffset"),
            (t[(t.IndexOffset = 1)] = "IndexOffset"),
            (t[(t.VBCount = 2)] = "VBCount"),
            (t[(t.IBCount = 3)] = "IBCount"),
            (t[(t.DataHash = 4)] = "DataHash"),
            (t[(t.Count = 5)] = "Count");
        })($O || ($O = {})),
        (function (t) {
          (t[(t.COMP = 0)] = "COMP"),
            (t[(t.MODEL = 1)] = "MODEL"),
            (t[(t.MIDDLEWARE = 2)] = "MIDDLEWARE"),
            (t[(t.SUB_NODE = 3)] = "SUB_NODE");
        })(ZO || (ZO = {}));
      class rI {
        constructor(t) {
          (this._accId = -1),
            (this._bufferId = -1),
            (this._vertexOffset = 0),
            (this._indexOffset = 0),
            (this._vb = null),
            (this._ib = null),
            (this._vData = null),
            (this._iData = null),
            (this._vertDirty = !1),
            (this._vbCount = 0),
            (this._ibCount = 0),
            (this._dataHash = 0),
            (this._isMeshBuffer = !1),
            (this._material = null),
            (this._texture = null),
            (this._sampler = null),
            (this._stride = 0),
            (this._useLocal = !1),
            (this._model = null),
            (this._drawInfoType = ZO.COMP),
            (this._subNode = null),
            this.init(t);
          const e = this._nativeObj.getAttrSharedBufferForJS();
          let i = 0;
          (this._uint8SharedBuffer = new Uint8Array(e, i, KO.Count)),
            (i += KO.Count * Uint8Array.BYTES_PER_ELEMENT),
            (this._uint16SharedBuffer = new Uint16Array(e, i, qO.Count)),
            (i += qO.Count * Uint16Array.BYTES_PER_ELEMENT),
            (this._uint32SharedBuffer = new Uint32Array(e, i, $O.Count));
        }
        get nativeObj() {
          return this._nativeObj;
        }
        get render2dBuffer() {
          return this._render2dBuffer;
        }
        init(t) {
          t && (this._nativeObj = t),
            this._nativeObj || (this._nativeObj = new kO());
        }
        clear() {
          (this._bufferId = 0),
            (this._vertexOffset = 0),
            (this._indexOffset = 0),
            (this._vertDirty = !1);
        }
        setAccId(t) {
          this._accId !== t && (this._uint16SharedBuffer[qO.AccessorID] = t),
            (this._accId = t);
        }
        setBufferId(t) {
          this._bufferId !== t &&
            ((this._uint16SharedBuffer[qO.BufferID] = t),
            this._nativeObj.changeMeshBuffer()),
            (this._bufferId = t);
        }
        setAccAndBuffer(t, e) {
          (this._accId === t && this._bufferId === e) ||
            ((this._uint16SharedBuffer[qO.AccessorID] = t),
            (this._uint16SharedBuffer[qO.BufferID] = e),
            this._nativeObj.changeMeshBuffer()),
            (this._bufferId = e),
            (this._accId = t);
        }
        setVertexOffset(t) {
          (this._vertexOffset = t),
            (this._uint32SharedBuffer[$O.VertexOffset] = t);
        }
        setIndexOffset(t) {
          (this._indexOffset = t),
            (this._uint32SharedBuffer[$O.IndexOffset] = t);
        }
        setVB(t) {
          this._nativeObj.vbBuffer = t;
        }
        setIB(t) {
          this._nativeObj.ibBuffer = t;
        }
        setVData(t) {
          this._nativeObj.vDataBuffer = t;
        }
        setIData(t) {
          this._nativeObj.iDataBuffer = t;
        }
        setVBCount(t) {
          (this._uint32SharedBuffer[$O.VBCount] = t), (this._vbCount = t);
        }
        setIBCount(t) {
          this._uint32SharedBuffer[$O.IBCount] = t;
        }
        setVertDirty(t) {
          (this._uint8SharedBuffer[KO.VertDirty] = t ? 1 : 0),
            (this._vertDirty = t);
        }
        setDataHash(t) {
          (this._uint32SharedBuffer[$O.DataHash] = t), (this._dataHash = t);
        }
        setIsMeshBuffer(t) {
          (this._uint8SharedBuffer[KO.IsMeshBuffer] = t ? 1 : 0),
            (this._isMeshBuffer = t);
        }
        setMaterial(t) {
          this._material !== t && (this._nativeObj.material = t),
            (this._material = t);
        }
        setTexture(t) {
          this._texture !== t && (this._nativeObj.texture = t),
            (this._texture = t);
        }
        setSampler(t) {
          this._sampler !== t && (this._nativeObj.sampler = t),
            (this._sampler = t);
        }
        setModel(t) {
          this._model !== t && (this._nativeObj.model = t);
        }
        setDrawInfoType(t) {
          this._drawInfoType !== t &&
            (this._uint8SharedBuffer[KO.DrawInfoType] = t),
            (this._drawInfoType = t);
        }
        setSubNode(t) {
          this._subNode !== t && (this._nativeObj.subNode = t),
            (this._subNode = t);
        }
        setStride(t) {
          (this._uint8SharedBuffer[KO.Stride] = t), (this._stride = t);
        }
        initRender2dBuffer() {
          (this._render2dBuffer = new Float32Array(
            this._vbCount * this._stride
          )),
            this._nativeObj.setRender2dBufferToNative(this._render2dBuffer);
        }
        fillRender2dBuffer(t) {
          {
            const e = Math.min(this._vbCount, t.length);
            let i = 0;
            for (let s = 0; s < e; s++) {
              const e = t[s];
              (this._render2dBuffer[i] = e.x),
                (this._render2dBuffer[i + 1] = e.y),
                (this._render2dBuffer[i + 2] = e.z),
                (i += this._stride);
            }
          }
        }
      }
      !(function (t) {
        (t[(t.DISABLED = 0)] = "DISABLED"),
          (t[(t.CLEAR = 1)] = "CLEAR"),
          (t[(t.ENTER_LEVEL = 2)] = "ENTER_LEVEL"),
          (t[(t.ENABLED = 3)] = "ENABLED"),
          (t[(t.EXIT_LEVEL = 4)] = "EXIT_LEVEL"),
          (t[(t.CLEAR_INVERTED = 5)] = "CLEAR_INVERTED"),
          (t[(t.ENTER_LEVEL_INVERTED = 6)] = "ENTER_LEVEL_INVERTED");
      })(QO || (QO = {})),
        (function (t) {
          (t[(t.stencilTest = 0)] = "stencilTest"),
            (t[(t.func = 1)] = "func"),
            (t[(t.stencilMask = 2)] = "stencilMask"),
            (t[(t.writeMask = 3)] = "writeMask"),
            (t[(t.failOp = 4)] = "failOp"),
            (t[(t.zFailOp = 5)] = "zFailOp"),
            (t[(t.passOp = 6)] = "passOp"),
            (t[(t.ref = 7)] = "ref"),
            (t[(t.count = 8)] = "count");
        })(JO || (JO = {}));
      class aI {
        constructor() {
          (this._maskStack = []),
            (this._stencilPattern = {
              stencilTest: !0,
              func: xc.ALWAYS,
              stencilMask: 65535,
              writeMask: 65535,
              failOp: Mc.KEEP,
              zFailOp: Mc.KEEP,
              passOp: Mc.KEEP,
              ref: 1,
            }),
            (this._stage = QO.DISABLED),
            (this.stencilStateMap = new Map()),
            (this.stencilStateMapWithDepth = new Map());
        }
        get stage() {
          return this._stage;
        }
        set stage(t) {
          this._stage = t;
        }
        get pattern() {
          return this._stencilPattern;
        }
        pushMask(t) {
          this._maskStack.push(t);
        }
        clear(t) {
          return t.stencilStage !== QO.ENTER_LEVEL
            ? QO.CLEAR_INVERTED
            : QO.CLEAR;
        }
        enableMask() {
          this.stage = QO.ENABLED;
        }
        exitMask() {
          0 !== this._maskStack.length &&
            (this._maskStack.pop(),
            0 === this._maskStack.length
              ? (this.stage = QO.DISABLED)
              : (this.stage = QO.ENABLED));
        }
        getWriteMask() {
          return 1 << (this._maskStack.length - 1);
        }
        getExitWriteMask() {
          return 1 << this._maskStack.length;
        }
        getStencilRef() {
          let t = 0;
          for (let e = 0; e < this._maskStack.length; ++e) t += 1 << e;
          return t;
        }
        getMaskStackSize() {
          return this._maskStack.length;
        }
        reset() {
          (this._maskStack.length = 0), (this.stage = QO.DISABLED);
        }
        destroy() {
          this.stencilStateMap.forEach((t) => {
            t.destroy();
          }),
            this.stencilStateMap.clear();
        }
        getStencilStage(t, e) {
          let i = 0,
            s = !1,
            n = !1,
            r = xc.LESS,
            a = this.stencilStateMap;
          if (e && e.passes[0]) {
            const o = e.passes[0].depthStencilState;
            let h = 0,
              l = 0;
            o.depthTest && (h = 1),
              o.depthWrite && (l = 1),
              (i =
                h |
                (l << 1) |
                (o.depthFunc << 2) |
                (t << 6) |
                (this._maskStack.length << 9)),
              (s = o.depthTest),
              (n = o.depthWrite),
              (r = o.depthFunc),
              (a = this.stencilStateMapWithDepth);
          } else i = (t << 16) | this._maskStack.length;
          if (a && a.has(i)) return a.get(i);
          this.setStateFromStage(t);
          const o = new S_(
            s,
            n,
            r,
            this._stencilPattern.stencilTest,
            this._stencilPattern.func,
            this._stencilPattern.stencilMask,
            this._stencilPattern.writeMask,
            this._stencilPattern.failOp,
            this._stencilPattern.zFailOp,
            this._stencilPattern.passOp,
            this._stencilPattern.ref,
            this._stencilPattern.stencilTest,
            this._stencilPattern.func,
            this._stencilPattern.stencilMask,
            this._stencilPattern.writeMask,
            this._stencilPattern.failOp,
            this._stencilPattern.zFailOp,
            this._stencilPattern.passOp,
            this._stencilPattern.ref
          );
          return a.set(i, o), o;
        }
        getStencilHash(t) {
          return (t << 8) | this._maskStack.length;
        }
        setStateFromStage(t) {
          const e = this._stencilPattern;
          t === QO.DISABLED
            ? ((e.stencilTest = !1),
              (e.func = xc.ALWAYS),
              (e.failOp = Mc.KEEP),
              (e.stencilMask = e.writeMask = 65535),
              (e.ref = 1))
            : ((e.stencilTest = !0),
              t === QO.ENABLED
                ? ((e.func = xc.EQUAL),
                  (e.failOp = Mc.KEEP),
                  (e.stencilMask = e.ref = this.getStencilRef()),
                  (e.writeMask = this.getWriteMask()))
                : t === QO.CLEAR
                ? ((e.func = xc.NEVER),
                  (e.failOp = Mc.ZERO),
                  (e.writeMask = e.stencilMask = e.ref = this.getWriteMask()))
                : t === QO.CLEAR_INVERTED || t === QO.ENTER_LEVEL
                ? ((e.func = xc.NEVER),
                  (e.failOp = Mc.REPLACE),
                  (e.writeMask = e.stencilMask = e.ref = this.getWriteMask()))
                : t === QO.ENTER_LEVEL_INVERTED &&
                  ((e.func = xc.NEVER),
                  (e.failOp = Mc.ZERO),
                  (e.writeMask = e.stencilMask = e.ref = this.getWriteMask())));
        }
      }
      t("StencilManager", aI),
        (aI.sharedManager = null),
        (aI.sharedManager = new aI()),
        (function (t) {
          (t[(t.STATIC = 0)] = "STATIC"),
            (t[(t.DYNAMIC = 1)] = "DYNAMIC"),
            (t[(t.CROSSED = 2)] = "CROSSED");
        })(tI || (tI = {})),
        (function (t) {
          (t[(t.localOpacity = 0)] = "localOpacity"),
            (t[(t.count = 1)] = "count");
        })(eI || (eI = {})),
        (function (t) {
          (t[(t.colorR = 0)] = "colorR"),
            (t[(t.colorG = 1)] = "colorG"),
            (t[(t.colorB = 2)] = "colorB"),
            (t[(t.colorA = 3)] = "colorA"),
            (t[(t.maskMode = 4)] = "maskMode"),
            (t[(t.count = 5)] = "count");
        })(iI || (iI = {})),
        (function (t) {
          (t[(t.colorDirty = 0)] = "colorDirty"),
            (t[(t.enabled = 1)] = "enabled"),
            (t[(t.useLocal = 2)] = "useLocal"),
            (t[(t.count = 3)] = "count");
        })(sI || (sI = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.MASK = 1)] = "MASK"),
            (t[(t.MASK_INVERTED = 2)] = "MASK_INVERTED"),
            (t[(t.MASK_NODE = 3)] = "MASK_NODE"),
            (t[(t.MASK_NODE_INVERTED = 4)] = "MASK_NODE_INVERTED");
        })(nI || (nI = {}));
      class oI {
        get nativeObj() {
          return this._nativeObj;
        }
        get renderDrawInfoArr() {
          return this._dynamicDrawInfoArr;
        }
        get renderEntityType() {
          return this._renderEntityType;
        }
        get color() {
          return this._color;
        }
        set color(t) {
          (this._color = t),
            (this._uint8SharedBuffer[iI.colorR] = t.r),
            (this._uint8SharedBuffer[iI.colorG] = t.g),
            (this._uint8SharedBuffer[iI.colorB] = t.b),
            (this._uint8SharedBuffer[iI.colorA] = t.a);
        }
        get localOpacity() {
          return this._localOpacity;
        }
        set localOpacity(t) {
          (this._localOpacity = t),
            (this._floatSharedBuffer[eI.localOpacity] = t);
        }
        get colorDirty() {
          return (
            (this._colorDirty = !!this._boolSharedBuffer[sI.colorDirty]),
            this._colorDirty
          );
        }
        set colorDirty(t) {
          (this._colorDirty = t),
            (this._boolSharedBuffer[sI.colorDirty] = t ? 1 : 0);
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(t) {
          (this._enabled = t), (this._boolSharedBuffer[sI.enabled] = t ? 1 : 0);
        }
        constructor(t) {
          (this._renderEntityType = tI.STATIC),
            (this._dynamicDrawInfoArr = []),
            (this._node = null),
            (this._renderTransform = null),
            (this._stencilStage = QO.DISABLED),
            (this._useLocal = !1),
            (this._maskMode = nI.NONE),
            (this._color = Qi.WHITE.clone()),
            (this._localOpacity = 255),
            (this._colorDirty = !0),
            (this._enabled = !1),
            this._nativeObj || (this._nativeObj = new HO(t)),
            (this._renderEntityType = t),
            this.initSharedBuffer();
        }
        addDynamicRenderDrawInfo(t) {
          t &&
            (this._dynamicDrawInfoArr.push(t),
            this._nativeObj.addDynamicRenderDrawInfo(t.nativeObj));
        }
        removeDynamicRenderDrawInfo() {
          this._dynamicDrawInfoArr.pop(),
            this._nativeObj.removeDynamicRenderDrawInfo();
        }
        clearDynamicRenderDrawInfos() {
          (this._dynamicDrawInfoArr.length = 0),
            this._nativeObj.clearDynamicRenderDrawInfos();
        }
        clearStaticRenderDrawInfos() {
          this._nativeObj.clearStaticRenderDrawInfos();
        }
        setDynamicRenderDrawInfo(t, e) {
          t &&
            (this._dynamicDrawInfoArr.length < e + 1
              ? (this._dynamicDrawInfoArr.push(t),
                this._nativeObj.addDynamicRenderDrawInfo(t.nativeObj))
              : ((this._dynamicDrawInfoArr[e] = t),
                this._nativeObj.setDynamicRenderDrawInfo(t.nativeObj, e)));
        }
        setMaskMode(t) {
          (this._uint8SharedBuffer[iI.maskMode] = t), (this._maskMode = t);
        }
        getStaticRenderDrawInfo() {
          {
            const t = this._nativeObj.getStaticRenderDrawInfo(
              this._nativeObj.staticDrawInfoSize++
            );
            return new rI(t);
          }
        }
        setNode(t) {
          this._node !== t && (this._nativeObj.node = t), (this._node = t);
        }
        setRenderTransform(t) {
          this._renderTransform !== t && (this._nativeObj.renderTransform = t),
            (this._renderTransform = t);
        }
        setStencilStage(t) {
          this._stencilStage !== t && (this._nativeObj.stencilStage = t),
            (this._stencilStage = t);
        }
        setUseLocal(t) {
          (this._boolSharedBuffer[sI.useLocal] = t ? 1 : 0),
            (this._useLocal = t);
        }
        initSharedBuffer() {
          {
            const t = this._nativeObj.getEntitySharedBufferForJS();
            let e = 0;
            (this._floatSharedBuffer = new Float32Array(t, e, eI.count)),
              (e += 4 * eI.count),
              (this._uint8SharedBuffer = new Uint8Array(t, e, iI.count)),
              (e += 1 * iI.count),
              (this._boolSharedBuffer = new Uint8Array(t, e, sI.count));
          }
        }
      }
      const hI = UO(PO) >> 2;
      class lI {
        get vertexCount() {
          return this._vc;
        }
        get indexCount() {
          return this._ic;
        }
        get stride() {
          return this._floatStride << 2;
        }
        get floatStride() {
          return this._floatStride;
        }
        get vertexFormat() {
          return this._vertexFormat;
        }
        get drawInfoType() {
          return this._drawInfoType;
        }
        set drawInfoType(t) {
          (this._drawInfoType = t),
            this._renderDrawInfo && this._renderDrawInfo.setDrawInfoType(t);
        }
        get renderDrawInfo() {
          return this._renderDrawInfo;
        }
        get material() {
          return this._material;
        }
        set material(t) {
          (this._material = t),
            this._renderDrawInfo && this._renderDrawInfo.setMaterial(t);
        }
        get dataHash() {
          return this._dataHash;
        }
        set dataHash(t) {
          (this._dataHash = t),
            this._renderDrawInfo && this._renderDrawInfo.setDataHash(t);
        }
        get multiOwner() {
          return this._multiOwner;
        }
        set multiOwner(t) {
          this._multiOwner = t;
        }
        get batcher() {
          return (
            this._batcher || (this._batcher = Lv.root.batcher2D), this._batcher
          );
        }
        constructor(t = PO) {
          (this.chunk = null),
            (this._renderDrawInfo = null),
            (this._material = null),
            (this._dataHash = 0),
            (this._isMeshBuffer = !1),
            (this._vc = 0),
            (this._ic = 0),
            (this._floatStride = 0),
            (this._vertexFormat = PO),
            (this._drawInfoType = ZO.COMP),
            (this._multiOwner = !1),
            (this._batcher = null),
            (this._floatStride = t === PO ? hI : UO(t) >> 2),
            (this._vertexFormat = t);
        }
        isValid() {
          return this._ic > 0 && this.chunk.vertexAccessor;
        }
        initRenderDrawInfo(t, e = ZO.COMP) {
          {
            const i = t.renderEntity;
            if (i.renderEntityType === tI.STATIC) {
              if (!this._renderDrawInfo) {
                const t = i.getStaticRenderDrawInfo();
                t && (this._renderDrawInfo = t);
              }
            } else
              !1 === this.multiOwner &&
                (this._renderDrawInfo ||
                  ((this._renderDrawInfo = new rI()),
                  i.addDynamicRenderDrawInfo(this._renderDrawInfo)));
            (this.drawInfoType = e), this.setRenderDrawInfoAttributes();
          }
        }
        removeRenderDrawInfo(t) {
          {
            const e = t.renderEntity;
            e.renderEntityType === tI.DYNAMIC
              ? e.removeDynamicRenderDrawInfo()
              : e.renderEntityType === tI.STATIC &&
                e.clearStaticRenderDrawInfos();
          }
        }
        setRenderDrawInfoAttributes() {
          this._renderDrawInfo &&
            (this.chunk &&
              (this._renderDrawInfo.setBufferId(this.chunk.bufferId),
              this._renderDrawInfo.setVertexOffset(this.chunk.vertexOffset),
              this._renderDrawInfo.setVB(this.chunk.vb),
              this._renderDrawInfo.setIB(this.chunk.ib),
              this.chunk.meshBuffer &&
                (this._renderDrawInfo.setIndexOffset(
                  this.chunk.meshBuffer.indexOffset
                ),
                this._renderDrawInfo.setVData(
                  this.chunk.meshBuffer.vData.buffer
                ),
                this._renderDrawInfo.setIData(
                  this.chunk.meshBuffer.iData.buffer
                ))),
            this._renderDrawInfo.setVBCount(this._vc),
            this._renderDrawInfo.setIBCount(this._ic),
            this._renderDrawInfo.setDataHash(this.dataHash),
            this._renderDrawInfo.setIsMeshBuffer(this._isMeshBuffer),
            this._renderDrawInfo.setMaterial(this.material),
            this._renderDrawInfo.setDrawInfoType(this._drawInfoType));
        }
      }
      t("BaseRenderData", lI);
      class cI extends lI {
        static add(t = PO, e = null) {
          const i = new cI(t, e);
          return (
            e || (e = Lv.root.batcher2D.switchBufferAccessor(i._vertexFormat)),
            (i._accessor = e),
            i
          );
        }
        static remove(t) {
          t.clear(), (t._accessor = null);
        }
        get dataLength() {
          return this._data.length;
        }
        set dataLength(t) {
          const e = this._data;
          if (e.length !== t) {
            for (let i = e.length; i < t; i++)
              e.push({ x: 0, y: 0, z: 0, u: 0, v: 0, color: Qi.WHITE.clone() });
            e.length = t;
          }
          this.syncRender2dBuffer();
        }
        get data() {
          return this._data;
        }
        get vertDirty() {
          return this._vertDirty;
        }
        set vertDirty(t) {
          (this._vertDirty = t),
            this._renderDrawInfo && t && this._renderDrawInfo.setVertDirty(t);
        }
        get textureHash() {
          return this._textureHash;
        }
        set textureHash(t) {
          this._textureHash = t;
        }
        set frame(t) {
          (this._frame = t),
            this._renderDrawInfo &&
              (this._frame
                ? (this._renderDrawInfo.setTexture(this._frame.getGFXTexture()),
                  this._renderDrawInfo.setSampler(this._frame.getGFXSampler()))
                : (this._renderDrawInfo.setTexture(null),
                  this._renderDrawInfo.setSampler(null)));
        }
        get frame() {
          return this._frame;
        }
        get accessor() {
          return this._accessor;
        }
        constructor(t = PO, e = null) {
          super(t),
            (this._vertDirty = !0),
            (this._textureHash = 0),
            (this.indices = null),
            (this.layer = 0),
            (this.nodeDirty = !0),
            (this.passDirty = !0),
            (this.textureDirty = !0),
            (this.hashDirty = !0),
            (this._data = []),
            (this._frame = null),
            (this._accessor = null),
            (this.vertexRow = 1),
            (this.vertexCol = 1),
            e || (e = this.batcher.switchBufferAccessor(this._vertexFormat)),
            (this._accessor = e);
        }
        resize(t, e) {
          (t === this._vc && e === this._ic && this.chunk) ||
            ((this._vc = t),
            (this._ic = e),
            this.chunk &&
              (this._accessor.recycleChunk(this.chunk), (this.chunk = null)),
            (this.chunk = this._accessor.allocateChunk(t, e)),
            this.updateHash(),
            !1 === this.multiOwner &&
              this._renderDrawInfo &&
              (this._renderDrawInfo.setDrawInfoType(this._drawInfoType),
              this._renderDrawInfo.setBufferId(this.chunk.bufferId),
              this._renderDrawInfo.setVertexOffset(this.chunk.vertexOffset),
              this._renderDrawInfo.setIndexOffset(
                this.chunk.meshBuffer.indexOffset
              ),
              this._renderDrawInfo.setVB(this.chunk.vb),
              this._renderDrawInfo.setIB(this.chunk.ib),
              this._renderDrawInfo.setVData(this.chunk.meshBuffer.vData.buffer),
              this._renderDrawInfo.setIData(this.chunk.meshBuffer.iData.buffer),
              this._renderDrawInfo.setVBCount(this._vc),
              this._renderDrawInfo.setIBCount(this._ic)));
        }
        setRenderDrawInfoAttributes() {
          this._renderDrawInfo &&
            (this._renderDrawInfo.setAccId(this._accessor.id),
            super.setRenderDrawInfoAttributes(),
            this._renderDrawInfo.setTexture(
              this.frame ? this.frame.getGFXTexture() : null
            ),
            this._renderDrawInfo.setSampler(
              this.frame ? this.frame.getGFXSampler() : null
            ));
        }
        fillDrawInfoAttributes(t) {
          t &&
            (t.setDrawInfoType(this._drawInfoType),
            t.setAccAndBuffer(this._accessor.id, this.chunk.bufferId),
            t.setVertexOffset(this.chunk.vertexOffset),
            t.setIndexOffset(this.chunk.meshBuffer.indexOffset),
            t.setVB(this.chunk.vb),
            t.setIB(this.chunk.ib),
            t.setVData(this.chunk.meshBuffer.vData.buffer),
            t.setIData(this.chunk.meshBuffer.iData.buffer),
            t.setVBCount(this._vc),
            t.setIBCount(this._ic),
            t.setDataHash(this.dataHash),
            t.setIsMeshBuffer(this._isMeshBuffer));
        }
        syncRender2dBuffer() {
          if (!1 === this.multiOwner) {
            if (!this._renderDrawInfo) return;
            this.renderDrawInfo.setStride(this.floatStride),
              this.renderDrawInfo.setVBCount(this.dataLength),
              this.renderDrawInfo.initRender2dBuffer();
          }
        }
        resizeAndCopy(t, e) {
          if (t === this._vc && e === this._ic && this.chunk) return;
          (this._vc = t), (this._ic = e);
          const i = this.chunk;
          (this.chunk = this._accessor.allocateChunk(t, e)),
            i && (this.chunk.vb.set(i.vb), this._accessor.recycleChunk(i)),
            this.updateHash();
        }
        getMeshBuffer() {
          return this.chunk && this._accessor
            ? this._accessor.getMeshBuffer(this.chunk.bufferId)
            : null;
        }
        updateNode(t) {
          (this.layer = t.node.layer),
            (this.nodeDirty = !1),
            (this.hashDirty = !0);
        }
        updatePass(t) {
          (this.material = t.getRenderMaterial(0)),
            (this.passDirty = !1),
            (this.hashDirty = !0);
        }
        updateTexture(t) {
          (this.frame = t),
            (this.textureHash = t.getHash()),
            (this.textureDirty = !1),
            (this.hashDirty = !0);
        }
        updateHash() {
          const t = `${this.chunk ? this.chunk.bufferId : -1}${this.layer} ${
            this.textureHash
          }`;
          (this.dataHash = tc(t, 666)), (this.hashDirty = !1);
        }
        updateRenderData(t, e) {
          if (
            (this.passDirty &&
              ((this.material = t.getRenderMaterial(0)),
              (this.passDirty = !1),
              (this.hashDirty = !0),
              this._renderDrawInfo &&
                this._renderDrawInfo.setMaterial(this.material)),
            this.nodeDirty)
          ) {
            const e = t.node.scene ? t._getRenderScene() : null;
            (this.layer = t.node.layer),
              null !== e && (this.nodeDirty = !1),
              (this.hashDirty = !0);
          }
          this.textureDirty &&
            ((this.frame = e),
            (this.textureHash = e.getHash()),
            (this.textureDirty = !1),
            (this.hashDirty = !0),
            this._renderDrawInfo &&
              (this._renderDrawInfo.setTexture(
                this.frame ? this.frame.getGFXTexture() : null
              ),
              this._renderDrawInfo.setSampler(
                this.frame ? this.frame.getGFXSampler() : null
              ))),
            this.hashDirty &&
              (this.updateHash(),
              this._renderDrawInfo &&
                this._renderDrawInfo.setDataHash(this.dataHash)),
            !1 === this.multiOwner &&
              this._renderDrawInfo.fillRender2dBuffer(this._data);
        }
        clear() {
          this.resize(0, 0),
            (this._data.length = 0),
            (this.indices = null),
            (this.vertDirty = !0),
            (this.material = null),
            (this.nodeDirty = !0),
            (this.passDirty = !0),
            (this.textureDirty = !0),
            (this.hashDirty = !0),
            (this.layer = 0),
            (this.frame = null),
            (this.textureHash = 0),
            (this.dataHash = 0),
            this._renderDrawInfo && this._renderDrawInfo.clear();
        }
        static createStaticVBAccessor(t, e, i) {
          const s = Lv.root.device;
          return new YO(s, t, e, i);
        }
      }
      t("RenderData", cI);
      class uI extends lI {
        static add(t = PO) {
          const e = new uI();
          return (
            (e._floatStride = t === PO ? hI : UO(t) >> 2),
            (e._vertexFormat = t),
            e
          );
        }
        static remove(t) {
          t.clear();
        }
        set formatByte(t) {}
        get formatByte() {
          return this.stride;
        }
        get floatStride() {
          return this._floatStride;
        }
        get vDataOffset() {
          return this._byteLength >>> 2;
        }
        constructor(t = PO) {
          super(t),
            (this._isMeshBuffer = !0),
            (this.vertexStart = 0),
            (this.vertexRange = 0),
            (this.indexStart = 0),
            (this.indexRange = 0),
            (this.lastFilledIndex = 0),
            (this.lastFilledVertex = 0),
            (this.frame = null),
            (this._byteLength = 0),
            (this._vertexBuffers = []),
            (this._indexBuffer = null),
            (this._iaPool = null),
            (this._iaInfo = null),
            (this.vData = new Float32Array(256 * this.stride)),
            (this.iData = new Uint16Array(1536));
        }
        request(t, e) {
          const i = this._byteLength + t * this.stride;
          return (
            !!this.reserve(t, e) &&
            ((this._vc += t),
            (this._ic += e),
            (this._byteLength = i),
            (this.vertexRange = this._vc),
            (this.indexRange = this._ic),
            !0)
          );
        }
        reserve(t, e) {
          const i = this._byteLength + t * this.stride,
            s = this.indexCount + e;
          if (t + this.vertexCount > 65535) return !1;
          let n = this.vData.byteLength,
            r = this.iData.length,
            a = this.vData.length,
            o = this.iData.length;
          if (i > n || s > r) {
            for (; n < i || r < s; ) (a *= 2), (o *= 2), (n = 4 * a), (r = o);
            this._reallocBuffer(a, o);
          }
          return !0;
        }
        resize(t, e) {
          const i = t * this.stride;
          t >= 0 && e >= 0 && i <= this.vData.byteLength && this.iData.length,
            (this._vc = t),
            (this._ic = e),
            (this._byteLength = i),
            this.updateRange(0, t, 0, e);
        }
        updateRange(t, e, i, s) {
          e >= 0 && s >= 0 && e <= this._vc && this._ic,
            (this.vertexStart = t),
            (this.indexStart = i),
            (this.vertexRange = e),
            (this.indexRange = s);
        }
        requestIA(t) {
          this._initIAInfo(t);
          const e = this._iaPool.add();
          return (
            (e.firstIndex = this.indexStart),
            (e.indexCount = this.indexRange),
            e
          );
        }
        uploadBuffers() {
          if (
            0 === this._byteLength ||
            !this._vertexBuffers[0] ||
            !this._indexBuffer
          )
            return;
          const t = this._ic,
            e = new Float32Array(this.vData.buffer, 0, this._byteLength >> 2),
            i = new Uint16Array(this.iData.buffer, 0, t),
            s = this._vertexBuffers[0];
          this._byteLength > s.size && s.resize(this._byteLength), s.update(e);
          const n = t << 1;
          n > this._indexBuffer.size && this._indexBuffer.resize(n),
            this._indexBuffer.update(i);
        }
        freeIAPool() {
          this._iaPool && this._iaPool.reset();
        }
        reset() {
          (this._vc = 0),
            (this._ic = 0),
            (this._byteLength = 0),
            (this.vertexStart = 0),
            (this.vertexRange = 0),
            (this.indexStart = 0),
            (this.indexRange = 0),
            (this.lastFilledIndex = 0),
            (this.lastFilledVertex = 0),
            (this.material = null),
            this.freeIAPool();
        }
        clear() {
          this.reset(),
            this._iaPool && this._iaPool.destroy(),
            this._vertexBuffers[0] &&
              (this._vertexBuffers[0].destroy(), (this._vertexBuffers = [])),
            (this._iaInfo = null),
            (this.vData = new Float32Array(256 * this.stride)),
            (this.iData = new Uint16Array(1536));
        }
        _initIAInfo(t) {
          if (!this._iaInfo) {
            const e = this.stride,
              i = this._vertexBuffers;
            i.length ||
              i.push(
                t.createBuffer(
                  new yu(Tc.VERTEX | Tc.TRANSFER_DST, vc.DEVICE, e, e)
                )
              );
            const s = Uint16Array.BYTES_PER_ELEMENT;
            this._indexBuffer ||
              (this._indexBuffer = t.createBuffer(
                new yu(Tc.INDEX | Tc.TRANSFER_DST, vc.DEVICE, s, s)
              )),
              (this._iaInfo = new Fu(this._vertexFormat, i, this._indexBuffer)),
              (this._iaPool = new Xn(
                () => t.createInputAssembler(this._iaInfo),
                1,
                (t) => {
                  t.destroy();
                }
              ));
          }
        }
        _reallocBuffer(t, e) {
          const i = this.vData;
          (this.vData = new Float32Array(t)), i && this.vData.set(i, 0);
          const s = this.iData;
          (this.iData = new Uint16Array(e)), s && this.iData.set(s, 0);
        }
        setRenderDrawInfoAttributes() {
          this._renderDrawInfo &&
            (this._renderDrawInfo.setVData(this.vData.buffer),
            this._renderDrawInfo.setIData(this.iData.buffer),
            this._renderDrawInfo.setVBCount(this._vc),
            this._renderDrawInfo.setIBCount(this._ic),
            this._renderDrawInfo.setVertexOffset(this.vertexStart),
            this._renderDrawInfo.setIndexOffset(this.indexStart),
            this._renderDrawInfo.setIsMeshBuffer(this._isMeshBuffer),
            this._renderDrawInfo.setMaterial(this.material),
            this.frame &&
              (this._renderDrawInfo.setTexture(this.frame.getGFXTexture()),
              this._renderDrawInfo.setSampler(this.frame.getGFXSampler())));
        }
        particleInitRenderDrawInfo(t) {
          if (t.renderEntityType === tI.STATIC && !this._renderDrawInfo) {
            const e = t.getStaticRenderDrawInfo();
            e && (this._renderDrawInfo = e);
          }
        }
      }
      var _I, dI, pI, mI, fI;
      t("MeshRenderData", uI);
      const gI = new Ss(),
        yI = new Ss(),
        TI = new Yi(),
        SI = new ms(),
        EI = new ms(),
        vI = new ms(),
        bI = new ms(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
        AI = new Ds();
      let CI =
        Ca("cc.UITransform")(
          (_I =
            Ia(110)(
              (_I =
                wa(
                  (((fI = class t extends np {
                    constructor() {
                      super(),
                        (this._priority = 0),
                        (this._contentSize = pI && pI()),
                        (this._anchorPoint = mI && mI());
                    }
                    get contentSize() {
                      return this._contentSize;
                    }
                    set contentSize(t) {
                      this._contentSize.equals(t) ||
                        (this._contentSize.set(t),
                        this.node.emit(bf.SIZE_CHANGED),
                        this._markRenderDataDirty());
                    }
                    get width() {
                      return this._contentSize.width;
                    }
                    set width(t) {
                      this._contentSize.width !== t &&
                        ((this._contentSize.width = t),
                        this.node.emit(bf.SIZE_CHANGED),
                        this._markRenderDataDirty());
                    }
                    get height() {
                      return this._contentSize.height;
                    }
                    set height(t) {
                      this.contentSize.height !== t &&
                        ((this._contentSize.height = t),
                        this.node.emit(bf.SIZE_CHANGED),
                        this._markRenderDataDirty());
                    }
                    get anchorPoint() {
                      return this._anchorPoint;
                    }
                    set anchorPoint(t) {
                      this._anchorPoint.equals(t) ||
                        (this._anchorPoint.set(t),
                        this.node.emit(bf.ANCHOR_CHANGED, this._anchorPoint),
                        this._markRenderDataDirty());
                    }
                    get anchorX() {
                      return this._anchorPoint.x;
                    }
                    set anchorX(t) {
                      this._anchorPoint.x !== t &&
                        ((this._anchorPoint.x = t),
                        this.node.emit(bf.ANCHOR_CHANGED, this._anchorPoint),
                        this._markRenderDataDirty());
                    }
                    get anchorY() {
                      return this._anchorPoint.y;
                    }
                    set anchorY(t) {
                      this._anchorPoint.y !== t &&
                        ((this._anchorPoint.y = t),
                        this.node.emit(bf.ANCHOR_CHANGED, this._anchorPoint),
                        this._markRenderDataDirty());
                    }
                    get priority() {
                      return this._priority;
                    }
                    set priority(e) {
                      this._priority !== e &&
                        (this.node.getComponent("cc.RenderRoot2D")
                          ? z(6706)
                          : ((this._priority = e),
                            this.node.parent &&
                              t.insertChangeMap(this.node.parent)));
                    }
                    get visibility() {
                      const t = Lv.root.batcher2D.getFirstRenderCamera(
                        this.node
                      );
                      return t ? t.visibility : 0;
                    }
                    get cameraPriority() {
                      const t = Lv.root.batcher2D.getFirstRenderCamera(
                        this.node
                      );
                      return t ? t.priority : 0;
                    }
                    __preload() {
                      this.node._uiProps.uiTransformComp = this;
                    }
                    onLoad() {
                      this.node.parent && t.insertChangeMap(this.node.parent);
                    }
                    onEnable() {
                      this.node.on(
                        bf.PARENT_CHANGED,
                        this._parentChanged,
                        this
                      ),
                        this._markRenderDataDirty();
                    }
                    onDisable() {
                      this.node.off(
                        bf.PARENT_CHANGED,
                        this._parentChanged,
                        this
                      );
                    }
                    onDestroy() {
                      this.node._uiProps.uiTransformComp = null;
                    }
                    setContentSize(t, e) {
                      const i = this._contentSize;
                      let s, n;
                      if (void 0 === e) {
                        if (
                          Ti((t = t).width, i.width, gi) &&
                          Ti(t.height, i.height, gi)
                        )
                          return;
                        (s = t.width), (n = t.height);
                      } else {
                        if (Ti((t = t), i.width, gi) && Ti(e, i.height, gi))
                          return;
                        (s = t), (n = e);
                      }
                      (i.width = s),
                        (i.height = n),
                        this.node.emit(bf.SIZE_CHANGED),
                        this._markRenderDataDirty();
                    }
                    setAnchorPoint(t, e) {
                      const i = this._anchorPoint;
                      if (void 0 === e) {
                        if ((t = t).x === i.x && t.y === i.y) return;
                        (i.x = t.x), (i.y = t.y);
                      } else {
                        if (t === i.x && e === i.y) return;
                        (i.x = t), (i.y = e);
                      }
                      this.node.emit(bf.ANCHOR_CHANGED, this._anchorPoint),
                        this._markRenderDataDirty();
                    }
                    isHit(t) {
                      const e = this._contentSize.width,
                        i = this._contentSize.height,
                        s = gI,
                        n = yI,
                        r = this._getRenderScene().cameras;
                      for (let a = 0; a < r.length; a++) {
                        const o = r[a];
                        if (!(o.visibility & this.node.layer)) continue;
                        o.node.getWorldRT(SI);
                        const h = SI.m12,
                          l = SI.m13,
                          c = this.node.scene.visibleRect.center;
                        if (
                          ((SI.m12 = c.x - (SI.m00 * h + SI.m04 * l)),
                          (SI.m13 = c.y - (SI.m01 * h + SI.m05 * l)),
                          ms.invert(SI, SI),
                          Ss.transformMat4(s, t, SI),
                          this.node.getWorldMatrix(vI),
                          ms.invert(SI, vI),
                          ms.strictEquals(SI, bI))
                        )
                          continue;
                        Ss.transformMat4(n, s, SI),
                          (n.x += this._anchorPoint.x * e),
                          (n.y += this._anchorPoint.y * i);
                        let u = !1;
                        if (
                          (n.x >= 0 &&
                            n.y >= 0 &&
                            n.x <= e &&
                            n.y <= i &&
                            (u = this._maskTest(s)),
                          u)
                        )
                          return !0;
                      }
                      return !1;
                    }
                    hitTest(t, e = 0) {
                      const i = this._contentSize.width,
                        s = this._contentSize.height,
                        n = TI,
                        r = gI,
                        a = yI,
                        o = this._getRenderScene().cameras;
                      for (let h = 0; h < o.length; h++) {
                        const l = o[h];
                        if (
                          !(l.visibility & this.node.layer) ||
                          (l.window && !l.window.swapchain)
                        )
                          continue;
                        if (l.systemWindowId !== e) continue;
                        if (
                          (Yi.set(n, t.x, t.y, 0),
                          l.screenToWorld(n, n),
                          Ss.set(r, n.x, n.y),
                          this.node.getWorldMatrix(vI),
                          ms.invert(SI, vI),
                          ms.strictEquals(SI, bI))
                        )
                          continue;
                        Ss.transformMat4(a, r, SI),
                          (a.x += this._anchorPoint.x * i),
                          (a.y += this._anchorPoint.y * s);
                        let c = !1;
                        if (
                          (a.x >= 0 &&
                            a.y >= 0 &&
                            a.x <= i &&
                            a.y <= s &&
                            (c = this._maskTest(r)),
                          c)
                        )
                          return !0;
                      }
                      return !1;
                    }
                    _maskTest(t) {
                      var e, i;
                      const s =
                        null === (e = this.node) ||
                        void 0 === e ||
                        null === (i = e.eventProcessor) ||
                        void 0 === i
                          ? void 0
                          : i.maskList;
                      if (s) {
                        let e = this.node;
                        const i = s.length;
                        for (let n = 0, r = 0; e && r < i; ++n, e = e.parent) {
                          const i = s[r];
                          if (n === i.index) {
                            if (e !== i.comp.node) {
                              s.length = r;
                              break;
                            }
                            {
                              const e = i.comp;
                              if (e && e._enabled && !e.isHit(t)) return !1;
                              r++;
                            }
                          } else if (n > i.index) {
                            s.length = r;
                            break;
                          }
                        }
                      }
                      return !0;
                    }
                    convertToNodeSpaceAR(t, e) {
                      return (
                        this.node.getWorldMatrix(vI),
                        ms.invert(SI, vI),
                        e || (e = new Yi()),
                        Yi.transformMat4(e, t, SI)
                      );
                    }
                    convertToWorldSpaceAR(t, e) {
                      return (
                        this.node.getWorldMatrix(vI),
                        e || (e = new Yi()),
                        Yi.transformMat4(e, t, vI)
                      );
                    }
                    getBoundingBox() {
                      const t = new Ds();
                      return (
                        this._selfBoundingBox(t),
                        ms.fromSRT(
                          EI,
                          this.node.rotation,
                          this.node.position,
                          this.node.scale
                        ),
                        t.transformMat4(EI),
                        t
                      );
                    }
                    getBoundingBoxToWorld() {
                      const e = new Ds(),
                        i = this.node.children;
                      for (let s = 0; s < i.length; ++s) {
                        const n = i[s];
                        if (n && n.active) {
                          const i = n.getComponent(t);
                          i &&
                            i.contentSize.width &&
                            i.contentSize.height &&
                            (i._selfBoundingBox(AI),
                            AI.transformMat4(n.worldMatrix),
                            0 === e.width ? e.set(AI) : Ds.union(e, e, AI));
                        }
                      }
                      return (
                        this._contentSize.width &&
                          this._contentSize.height &&
                          (this._selfBoundingBox(AI),
                          AI.transformMat4(this.node.worldMatrix),
                          0 === e.width ? e.set(AI) : Ds.union(e, e, AI)),
                        e
                      );
                    }
                    getBoundingBoxTo(e) {
                      const i = new Ds(),
                        s = this.node.children;
                      ms.invert(SI, e);
                      for (let e = 0; e < s.length; ++e) {
                        const n = s[e];
                        if (n && n.active) {
                          const e = n.getComponent(t);
                          e &&
                            e.contentSize.width &&
                            e.contentSize.height &&
                            (e._selfBoundingBox(AI),
                            ms.multiply(EI, n.worldMatrix, SI),
                            AI.transformMat4(EI),
                            0 === i.width ? i.set(AI) : Ds.union(i, i, AI));
                        }
                      }
                      return (
                        this._contentSize.width &&
                          this._contentSize.height &&
                          (this._selfBoundingBox(AI),
                          ms.multiply(EI, this.node.worldMatrix, SI),
                          AI.transformMat4(EI),
                          0 === i.width ? i.set(AI) : Ds.union(i, i, AI)),
                        i
                      );
                    }
                    getComputeAABB(t) {
                      const e = this._contentSize.width,
                        i = this._contentSize.height;
                      AI.set(
                        -this._anchorPoint.x * e,
                        -this._anchorPoint.y * i,
                        e,
                        i
                      ),
                        AI.transformMat4(this.node.worldMatrix);
                      const s = AI.x + 0.5 * AI.width,
                        n = AI.y + 0.5 * AI.height,
                        r = this.node.worldPosition.z,
                        a = AI.width / 2,
                        o = AI.height / 2;
                      return null != t
                        ? (Kr.set(t, s, n, r, a, o, 0.001), t)
                        : new Kr(s, n, r, a, o, 0.001);
                    }
                    _selfBoundingBox(t) {
                      const e = this._contentSize.width,
                        i = this._contentSize.height;
                      return (
                        t.set(
                          -this._anchorPoint.x * e,
                          -this._anchorPoint.y * i,
                          e,
                          i
                        ),
                        t
                      );
                    }
                    _parentChanged(e) {
                      this.node.getComponent("cc.RenderRoot2D") ||
                        (this.node.parent &&
                          t.insertChangeMap(this.node.parent));
                    }
                    _markRenderDataDirty() {
                      const t = this.node._uiProps.uiComp;
                      t && t.markForUpdateRenderData();
                    }
                    static insertChangeMap(e) {
                      const i = e.uuid;
                      t.priorityChangeNodeMap.has(i) ||
                        t.priorityChangeNodeMap.set(i, e);
                    }
                    static _sortChildrenSibling(t) {
                      const e = t.children;
                      e &&
                        e.sort((t, e) => {
                          const i = t._uiProps.uiTransformComp,
                            s = e._uiProps.uiTransformComp,
                            n = (i ? i._priority : 0) - (s ? s._priority : 0);
                          return 0 === n
                            ? t.getSiblingIndex() - e.getSiblingIndex()
                            : n;
                        });
                    }
                    static _sortSiblings() {
                      t.priorityChangeNodeMap.forEach((e) => {
                        t._sortChildrenSibling(e),
                          e._updateSiblingIndex(),
                          e.emit("childrenSiblingOrderChanged");
                      }),
                        t.priorityChangeNodeMap.clear();
                    }
                    static _cleanChangeMap() {
                      t.priorityChangeNodeMap.clear();
                    }
                  }).EventType = bf),
                  (fI.priorityChangeNodeMap = new Map()),
                  (pI = fa(
                    (dI = fI).prototype,
                    "_contentSize",
                    [Na],
                    function () {
                      return new ws(100, 100);
                    }
                  )),
                  (mI = fa(dI.prototype, "_anchorPoint", [Na], function () {
                    return new Ss(0.5, 0.5);
                  })),
                  (_I = dI))
                ) || _I)
            ) || _I)
        ) || _I;
      t({ UITransform: CI, UITransformComponent: CI }),
        Lv.on(Nv.EVENT_AFTER_UPDATE, CI._sortSiblings),
        Lv.on(Nv.EVENT_BEFORE_SCENE_LAUNCH, CI._cleanChangeMap);
      const OI = jsb.MaterialInstance,
        II = jsb.MaterialInstance.prototype;
      var wI, RI, DI, xI, MI, PI;
      Object.defineProperty(II, "parent", {
        configurable: !0,
        enumerable: !0,
        get() {
          return this._parent;
        },
      }),
        Object.defineProperty(II, "owner", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this._owner;
          },
        }),
        (II._ctor = function (t) {
          jsb.Material.prototype._ctor.apply(this, arguments),
            this._registerListeners(),
            (this._parent = t.parent),
            (this._owner = t.owner || null),
            (this._subModelIdx = t.subModelIdx || 0),
            (this._passes = this.getPasses());
        }),
        (II._onRebuildPSO = function () {
          this._owner && this._owner._onRebuildPSO(this._subModelIdx, this);
        });
      const NI = { parent: null, owner: null, subModelIdx: 0 },
        {
          ccclass: LI,
          serializable: BI,
          disallowMultiple: FI,
          type: UI,
          displayOrder: kI,
          displayName: zI,
        } = go;
      let HI = t(
        "Renderer",
        ((wI = LI("cc.Renderer")),
        (RI = UI(ey)),
        (DI = UI([ey])),
        wI(
          (xI =
            FI(
              (s(
                (MI = class extends np {
                  constructor() {
                    super(),
                      (this._materials = PI && PI()),
                      (this._materialInstances = []);
                  }
                  get sharedMaterial() {
                    return this.getSharedMaterial(0);
                  }
                  get sharedMaterials() {
                    return this._materials;
                  }
                  set sharedMaterials(t) {
                    for (let e = 0; e < t.length; e++)
                      t[e] !== this._materials[e] &&
                        this.setSharedMaterial(t[e], e);
                    if (t.length < this._materials.length) {
                      for (let e = t.length; e < this._materials.length; e++)
                        this.setSharedMaterial(null, e);
                      this._materials.splice(t.length);
                    }
                  }
                  get material() {
                    return this.getMaterialInstance(0);
                  }
                  set material(t) {
                    (1 !== this._materials.length ||
                      this._materialInstances[0] ||
                      this._materials[0] !== t) &&
                      this.setMaterialInstance(t, 0);
                  }
                  get materials() {
                    for (let t = 0; t < this._materials.length; t++)
                      this._materialInstances[t] = this.getMaterialInstance(t);
                    return this._materialInstances;
                  }
                  set materials(t) {
                    const e = t.length,
                      i = this._materials.length;
                    for (let t = e; t < i; t++)
                      this.setMaterialInstance(null, t);
                    (this._materials.length = e),
                      (this._materialInstances.length = e);
                    for (let i = 0; i < e; i++)
                      this._materialInstances[i] != t[i] &&
                        this.setMaterialInstance(t[i], i);
                  }
                  getMaterial(t) {
                    return this.getSharedMaterial(t);
                  }
                  setMaterial(t, e) {
                    this.setSharedMaterial(t, e);
                  }
                  getSharedMaterial(t) {
                    return t < 0 || t >= this._materials.length
                      ? null
                      : this._materials[t];
                  }
                  setSharedMaterial(t, e) {
                    t && t instanceof OI && G(12012), (this._materials[e] = t);
                    const i = this._materialInstances[e];
                    i && (i.destroy(), (this._materialInstances[e] = null)),
                      this._onMaterialModified(e, this._materials[e]);
                  }
                  getMaterialInstance(t) {
                    if (!this._materials[t]) return null;
                    if (!this._materialInstances[t]) {
                      (NI.parent = this._materials[t]),
                        (NI.owner = this),
                        (NI.subModelIdx = t);
                      const e = new OI(NI);
                      (NI.parent = null),
                        (NI.owner = null),
                        (NI.subModelIdx = 0),
                        this.setMaterialInstance(e, t);
                    }
                    return this._materialInstances[t];
                  }
                  setMaterialInstance(t, e) {
                    if ("number" == typeof t) {
                      z(12007);
                      const i = t;
                      (t = e), (e = i);
                    }
                    const i = this._materialInstances[e];
                    t && t.parent
                      ? t !== i &&
                        ((this._materialInstances[e] = t),
                        this._onMaterialModified(e, t))
                      : (t !== this._materials[e] || i) &&
                        this.setSharedMaterial(t, e);
                  }
                  getRenderMaterial(t) {
                    return this._materialInstances[t] || this._materials[t];
                  }
                  _onMaterialModified(t, e) {}
                  _onRebuildPSO(t, e) {}
                  _clearMaterials() {}
                }).prototype,
                "sharedMaterials",
                [RI],
                Object.getOwnPropertyDescriptor(
                  MI.prototype,
                  "sharedMaterials"
                ),
                MI.prototype
              ),
              (PI = fa(MI.prototype, "_materials", [DI], function () {
                return [];
              })),
              (xI = MI))
            ) || xI)
        ) || xI)
      );
      var GI, VI, jI, WI, XI, YI, KI, qI, $I, ZI, QI, JI;
      let tw;
      de(Pc),
        de(Nc),
        de(Lc),
        t("InstanceMaterialType", tw),
        (function (t) {
          (t[(t.ADD_COLOR = 0)] = "ADD_COLOR"),
            (t[(t.ADD_COLOR_AND_TEXTURE = 1)] = "ADD_COLOR_AND_TEXTURE"),
            (t[(t.GRAYSCALE = 2)] = "GRAYSCALE"),
            (t[(t.USE_ALPHA_SEPARATED = 3)] = "USE_ALPHA_SEPARATED"),
            (t[(t.USE_ALPHA_SEPARATED_AND_GRAY = 4)] =
              "USE_ALPHA_SEPARATED_AND_GRAY");
        })(tw || t("InstanceMaterialType", (tw = {})));
      let ew =
        ((GI = Ca("cc.UIRenderer")),
        (VI = Oa(CI)),
        (jI = ao(ey)),
        (WI = ao(ey)),
        GI(
          (XI =
            VI(
              (((JI = class t extends HI {
                constructor() {
                  super(),
                    (this._renderData = null),
                    (this._materials = KI && KI()),
                    (this._customMaterial = qI && qI()),
                    (this._srcBlendFactor = $I && $I()),
                    (this._dstBlendFactor = ZI && ZI()),
                    (this._color = QI && QI()),
                    (this._stencilStage = QO.DISABLED),
                    (this._assembler = null),
                    (this._postAssembler = null),
                    (this._renderDataFlag = !0),
                    (this._renderFlag = !0),
                    (this._instanceMaterialType = -1),
                    (this._srcBlendFactorCache = Pc.SRC_ALPHA),
                    (this._dstBlendFactorCache = Pc.ONE_MINUS_SRC_ALPHA),
                    (this._dirtyVersion = -1),
                    (this._internalId = -1),
                    (this._flagChangedVersion = -1),
                    (this._useVertexOpacity = !1),
                    (this._lastParent = null),
                    (this._renderEntity = this.createRenderEntity());
                }
                get sharedMaterials() {
                  return this._materials;
                }
                set sharedMaterials(t) {
                  for (let e = 0; e < t.length; e++)
                    t[e] !== this._materials[e] &&
                      this.setSharedMaterial(t[e], e);
                  if (t.length < this._materials.length) {
                    for (let e = t.length; e < this._materials.length; e++)
                      this.setSharedMaterial(null, e);
                    this._materials.splice(t.length);
                  }
                }
                get customMaterial() {
                  return this._customMaterial;
                }
                set customMaterial(t) {
                  (this._customMaterial = t), this.updateMaterial();
                }
                get color() {
                  return this._color;
                }
                set color(t) {
                  this._color.equals(t) ||
                    (this._color.set(t), this._updateColor());
                }
                get renderData() {
                  return this._renderData;
                }
                setRenderData(t) {
                  this._renderData = t;
                }
                get useVertexOpacity() {
                  return this._useVertexOpacity;
                }
                get stencilStage() {
                  return this._stencilStage;
                }
                set stencilStage(t) {
                  (this._stencilStage = t),
                    this._renderEntity.setStencilStage(t);
                }
                get srcBlendFactor() {
                  return this._srcBlendFactor;
                }
                set srcBlendFactor(t) {
                  this._srcBlendFactor = t;
                }
                get batcher() {
                  return Lv.root.batcher2D;
                }
                get renderEntity() {
                  return this._renderEntity;
                }
                onLoad() {
                  this._renderEntity.setNode(this.node);
                }
                __preload() {
                  (this.node._uiProps.uiComp = this),
                    this._flushAssembler && this._flushAssembler();
                }
                onEnable() {
                  this.node.on(bf.ANCHOR_CHANGED, this._nodeStateChange, this),
                    this.node.on(bf.SIZE_CHANGED, this._nodeStateChange, this),
                    this.node.on(bf.PARENT_CHANGED, this._colorDirty, this),
                    this.updateMaterial(),
                    this._colorDirty(),
                    iE.addRenderer(this),
                    this.markForUpdateRenderData();
                }
                onRestore() {
                  this.updateMaterial(), this.markForUpdateRenderData();
                }
                onDisable() {
                  this.node.off(bf.ANCHOR_CHANGED, this._nodeStateChange, this),
                    this.node.off(bf.SIZE_CHANGED, this._nodeStateChange, this),
                    this.node.off(bf.PARENT_CHANGED, this._colorDirty, this),
                    iE.removeRenderer(this),
                    (this._renderFlag = !1),
                    (this._renderEntity.enabled = !1);
                }
                onDestroy() {
                  if (
                    (this._renderEntity.setNode(null),
                    this.node._uiProps.uiComp === this &&
                      (this.node._uiProps.uiComp = null),
                    this.destroyRenderData(),
                    this._materialInstances)
                  )
                    for (let t = 0; t < this._materialInstances.length; t++) {
                      const e = this._materialInstances[t];
                      e && e.destroy();
                    }
                }
                markForUpdateRenderData(t = !0) {
                  if (t) {
                    const t = this._renderData;
                    t && (t.vertDirty = !0), iE.markDirtyRenderer(this);
                  }
                }
                requestRenderData(t = ZO.COMP) {
                  const e = cI.add();
                  return (
                    e.initRenderDrawInfo(this, t), (this._renderData = e), e
                  );
                }
                destroyRenderData() {
                  this._renderData &&
                    (this._renderData.removeRenderDrawInfo(this),
                    cI.remove(this._renderData),
                    (this._renderData = null));
                }
                updateRenderer() {
                  this._assembler && this._assembler.updateRenderData(this),
                    (this._renderFlag = this._canRender()),
                    (this._renderEntity.enabled = this._renderFlag);
                }
                fillBuffers(t) {
                  this._renderFlag && this._render(t);
                }
                postUpdateAssembler(t) {
                  this._postAssembler &&
                    this._renderFlag &&
                    this._postRender(t);
                }
                _render(t) {}
                _postRender(t) {}
                _canRender() {
                  return (
                    null !== this.getSharedMaterial(0) &&
                    this._enabled &&
                    this._color.a > 0
                  );
                }
                _postCanRender() {}
                updateMaterial() {
                  if (this._customMaterial)
                    return void (
                      this.getSharedMaterial(0) !== this._customMaterial &&
                      this.setSharedMaterial(this._customMaterial, 0)
                    );
                  const t = this._updateBuiltinMaterial();
                  this.setSharedMaterial(t, 0),
                    (this.stencilStage !== QO.ENTER_LEVEL &&
                      this.stencilStage !== QO.ENTER_LEVEL_INVERTED) ||
                      this.getMaterialInstance(0).recompileShaders({
                        USE_ALPHA_TEST: !0,
                      }),
                    this._updateBlendFunc();
                }
                _updateColor() {
                  if (
                    ((this.node._uiProps.colorDirty = !0),
                    this.setEntityColorDirty(!0),
                    this.setEntityColor(this._color),
                    this.setEntityOpacity(this.node._uiProps.localOpacity),
                    this._assembler)
                  ) {
                    this._assembler.updateColor(this);
                    const t = this._renderFlag;
                    if (
                      ((this._renderFlag = this._canRender()),
                      this.setEntityEnabled(this._renderFlag),
                      t !== this._renderFlag)
                    ) {
                      const t = this.renderData;
                      t && (t.vertDirty = !0);
                    }
                  }
                }
                static setEntityColorDirtyRecursively(e, i) {
                  const s = e._uiProps.uiComp;
                  s && s.color && (s._renderEntity.colorDirty = i);
                  for (let s = 0; s < e.children.length; s++)
                    t.setEntityColorDirtyRecursively(e.children[s], i);
                }
                setEntityColorDirty(e) {
                  t.setEntityColorDirtyRecursively(this.node, e);
                }
                setEntityColor(t) {
                  this._renderEntity.color = t;
                }
                setEntityOpacity(t) {
                  this._renderEntity.localOpacity = t;
                }
                setEntityEnabled(t) {
                  this._renderEntity.enabled = t;
                }
                _updateBlendFunc() {
                  let t =
                    this.getRenderMaterial(0).passes[0].blendState.targets[0];
                  if (
                    ((this._dstBlendFactorCache = t.blendDst),
                    (this._srcBlendFactorCache = t.blendSrc),
                    this._dstBlendFactorCache !== this._dstBlendFactor ||
                      this._srcBlendFactorCache !== this._srcBlendFactor)
                  ) {
                    (t =
                      this.getMaterialInstance(0).passes[0].blendState
                        .targets[0]),
                      (t.blend = !0),
                      (t.blendDstAlpha = Pc.ONE_MINUS_SRC_ALPHA),
                      (t.blendDst = this._dstBlendFactor),
                      (t.blendSrc = this._srcBlendFactor);
                    const e = this.getMaterialInstance(0).passes[0];
                    e.blendState.setTarget(0, t),
                      e._updatePassHash(),
                      (this._dstBlendFactorCache = this._dstBlendFactor),
                      (this._srcBlendFactorCache = this._srcBlendFactor);
                  }
                }
                _nodeStateChange(e) {
                  this._renderData && this.markForUpdateRenderData();
                  for (let e = 0; e < this.node.children.length; ++e) {
                    const i = this.node.children[e].getComponent(t);
                    i && i.markForUpdateRenderData();
                  }
                }
                _colorDirty() {
                  (this.node._uiProps.colorDirty = !0),
                    this.setEntityColorDirty(!0);
                }
                _onMaterialModified(t, e) {
                  this._renderData &&
                    (this.markForUpdateRenderData(),
                    (this._renderData.passDirty = !0)),
                    super._onMaterialModified(t, e);
                }
                _updateBuiltinMaterial() {
                  let t;
                  switch (this._instanceMaterialType) {
                    case tw.ADD_COLOR:
                      t = Pv.get("ui-base-material");
                      break;
                    case tw.GRAYSCALE:
                      t = Pv.get("ui-sprite-gray-material");
                      break;
                    case tw.USE_ALPHA_SEPARATED:
                      t = Pv.get("ui-sprite-alpha-sep-material");
                      break;
                    case tw.USE_ALPHA_SEPARATED_AND_GRAY:
                      t = Pv.get("ui-sprite-gray-alpha-sep-material");
                      break;
                    default:
                      t = Pv.get("ui-sprite-material");
                  }
                  return t;
                }
                setNodeDirty() {
                  this._renderData && (this._renderData.nodeDirty = !0);
                }
                setTextureDirty() {
                  this._renderData && (this._renderData.textureDirty = !0);
                }
                createRenderEntity() {
                  return new oI(tI.STATIC);
                }
              }).BlendState = Pc),
              (JI.Assembler = null),
              (JI.PostAssembler = null),
              s(
                (YI = JI).prototype,
                "sharedMaterials",
                [oo],
                Object.getOwnPropertyDescriptor(
                  YI.prototype,
                  "sharedMaterials"
                ),
                YI.prototype
              ),
              s(
                YI.prototype,
                "customMaterial",
                [jI],
                Object.getOwnPropertyDescriptor(YI.prototype, "customMaterial"),
                YI.prototype
              ),
              (KI = fa(YI.prototype, "_materials", [oo], function () {
                return [];
              })),
              (qI = fa(YI.prototype, "_customMaterial", [WI], function () {
                return null;
              })),
              ($I = fa(YI.prototype, "_srcBlendFactor", [Na], function () {
                return Pc.SRC_ALPHA;
              })),
              (ZI = fa(YI.prototype, "_dstBlendFactor", [Na], function () {
                return Pc.ONE_MINUS_SRC_ALPHA;
              })),
              (QI = fa(YI.prototype, "_color", [Na], function () {
                return Qi.WHITE.clone();
              })),
              (XI = YI))
            ) || XI)
        ) || XI);
      t({
        UIRenderer: ew,
        RenderComponent: ew,
        UIRenderable: ew,
        Renderable2D: ew,
      }),
        (a.internal.UIRenderer = ew);
      class iw {
        constructor() {
          (this.isBold = !1),
            (this.isItalic = !1),
            (this.isUnderline = !1),
            (this.underlineHeight = 1),
            (this.isOutlined = !1),
            (this.outlineColor = Qi.WHITE.clone()),
            (this.outlineWidth = 1),
            (this.hasShadow = !1),
            (this.shadowColor = Qi.BLACK.clone()),
            (this.shadowBlur = 2),
            (this.shadowOffsetX = 0),
            (this.shadowOffsetY = 0),
            (this.color = Qi.WHITE.clone()),
            (this.fontSize = 40),
            (this.actualFontSize = 0),
            (this.isSystemFontUsed = !1),
            (this.originFontSize = 0),
            (this.bmfontScale = 1),
            (this.fontFamily = "Arial"),
            (this.fontDesc = ""),
            (this.fntConfig = null),
            (this.spriteFrame = null),
            (this.fontScale = 1);
        }
        reset() {
          (this.isBold = !1),
            (this.isItalic = !1),
            (this.isUnderline = !1),
            (this.underlineHeight = 1),
            (this.isOutlined = !1),
            this.outlineColor.set(),
            (this.outlineWidth = 1),
            (this.hasShadow = !1),
            this.shadowColor.set(),
            (this.shadowBlur = 2),
            (this.shadowOffsetX = 0),
            (this.shadowOffsetY = 0);
        }
      }
      class sw {
        constructor() {
          (this.horizontalAlign = 0),
            (this.verticalAlign = 0),
            (this.wrapping = !0),
            (this.overFlow = 0),
            (this.lineHeight = 10),
            (this.maxLineWidth = 0),
            (this.spacingX = 0),
            (this.textWidthTemp = 0),
            (this.textHeightTemp = 0),
            (this.textDimensions = new ws()),
            (this.horizontalKerning = []),
            (this.numberOfLines = 1),
            (this.linesOffsetX = []),
            (this.letterOffsetY = 0),
            (this.tailoredTopY = 0),
            (this.tailoredBottomY = 0),
            (this.textDesiredHeight = 0),
            (this.linesWidth = []);
        }
        reset() {
          (this.horizontalAlign = 0),
            (this.verticalAlign = 0),
            (this.wrapping = !0),
            (this.overFlow = 0),
            (this.lineHeight = 10),
            (this.maxLineWidth = 0),
            (this.spacingX = 0),
            (this.textWidthTemp = 0),
            (this.textHeightTemp = 0),
            this.textDimensions.set(),
            (this.horizontalKerning.length = 0),
            (this.numberOfLines = 1),
            (this.linesOffsetX.length = 0),
            (this.letterOffsetY = 0),
            (this.tailoredTopY = 0),
            (this.tailoredBottomY = 0),
            (this.textDesiredHeight = 0),
            (this.linesWidth.length = 0);
        }
      }
      class nw {
        constructor() {
          (this.parsedString = []),
            (this.nodeContentSize = ws.ZERO.clone()),
            (this.canvasSize = new ws()),
            (this.canvasPadding = new Ds()),
            (this.contentSizeExtend = ws.ZERO.clone()),
            (this.startPosition = Ss.ZERO.clone());
        }
        reset() {
          (this.parsedString.length = 0),
            this.nodeContentSize.set(0, 0),
            this.canvasSize.set(),
            this.canvasPadding.set(),
            this.contentSizeExtend.set(),
            this.startPosition.set();
        }
      }
      class rw {
        constructor() {
          (this.quadCount = 0),
            (this.vertexBuffer = []),
            (this.texture = null),
            (this.uiTransAnchorX = 0.5),
            (this.uiTransAnchorY = 0.5);
        }
        reset() {
          (this.quadCount = 0),
            (this.vertexBuffer.length = 0),
            (this.texture = null),
            (this.uiTransAnchorX = 0.5),
            (this.uiTransAnchorY = 0.5);
        }
      }
      var aw,
        ow,
        hw,
        lw,
        cw,
        uw,
        _w,
        dw,
        pw,
        mw,
        fw,
        gw,
        yw,
        Tw,
        Sw,
        Ew,
        vw,
        bw,
        Aw,
        Cw,
        Ow,
        Iw,
        ww,
        Rw,
        Dw,
        xw,
        Mw,
        Pw,
        Nw,
        Lw,
        Bw,
        Fw,
        Uw,
        kw;
      const zw = Qi.WHITE.clone();
      let Hw, Gw, Vw, jw;
      t("HorizontalTextAlignment", Hw),
        (function (t) {
          (t[(t.LEFT = 0)] = "LEFT"),
            (t[(t.CENTER = 1)] = "CENTER"),
            (t[(t.RIGHT = 2)] = "RIGHT");
        })(Hw || t("HorizontalTextAlignment", (Hw = {}))),
        de(Hw),
        t("VerticalTextAlignment", Gw),
        (function (t) {
          (t[(t.TOP = 0)] = "TOP"),
            (t[(t.CENTER = 1)] = "CENTER"),
            (t[(t.BOTTOM = 2)] = "BOTTOM");
        })(Gw || t("VerticalTextAlignment", (Gw = {}))),
        de(Gw),
        t("Overflow", Vw),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.CLAMP = 1)] = "CLAMP"),
            (t[(t.SHRINK = 2)] = "SHRINK"),
            (t[(t.RESIZE_HEIGHT = 3)] = "RESIZE_HEIGHT");
        })(Vw || t("Overflow", (Vw = {}))),
        de(Vw),
        t("CacheMode", jw),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.BITMAP = 1)] = "BITMAP"),
            (t[(t.CHAR = 2)] = "CHAR");
        })(jw || t("CacheMode", (jw = {}))),
        de(jw);
      let Ww =
        ((aw = Ca("cc.Label")),
        (ow = Ia(110)),
        (hw = ao(Hw)),
        (lw = ao(Gw)),
        (cw = ao(Vw)),
        (uw = ao(bC)),
        (_w = ao(jw)),
        aw(
          (dw =
            ow(
              (((kw = class t extends ew {
                get string() {
                  return this._string;
                }
                set string(t) {
                  (t = null == t ? "" : t.toString()),
                    this._string !== t &&
                      ((this._string = t), this.markForUpdateRenderData());
                }
                get horizontalAlign() {
                  return this._horizontalAlign;
                }
                set horizontalAlign(t) {
                  this._horizontalAlign !== t &&
                    ((this._horizontalAlign = t),
                    this.markForUpdateRenderData());
                }
                get verticalAlign() {
                  return this._verticalAlign;
                }
                set verticalAlign(t) {
                  this._verticalAlign !== t &&
                    ((this._verticalAlign = t), this.markForUpdateRenderData());
                }
                get actualFontSize() {
                  return this._actualFontSize;
                }
                set actualFontSize(t) {
                  this._actualFontSize = t;
                }
                get fontSize() {
                  return this._fontSize;
                }
                set fontSize(t) {
                  this._fontSize !== t &&
                    ((this._fontSize = t), this.markForUpdateRenderData());
                }
                get lineHeight() {
                  return this._lineHeight;
                }
                set lineHeight(t) {
                  this._lineHeight !== t &&
                    ((this._lineHeight = t), this.markForUpdateRenderData());
                }
                get spacingX() {
                  return this._spacingX;
                }
                set spacingX(t) {
                  this._spacingX !== t &&
                    ((this._spacingX = t), this.markForUpdateRenderData());
                }
                get overflow() {
                  return this._overflow;
                }
                set overflow(t) {
                  this._overflow !== t &&
                    ((this._overflow = t), this.markForUpdateRenderData());
                }
                get enableWrapText() {
                  return this._enableWrapText;
                }
                set enableWrapText(t) {
                  this._enableWrapText !== t &&
                    ((this._enableWrapText = t),
                    this.markForUpdateRenderData());
                }
                get useSystemFont() {
                  return this._isSystemFontUsed;
                }
                set useSystemFont(t) {
                  this._isSystemFontUsed !== t &&
                    (this.destroyRenderData(),
                    (this._isSystemFontUsed = !!t),
                    t && (this.font = null),
                    this._flushAssembler(),
                    this.markForUpdateRenderData());
                }
                get fontFamily() {
                  return this._fontFamily;
                }
                set fontFamily(t) {
                  this._fontFamily !== t &&
                    ((this._fontFamily = t), this.markForUpdateRenderData());
                }
                get font() {
                  return this._font;
                }
                set font(t) {
                  this._font !== t &&
                    ((this._isSystemFontUsed = !t),
                    (this._font = t),
                    this.destroyRenderData(),
                    (this._fontAtlas = null),
                    this.updateRenderData(!0));
                }
                get cacheMode() {
                  return this._cacheMode;
                }
                set cacheMode(t) {
                  this._cacheMode !== t &&
                    (this._cacheMode !== jw.BITMAP ||
                      this._font instanceof SO ||
                      !this._ttfSpriteFrame ||
                      this._ttfSpriteFrame._resetDynamicAtlasFrame(),
                    this._cacheMode === jw.CHAR &&
                      (this._ttfSpriteFrame = null),
                    (this._cacheMode = t),
                    this.updateRenderData(!0));
                }
                get isBold() {
                  return this._isBold;
                }
                set isBold(t) {
                  this._isBold !== t &&
                    ((this._isBold = t), this.markForUpdateRenderData());
                }
                get isItalic() {
                  return this._isItalic;
                }
                set isItalic(t) {
                  this._isItalic !== t &&
                    ((this._isItalic = t), this.markForUpdateRenderData());
                }
                get isUnderline() {
                  return this._isUnderline;
                }
                set isUnderline(t) {
                  this._isUnderline !== t &&
                    ((this._isUnderline = t), this.markForUpdateRenderData());
                }
                get underlineHeight() {
                  return this._underlineHeight;
                }
                set underlineHeight(t) {
                  this._underlineHeight !== t &&
                    ((this._underlineHeight = t),
                    this.markForUpdateRenderData());
                }
                get enableOutline() {
                  return this._enableOutline;
                }
                set enableOutline(t) {
                  this._enableOutline !== t &&
                    ((this._enableOutline = t), this.markForUpdateRenderData());
                }
                get outlineColor() {
                  return this._outlineColor;
                }
                set outlineColor(t) {
                  this._outlineColor !== t &&
                    (this._outlineColor.set(t), this.markForUpdateRenderData());
                }
                get outlineWidth() {
                  return this._outlineWidth;
                }
                set outlineWidth(t) {
                  this._outlineWidth !== t &&
                    ((this._outlineWidth = t), this.markForUpdateRenderData());
                }
                get enableShadow() {
                  return this._enableShadow;
                }
                set enableShadow(t) {
                  this._enableShadow !== t &&
                    ((this._enableShadow = t), this.markForUpdateRenderData());
                }
                get shadowColor() {
                  return this._shadowColor;
                }
                set shadowColor(t) {
                  this._shadowColor !== t &&
                    (this._shadowColor.set(t), this.markForUpdateRenderData());
                }
                get shadowOffset() {
                  return this._shadowOffset;
                }
                set shadowOffset(t) {
                  this._shadowOffset !== t &&
                    (this._shadowOffset.set(t), this.markForUpdateRenderData());
                }
                get shadowBlur() {
                  return this._shadowBlur;
                }
                set shadowBlur(t) {
                  this._shadowBlur !== t &&
                    ((this._shadowBlur = t), this.markForUpdateRenderData());
                }
                get spriteFrame() {
                  return this._texture;
                }
                get ttfSpriteFrame() {
                  return this._ttfSpriteFrame;
                }
                get assemblerData() {
                  return this._assemblerData;
                }
                get fontAtlas() {
                  return this._fontAtlas;
                }
                set fontAtlas(t) {
                  this._fontAtlas = t;
                }
                get _bmFontOriginalSize() {
                  return this._font instanceof SO ? this._font.fontSize : -1;
                }
                get textStyle() {
                  return this._textStyle;
                }
                get textLayout() {
                  return this._textLayout;
                }
                get textRenderData() {
                  return this._textRenderData;
                }
                get textLayoutData() {
                  return this._textLayoutData;
                }
                get contentWidth() {
                  return this._contentWidth;
                }
                set contentWidth(t) {
                  this._contentWidth = t;
                }
                constructor() {
                  super(),
                    (this._string = mw && mw()),
                    (this._horizontalAlign = fw && fw()),
                    (this._verticalAlign = gw && gw()),
                    (this._actualFontSize = yw && yw()),
                    (this._fontSize = Tw && Tw()),
                    (this._fontFamily = Sw && Sw()),
                    (this._lineHeight = Ew && Ew()),
                    (this._overflow = vw && vw()),
                    (this._enableWrapText = bw && bw()),
                    (this._font = Aw && Aw()),
                    (this._isSystemFontUsed = Cw && Cw()),
                    (this._spacingX = Ow && Ow()),
                    (this._isItalic = Iw && Iw()),
                    (this._isBold = ww && ww()),
                    (this._isUnderline = Rw && Rw()),
                    (this._underlineHeight = Dw && Dw()),
                    (this._cacheMode = xw && xw()),
                    (this._enableOutline = Mw && Mw()),
                    (this._outlineColor = Pw && Pw()),
                    (this._outlineWidth = Nw && Nw()),
                    (this._enableShadow = Lw && Lw()),
                    (this._shadowColor = Bw && Bw()),
                    (this._shadowOffset = Fw && Fw()),
                    (this._shadowBlur = Uw && Uw()),
                    (this._N$file = null),
                    (this._texture = null),
                    (this._ttfSpriteFrame = null),
                    (this._userDefinedFont = null),
                    (this._assemblerData = null),
                    (this._fontAtlas = null),
                    (this._letterTexture = null),
                    (this._contentWidth = 0),
                    (this._textStyle = null),
                    (this._textLayout = null),
                    (this._textRenderData = null),
                    (this._textLayoutData = null),
                    (this._ttfSpriteFrame = null),
                    (this._textStyle = new iw()),
                    (this._textLayout = new sw()),
                    (this._textLayoutData = new nw()),
                    (this._textRenderData = new rw());
                }
                onEnable() {
                  super.onEnable(),
                    this._font ||
                      this._isSystemFontUsed ||
                      (this.useSystemFont = !0),
                    this._isSystemFontUsed &&
                      !this._fontFamily &&
                      (this.fontFamily = "Arial"),
                    this._applyFontTexture();
                }
                destroyTtfSpriteFrame() {
                  if (!this._ttfSpriteFrame) return;
                  this._ttfSpriteFrame._resetDynamicAtlasFrame();
                  const t = this._ttfSpriteFrame.texture;
                  if ((this._ttfSpriteFrame.destroy(), t)) {
                    const e = t;
                    e.image && e.image.destroy(), t.destroy();
                  }
                  this._ttfSpriteFrame = null;
                }
                _onPreDestroy() {
                  super._onPreDestroy(),
                    this._isOnLoadCalled || this.destroyTtfSpriteFrame();
                }
                onDestroy() {
                  this._assembler &&
                    this._assembler.resetAssemblerData &&
                    this._assembler.resetAssemblerData(this._assemblerData),
                    (this._assemblerData = null),
                    this.destroyTtfSpriteFrame(),
                    (this._letterTexture = null),
                    super.onDestroy();
                }
                updateRenderData(t = !1) {
                  t &&
                    (this._flushAssembler(),
                    this.renderData && (this.renderData.vertDirty = !0),
                    this._applyFontTexture()),
                    this._assembler && this._assembler.updateRenderData(this);
                }
                _render(t) {
                  t.commitComp(
                    this,
                    this.renderData,
                    this._texture,
                    this._assembler,
                    null
                  );
                }
                _updateColor() {
                  super._updateColor(), this.markForUpdateRenderData();
                }
                setEntityColor(t) {
                  this._font instanceof SO
                    ? (this._renderEntity.color = t)
                    : (zw.set(255, 255, 255, t.a),
                      (this._renderEntity.color = zw));
                }
                _canRender() {
                  if (!super._canRender() || !this._string) return !1;
                  const t = this._font;
                  if (t && t instanceof SO) {
                    const e = t.spriteFrame;
                    if (!e || !e.texture) return !1;
                  }
                  return !0;
                }
                _flushAssembler() {
                  const e = t.Assembler.getAssembler(this);
                  this._assembler !== e &&
                    (this.destroyRenderData(),
                    (this._assembler = e),
                    this.textStyle.reset(),
                    this.textLayout.reset(),
                    this.textLayoutData.reset(),
                    this.textRenderData.reset()),
                    this.renderData ||
                      (this._assembler &&
                        this._assembler.createData &&
                        ((this._renderData = this._assembler.createData(this)),
                        (this.renderData.material = this.material),
                        this._updateColor()));
                }
                _applyFontTexture() {
                  this.markForUpdateRenderData();
                  const t = this._font;
                  if (t instanceof SO) {
                    const e = t.spriteFrame;
                    e &&
                      e.texture &&
                      ((this._texture = e),
                      this.renderData && (this.renderData.textureDirty = !0),
                      this.changeMaterialForDefine(),
                      this._assembler &&
                        this._assembler.updateRenderData(this));
                  } else {
                    if (this.cacheMode === jw.CHAR)
                      (this._letterTexture =
                        this._assembler.getAssemblerData()),
                        (this._texture = this._letterTexture);
                    else if (!this._ttfSpriteFrame) {
                      (this._ttfSpriteFrame = new uC()),
                        (this._assemblerData =
                          this._assembler.getAssemblerData());
                      const t = new wd(this._assemblerData.canvas),
                        e = new sm();
                      (e.image = t),
                        a.sys.os === a.sys.OS.WINDOWS &&
                          e.setFilters(Id.LINEAR, Id.LINEAR),
                        (this._ttfSpriteFrame.texture = e);
                    }
                    this.cacheMode !== jw.CHAR &&
                      (this._texture = this._ttfSpriteFrame),
                      this.changeMaterialForDefine();
                  }
                }
                changeMaterialForDefine() {
                  if (!this._texture) return;
                  let t = !1;
                  if (this.cacheMode !== jw.CHAR) {
                    const e = this._texture.texture;
                    if (e instanceof Xp) {
                      const i = e.getPixelFormat();
                      t =
                        i === Cd.RGBA_ETC1 ||
                        i === Cd.RGB_A_PVRTC_4BPPV1 ||
                        i === Cd.RGB_A_PVRTC_2BPPV1;
                    }
                  }
                  (this._instanceMaterialType = t
                    ? tw.USE_ALPHA_SEPARATED
                    : tw.ADD_COLOR_AND_TEXTURE),
                    this.updateMaterial();
                }
                _updateBlendFunc() {
                  super._updateBlendFunc();
                }
              }).HorizontalAlign = Hw),
              (kw.VerticalAlign = Gw),
              (kw.Overflow = Vw),
              (kw.CacheMode = jw),
              (kw._canvasPool = AO.getInstance()),
              s(
                (pw = kw).prototype,
                "horizontalAlign",
                [hw],
                Object.getOwnPropertyDescriptor(
                  pw.prototype,
                  "horizontalAlign"
                ),
                pw.prototype
              ),
              s(
                pw.prototype,
                "verticalAlign",
                [lw],
                Object.getOwnPropertyDescriptor(pw.prototype, "verticalAlign"),
                pw.prototype
              ),
              s(
                pw.prototype,
                "overflow",
                [cw],
                Object.getOwnPropertyDescriptor(pw.prototype, "overflow"),
                pw.prototype
              ),
              s(
                pw.prototype,
                "font",
                [uw],
                Object.getOwnPropertyDescriptor(pw.prototype, "font"),
                pw.prototype
              ),
              s(
                pw.prototype,
                "cacheMode",
                [_w],
                Object.getOwnPropertyDescriptor(pw.prototype, "cacheMode"),
                pw.prototype
              ),
              (mw = fa(pw.prototype, "_string", [Na], function () {
                return "label";
              })),
              (fw = fa(pw.prototype, "_horizontalAlign", [Na], function () {
                return Hw.CENTER;
              })),
              (gw = fa(pw.prototype, "_verticalAlign", [Na], function () {
                return Gw.CENTER;
              })),
              (yw = fa(pw.prototype, "_actualFontSize", [Na], function () {
                return 0;
              })),
              (Tw = fa(pw.prototype, "_fontSize", [Na], function () {
                return 40;
              })),
              (Sw = fa(pw.prototype, "_fontFamily", [Na], function () {
                return "Arial";
              })),
              (Ew = fa(pw.prototype, "_lineHeight", [Na], function () {
                return 40;
              })),
              (vw = fa(pw.prototype, "_overflow", [Na], function () {
                return Vw.NONE;
              })),
              (bw = fa(pw.prototype, "_enableWrapText", [Na], function () {
                return !0;
              })),
              (Aw = fa(pw.prototype, "_font", [Na], function () {
                return null;
              })),
              (Cw = fa(pw.prototype, "_isSystemFontUsed", [Na], function () {
                return !0;
              })),
              (Ow = fa(pw.prototype, "_spacingX", [Na], function () {
                return 0;
              })),
              (Iw = fa(pw.prototype, "_isItalic", [Na], function () {
                return !1;
              })),
              (ww = fa(pw.prototype, "_isBold", [Na], function () {
                return !1;
              })),
              (Rw = fa(pw.prototype, "_isUnderline", [Na], function () {
                return !1;
              })),
              (Dw = fa(pw.prototype, "_underlineHeight", [Na], function () {
                return 2;
              })),
              (xw = fa(pw.prototype, "_cacheMode", [Na], function () {
                return jw.NONE;
              })),
              (Mw = fa(pw.prototype, "_enableOutline", [Na], function () {
                return !1;
              })),
              (Pw = fa(pw.prototype, "_outlineColor", [Na], function () {
                return new Qi(0, 0, 0, 255);
              })),
              (Nw = fa(pw.prototype, "_outlineWidth", [Na], function () {
                return 2;
              })),
              (Lw = fa(pw.prototype, "_enableShadow", [Na], function () {
                return !1;
              })),
              (Bw = fa(pw.prototype, "_shadowColor", [Na], function () {
                return new Qi(0, 0, 0, 255);
              })),
              (Fw = fa(pw.prototype, "_shadowOffset", [Na], function () {
                return new Ss(2, 2);
              })),
              (Uw = fa(pw.prototype, "_shadowBlur", [Na], function () {
                return 2;
              })),
              (dw = pw))
            ) || dw)
        ) || dw);
      t({ Label: Ww, LabelComponent: Ww }), (a.Label = Ww);
      let Xw = 0;
      const Yw = {};
      var Kw = {
        addStage(t) {
          if (void 0 !== Yw[t]) return;
          const e = 1 << Xw;
          (Yw[t] = e), (Xw += 1);
        },
        stageID(t) {
          const e = Yw[t];
          return void 0 === e ? -1 : e;
        },
        stageIDs(t) {
          let e = 0;
          for (const i of t) {
            const t = Yw[i];
            void 0 !== t && (e |= t);
          }
          return e;
        },
      };
      let qw, $w;
      !(function (t) {
        (t[(t.OPAQUE = 0)] = "OPAQUE"),
          (t[(t.TRANSPARENT = 1)] = "TRANSPARENT"),
          (t[(t.OVERLAY = 2)] = "OVERLAY");
      })(qw || (qw = {})),
        (function (t) {
          (t[(t.DEFAULT = 1)] = "DEFAULT"),
            (t[(t.FORWARD = 2)] = "FORWARD"),
            (t[(t.SHADOWCAST = 4)] = "SHADOWCAST");
        })($w || ($w = {}));
      const Zw = 4227858432,
        Qw = 66060288,
        Jw = 1044480,
        tR = {
          [yc.UNKNOWN]: (t, e, i = 0) => z(12010, i),
          [yc.INT]: (t, e, i = 0) => t[i],
          [yc.INT2]: (t, e, i = 0) => Ss.fromArray(e, t, i),
          [yc.INT3]: (t, e, i = 0) => Yi.fromArray(e, t, i),
          [yc.INT4]: (t, e, i = 0) => Wi.fromArray(e, t, i),
          [yc.FLOAT]: (t, e, i = 0) => t[i],
          [yc.FLOAT2]: (t, e, i = 0) => Ss.fromArray(e, t, i),
          [yc.FLOAT3]: (t, e, i = 0) => Yi.fromArray(e, t, i),
          [yc.FLOAT4]: (t, e, i = 0) => Wi.fromArray(e, t, i),
          [yc.MAT3]: (t, e, i = 0) => es.fromArray(e, t, i),
          [yc.MAT4]: (t, e, i = 0) => ms.fromArray(e, t, i),
        },
        eR = {
          [yc.UNKNOWN]: (t, e, i = 0) => z(12010, i),
          [yc.INT]: (t, e, i = 0) => (t[i] = e),
          [yc.INT2]: (t, e, i = 0) => Ss.toArray(t, e, i),
          [yc.INT3]: (t, e, i = 0) => Yi.toArray(t, e, i),
          [yc.INT4]: (t, e, i = 0) => Wi.toArray(t, e, i),
          [yc.FLOAT]: (t, e, i = 0) => (t[i] = e),
          [yc.FLOAT2]: (t, e, i = 0) => Ss.toArray(t, e, i),
          [yc.FLOAT3]: (t, e, i = 0) => Yi.toArray(t, e, i),
          [yc.FLOAT4]: (t, e, i = 0) => Wi.toArray(t, e, i),
          [yc.MAT3]: (t, e, i = 0) => es.toArray(t, e, i),
          [yc.MAT4]: (t, e, i = 0) => ms.toArray(t, e, i),
        },
        iR = {
          [yc.INT]: (t) => "number" == typeof t,
          [yc.FLOAT]: (t) => "number" == typeof t,
          [yc.INT2]: (t) => !!(t instanceof Ss),
          [yc.FLOAT2]: (t) => !!(t instanceof Ss),
          [yc.INT3]: (t) => !!(t instanceof Yi),
          [yc.FLOAT3]: (t) => !!(t instanceof Yi),
          [yc.INT4]: (t) => !!(t instanceof Wi),
          [yc.FLOAT4]: (t) =>
            !!(t instanceof Wi || t instanceof Qi || t instanceof as),
          [yc.MAT3]: (t) => !!(t instanceof es),
          [yc.MAT4]: (t) => !!(t instanceof ms),
        },
        sR = [
          Object.freeze([0]),
          Object.freeze([0, 0]),
          Object.freeze([0, 0, 0, 0]),
          Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        ];
      function nR(t) {
        switch (t) {
          case yc.BOOL:
          case yc.INT:
          case yc.UINT:
          case yc.FLOAT:
            return sR[0];
          case yc.BOOL2:
          case yc.INT2:
          case yc.UINT2:
          case yc.FLOAT2:
            return sR[1];
          case yc.BOOL4:
          case yc.INT4:
          case yc.UINT4:
          case yc.FLOAT4:
            return sR[2];
          case yc.MAT4:
            return sR[3];
          case yc.SAMPLER2D:
            return "default-texture";
          case yc.SAMPLER_CUBE:
            return "default-cube-texture";
          case yc.SAMPLER2D_ARRAY:
            return "default-array-texture";
          case yc.SAMPLER3D:
            return "default-3d-texture";
        }
        return sR[0];
      }
      function rR(t) {
        switch (t) {
          case yc.SAMPLER2D:
            return "-texture";
          case yc.SAMPLER_CUBE:
            return "-cube-texture";
          case yc.SAMPLER2D_ARRAY:
            return "-array-texture";
          case yc.SAMPLER3D:
            return "-3d-texture";
          default:
            return "-unknown";
        }
      }
      function aR(t, e) {
        const i = Object.entries(e);
        let s = !1;
        for (let e = 0; e < i.length; e++)
          t[i[e][0]] !== i[e][1] && ((t[i[e][0]] = i[e][1]), (s = !0));
        return s;
      }
      let oR;
      !(function (t) {
        (t[(t.NONE = 0)] = "NONE"), (t[(t.INSTANCING = 1)] = "INSTANCING");
      })(oR || (oR = {}));
      const hR = jsb.Pass;
      hR.prototype.getUniform = function (t, e) {
        const i = this._getUniform(t);
        if ("object" == typeof i)
          if (i.type)
            switch (i.type) {
              case bs.VEC2:
                Ss.copy(e, i);
                break;
              case bs.VEC3:
                Yi.copy(e, i);
                break;
              case bs.VEC4:
                Wi.copy(e, i);
                break;
              case bs.COLOR:
                (e.x = i.x), (e.y = i.y), (e.z = i.z), (e.w = i.w);
                break;
              case bs.MAT3:
                es.copy(e, i);
                break;
              case bs.MAT4:
                ms.copy(e, i);
                break;
              case bs.QUATERNION:
                as.copy(e, i);
                break;
              default:
                console.error(`getUniform, unknown object type: ${i.type}`);
            }
          else console.error(`getUniform, unknown object: ${i}`);
        else
          "number" == typeof i
            ? (e = i)
            : console.error(`getUniform, not supported: ${i}`);
        return e;
      };
      const lR = jsb.ProgramLib.getInstance();
      function cR(t) {
        return (
          --t,
          (t |= t >> 16),
          (t |= t >> 8),
          (t |= t >> 4),
          (t |= t >> 2),
          (t |= t >> 1),
          ++t
        );
      }
      function uR(t, e) {
        return Math.ceil(t / e) * e;
      }
      a.programLib = lR;
      class _R {
        constructor(t) {
          (this._format = fc.UNKNOWN),
            (this._formatSize = 0),
            (this._chunks = []),
            (this._chunkCount = 0),
            (this._handles = []),
            (this._region0 = new _u()),
            (this._region1 = new _u()),
            (this._region2 = new _u()),
            (this._roundUpFn = null),
            (this._bufferViewCtor = Uint8Array),
            (this._channels = 4),
            (this._alignment = 1),
            (this._device = t);
        }
        initialize(t) {
          const e = a_[t.format];
          (this._format = t.format),
            (this._formatSize = e.size),
            (this._channels = e.count),
            (this._bufferViewCtor = m_(e)),
            (this._roundUpFn = t.roundUpFn || null),
            (this._alignment = t.alignment || 1),
            t.inOrderFree && (this.alloc = this._McDonaldAlloc);
        }
        destroy() {
          for (let t = 0; t < this._chunkCount; ++t)
            this._chunks[t].texture.destroy();
          (this._chunks.length = 0), (this._handles.length = 0);
        }
        alloc(t, e) {
          t = uR(t, this._alignment);
          let i = -1,
            s = -1;
          if (
            (void 0 !== e && ((i = e), (s = this._findAvailableSpace(t, i))),
            s < 0)
          )
            for (
              let e = 0;
              e < this._chunkCount &&
              ((i = e), (s = this._findAvailableSpace(t, i)), !(s >= 0));
              ++e
            );
          if (s >= 0) {
            const e = this._chunks[i];
            e.start += t;
            const n = { chunkIdx: i, start: s, end: s + t, texture: e.texture };
            return this._handles.push(n), n;
          }
          const n = Math.sqrt(t / this._formatSize),
            r =
              (this._roundUpFn && this._roundUpFn(n, this._formatSize)) ||
              Math.max(1024, cR(n)),
            a = this._chunks[this.createChunk(r)];
          a.start += t;
          const o = {
            chunkIdx: this._chunkCount - 1,
            start: 0,
            end: t,
            texture: a.texture,
          };
          return this._handles.push(o), o;
        }
        free(t) {
          for (let e = 0; e < this._handles.length; ++e)
            if (this._handles[e] === t)
              return (
                (this._chunks[t.chunkIdx].end = t.end),
                void this._handles.splice(e, 1)
              );
        }
        createChunk(t) {
          const e = t * t * this._formatSize;
          x(
            `TextureBufferPool: Allocate chunk ${this._chunkCount}, size: ${e}, format: ${this._format}`
          );
          const i = {
            texture: this._device.createTexture(
              new bu(bc.TEX2D, Ac.SAMPLED | Ac.TRANSFER_DST, this._format, t, t)
            ),
            size: e,
            start: 0,
            end: e,
          };
          return (this._chunks[this._chunkCount] = i), this._chunkCount++;
        }
        update(t, e) {
          const i = [],
            s = [],
            n = t.start / this._formatSize;
          let r = e.byteLength / this._formatSize,
            a = n % t.texture.width,
            o = Math.floor(n / t.texture.width),
            h = Math.min(t.texture.width - a, r),
            l = 0;
          a > 0 &&
            ((this._region0.texOffset.x = a),
            (this._region0.texOffset.y = o),
            (this._region0.texExtent.width = h),
            (this._region0.texExtent.height = 1),
            i.push(
              new this._bufferViewCtor(
                e,
                l * this._formatSize,
                h * this._channels
              )
            ),
            s.push(this._region0),
            (a = 0),
            (o += 1),
            (r -= h),
            (l += h)),
            r > 0 &&
              ((this._region1.texOffset.x = a),
              (this._region1.texOffset.y = o),
              r > t.texture.width
                ? ((this._region1.texExtent.width = t.texture.width),
                  (this._region1.texExtent.height = Math.floor(
                    r / t.texture.width
                  )),
                  (h =
                    this._region1.texExtent.width *
                    this._region1.texExtent.height))
                : ((h = r),
                  (this._region1.texExtent.width = h),
                  (this._region1.texExtent.height = 1)),
              i.push(
                new this._bufferViewCtor(
                  e,
                  l * this._formatSize,
                  h * this._channels
                )
              ),
              s.push(this._region1),
              (a = 0),
              (o += this._region1.texExtent.height),
              (r -= h),
              (l += h)),
            r > 0 &&
              ((this._region2.texOffset.x = a),
              (this._region2.texOffset.y = o),
              (this._region2.texExtent.width = r),
              (this._region2.texExtent.height = 1),
              i.push(
                new this._bufferViewCtor(
                  e,
                  l * this._formatSize,
                  r * this._channels
                )
              ),
              s.push(this._region2)),
            this._device.copyBuffersToTexture(i, t.texture, s);
        }
        _findAvailableSpace(t, e) {
          const i = this._chunks[e];
          let s = !1,
            n = i.start;
          if (n + t <= i.size) s = !0;
          else {
            n = 0;
            const r = this._handles
              .filter((t) => t.chunkIdx === e)
              .sort((t, e) => t.start - e.start);
            for (let e = 0; e < r.length; e++) {
              const i = r[e];
              if (n + t <= i.start) {
                s = !0;
                break;
              }
              n = i.end;
            }
            !s && n + t <= i.size && (s = !0);
          }
          return s ? n : -1;
        }
        _McDonaldAlloc(t) {
          t = uR(t, this._alignment);
          for (let e = 0; e < this._chunkCount; ++e) {
            const i = this._chunks[e];
            let s = !1,
              n = i.start;
            if (
              (n + t <= i.end
                ? (s = !0)
                : n > i.end
                ? n + t <= i.size
                  ? (s = !0)
                  : t <= i.end && ((i.start = n = 0), (s = !0))
                : n === i.end &&
                  ((i.start = n = 0), (i.end = i.size), t <= i.end && (s = !0)),
              s)
            ) {
              i.start += t;
              const s = {
                chunkIdx: e,
                start: n,
                end: n + t,
                texture: i.texture,
              };
              return this._handles.push(s), s;
            }
          }
          const e = Math.sqrt(t / this._formatSize),
            i =
              (this._roundUpFn && this._roundUpFn(e, this._formatSize)) ||
              Math.max(1024, cR(e)),
            s = this._chunks[this.createChunk(i)];
          s.start += t;
          const n = {
            chunkIdx: this._chunkCount,
            start: 0,
            end: t,
            texture: s.texture,
          };
          return this._handles.push(n), n;
        }
      }
      const dR = jsb.NativeBufferPool;
      var pR;
      jsb.NativeObjectPool,
        jsb.NativeBufferAllocator,
        (function (t) {
          (t[(t.UINT32 = 0)] = "UINT32"),
            (t[(t.FLOAT32 = 1)] = "FLOAT32"),
            (t[(t.NEVER = 2)] = "NEVER");
        })(pR || (pR = {}));
      class mR {
        constructor(t, e, i, s, n = 8) {
          (this._arrayBuffers = []),
            (this._freeLists = []),
            (this._uint32BufferViews = []),
            (this._float32BufferViews = []),
            (this._hasUint32 = !1),
            (this._hasFloat32 = !1),
            (this._elementCount = s.COUNT),
            (this._entryBits = n),
            (this._dataType = e),
            (this._dataMembers = i),
            (this._stride = 4 * this._elementCount),
            (this._entriesPerChunk = 1 << n),
            (this._entryMask = this._entriesPerChunk - 1),
            (this._poolFlag = 1 << 30),
            (this._chunkMask = ~(this._entryMask | this._poolFlag)),
            (this._nativePool = new dR(t, n, this._stride));
          let r = pR.NEVER,
            a = !1,
            o = !1;
          for (const t in e) {
            if (((a = this._hasFloat32), (o = this._hasUint32), o && a)) break;
            (r = e[t]),
              a || r !== pR.FLOAT32
                ? o || r !== pR.UINT32 || (this._hasUint32 = !0)
                : (this._hasFloat32 = !0);
          }
        }
        alloc() {
          let t = 0;
          for (; t < this._freeLists.length; t++) {
            const e = this._freeLists[t];
            if (e.length) {
              const i = e[e.length - 1];
              return e.length--, (t << this._entryBits) + i + this._poolFlag;
            }
          }
          const e = this._nativePool.allocateNewChunk(),
            i = [],
            s = [],
            n = [],
            r = this._hasFloat32,
            a = this._hasUint32;
          for (let t = 0; t < this._entriesPerChunk; t++)
            r &&
              i.push(new Float32Array(e, this._stride * t, this._elementCount)),
              a &&
                s.push(
                  new Uint32Array(e, this._stride * t, this._elementCount)
                ),
              t && n.push(t);
          return (
            a && this._uint32BufferViews.push(s),
            r && this._float32BufferViews.push(i),
            this._freeLists.push(n),
            this._arrayBuffers.push(e),
            (t << this._entryBits) + this._poolFlag
          );
        }
        getBuffer(t) {
          const e = (this._chunkMask & t) >> this._entryBits,
            i = this._entryMask & t;
          return (
            this._hasFloat32
              ? this._float32BufferViews
              : this._uint32BufferViews
          )[e][i];
        }
        getTypedArray(t, e) {
          const i = (this._chunkMask & t) >> this._entryBits,
            s = this._entryMask & t,
            n = e,
            r = (
              this._dataType[e] === pR.UINT32
                ? this._uint32BufferViews
                : this._float32BufferViews
            )[i][s],
            a = this._dataMembers[e];
          return r.subarray(n, n + a);
        }
        free(t) {
          const e = (this._chunkMask & t) >> this._entryBits,
            i = this._entryMask & t;
          (this._hasUint32
            ? this._uint32BufferViews
            : this._float32BufferViews)[e][i].fill(0),
            this._freeLists[e].push(i);
        }
      }
      let fR, gR;
      !(function (t) {
        (t[(t.NODE = 0)] = "NODE"),
          (t[(t.PASS = 1)] = "PASS"),
          (t[(t.AABB = 2)] = "AABB"),
          (t[(t.RENDER2D = 3)] = "RENDER2D");
      })(fR || (fR = {})),
        (function (t) {
          (t[(t.POSITION = 0)] = "POSITION"),
            (t[(t.UV = 3)] = "UV"),
            (t[(t.COLOR = 5)] = "COLOR"),
            (t[(t.COUNT = 9)] = "COUNT");
        })(gR || (gR = {}));
      const yR = {
          [gR.POSITION]: pR.FLOAT32,
          [gR.UV]: pR.FLOAT32,
          [gR.COLOR]: pR.UINT32,
          [gR.COUNT]: pR.NEVER,
        },
        TR = {
          [gR.POSITION]: gR.UV - gR.POSITION,
          [gR.UV]: gR.COLOR - gR.UV,
          [gR.COLOR]: gR.COUNT - gR.COLOR,
          [gR.COUNT]: 1,
        },
        SR = new mR(fR.RENDER2D, yR, TR, gR);
      let ER;
      !(function (t) {
        (t[(t.DIRTY_FLAG = 0)] = "DIRTY_FLAG"),
          (t[(t.LAYER = 1)] = "LAYER"),
          (t[(t.WORLD_SCALE = 2)] = "WORLD_SCALE"),
          (t[(t.WORLD_POSITION = 5)] = "WORLD_POSITION"),
          (t[(t.WORLD_ROTATION = 8)] = "WORLD_ROTATION"),
          (t[(t.WORLD_MATRIX = 12)] = "WORLD_MATRIX"),
          (t[(t.LOCAL_SCALE = 28)] = "LOCAL_SCALE"),
          (t[(t.LOCAL_POSITION = 31)] = "LOCAL_POSITION"),
          (t[(t.LOCAL_ROTATION = 34)] = "LOCAL_ROTATION"),
          (t[(t.COUNT = 38)] = "COUNT");
      })(ER || (ER = {}));
      const vR = {
          [ER.DIRTY_FLAG]: pR.UINT32,
          [ER.LAYER]: pR.UINT32,
          [ER.WORLD_SCALE]: pR.FLOAT32,
          [ER.WORLD_POSITION]: pR.FLOAT32,
          [ER.WORLD_ROTATION]: pR.FLOAT32,
          [ER.WORLD_MATRIX]: pR.FLOAT32,
          [ER.LOCAL_SCALE]: pR.FLOAT32,
          [ER.LOCAL_POSITION]: pR.FLOAT32,
          [ER.LOCAL_ROTATION]: pR.FLOAT32,
          [ER.COUNT]: pR.NEVER,
        },
        bR = {
          [ER.DIRTY_FLAG]: ER.LAYER - ER.DIRTY_FLAG,
          [ER.LAYER]: ER.WORLD_SCALE - ER.LAYER,
          [ER.WORLD_SCALE]: ER.WORLD_POSITION - ER.WORLD_SCALE,
          [ER.WORLD_POSITION]: ER.WORLD_ROTATION - ER.WORLD_POSITION,
          [ER.WORLD_ROTATION]: ER.WORLD_MATRIX - ER.WORLD_ROTATION,
          [ER.WORLD_MATRIX]: ER.LOCAL_SCALE - ER.WORLD_MATRIX,
          [ER.LOCAL_SCALE]: ER.LOCAL_POSITION - ER.LOCAL_SCALE,
          [ER.LOCAL_POSITION]: ER.LOCAL_ROTATION - ER.LOCAL_POSITION,
          [ER.LOCAL_ROTATION]: ER.COUNT - ER.LOCAL_ROTATION,
          [ER.COUNT]: 1,
        },
        AR = new mR(fR.NODE, vR, bR, ER);
      let CR;
      !(function (t) {
        (t[(t.PRIORITY = 0)] = "PRIORITY"),
          (t[(t.STAGE = 1)] = "STAGE"),
          (t[(t.PHASE = 2)] = "PHASE"),
          (t[(t.PRIMITIVE = 3)] = "PRIMITIVE"),
          (t[(t.BATCHING_SCHEME = 4)] = "BATCHING_SCHEME"),
          (t[(t.DYNAMIC_STATE = 5)] = "DYNAMIC_STATE"),
          (t[(t.HASH = 6)] = "HASH"),
          (t[(t.COUNT = 7)] = "COUNT");
      })(CR || (CR = {}));
      const OR = {
          [CR.PRIORITY]: pR.UINT32,
          [CR.STAGE]: pR.UINT32,
          [CR.PHASE]: pR.UINT32,
          [CR.PRIMITIVE]: pR.UINT32,
          [CR.BATCHING_SCHEME]: pR.UINT32,
          [CR.DYNAMIC_STATE]: pR.UINT32,
          [CR.HASH]: pR.UINT32,
          [CR.COUNT]: pR.NEVER,
        },
        IR = {
          [CR.PRIORITY]: CR.STAGE - CR.PRIORITY,
          [CR.STAGE]: CR.PHASE - CR.STAGE,
          [CR.PHASE]: CR.PRIMITIVE - CR.PHASE,
          [CR.PRIMITIVE]: CR.BATCHING_SCHEME - CR.PRIMITIVE,
          [CR.BATCHING_SCHEME]: CR.DYNAMIC_STATE - CR.BATCHING_SCHEME,
          [CR.DYNAMIC_STATE]: CR.HASH - CR.DYNAMIC_STATE,
          [CR.HASH]: CR.COUNT - CR.HASH,
          [CR.COUNT]: 1,
        },
        wR = new mR(fR.PASS, OR, IR, CR);
      let RR;
      !(function (t) {
        (t[(t.CENTER = 0)] = "CENTER"),
          (t[(t.HALFEXTENTS = 3)] = "HALFEXTENTS"),
          (t[(t.COUNT = 6)] = "COUNT");
      })(RR || (RR = {}));
      const DR = {
          [RR.CENTER]: pR.FLOAT32,
          [RR.HALFEXTENTS]: pR.FLOAT32,
          [RR.COUNT]: pR.NEVER,
        },
        xR = {
          [RR.CENTER]: RR.HALFEXTENTS - RR.CENTER,
          [RR.HALFEXTENTS]: RR.COUNT - RR.HALFEXTENTS,
          [RR.COUNT]: 1,
        },
        MR = new mR(fR.AABB, DR, xR, RR),
        PR = jsb.RenderScene.prototype;
      Object.defineProperty(PR, "mainLight", {
        enumerable: !0,
        configurable: !0,
        get() {
          return this.getMainLight();
        },
      });
      const NR = jsb.RenderScene,
        LR = jsb.RenderWindow;
      ce({
        Low_256x256: 256,
        Medium_512x512: 512,
        High_1024x1024: 1024,
        Ultra_2048x2048: 2048,
      });
      const BR = ce({ Planar: 0, ShadowMap: 1 });
      ce({ HARD: 0, SOFT: 1, SOFT_2X: 2, SOFT_4X: 3 }),
        ce({ LEVEL_1: 1, LEVEL_2: 2, LEVEL_3: 3, LEVEL_4: 4 }),
        ce({ NONE: 1, RemoveDuplicates: 2, DisableRotationFix: 3 });
      const FR = BR.ShadowMap + 1;
      class UR {
        constructor() {
          (this.fixedSphere = new en(0, 0, 0, 0.01)),
            (this.maxReceived = 4),
            (this._matLight = new ms()),
            (this._material = null),
            (this._instancingMaterial = null),
            (this._enabled = !1),
            (this._type = FR),
            (this._distance = 0),
            (this._planeBias = 1),
            (this._normal = new Yi(0, 1, 0)),
            (this._shadowColor = new Qi(0, 0, 0, 76)),
            (this._size = new Ss(1024, 1024)),
            (this._shadowMapDirty = !1);
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(t) {
          (this._enabled = t), this.activate();
        }
        get type() {
          return this._type;
        }
        set type(t) {
          (this._type = this.enabled ? t : FR), this.activate();
        }
        get normal() {
          return this._normal;
        }
        set normal(t) {
          Yi.copy(this._normal, t);
        }
        get distance() {
          return this._distance;
        }
        set distance(t) {
          this._distance = t;
        }
        get planeBias() {
          return this._planeBias;
        }
        set planeBias(t) {
          this._planeBias = t;
        }
        get shadowColor() {
          return this._shadowColor;
        }
        set shadowColor(t) {
          this._shadowColor = t;
        }
        get size() {
          return this._size;
        }
        set size(t) {
          this._size.set(t);
        }
        get shadowMapDirty() {
          return this._shadowMapDirty;
        }
        set shadowMapDirty(t) {
          this._shadowMapDirty = t;
        }
        get matLight() {
          return this._matLight;
        }
        get material() {
          return this._material;
        }
        get instancingMaterial() {
          return this._instancingMaterial;
        }
        getPlanarShader(t) {
          this._material ||
            ((this._material = new ey()),
            this._material.initialize({
              effectName: "pipeline/planar-shadow",
            }));
          const e = this._material.passes;
          return e.length > 0 ? e[0].getShaderVariant(t) : null;
        }
        initialize(t) {
          (this._enabled = t.enabled),
            (this._type = this.enabled ? t.type : FR),
            (this.normal = t.planeDirection),
            (this.distance = t.planeHeight),
            (this.planeBias = t.planeBias),
            (this.shadowColor = t.shadowColor),
            (this.maxReceived = t.maxReceived),
            t.shadowMapSize !== this._size.x &&
              (this.size.set(t.shadowMapSize, t.shadowMapSize),
              (this._shadowMapDirty = !0));
        }
        activate() {
          if (this._enabled)
            if (this.type === BR.Planar) this._updatePlanarInfo();
            else {
              const t = a.director.root;
              (t.pipeline.macros.CC_SHADOW_TYPE = 2),
                t.onGlobalPipelineStateChanged();
            }
          else {
            const t = a.director.root;
            (t.pipeline.macros.CC_SHADOW_TYPE = 0),
              t.onGlobalPipelineStateChanged();
          }
        }
        _updatePlanarInfo() {
          this._material ||
            ((this._material = new ey()),
            this._material.initialize({
              effectName: "pipeline/planar-shadow",
            }));
          const t = a.director.root;
          (t.pipeline.macros.CC_SHADOW_TYPE = 1),
            t.onGlobalPipelineStateChanged();
        }
        destroy() {
          this._material && this._material.destroy(),
            this._instancingMaterial && this._instancingMaterial.destroy(),
            this.fixedSphere.destroy();
        }
      }
      (UR.MAX_FAR = 2e3),
        (UR.COEFFICIENT_OF_EXPANSION = 2 * Math.sqrt(3)),
        (a.Shadows = UR),
        Z(NR.prototype, "RenderScene.prototype", [
          { name: "raycastUI2DNode" },
          { name: "raycastUINode" },
        ]),
        Z(NR.prototype, "RenderScene.prototype", [
          {
            name: "raycastAll",
            suggest: "using intersect.rayModel in geometry",
          },
          {
            name: "raycastAllModels",
            suggest: "using intersect.rayModel in geometry",
          },
          {
            name: "raycastSingleModel",
            suggest: "using intersect.rayModel in geometry",
          },
          {
            name: "raycastAllCanvas",
            suggest: "using intersect.rayAABB in geometry",
          },
          { name: "rayResultCanvas" },
          { name: "rayResultModels" },
          { name: "rayResultAll" },
          { name: "rayResultSingleModel" },
        ]),
        Z(tg.prototype, "Model.prototype", [
          { name: "isInstancingEnabled" },
          { name: "instancedAttributes" },
        ]);
      const kR = {};
      Z(kR, "CameraVisFlags", [{ name: "GENERAL" }]),
        $(kR, "CameraVisFlags", [
          {
            name: "PROFILER",
            newName: "PROFILER",
            target: Rf.BitMask,
            targetName: "PROFILER",
          },
          {
            name: "GIZMOS",
            newName: "GIZMOS",
            target: Rf.BitMask,
            targetName: "GIZMOS",
          },
          {
            name: "EDITOR",
            newName: "EDITOR",
            target: Rf.BitMask,
            targetName: "EDITOR",
          },
          {
            name: "UI",
            newName: "UI",
            target: Rf.BitMask,
            targetName: "UI_3D",
          },
          {
            name: "UI2D",
            newName: "UI2D",
            target: Rf.BitMask,
            targetName: "UI_2D",
          },
        ]),
        (a.CameraVisFlags = kR);
      const zR = {};
      Z(zR, "VisibilityFlags", [{ name: "GENERAL" }]),
        $(zR, "VisibilityFlags", [
          {
            name: "ALWALS",
            newName: "ALWALS",
            target: Rf.Enum,
            targetName: "ALWALS",
          },
          {
            name: "PROFILER",
            newName: "PROFILER",
            target: Rf.Enum,
            targetName: "PROFILER",
          },
          {
            name: "GIZMOS",
            newName: "GIZMOS",
            target: Rf.Enum,
            targetName: "GIZMOS",
          },
          {
            name: "EDITOR",
            newName: "EDITOR",
            target: Rf.Enum,
            targetName: "EDITOR",
          },
          { name: "UI", newName: "UI", target: Rf.Enum, targetName: "UI_3D" },
          {
            name: "UI2D",
            newName: "UI2D",
            target: Rf.Enum,
            targetName: "UI_2D",
          },
        ]),
        (a.VisibilityFlags = zR),
        $(hR.prototype, "Pass.prototype", [
          {
            name: "getBindingTypeFromHandle",
            newName: "getDescriptorTypeFromHandle",
          },
        ]),
        Z(dg.prototype, "Camera.prototype", [
          { name: "getSplitFrustum" },
          { name: "setMatView" },
          { name: "setMatViewInv" },
          { name: "setMatProjInv" },
          { name: "setMatViewProjInv" },
          { name: "setMatProj" },
          { name: "setMatViewProj" },
          { name: "getMatViewInv" },
        ]),
        Z(UR.prototype, "Shadows.prototype", [
          { name: "aspect" },
          { name: "selfShadow" },
          { name: "linear" },
          { name: "packing" },
          { name: "autoAdapt" },
          { name: "fixedArea" },
          { name: "pcf" },
          { name: "bias" },
          { name: "normalBias" },
          { name: "near" },
          { name: "far" },
          { name: "shadowDistance" },
          { name: "invisibleOcclusionRange" },
          { name: "orthoSize" },
          { name: "saturation" },
        ]),
        Z(Dg.prototype, "SpotLight.prototype", [{ name: "aspect" }]),
        $(sg.prototype, "SubModel.prototype", [
          { name: "subMeshData", newName: "subMesh" },
        ]),
        Z(sg.prototype, "SubModel.prototype", [
          { name: "getSubModel", suggest: "Use `subModels[i]` instead" },
          { name: "subModelNum", suggest: "Use `subModels.length` instead" },
        ]);
      const HR = Kw.addStage;
      var GR = Object.freeze({
        __proto__: null,
        addStage: HR,
        scene: $g,
        createIA: function (t, e) {
          if (!e.positions) return G(16306), null;
          const i = [],
            s = e.positions.length / 3;
          for (let t = 0; t < s; ++t)
            i.push(
              e.positions[3 * t],
              e.positions[3 * t + 1],
              e.positions[3 * t + 2]
            ),
              e.normals &&
                i.push(
                  e.normals[3 * t],
                  e.normals[3 * t + 1],
                  e.normals[3 * t + 2]
                ),
              e.uvs && i.push(e.uvs[2 * t], e.uvs[2 * t + 1]),
              e.colors &&
                i.push(
                  e.colors[3 * t],
                  e.colors[3 * t + 1],
                  e.colors[3 * t + 2]
                );
          const n = [];
          n.push(new Lu(eu.ATTR_POSITION, fc.RGB32F)),
            e.normals && n.push(new Lu(eu.ATTR_NORMAL, fc.RGB32F)),
            e.uvs && n.push(new Lu(eu.ATTR_TEX_COORD, fc.RG32F)),
            e.colors && n.push(new Lu(eu.ATTR_COLOR, fc.RGB32F));
          const r = t.createBuffer(
            new yu(
              Tc.VERTEX | Tc.TRANSFER_DST,
              vc.DEVICE,
              4 * i.length,
              (4 * i.length) / s
            )
          );
          r.update(new Float32Array(i));
          let a = null;
          return (
            e.indices &&
              ((a = t.createBuffer(
                new yu(
                  Tc.INDEX | Tc.TRANSFER_DST,
                  vc.DEVICE,
                  2 * e.indices.length,
                  2
                )
              )),
              a.update(new Uint16Array(e.indices))),
            t.createInputAssembler(new Fu(n, [r], a))
          );
        },
        programLib: lR,
        getDeviceShaderVersion: function (t) {
          switch (t.gfxAPI) {
            case dc.GLES2:
            case dc.WEBGL:
              return "glsl1";
            case dc.GLES3:
            case dc.WEBGL2:
              return "glsl3";
            default:
              return "glsl4";
          }
        },
        RenderWindow: LR,
        get RenderQueue() {
          return qw;
        },
        get PassStage() {
          return $w;
        },
        genHandle: (t, e, i, s = 0) =>
          ((e << 26) & Zw) | ((t << 20) & Qw) | ((i << 12) & Jw) | (4095 & s),
        getTypeFromHandle: (t) => (t & Zw) >>> 26,
        getBindingFromHandle: (t) => (t & Qw) >>> 20,
        getCountFromHandle: (t) => (t & Jw) >>> 12,
        getOffsetFromHandle: (t) => 4095 & t,
        customizeType: (t, e) => (67108863 & t) | ((e << 26) & Zw),
        type2reader: tR,
        type2writer: eR,
        type2validator: iR,
        getDefaultFromType: nR,
        getStringFromType: rR,
        overrideMacros: aR,
        get BatchingSchemes() {
          return oR;
        },
        Pass: hR,
        nearestPOT: cR,
        TextureBufferPool: _R,
        MaterialInstance: OI,
        PassInstance: class extends hR {
          get parent() {
            return this._parent;
          }
          constructor(t, e) {
            super(t.root),
              (this._dontNotify = !1),
              (this._parent = t),
              (this._owner = e),
              this._doInit(this._parent, !0);
            for (let t = 0; t < this._shaderInfo.blocks.length; t++) {
              const e = this._shaderInfo.blocks[t],
                i = this._blocks[e.binding],
                s = this._parent.blocks[e.binding];
              i.set(s);
            }
            this._rootBufferDirty = !0;
            const i = this._parent;
            for (let t = 0; t < this._shaderInfo.samplerTextures.length; t++) {
              const e = this._shaderInfo.samplerTextures[t];
              for (let t = 0; t < e.count; t++) {
                const s = i._descriptorSet.getSampler(e.binding, t),
                  n = i._descriptorSet.getTexture(e.binding, t);
                this._descriptorSet.bindSampler(e.binding, s, t),
                  this._descriptorSet.bindTexture(e.binding, n, t);
              }
            }
            super.tryCompile();
          }
          overridePipelineStates(t, e) {
            this._bs.reset(),
              this._rs.reset(),
              this._dss.reset(),
              hR.fillPipelineInfo(this, t),
              hR.fillPipelineInfo(this, e),
              this._onStateChange();
          }
          tryCompile(t) {
            if (t && !aR(this._defines, t)) return !1;
            const e = super.tryCompile();
            return this._onStateChange(), e;
          }
          beginChangeStatesSilently() {
            this._dontNotify = !0;
          }
          endChangeStatesSilently() {
            this._dontNotify = !1;
          }
          _syncBatchingScheme() {
            (this._defines.USE_INSTANCING = !1),
              (this._batchingScheme = oR.NONE);
          }
          _onStateChange() {
            (this._hash = hR.getPassHash(this)),
              this._owner.onPassStateChange(this._dontNotify);
          }
        },
        get PoolType() {
          return fR;
        },
        NULL_HANDLE: 0,
        get Render2dView() {
          return gR;
        },
        Render2dPool: SR,
        get NodeView() {
          return ER;
        },
        NodePool: AR,
        get PassView() {
          return CR;
        },
        PassPool: wR,
        get AABBView() {
          return RR;
        },
        AABBPool: MR,
        RenderScene: NR,
        CameraVisFlags: kR,
        VisibilityFlags: zR,
      });
      let VR, jR, WR;
      t("renderer", GR),
        (function (t) {
          (t[(t.BUTT = 0)] = "BUTT"),
            (t[(t.ROUND = 1)] = "ROUND"),
            (t[(t.SQUARE = 2)] = "SQUARE");
        })(VR || (VR = {})),
        de(VR),
        (function (t) {
          (t[(t.BEVEL = 0)] = "BEVEL"),
            (t[(t.ROUND = 1)] = "ROUND"),
            (t[(t.MITER = 2)] = "MITER");
        })(jR || (jR = {})),
        de(jR),
        (function (t) {
          (t[(t.PT_CORNER = 1)] = "PT_CORNER"),
            (t[(t.PT_LEFT = 2)] = "PT_LEFT"),
            (t[(t.PT_BEVEL = 4)] = "PT_BEVEL"),
            (t[(t.PT_INNERBEVEL = 8)] = "PT_INNERBEVEL");
        })(WR || (WR = {})),
        de(WR);
      const XR = Math.PI,
        YR = Math.min,
        KR = Math.max,
        qR = Math.cos,
        $R = Math.sin,
        ZR = Math.abs,
        QR = Math.sign,
        JR = 0.5522847493;
      function tD(t, e, i, s, n) {
        t.moveTo(e - s, i),
          t.bezierCurveTo(e - s, i + n * JR, e - s * JR, i + n, e, i + n),
          t.bezierCurveTo(e + s * JR, i + n, e + s, i + n * JR, e + s, i),
          t.bezierCurveTo(e + s, i - n * JR, e + s * JR, i - n, e, i - n),
          t.bezierCurveTo(e - s * JR, i - n, e - s, i - n * JR, e - s, i),
          t.close();
      }
      function eD(t, e, i, s, n, r, a, o, h, l, c) {
        let u = 0,
          _ = 0,
          d = 0,
          p = 0,
          m = 0,
          f = 0,
          g = 0,
          y = 0,
          T = 0,
          S = 0,
          E = 0,
          v = 0,
          b = 0,
          A = 0,
          C = 0,
          O = 0;
        l > 10 ||
          ((u = 0.5 * (e + s)),
          (_ = 0.5 * (i + n)),
          (d = 0.5 * (s + r)),
          (p = 0.5 * (n + a)),
          (m = 0.5 * (r + o)),
          (f = 0.5 * (a + h)),
          (g = 0.5 * (u + d)),
          (y = 0.5 * (_ + p)),
          (b = o - e),
          (A = h - i),
          (C = ZR((s - o) * A - (n - h) * b)),
          (O = ZR((r - o) * A - (a - h) * b)),
          (C + O) * (C + O) < t.tessTol * (b * b + A * A)
            ? t.addPoint(o, h, 0 === c ? c | WR.PT_BEVEL : c)
            : ((T = 0.5 * (d + m)),
              (S = 0.5 * (p + f)),
              (E = 0.5 * (g + T)),
              (v = 0.5 * (y + S)),
              eD(t, e, i, u, _, g, y, E, v, l + 1, 0),
              eD(t, E, v, T, S, m, f, o, h, l + 1, c)));
      }
      class iD extends Ss {
        constructor(t, e) {
          super(t, e),
            (this.dx = 0),
            (this.dy = 0),
            (this.dmx = 0),
            (this.dmy = 0),
            (this.flags = 0),
            (this.len = 0);
        }
        reset() {
          (this.dx = 0),
            (this.dy = 0),
            (this.dmx = 0),
            (this.dmy = 0),
            (this.flags = 0),
            (this.len = 0);
        }
      }
      class sD {
        constructor() {
          (this.closed = !1),
            (this.bevel = 0),
            (this.complex = !0),
            (this.points = []);
        }
        reset() {
          (this.closed = !1),
            (this.bevel = 0),
            (this.complex = !0),
            (this.points.length = 0);
        }
      }
      class nD {
        constructor(t) {
          (this.dataOffset = 0),
            (this.updatePathOffset = !1),
            (this.pathLength = 0),
            (this.pathOffset = 0),
            (this.paths = []),
            (this.tessTol = 0.25),
            (this.distTol = 0.01),
            (this.fillColor = Qi.WHITE.clone()),
            (this.lineCap = VR.BUTT),
            (this.strokeColor = Qi.BLACK.clone()),
            (this.lineJoin = jR.MITER),
            (this.lineWidth = 0),
            (this.pointsOffset = 0),
            (this._commandX = 0),
            (this._commandY = 0),
            (this._points = []),
            (this._recycledPoints = []),
            (this._renderDataList = []),
            (this._curPath = null),
            (this._comp = t);
        }
        moveTo(t, e) {
          this.updatePathOffset &&
            ((this.pathOffset = this.pathLength), (this.updatePathOffset = !1)),
            this._addPath(),
            this.addPoint(t, e, WR.PT_CORNER),
            (this._commandX = t),
            (this._commandY = e);
        }
        lineTo(t, e) {
          this.addPoint(t, e, WR.PT_CORNER),
            (this._commandX = t),
            (this._commandY = e);
        }
        bezierCurveTo(t, e, i, s, n, r) {
          const a = this._curPath,
            o = a.points[a.points.length - 1];
          o &&
            (o.x !== t || o.y !== e || i !== n || s !== r
              ? (eD(this, o.x, o.y, t, e, i, s, n, r, 0, WR.PT_CORNER),
                (this._commandX = n),
                (this._commandY = r))
              : this.lineTo(n, r));
        }
        quadraticCurveTo(t, e, i, s) {
          const n = this._commandX,
            r = this._commandY;
          this.bezierCurveTo(
            n + (2 / 3) * (t - n),
            r + (2 / 3) * (e - r),
            i + (2 / 3) * (t - i),
            s + (2 / 3) * (e - s),
            i,
            s
          );
        }
        arc(t, e, i, s, n, r) {
          !(function (t, e, i, s, n, r, a) {
            let o = 0,
              h = 0,
              l = 0,
              c = 0,
              u = 0,
              _ = 0,
              d = 0,
              p = 0,
              m = 0,
              f = 0,
              g = 0,
              y = 0,
              T = 0,
              S = 0,
              E = 0,
              v = 0;
            if (((h = r - n), (a = a || !1)))
              if (ZR(h) >= 2 * XR) h = 2 * XR;
              else for (; h < 0; ) h += 2 * XR;
            else if (ZR(h) >= 2 * XR) h = 2 * -XR;
            else for (; h > 0; ) h -= 2 * XR;
            for (
              v = 0 | KR(1, YR(ZR(h) / (0.5 * XR) + 0.5, 5)),
                l = h / v / 2,
                c = ZR(((4 / 3) * (1 - qR(l))) / $R(l)),
                a || (c = -c),
                E = 0;
              E <= v;
              E++
            )
              (o = n + h * (E / v)),
                (u = qR(o)),
                (_ = $R(o)),
                (d = e + u * s),
                (p = i + _ * s),
                (m = -_ * s * c),
                (f = u * s * c),
                0 === E
                  ? t.moveTo(d, p)
                  : t.bezierCurveTo(g + T, y + S, d - m, p - f, d, p),
                (g = d),
                (y = p),
                (T = m),
                (S = f);
          })(this, t, e, i, s, n, r);
        }
        ellipse(t, e, i, s) {
          tD(this, t, e, i, s), (this._curPath.complex = !1);
        }
        circle(t, e, i) {
          tD(this, t, e, i, i), (this._curPath.complex = !1);
        }
        rect(t, e, i, s) {
          this.moveTo(t, e),
            this.lineTo(t + i, e),
            this.lineTo(t + i, e + s),
            this.lineTo(t, e + s),
            this.close(),
            (this._curPath.complex = !1);
        }
        roundRect(t, e, i, s, n) {
          !(function (t, e, i, s, n, r) {
            if (r < 0.1) t.rect(e, i, s, n);
            else {
              const a = YR(r, 0.5 * ZR(s)) * QR(s),
                o = YR(r, 0.5 * ZR(n)) * QR(n);
              t.moveTo(e, i + o),
                t.lineTo(e, i + n - o),
                t.bezierCurveTo(
                  e,
                  i + n - o * (1 - JR),
                  e + a * (1 - JR),
                  i + n,
                  e + a,
                  i + n
                ),
                t.lineTo(e + s - a, i + n),
                t.bezierCurveTo(
                  e + s - a * (1 - JR),
                  i + n,
                  e + s,
                  i + n - o * (1 - JR),
                  e + s,
                  i + n - o
                ),
                t.lineTo(e + s, i + o),
                t.bezierCurveTo(
                  e + s,
                  i + o * (1 - JR),
                  e + s - a * (1 - JR),
                  i,
                  e + s - a,
                  i
                ),
                t.lineTo(e + a, i),
                t.bezierCurveTo(
                  e + a * (1 - JR),
                  i,
                  e,
                  i + o * (1 - JR),
                  e,
                  i + o
                ),
                t.close();
            }
          })(this, t, e, i, s, n),
            (this._curPath.complex = !1);
        }
        clear() {
          (this.pathLength = 0),
            (this.pathOffset = 0),
            (this.pointsOffset = 0),
            (this.dataOffset = 0),
            (this._curPath = null),
            (this.paths.length = 0),
            this._recycledPoints.push(...this._points),
            (this._points.length = 0);
          const t = this._renderDataList;
          for (let e = 0, i = t.length; e < i; e++) {
            const i = t[e];
            i && (uI.remove(i), i.removeRenderDrawInfo(this._comp));
          }
          this._renderDataList.length = 0;
        }
        clearRecycledPoints() {
          this._recycledPoints.length = 0;
        }
        close() {
          this._curPath.closed = !0;
        }
        requestRenderData() {
          const t = uI.add();
          return (
            this._renderDataList.push(t),
            t.initRenderDrawInfo(this._comp, ZO.MODEL),
            (t.material = this._comp.getMaterialInstance(0)),
            this._comp.setRenderData(t),
            t
          );
        }
        getRenderDataList() {
          return (
            0 === this._renderDataList.length && this.requestRenderData(),
            this._renderDataList
          );
        }
        getPoint(t, e) {
          if (this._recycledPoints.length <= 0) return new iD(t, e);
          const i = this._recycledPoints.pop();
          return i ? (i.reset(), (i.x = t), (i.y = e), i) : new iD(t, e);
        }
        addPoint(t, e, i) {
          const s = this._curPath;
          if (!s) return;
          const n = this._points,
            r = s.points;
          let a = n[this.pointsOffset++];
          a ? ((a.x = t), (a.y = e)) : ((a = this.getPoint(t, e)), n.push(a)),
            (a.flags = i),
            r.push(a);
        }
        _addPath() {
          const t = this.pathLength;
          let e = this.paths[t];
          return (
            e ? e.reset() : ((e = new sD()), this.paths.push(e)),
            this.pathLength++,
            (this._curPath = e),
            e
          );
        }
      }
      var rD, aD, oD, hD, lD, cD, uD, _D, dD, pD, mD, fD, gD;
      const yD = MO.concat([new Lu("a_dist", fc.R32F)]),
        TD = FO(yD),
        SD = UO(yD);
      let ED =
        ((rD = Ca("cc.Graphics")),
        (aD = Ia(110)),
        (oD = ao(jR)),
        (hD = ao(VR)),
        rD(
          (lD =
            aD(
              (((gD = class t extends ew {
                get lineWidth() {
                  return this._lineWidth;
                }
                set lineWidth(t) {
                  (this._lineWidth = t), this.impl && (this.impl.lineWidth = t);
                }
                get lineJoin() {
                  return this._lineJoin;
                }
                set lineJoin(t) {
                  (this._lineJoin = t), this.impl && (this.impl.lineJoin = t);
                }
                get lineCap() {
                  return this._lineCap;
                }
                set lineCap(t) {
                  (this._lineCap = t), this.impl && (this.impl.lineCap = t);
                }
                get strokeColor() {
                  return this._strokeColor;
                }
                set strokeColor(t) {
                  this.impl &&
                    (this._strokeColor.set(t),
                    (this.impl.strokeColor = this._strokeColor));
                }
                get fillColor() {
                  return this._fillColor;
                }
                set fillColor(t) {
                  this.impl &&
                    (this._fillColor.set(t),
                    (this.impl.fillColor = this._fillColor));
                }
                get miterLimit() {
                  return this._miterLimit;
                }
                set miterLimit(t) {
                  this._miterLimit = t;
                }
                get color() {
                  return this._color;
                }
                set color(t) {
                  this._color !== t && this._color.set(t);
                }
                get graphicsNativeProxy() {
                  return this._graphicsNativeProxy;
                }
                constructor() {
                  super(),
                    (this.impl = null),
                    (this.model = null),
                    (this._lineWidth = uD && uD()),
                    (this._strokeColor = _D && _D()),
                    (this._lineJoin = dD && dD()),
                    (this._lineCap = pD && pD()),
                    (this._fillColor = mD && mD()),
                    (this._miterLimit = fD && fD()),
                    (this._isDrawing = !1),
                    (this._isNeedUploadData = !0),
                    (this._graphicsUseSubMeshes = []),
                    (this._instanceMaterialType = tw.ADD_COLOR),
                    (this.impl = new nD(this)),
                    (this._graphicsNativeProxy = new GO());
                }
                onRestore() {
                  this.impl || this._flushAssembler();
                }
                onLoad() {
                  super.onLoad(),
                    this._graphicsNativeProxy.initModel(this.node),
                    (this.model = this._graphicsNativeProxy.getModel()),
                    this._flushAssembler();
                }
                onEnable() {
                  super.onEnable(), this._updateMtlForGraphics();
                }
                onDestroy() {
                  (this._sceneGetter = null),
                    this._graphicsNativeProxy.destroy(),
                    (this.model = null),
                    this.impl &&
                      ((this._isDrawing = !1),
                      this.impl.clear(),
                      this.impl.clearRecycledPoints(),
                      (this.impl = null)),
                    super.onDestroy();
                }
                moveTo(t, e) {
                  this.impl && this.impl.moveTo(t, e);
                }
                lineTo(t, e) {
                  this.impl && this.impl.lineTo(t, e);
                }
                bezierCurveTo(t, e, i, s, n, r) {
                  this.impl && this.impl.bezierCurveTo(t, e, i, s, n, r);
                }
                quadraticCurveTo(t, e, i, s) {
                  this.impl && this.impl.quadraticCurveTo(t, e, i, s);
                }
                arc(t, e, i, s, n, r) {
                  this.impl && this.impl.arc(t, e, i, s, n, r);
                }
                ellipse(t, e, i, s) {
                  this.impl && this.impl.ellipse(t, e, i, s);
                }
                circle(t, e, i) {
                  this.impl && this.impl.circle(t, e, i);
                }
                rect(t, e, i, s) {
                  this.impl && this.impl.rect(t, e, i, s);
                }
                roundRect(t, e, i, s, n) {
                  this.impl && this.impl.roundRect(t, e, i, s, n);
                }
                fillRect(t, e, i, s) {
                  this.rect(t, e, i, s), this.fill();
                }
                clear() {
                  this.impl &&
                    (this.impl.clear(),
                    (this._isDrawing = !1),
                    this._graphicsNativeProxy.clear(),
                    this.markForUpdateRenderData());
                }
                close() {
                  this.impl && this.impl.close();
                }
                stroke() {
                  this._assembler || this._flushAssembler(),
                    (this._isDrawing = !0),
                    (this._isNeedUploadData = !0),
                    this._assembler.stroke(this);
                }
                fill() {
                  this._assembler || this._flushAssembler(),
                    (this._isDrawing = !0),
                    (this._isNeedUploadData = !0),
                    this._assembler.fill(this);
                }
                _updateMtlForGraphics() {
                  let t;
                  this._customMaterial
                    ? (t = this.getMaterialInstance(0))
                    : ((t = Pv.get("ui-graphics-material")),
                      this.setSharedMaterial(t, 0),
                      (t = this.getMaterialInstance(0)),
                      t.recompileShaders({ USE_LOCAL: !0 }));
                }
                activeSubModel(t) {
                  if (this.model) {
                    if (this.model.subModels.length <= t) {
                      const e = I_.gfxDevice,
                        i = e.createBuffer(
                          new yu(
                            Tc.VERTEX | Tc.TRANSFER_DST,
                            vc.DEVICE,
                            65535 * SD,
                            SD
                          )
                        ),
                        s = e.createBuffer(
                          new yu(
                            Tc.INDEX | Tc.TRANSFER_DST,
                            vc.DEVICE,
                            131070 * Uint16Array.BYTES_PER_ELEMENT,
                            Uint16Array.BYTES_PER_ELEMENT
                          )
                        ),
                        n = new fC([i], yD, Gc.TRIANGLE_LIST, s);
                      (n.subMeshIdx = 0),
                        this.model.initSubModel(
                          t,
                          n,
                          this.getMaterialInstance(0)
                        ),
                        this._graphicsUseSubMeshes.push(n);
                    }
                  } else z(4500, this.node.name);
                }
                _uploadData() {
                  const t = this.impl;
                  if (!t) return;
                  const e = t && t.getRenderDataList();
                  if (e.length <= 0 || !this.model) return;
                  const i = this.model.subModels;
                  for (let t = 0; t < e.length; t++) {
                    const s = e[t],
                      n = i[t].inputAssembler;
                    if (s.lastFilledVertex === s.vertexStart) continue;
                    const r = new Float32Array(
                      s.vData.buffer,
                      0,
                      s.vertexStart * TD
                    );
                    n.vertexBuffers[0].update(r),
                      (n.vertexCount = s.vertexStart);
                    const a = new Uint16Array(s.iData.buffer, 0, s.indexStart);
                    n.indexBuffer.update(a),
                      (n.indexCount = s.indexStart),
                      (s.lastFilledVertex = s.vertexStart),
                      (s.lastFilledIndex = s.indexStart);
                  }
                  this._isNeedUploadData = !1;
                }
                _render(t) {
                  if (this._isNeedUploadData) {
                    if (this.impl) {
                      const t = this.impl.getRenderDataList(),
                        e = this.model.subModels.length;
                      if (t.length > e)
                        for (let i = e; i < t.length; i++)
                          this.activeSubModel(i);
                    }
                    this._uploadData();
                  }
                  t.commitModel(this, this.model, this.getMaterialInstance(0));
                }
                _flushAssembler() {
                  const e = t.Assembler.getAssembler(this);
                  this._assembler !== e && (this._assembler = e);
                }
                _canRender() {
                  return !!super._canRender() && this._isDrawing;
                }
                updateRenderer() {
                  if ((super.updateRenderer(), this._isNeedUploadData)) {
                    if (this.impl) {
                      const t = this.impl.getRenderDataList();
                      for (let e = 0; e < t.length; e++)
                        t[e].setRenderDrawInfoAttributes();
                      this._graphicsNativeProxy.activeSubModels();
                    }
                    this._graphicsNativeProxy.uploadData(),
                      (this._isNeedUploadData = !1);
                  }
                }
                createRenderEntity() {
                  return new oI(tI.DYNAMIC);
                }
              }).LineJoin = jR),
              (gD.LineCap = VR),
              s(
                (cD = gD).prototype,
                "lineJoin",
                [oD],
                Object.getOwnPropertyDescriptor(cD.prototype, "lineJoin"),
                cD.prototype
              ),
              s(
                cD.prototype,
                "lineCap",
                [hD],
                Object.getOwnPropertyDescriptor(cD.prototype, "lineCap"),
                cD.prototype
              ),
              s(
                cD.prototype,
                "color",
                [oo],
                Object.getOwnPropertyDescriptor(cD.prototype, "color"),
                cD.prototype
              ),
              (uD = fa(cD.prototype, "_lineWidth", [Na], function () {
                return 1;
              })),
              (_D = fa(cD.prototype, "_strokeColor", [Na], function () {
                return Qi.BLACK.clone();
              })),
              (dD = fa(cD.prototype, "_lineJoin", [Na], function () {
                return jR.MITER;
              })),
              (pD = fa(cD.prototype, "_lineCap", [Na], function () {
                return VR.BUTT;
              })),
              (mD = fa(cD.prototype, "_fillColor", [Na], function () {
                return Qi.WHITE.clone();
              })),
              (fD = fa(cD.prototype, "_miterLimit", [Na], function () {
                return 10;
              })),
              (lD = cD))
            ) || lD)
        ) || lD);
      var vD,
        bD,
        AD,
        CD,
        OD,
        ID,
        wD,
        RD,
        DD,
        xD,
        MD,
        PD,
        ND,
        LD,
        BD,
        FD,
        UD,
        kD,
        zD,
        HD;
      let GD;
      var VD, jD, WD;
      t({ Graphics: ED, GraphicsComponent: ED }),
        (a.Graphics = ED),
        (function (t) {
          (t[(t.SIMPLE = 0)] = "SIMPLE"),
            (t[(t.SLICED = 1)] = "SLICED"),
            (t[(t.TILED = 2)] = "TILED"),
            (t[(t.FILLED = 3)] = "FILLED");
        })(GD || (GD = {})),
        de(GD),
        (function (t) {
          (t[(t.HORIZONTAL = 0)] = "HORIZONTAL"),
            (t[(t.VERTICAL = 1)] = "VERTICAL"),
            (t[(t.RADIAL = 2)] = "RADIAL");
        })(VD || (VD = {})),
        de(VD),
        (function (t) {
          (t[(t.CUSTOM = 0)] = "CUSTOM"),
            (t[(t.TRIMMED = 1)] = "TRIMMED"),
            (t[(t.RAW = 2)] = "RAW");
        })(jD || (jD = {})),
        de(jD),
        (function (t) {
          t.SPRITE_FRAME_CHANGED = "spriteframe-changed";
        })(WD || (WD = {}));
      let XD =
        ((vD = Ca("cc.Sprite")),
        (bD = Ia(110)),
        (AD = ao(EC)),
        (CD = ao(uC)),
        (OD = ao(GD)),
        (ID = ao(VD)),
        (wD = ao(jD)),
        vD(
          (RD =
            bD(
              (((HD = class t extends ew {
                constructor() {
                  super(),
                    (this._spriteFrame = xD && xD()),
                    (this._type = MD && MD()),
                    (this._fillType = PD && PD()),
                    (this._sizeMode = ND && ND()),
                    (this._fillCenter = LD && LD()),
                    (this._fillStart = BD && BD()),
                    (this._fillRange = FD && FD()),
                    (this._isTrimmedMode = UD && UD()),
                    (this._useGrayscale = kD && kD()),
                    (this._atlas = zD && zD());
                }
                get spriteAtlas() {
                  return this._atlas;
                }
                set spriteAtlas(t) {
                  this._atlas !== t && (this._atlas = t);
                }
                get spriteFrame() {
                  return this._spriteFrame;
                }
                set spriteFrame(t) {
                  if (this._spriteFrame === t) return;
                  const e = this._spriteFrame;
                  (this._spriteFrame = t),
                    this.markForUpdateRenderData(),
                    this._applySpriteFrame(e);
                }
                onSetInternalEnabled(t) {
                  t ||
                    (this._assembler && this._assembler.updateRenderData(this),
                    (this._renderFlag = !1),
                    (this._renderEntity.enabled = this._renderFlag));
                }
                get type() {
                  return this._type;
                }
                set type(t) {
                  this._type !== t &&
                    ((this._type = t), this._flushAssembler());
                }
                get fillType() {
                  return this._fillType;
                }
                set fillType(t) {
                  this._fillType !== t &&
                    (t === VD.RADIAL || this._fillType === VD.RADIAL
                      ? this.destroyRenderData()
                      : this.renderData && this.markForUpdateRenderData(!0)),
                    (this._fillType = t),
                    this._flushAssembler();
                }
                get fillCenter() {
                  return this._fillCenter;
                }
                set fillCenter(t) {
                  (this._fillCenter.x = t.x),
                    (this._fillCenter.y = t.y),
                    this._type === GD.FILLED &&
                      this.renderData &&
                      this.markForUpdateRenderData();
                }
                get fillStart() {
                  return this._fillStart;
                }
                set fillStart(t) {
                  (this._fillStart = Si(t, 0, 1)),
                    this._type === GD.FILLED &&
                      this.renderData &&
                      (this.markForUpdateRenderData(), this._updateUVs());
                }
                get fillRange() {
                  return this._fillRange;
                }
                set fillRange(t) {
                  (this._fillRange = Si(t, -1, 1)),
                    this._type === GD.FILLED &&
                      this.renderData &&
                      (this.markForUpdateRenderData(), this._updateUVs());
                }
                get trim() {
                  return this._isTrimmedMode;
                }
                set trim(t) {
                  this._isTrimmedMode !== t &&
                    ((this._isTrimmedMode = t),
                    this._type === GD.SIMPLE &&
                      this.renderData &&
                      this.markForUpdateRenderData(!0));
                }
                get grayscale() {
                  return this._useGrayscale;
                }
                set grayscale(t) {
                  this._useGrayscale !== t &&
                    ((this._useGrayscale = t),
                    this.changeMaterialForDefine(),
                    this.updateMaterial());
                }
                get sizeMode() {
                  return this._sizeMode;
                }
                set sizeMode(t) {
                  this._sizeMode !== t &&
                    ((this._sizeMode = t),
                    t !== jD.CUSTOM && this._applySpriteSize());
                }
                __preload() {
                  this.changeMaterialForDefine(), super.__preload();
                }
                onEnable() {
                  super.onEnable(), this._activateMaterial();
                  const t = this._spriteFrame;
                  t &&
                    (this._updateUVs(),
                    this._type === GD.SLICED &&
                      t.on(uC.EVENT_UV_UPDATED, this._updateUVs, this));
                }
                onDisable() {
                  super.onDisable(),
                    this._spriteFrame &&
                      this._type === GD.SLICED &&
                      this._spriteFrame.off(
                        uC.EVENT_UV_UPDATED,
                        this._updateUVs,
                        this
                      );
                }
                onDestroy() {
                  super.onDestroy();
                }
                changeSpriteFrameFromAtlas(t) {
                  if (!this._atlas) return void z(16377);
                  const e = this._atlas.getSpriteFrame(t);
                  this.spriteFrame = e;
                }
                changeMaterialForDefine() {
                  let t;
                  const e = this._instanceMaterialType;
                  this._spriteFrame && (t = this._spriteFrame.texture);
                  let i = !1;
                  if (t instanceof Xp) {
                    const e = t.getPixelFormat();
                    i =
                      e === Cd.RGBA_ETC1 ||
                      e === Cd.RGB_A_PVRTC_4BPPV1 ||
                      e === Cd.RGB_A_PVRTC_2BPPV1;
                  }
                  i && this.grayscale
                    ? (this._instanceMaterialType =
                        tw.USE_ALPHA_SEPARATED_AND_GRAY)
                    : i
                    ? (this._instanceMaterialType = tw.USE_ALPHA_SEPARATED)
                    : this.grayscale
                    ? (this._instanceMaterialType = tw.GRAYSCALE)
                    : (this._instanceMaterialType = tw.ADD_COLOR_AND_TEXTURE),
                    e !== this._instanceMaterialType && this.updateMaterial();
                }
                _updateBuiltinMaterial() {
                  let t = super._updateBuiltinMaterial();
                  if (
                    this.spriteFrame &&
                    this.spriteFrame.texture instanceof pC
                  ) {
                    const e = new ey();
                    e.copy(t, { defines: { SAMPLE_FROM_RT: !0 } }), (t = e);
                  }
                  return t;
                }
                _render(t) {
                  t.commitComp(
                    this,
                    this.renderData,
                    this._spriteFrame,
                    this._assembler,
                    null
                  );
                }
                _canRender() {
                  if (!super._canRender()) return !1;
                  const t = this._spriteFrame;
                  return !(!t || !t.texture);
                }
                _flushAssembler() {
                  const e = t.Assembler.getAssembler(this);
                  this._assembler !== e &&
                    (this.destroyRenderData(), (this._assembler = e)),
                    this._renderData ||
                      (this._assembler &&
                        this._assembler.createData &&
                        ((this._renderData = this._assembler.createData(this)),
                        (this._renderData.material = this.getRenderMaterial(0)),
                        this.markForUpdateRenderData(),
                        this.spriteFrame && this._assembler.updateUVs(this),
                        this._updateColor())),
                    this._spriteFrame &&
                      (this._type === GD.SLICED
                        ? this._spriteFrame.on(
                            uC.EVENT_UV_UPDATED,
                            this._updateUVs,
                            this
                          )
                        : this._spriteFrame.off(
                            uC.EVENT_UV_UPDATED,
                            this._updateUVs,
                            this
                          ));
                }
                _applySpriteSize() {
                  if (this._spriteFrame) {
                    if (!Qn(this.node, !0)) return;
                    if (jD.RAW === this._sizeMode) {
                      const t = this._spriteFrame.originalSize;
                      this.node._uiProps.uiTransformComp.setContentSize(t);
                    } else if (jD.TRIMMED === this._sizeMode) {
                      const t = this._spriteFrame.rect;
                      this.node._uiProps.uiTransformComp.setContentSize(
                        t.width,
                        t.height
                      );
                    }
                  }
                }
                _resized() {}
                _activateMaterial() {
                  const t = this._spriteFrame,
                    e = this.getRenderMaterial(0);
                  t && e && this.markForUpdateRenderData(),
                    this.renderData && (this.renderData.material = e);
                }
                _updateUVs() {
                  this._assembler && this._assembler.updateUVs(this);
                }
                _applySpriteFrame(t) {
                  const e = this._spriteFrame;
                  t &&
                    this._type === GD.SLICED &&
                    t.off(uC.EVENT_UV_UPDATED, this._updateUVs, this);
                  let i = !1;
                  e &&
                    ((t && t.texture === e.texture) || (i = !0),
                    i &&
                      (this.renderData && (this.renderData.textureDirty = !0),
                      (!!t && t.texture instanceof pC) !=
                        e.texture instanceof pC &&
                        (this._instanceMaterialType = -1),
                      this.changeMaterialForDefine()),
                    this._applySpriteSize(),
                    this._type === GD.SLICED &&
                      e.on(uC.EVENT_UV_UPDATED, this._updateUVs, this));
                }
              }).FillType = VD),
              (HD.Type = GD),
              (HD.SizeMode = jD),
              (HD.EventType = WD),
              s(
                (DD = HD).prototype,
                "spriteAtlas",
                [AD],
                Object.getOwnPropertyDescriptor(DD.prototype, "spriteAtlas"),
                DD.prototype
              ),
              s(
                DD.prototype,
                "spriteFrame",
                [CD],
                Object.getOwnPropertyDescriptor(DD.prototype, "spriteFrame"),
                DD.prototype
              ),
              s(
                DD.prototype,
                "type",
                [OD],
                Object.getOwnPropertyDescriptor(DD.prototype, "type"),
                DD.prototype
              ),
              s(
                DD.prototype,
                "fillType",
                [ID],
                Object.getOwnPropertyDescriptor(DD.prototype, "fillType"),
                DD.prototype
              ),
              s(
                DD.prototype,
                "sizeMode",
                [wD],
                Object.getOwnPropertyDescriptor(DD.prototype, "sizeMode"),
                DD.prototype
              ),
              (xD = fa(DD.prototype, "_spriteFrame", [Na], function () {
                return null;
              })),
              (MD = fa(DD.prototype, "_type", [Na], function () {
                return GD.SIMPLE;
              })),
              (PD = fa(DD.prototype, "_fillType", [Na], function () {
                return VD.HORIZONTAL;
              })),
              (ND = fa(DD.prototype, "_sizeMode", [Na], function () {
                return jD.TRIMMED;
              })),
              (LD = fa(DD.prototype, "_fillCenter", [Na], function () {
                return new Ss(0, 0);
              })),
              (BD = fa(DD.prototype, "_fillStart", [Na], function () {
                return 0;
              })),
              (FD = fa(DD.prototype, "_fillRange", [Na], function () {
                return 0;
              })),
              (UD = fa(DD.prototype, "_isTrimmedMode", [Na], function () {
                return !0;
              })),
              (kD = fa(DD.prototype, "_useGrayscale", [Na], function () {
                return !1;
              })),
              (zD = fa(DD.prototype, "_atlas", [Na], function () {
                return null;
              })),
              (RD = DD))
            ) || RD)
        ) || RD);
      var YD, KD, qD, $D, ZD, QD, JD, tx, ex, ix;
      t({ Sprite: XD, SpriteComponent: XD }), (a.Sprite = XD);
      const sx = new ms(),
        nx = new Ss(),
        rx = new ms(),
        ax = [];
      let ox;
      !(function (t) {
        (t[(t.GRAPHICS_RECT = 0)] = "GRAPHICS_RECT"),
          (t[(t.GRAPHICS_ELLIPSE = 1)] = "GRAPHICS_ELLIPSE"),
          (t[(t.GRAPHICS_STENCIL = 2)] = "GRAPHICS_STENCIL"),
          (t[(t.SPRITE_STENCIL = 3)] = "SPRITE_STENCIL");
      })(ox || (ox = {})),
        de(ox);
      let hx =
        ((YD = Ca("cc.Mask")),
        (KD = Ia(110)),
        (qD = ao(ox)),
        YD(
          ($D =
            KD(
              (((ix = class extends np {
                constructor() {
                  super(),
                    (this._type = QD && QD()),
                    (this._inverted = JD && JD()),
                    (this._segments = tx && tx()),
                    (this._alphaThreshold = ex && ex()),
                    (this._sprite = null),
                    (this._graphics = null),
                    (this._stencilStage = QO.DISABLED);
                }
                get type() {
                  return this._type;
                }
                set type(t) {
                  this._type !== t &&
                    ((this._type = t),
                    this._type !== ox.SPRITE_STENCIL
                      ? (this._sprite &&
                          (this.node.removeComponent(XD),
                          this._sprite._destroyImmediate(),
                          (this._sprite = null)),
                        this._changeRenderType(),
                        this._updateGraphics(),
                        this.subComp.renderEntity.setMaskMode(
                          this._inverted ? nI.MASK_INVERTED : nI.MASK
                        ))
                      : (this._graphics &&
                          (this._graphics.clear(),
                          this.node.removeComponent(ED),
                          this._graphics._destroyImmediate(),
                          (this._graphics = null)),
                        this._changeRenderType(),
                        this.subComp.renderEntity.setMaskMode(
                          this._inverted ? nI.MASK_INVERTED : nI.MASK
                        )));
                }
                get inverted() {
                  return this._inverted;
                }
                set inverted(t) {
                  (this._inverted = t),
                    (this.subComp.stencilStage = this.inverted
                      ? QO.ENTER_LEVEL_INVERTED
                      : QO.ENTER_LEVEL),
                    this.subComp.renderEntity.setMaskMode(
                      this._inverted ? nI.MASK_INVERTED : nI.MASK
                    );
                }
                get segments() {
                  return this._segments;
                }
                set segments(t) {
                  this._segments !== t &&
                    ((this._segments = Si(t, 3, 1e4)), this._updateGraphics());
                }
                get spriteFrame() {
                  return this._sprite ? this._sprite.spriteFrame : null;
                }
                set spriteFrame(t) {
                  this._sprite ? (this._sprite.spriteFrame = t) : G(16307);
                }
                get alphaThreshold() {
                  return this._alphaThreshold;
                }
                set alphaThreshold(t) {
                  this._alphaThreshold !== t &&
                    ((this._alphaThreshold = t),
                    this.type === ox.SPRITE_STENCIL && this._sprite) &&
                    this._sprite
                      .getMaterialInstance(0)
                      .setProperty("alphaThreshold", this._alphaThreshold);
                }
                get subComp() {
                  return this._graphics || this._sprite;
                }
                onLoad() {
                  this._changeRenderType(),
                    this.subComp &&
                      this.subComp.renderEntity.setMaskMode(
                        this._inverted ? nI.MASK_INVERTED : nI.MASK
                      );
                }
                onEnable() {
                  this._changeRenderType(),
                    this._updateGraphics(),
                    this._enableRender(),
                    this.node.on(
                      bf.ANCHOR_CHANGED,
                      this._nodeStateChange,
                      this
                    ),
                    this.node.on(bf.SIZE_CHANGED, this._nodeStateChange, this);
                }
                onRestore() {
                  this._changeRenderType(), this._updateGraphics();
                }
                onDisable() {
                  this._disableRender(),
                    this.node.off(
                      bf.ANCHOR_CHANGED,
                      this._nodeStateChange,
                      this
                    ),
                    this.node.off(bf.SIZE_CHANGED, this._nodeStateChange, this);
                }
                onDestroy() {
                  this._removeMaskNode();
                }
                isHit(t) {
                  const e = this.node._uiProps.uiTransformComp,
                    i = e.contentSize,
                    s = i.width,
                    n = i.height,
                    r = nx;
                  this.node.getWorldMatrix(sx),
                    ms.invert(rx, sx),
                    Ss.transformMat4(r, t, rx);
                  const a = e.anchorPoint;
                  (r.x += a.x * s), (r.y += a.y * n);
                  let o = !1;
                  if (
                    this.type === ox.GRAPHICS_RECT ||
                    this.type === ox.GRAPHICS_STENCIL ||
                    this.type === ox.SPRITE_STENCIL
                  )
                    o = r.x >= 0 && r.y >= 0 && r.x <= s && r.y <= n;
                  else if (this.type === ox.GRAPHICS_ELLIPSE) {
                    const t = s / 2,
                      e = n / 2,
                      i = r.x - 0.5 * s,
                      a = r.y - 0.5 * n;
                    o = (i * i) / (t * t) + (a * a) / (e * e) < 1;
                  }
                  return this._inverted && (o = !o), o;
                }
                _nodeStateChange(t) {
                  this._updateGraphics();
                }
                _changeRenderType() {
                  this._type !== ox.SPRITE_STENCIL
                    ? this._createGraphics()
                    : this._createSprite();
                }
                _createSprite() {
                  if (!this._sprite) {
                    let t = (this._sprite = this.node.getComponent(XD));
                    if (!t) {
                      const e = this.node;
                      t = this._sprite = e.addComponent(XD);
                    }
                  }
                  (this._sprite.stencilStage = this.inverted
                    ? QO.ENTER_LEVEL_INVERTED
                    : QO.ENTER_LEVEL),
                    this._sprite.updateMaterial();
                }
                _createGraphics() {
                  if (!this._graphics) {
                    let t = (this._graphics = this.node.getComponent(ED));
                    if (!t) {
                      const e = this.node;
                      t = this._graphics = e.addComponent(ED);
                    }
                    t.lineWidth = 1;
                    const e = Qi.WHITE.clone();
                    (e.a = 0), (t.fillColor = e);
                  }
                  this._graphics.stencilStage = this.inverted
                    ? QO.ENTER_LEVEL_INVERTED
                    : QO.ENTER_LEVEL;
                }
                _updateGraphics() {
                  if (
                    !this._graphics ||
                    (this._type !== ox.GRAPHICS_RECT &&
                      this._type !== ox.GRAPHICS_ELLIPSE)
                  )
                    return;
                  const t = this.node._uiProps.uiTransformComp,
                    e = this._graphics;
                  e.clear();
                  const i = t.contentSize,
                    s = i.width,
                    n = i.height,
                    r = t.anchorPoint,
                    a = -s * r.x,
                    o = -n * r.y;
                  if (this._type === ox.GRAPHICS_RECT) e.rect(a, o, s, n);
                  else if (this._type === ox.GRAPHICS_ELLIPSE) {
                    const t = (function (t, e, i) {
                      ax.length = 0;
                      const s = (2 * Math.PI) / i;
                      for (let n = 0; n < i; ++n)
                        ax.push(
                          new Yi(
                            e.x * Math.cos(s * n) + t.x,
                            e.y * Math.sin(s * n) + t.y,
                            0
                          )
                        );
                      return ax;
                    })(
                      new Yi(a + s / 2, o + n / 2, 0),
                      new Yi(s / 2, n / 2, 0),
                      this._segments
                    );
                    for (let i = 0; i < t.length; ++i) {
                      const s = t[i];
                      0 === i ? e.moveTo(s.x, s.y) : e.lineTo(s.x, s.y);
                    }
                    e.close();
                  }
                  e.fill();
                }
                _enableRender() {
                  this.subComp && (this.subComp.enabled = !0);
                }
                _disableRender() {
                  this.subComp &&
                    ((this.subComp.stencilStage = QO.DISABLED),
                    this.subComp.updateMaterial(),
                    this.node.activeInHierarchy && (this.subComp.enabled = !1));
                }
                _removeMaskNode() {
                  this._sprite && (this._sprite = null),
                    this._graphics && (this._graphics = null);
                }
                get customMaterial() {
                  return (
                    z(9007), this.subComp ? this.subComp.customMaterial : null
                  );
                }
                set customMaterial(t) {
                  z(9007), this.subComp && (this.subComp.customMaterial = t);
                }
                get color() {
                  return z(9007), this.subComp ? this.subComp.color : null;
                }
                set color(t) {
                  z(9007), this.subComp && t && (this.subComp.color = t);
                }
                markForUpdateRenderData(t = !0) {
                  z(9007),
                    this.subComp && this.subComp.markForUpdateRenderData(t);
                }
                requestRenderData(t) {
                  z(9007);
                }
                destroyRenderData() {
                  z(9007);
                }
                updateRenderer() {
                  z(9007), this.subComp && this.subComp.updateRenderer();
                }
                fillBuffers(t) {
                  z(9007);
                }
                postUpdateAssembler(t) {
                  z(9007);
                }
                setNodeDirty() {
                  z(9007), this.subComp && this.subComp.setNodeDirty();
                }
                setTextureDirty() {
                  z(9007), this.subComp && this.subComp.setTextureDirty();
                }
                get sharedMaterial() {
                  return (
                    z(9007), this.subComp ? this.subComp.sharedMaterial : null
                  );
                }
                get sharedMaterials() {
                  return (
                    z(9007), this.subComp ? this.subComp.sharedMaterials : null
                  );
                }
                set sharedMaterials(t) {
                  z(9007),
                    this.subComp && t && (this.subComp.sharedMaterials = t);
                }
                get material() {
                  return z(9007), this.subComp ? this.subComp.material : null;
                }
                set material(t) {
                  z(9007), this.subComp && (this.subComp.material = t);
                }
                get materials() {
                  return (
                    z(9007), this.subComp ? this.subComp.materials : [null]
                  );
                }
                set materials(t) {
                  z(9007), this.subComp && (this.subComp.materials = t);
                }
                getMaterial(t) {
                  return (
                    z(9007),
                    this.subComp ? this.subComp.getSharedMaterial(t) : null
                  );
                }
                setMaterial(t, e) {
                  z(9007), this.subComp && this.subComp.setMaterial(t, e);
                }
                getMaterialInstance(t) {
                  return (
                    z(9007),
                    this.subComp ? this.subComp.getMaterialInstance(t) : null
                  );
                }
                setMaterialInstance(t, e) {
                  z(9007),
                    this.subComp && this.subComp.setMaterialInstance(t, e);
                }
                getRenderMaterial(t) {
                  return (
                    z(9007),
                    this.subComp ? this.subComp.getRenderMaterial(t) : null
                  );
                }
              }).Type = ox),
              s(
                (ZD = ix).prototype,
                "type",
                [qD],
                Object.getOwnPropertyDescriptor(ZD.prototype, "type"),
                ZD.prototype
              ),
              (QD = fa(ZD.prototype, "_type", [Na], function () {
                return ox.GRAPHICS_RECT;
              })),
              (JD = fa(ZD.prototype, "_inverted", [Na], function () {
                return !1;
              })),
              (tx = fa(ZD.prototype, "_segments", [Na], function () {
                return 64;
              })),
              (ex = fa(ZD.prototype, "_alphaThreshold", [Na], function () {
                return 0.1;
              })),
              ($D = ZD))
            ) || $D)
        ) || $D);
      var lx, cx, ux, _x, dx, px;
      t({ Mask: hx, MaskComponent: hx }),
        (Yf._maskComp = hx),
        (a.Mask = hx),
        rt({
          RenderComponent: {
            newName: "UIRenderer",
            since: "1.2.0",
            removed: !0,
          },
          UITransformComponent: {
            newName: "UITransform",
            since: "1.2.0",
            removed: !1,
          },
          CanvasComponent: { newName: "Canvas", since: "1.2.0", removed: !1 },
        }),
        rt({
          UIRenderable: { newName: "UIRenderer", since: "3.0.0", removed: !0 },
        }),
        rt({
          Renderable2D: { newName: "UIRenderer", since: "3.6.0", removed: !1 },
        });
      let mx =
        Ca("cc.PostProcess")(
          (lx =
            wa(
              (((px = class t extends np {
                constructor() {
                  super(),
                    (this.global = ux && ux()),
                    (this._shadingScale = _x && _x()),
                    (this.enableShadingScaleInEditor = dx && dx()),
                    (this.settings = new Map());
                }
                get shadingScale() {
                  return this._shadingScale;
                }
                set shadingScale(t) {
                  this._shadingScale = t;
                }
                addSetting(t) {
                  this.settings.set(t.constructor, t);
                }
                removeSetting(t) {
                  this.settings.delete(t.constructor);
                }
                getSetting(t) {
                  return this.settings.get(t);
                }
                onEnable() {
                  t.all.push(this);
                }
                onDisable() {
                  const e = t.all.indexOf(this);
                  -1 !== e && t.all.splice(e, 1);
                }
              }).all = []),
              (ux = fa((cx = px).prototype, "global", [Ra, Na], function () {
                return !0;
              })),
              (_x = fa(cx.prototype, "_shadingScale", [Na], function () {
                return 1;
              })),
              s(
                cx.prototype,
                "shadingScale",
                [Ra],
                Object.getOwnPropertyDescriptor(cx.prototype, "shadingScale"),
                cx.prototype
              ),
              (dx = fa(
                cx.prototype,
                "enableShadingScaleInEditor",
                [Ra, Na],
                function () {
                  return !1;
                }
              )),
              (lx = cx))
            ) || lx)
        ) || lx;
      var fx,
        gx,
        yx,
        Tx,
        Sx,
        Ex,
        vx,
        bx,
        Ax,
        Cx,
        Ox,
        Ix,
        wx,
        Rx,
        Dx,
        xx,
        Mx,
        Px,
        Nx,
        Lx,
        Bx,
        Fx,
        Ux,
        kx,
        zx,
        Hx,
        Gx,
        Vx,
        jx,
        Wx,
        Xx,
        Yx,
        Kx,
        qx,
        $x;
      const Zx = new Yi(),
        Qx = ce(rg),
        Jx = ce(ng),
        tM = ce(ag),
        eM = ce(hg),
        iM = ce(og),
        sM = ce({
          SKYBOX: _g | Qc.DEPTH_STENCIL,
          SOLID_COLOR: Qc.ALL,
          DEPTH_ONLY: Qc.DEPTH_STENCIL,
          DONT_CLEAR: Qc.NONE,
        });
      let nM =
        ((fx = Ca("cc.Camera")),
        (gx = ao(Rf.BitMask)),
        (yx = ao(sM)),
        (Tx = ao(Qx)),
        (Sx = ao(Jx)),
        (Ex = ao(tM)),
        (vx = ao(eM)),
        (bx = ao(iM)),
        (Ax = ao(pC)),
        (Cx = ao(mx)),
        fx(
          ((($x = class t extends np {
            constructor() {
              super(),
                (this._projection = wx && wx()),
                (this._priority = Rx && Rx()),
                (this._fov = Dx && Dx()),
                (this._fovAxis = xx && xx()),
                (this._orthoHeight = Mx && Mx()),
                (this._near = Px && Px()),
                (this._far = Nx && Nx()),
                (this._color = Lx && Lx()),
                (this._depth = Bx && Bx()),
                (this._stencil = Fx && Fx()),
                (this._clearFlags = Ux && Ux()),
                (this._rect = kx && kx()),
                (this._aperture = zx && zx()),
                (this._shutter = Hx && Hx()),
                (this._iso = Gx && Gx()),
                (this._screenScale = Vx && Vx()),
                (this._visibility = jx && jx()),
                (this._targetTexture = Wx && Wx()),
                (this._postProcess = Xx && Xx()),
                (this._usePostProcess = Yx && Yx()),
                (this._camera = null),
                (this._inEditorMode = !1),
                (this._flows = void 0),
                (this._cameraType = Kx && Kx()),
                (this._trackingType = qx && qx());
            }
            get camera() {
              return this._camera;
            }
            get priority() {
              return this._priority;
            }
            set priority(t) {
              (this._priority = t), this._camera && (this._camera.priority = t);
            }
            get visibility() {
              return this._visibility;
            }
            set visibility(t) {
              (this._visibility = t),
                this._camera && (this._camera.visibility = t);
            }
            get clearFlags() {
              return this._clearFlags;
            }
            set clearFlags(t) {
              (this._clearFlags = t),
                this._camera && (this._camera.clearFlag = t);
            }
            get clearColor() {
              return this._color;
            }
            set clearColor(t) {
              this._color.set(t),
                this._camera && (this._camera.clearColor = this._color);
            }
            get clearDepth() {
              return this._depth;
            }
            set clearDepth(t) {
              (this._depth = t), this._camera && (this._camera.clearDepth = t);
            }
            get clearStencil() {
              return this._stencil;
            }
            set clearStencil(t) {
              (this._stencil = t),
                this._camera && (this._camera.clearStencil = t);
            }
            get projection() {
              return this._projection;
            }
            set projection(t) {
              (this._projection = t),
                this._camera && (this._camera.projectionType = t);
            }
            get fovAxis() {
              return this._fovAxis;
            }
            set fovAxis(t) {
              t !== this._fovAxis &&
                ((this._fovAxis = t),
                this._camera &&
                  ((this._camera.fovAxis = t),
                  t === ng.VERTICAL
                    ? (this.fov = this._fov * this._camera.aspect)
                    : (this.fov = this._fov / this._camera.aspect)));
            }
            get fov() {
              return this._fov;
            }
            set fov(t) {
              (this._fov = t), this._camera && (this._camera.fov = bi(t));
            }
            get orthoHeight() {
              return this._orthoHeight;
            }
            set orthoHeight(t) {
              (this._orthoHeight = t),
                this._camera && (this._camera.orthoHeight = t);
            }
            get near() {
              return this._near;
            }
            set near(t) {
              (this._near = t), this._camera && (this._camera.nearClip = t);
            }
            get far() {
              return this._far;
            }
            set far(t) {
              (this._far = t), this._camera && (this._camera.farClip = t);
            }
            get aperture() {
              return this._aperture;
            }
            set aperture(t) {
              (this._aperture = t), this._camera && (this._camera.aperture = t);
            }
            get shutter() {
              return this._shutter;
            }
            set shutter(t) {
              (this._shutter = t), this._camera && (this._camera.shutter = t);
            }
            get iso() {
              return this._iso;
            }
            set iso(t) {
              (this._iso = t), this._camera && (this._camera.iso = t);
            }
            get rect() {
              return this._rect;
            }
            set rect(t) {
              (this._rect = t),
                this._camera && this._camera.setViewportInOrientedSpace(t);
            }
            get targetTexture() {
              return this._targetTexture;
            }
            set targetTexture(e) {
              if (this._targetTexture === e) return;
              const i = this._targetTexture;
              (this._targetTexture = e),
                this._checkTargetTextureEvent(i),
                this._updateTargetTexture(),
                !e &&
                  this._camera &&
                  (this._camera.changeTargetWindow(null),
                  (this._camera.isWindowSize = !0)),
                this.node.emit(t.TARGET_TEXTURE_CHANGE, this);
            }
            get usePostProcess() {
              return this._usePostProcess;
            }
            set usePostProcess(t) {
              (this._usePostProcess = t),
                this._camera && (this._camera.usePostProcess = t);
            }
            get postProcess() {
              return this._postProcess;
            }
            set postProcess(t) {
              (this._postProcess = t),
                this._camera && (this._camera.postProcess = t);
            }
            get screenScale() {
              return this._screenScale;
            }
            set screenScale(t) {
              (this._screenScale = t),
                this._camera && (this._camera.screenScale = t);
            }
            get inEditorMode() {
              return this._inEditorMode;
            }
            set inEditorMode(t) {
              (this._inEditorMode = t),
                this._camera &&
                  this._camera.changeTargetWindow(
                    t
                      ? a.director.root && a.director.root.mainWindow
                      : a.director.root && a.director.root.tempWindow
                  );
            }
            get cameraType() {
              return this._cameraType;
            }
            set cameraType(t) {
              this._cameraType !== t &&
                ((this._cameraType = t),
                this.camera && (this.camera.cameraType = t));
            }
            get trackingType() {
              return this._trackingType;
            }
            set trackingType(t) {
              this._trackingType !== t &&
                ((this._trackingType = t),
                this.camera && (this.camera.trackingType = t));
            }
            onLoad() {
              this._createCamera();
            }
            onEnable() {
              (this.node.hasChangedFlags |= Cf.POSITION),
                this._camera && this._attachToScene();
            }
            onDisable() {
              this._camera && this._detachFromScene();
            }
            onDestroy() {
              this._camera && (this._camera.destroy(), (this._camera = null)),
                this._targetTexture && this._targetTexture.off("resize");
            }
            screenPointToRay(t, e, i) {
              return (
                i || (i = qs.create()),
                this._camera && this._camera.screenPointToRay(i, t, e),
                i
              );
            }
            worldToScreen(t, e) {
              return (
                e || (e = new Yi()),
                this._camera && this._camera.worldToScreen(e, t),
                e
              );
            }
            screenToWorld(t, e) {
              return (
                e || (e = this.node.getWorldPosition()),
                this._camera && this._camera.screenToWorld(e, t),
                e
              );
            }
            convertToUINode(t, e, i) {
              if ((i || (i = new Yi()), !this._camera)) return i;
              this.worldToScreen(t, Zx);
              const s = e.getComponent("cc.UITransform"),
                n = a.view.getVisibleSize(),
                r = Zx.x - 0.5 * this._camera.width,
                o = Zx.y - 0.5 * this._camera.height;
              return (
                (Zx.x = r / a.view.getScaleX() + 0.5 * n.width),
                (Zx.y = o / a.view.getScaleY() + 0.5 * n.height),
                s && s.convertToNodeSpaceAR(Zx, i),
                i
              );
            }
            _createCamera() {
              if (!this._camera) {
                this._camera = a.director.root.createCamera();
                let t = this._inEditorMode
                  ? a.director.root && a.director.root.mainWindow
                  : a.director.root && a.director.root.tempWindow;
                null != this.node.scene.renderWindow &&
                  (t = this.node.scene.renderWindow),
                  this._camera.initialize({
                    name: this.node.name,
                    node: this.node,
                    projection: this._projection,
                    window: t,
                    priority: this._priority,
                    cameraType: this.cameraType,
                    trackingType: this.trackingType,
                  }),
                  this._camera.setViewportInOrientedSpace(this._rect),
                  (this._camera.fovAxis = this._fovAxis),
                  (this._camera.fov = bi(this._fov)),
                  (this._camera.orthoHeight = this._orthoHeight),
                  (this._camera.nearClip = this._near),
                  (this._camera.farClip = this._far),
                  (this._camera.clearColor = this._color),
                  (this._camera.clearDepth = this._depth),
                  (this._camera.clearStencil = this._stencil),
                  (this._camera.clearFlag = this._clearFlags),
                  (this._camera.visibility = this._visibility),
                  (this._camera.aperture = this._aperture),
                  (this._camera.shutter = this._shutter),
                  (this._camera.iso = this._iso),
                  (this._camera.postProcess = this._postProcess),
                  (this._camera.usePostProcess = this._usePostProcess);
              }
              this._updateTargetTexture();
            }
            _attachToScene() {
              this.node.scene &&
                this._camera &&
                (this._camera &&
                  this._camera.scene &&
                  this._camera.scene.removeCamera(this._camera),
                this._getRenderScene().addCamera(this._camera));
            }
            _detachFromScene() {
              this._camera &&
                this._camera.scene &&
                this._camera.scene.removeCamera(this._camera);
            }
            _checkTargetTextureEvent(t) {
              t && t.off("resize"),
                this._targetTexture &&
                  this._targetTexture.on(
                    "resize",
                    (t) => {
                      this._camera &&
                        this._camera.setFixedSize(t.width, t.height);
                    },
                    this
                  );
            }
            _updateTargetTexture() {
              if (this._camera && this._targetTexture) {
                const t = this._targetTexture.window;
                this._camera.changeTargetWindow(t),
                  this._camera.setFixedSize(t.width, t.height);
              }
            }
          }).ProjectionType = Qx),
          ($x.FOVAxis = Jx),
          ($x.ClearFlag = sM),
          ($x.Aperture = tM),
          ($x.Shutter = eM),
          ($x.ISO = iM),
          ($x.TARGET_TEXTURE_CHANGE = "tex-change"),
          (wx = fa((Ix = $x).prototype, "_projection", [Na], function () {
            return Qx.PERSPECTIVE;
          })),
          (Rx = fa(Ix.prototype, "_priority", [Na], function () {
            return 0;
          })),
          (Dx = fa(Ix.prototype, "_fov", [Na], function () {
            return 45;
          })),
          (xx = fa(Ix.prototype, "_fovAxis", [Na], function () {
            return Jx.VERTICAL;
          })),
          (Mx = fa(Ix.prototype, "_orthoHeight", [Na], function () {
            return 10;
          })),
          (Px = fa(Ix.prototype, "_near", [Na], function () {
            return 1;
          })),
          (Nx = fa(Ix.prototype, "_far", [Na], function () {
            return 1e3;
          })),
          (Lx = fa(Ix.prototype, "_color", [Na], function () {
            return new Qi("#333333");
          })),
          (Bx = fa(Ix.prototype, "_depth", [Na], function () {
            return 1;
          })),
          (Fx = fa(Ix.prototype, "_stencil", [Na], function () {
            return 0;
          })),
          (Ux = fa(Ix.prototype, "_clearFlags", [Na], function () {
            return sM.SOLID_COLOR;
          })),
          (kx = fa(Ix.prototype, "_rect", [Na], function () {
            return new Ds(0, 0, 1, 1);
          })),
          (zx = fa(Ix.prototype, "_aperture", [Na], function () {
            return tM.F16_0;
          })),
          (Hx = fa(Ix.prototype, "_shutter", [Na], function () {
            return eM.D125;
          })),
          (Gx = fa(Ix.prototype, "_iso", [Na], function () {
            return iM.ISO100;
          })),
          (Vx = fa(Ix.prototype, "_screenScale", [Na], function () {
            return 1;
          })),
          (jx = fa(Ix.prototype, "_visibility", [Na], function () {
            return AA;
          })),
          (Wx = fa(Ix.prototype, "_targetTexture", [Na], function () {
            return null;
          })),
          (Xx = fa(Ix.prototype, "_postProcess", [Na], function () {
            return null;
          })),
          (Yx = fa(Ix.prototype, "_usePostProcess", [Na], function () {
            return !1;
          })),
          (Kx = fa(Ix.prototype, "_cameraType", [Na], function () {
            return lg.DEFAULT;
          })),
          (qx = fa(Ix.prototype, "_trackingType", [Na], function () {
            return cg.NO_TRACKING;
          })),
          s(
            Ix.prototype,
            "visibility",
            [gx],
            Object.getOwnPropertyDescriptor(Ix.prototype, "visibility"),
            Ix.prototype
          ),
          s(
            Ix.prototype,
            "clearFlags",
            [yx],
            Object.getOwnPropertyDescriptor(Ix.prototype, "clearFlags"),
            Ix.prototype
          ),
          s(
            Ix.prototype,
            "projection",
            [Tx],
            Object.getOwnPropertyDescriptor(Ix.prototype, "projection"),
            Ix.prototype
          ),
          s(
            Ix.prototype,
            "fovAxis",
            [Sx],
            Object.getOwnPropertyDescriptor(Ix.prototype, "fovAxis"),
            Ix.prototype
          ),
          s(
            Ix.prototype,
            "aperture",
            [Ex],
            Object.getOwnPropertyDescriptor(Ix.prototype, "aperture"),
            Ix.prototype
          ),
          s(
            Ix.prototype,
            "shutter",
            [vx],
            Object.getOwnPropertyDescriptor(Ix.prototype, "shutter"),
            Ix.prototype
          ),
          s(
            Ix.prototype,
            "iso",
            [bx],
            Object.getOwnPropertyDescriptor(Ix.prototype, "iso"),
            Ix.prototype
          ),
          s(
            Ix.prototype,
            "targetTexture",
            [Ax],
            Object.getOwnPropertyDescriptor(Ix.prototype, "targetTexture"),
            Ix.prototype
          ),
          s(
            Ix.prototype,
            "usePostProcess",
            [Ra],
            Object.getOwnPropertyDescriptor(Ix.prototype, "usePostProcess"),
            Ix.prototype
          ),
          s(
            Ix.prototype,
            "postProcess",
            [Cx],
            Object.getOwnPropertyDescriptor(Ix.prototype, "postProcess"),
            Ix.prototype
          ),
          (Ox = Ix))
        ) || Ox);
      var rM;
      t({ Camera: nM, CameraComponent: nM }), (a.Camera = nM);
      let aM = t(
        "RenderRoot2D",
        Ca("cc.RenderRoot2D")(
          (rM =
            Ia(100)(
              (rM =
                Oa(CI)(
                  (rM =
                    wa(
                      (rM = class extends np {
                        onEnable() {
                          a.director.root.batcher2D.addScreen(this);
                        }
                        onDisable() {
                          a.director.root.batcher2D.removeScreen(this);
                        }
                        onDestroy() {
                          a.director.root.batcher2D.removeScreen(this);
                        }
                      })
                    ) || rM)
                ) || rM)
            ) || rM)
        ) || rM
      );
      var oM, hM, lM, cM, uM, _M, dM, pM, mM, fM, gM, yM, TM;
      const SM = new Yi(),
        EM = ce({ OVERLAY: 0, INTERSPERSE: 1 });
      let vM;
      t("OverrideResolutionPolicy", vM),
        (function (t) {
          (t[(t.EXACT_FIT = HA.EXACT_FIT)] = "EXACT_FIT"),
            (t[(t.NO_BORDER = HA.NO_BORDER)] = "NO_BORDER"),
            (t[(t.SHOW_ALL = HA.SHOW_ALL)] = "SHOW_ALL"),
            (t[(t.FIXED_HEIGHT = HA.FIXED_HEIGHT)] = "FIXED_HEIGHT"),
            (t[(t.FIXED_WIDTH = HA.FIXED_WIDTH)] = "FIXED_WIDTH"),
            (t[(t.UNKNOWN = HA.UNKNOWN)] = "UNKNOWN");
        })(vM || t("OverrideResolutionPolicy", (vM = {}))),
        de(vM);
      let bM =
        ((oM = Ca("cc.Canvas")),
        (hM = Ia(100)),
        (lM = ao(nM)),
        (cM = ao(nM)),
        (uM = ao(vM)),
        oM(
          (_M =
            hM(
              (_M =
                wa(
                  (s(
                    (dM = class extends aM {
                      get renderMode() {
                        return this._renderMode;
                      }
                      set renderMode(t) {
                        (this._renderMode = t),
                          this._cameraComponent &&
                            (this._cameraComponent.priority =
                              this._getViewPriority());
                      }
                      get cameraComponent() {
                        return this._cameraComponent;
                      }
                      set cameraComponent(t) {
                        this._cameraComponent !== t &&
                          ((this._cameraComponent = t), this._onResizeCamera());
                      }
                      get alignCanvasWithScreen() {
                        return this._alignCanvasWithScreen;
                      }
                      set alignCanvasWithScreen(t) {
                        (this._alignCanvasWithScreen = t),
                          this._onResizeCamera();
                      }
                      get overrideDesignResolution() {
                        return this._overrideDesignResolution;
                      }
                      set overrideDesignResolution(t) {
                        (this._overrideDesignResolution = t),
                          this.applyOverrideDesignResolutionSettings();
                      }
                      get designResolution() {
                        return this._designResolution;
                      }
                      set designResolution(t) {
                        (this._designResolution = t),
                          (this.overrideDesignResolution = !0);
                      }
                      get overrideResolutionPolicy() {
                        return this._overrideResolutionPolicy;
                      }
                      set overrideResolutionPolicy(t) {
                        (this._overrideResolutionPolicy = t),
                          this.applyOverrideDesignResolutionSettings();
                      }
                      get resolutionPolicy() {
                        return this._resolutionPolicy;
                      }
                      set resolutionPolicy(t) {
                        (this._resolutionPolicy = t),
                          (this.overrideResolutionPolicy = !0);
                      }
                      constructor() {
                        super(),
                          (this._cameraComponent = pM && pM()),
                          (this._alignCanvasWithScreen = mM && mM()),
                          (this._overrideDesignResolution = fM && fM()),
                          (this._designResolution = gM && gM()),
                          (this._overrideResolutionPolicy = yM && yM()),
                          (this._resolutionPolicy = TM && TM()),
                          (this._pos = new Yi()),
                          (this._renderMode = EM.OVERLAY),
                          (this._thisOnCameraResized =
                            this._onResizeCamera.bind(this));
                      }
                      applyOverrideDesignResolutionSettings() {}
                      __preload() {
                        this.applyOverrideDesignResolutionSettings();
                        const t = this.getComponent("cc.Widget");
                        t && t.updateAlignment(),
                          this._cameraComponent &&
                            (this._cameraComponent._createCamera(),
                            this._cameraComponent.node.on(
                              nM.TARGET_TEXTURE_CHANGE,
                              this._thisOnCameraResized
                            )),
                          this._onResizeCamera(),
                          GA.on(
                            "canvas-resize",
                            this._thisOnCameraResized,
                            this
                          ),
                          GA.on(
                            "design-resolution-changed",
                            this._thisOnCameraResized,
                            this
                          );
                      }
                      onEnable() {
                        super.onEnable(),
                          this._cameraComponent &&
                            this._cameraComponent.node.on(
                              nM.TARGET_TEXTURE_CHANGE,
                              this._thisOnCameraResized
                            );
                      }
                      onDisable() {
                        super.onDisable(),
                          this._cameraComponent &&
                            this._cameraComponent.node.off(
                              nM.TARGET_TEXTURE_CHANGE,
                              this._thisOnCameraResized
                            );
                      }
                      onDestroy() {
                        super.onDestroy(),
                          GA.off(
                            "canvas-resize",
                            this._thisOnCameraResized,
                            this
                          ),
                          GA.off(
                            "design-resolution-changed",
                            this._thisOnCameraResized,
                            this
                          );
                      }
                      _onResizeCamera() {
                        if (
                          this._cameraComponent &&
                          this._alignCanvasWithScreen
                        ) {
                          if (this._cameraComponent.targetTexture) {
                            var t, e, i, s, n;
                            let r =
                                null !==
                                  (t = Lv.scenes.get(
                                    null !==
                                      (e =
                                        null === (i = this.cameraComponent) ||
                                        void 0 === i ||
                                        null === (s = i.camera) ||
                                        void 0 === s
                                          ? void 0
                                          : s.systemWindowId) && void 0 !== e
                                      ? e
                                      : 1
                                  )) && void 0 !== t
                                  ? t
                                  : Lv.getScene(),
                              a =
                                null !==
                                  (n = null == r ? void 0 : r.visibleRect) &&
                                void 0 !== n
                                  ? n
                                  : Hr;
                            this._cameraComponent.orthoHeight = a.height / 2;
                          } else {
                            var r, a, o, h, l, c;
                            let t =
                              null !==
                                (r = Lv.scenes.get(
                                  null !==
                                    (a =
                                      null === (o = this.cameraComponent) ||
                                      void 0 === o ||
                                      null === (h = o.camera) ||
                                      void 0 === h
                                        ? void 0
                                        : h.systemWindowId) && void 0 !== a
                                    ? a
                                    : 1
                                )) && void 0 !== r
                                ? r
                                : Lv.getScene();
                            const e =
                                null !==
                                  (l = null == t ? void 0 : t.windowSize) &&
                                void 0 !== l
                                  ? l
                                  : kr.windowSize,
                              i =
                                null !==
                                  (c =
                                    null == t
                                      ? void 0
                                      : t.designResolutionScaleY) &&
                                void 0 !== c
                                  ? c
                                  : GA.getScaleY();
                            this._cameraComponent.orthoHeight =
                              e.height / i / 2;
                          }
                          this.node.getWorldPosition(SM),
                            this._cameraComponent.node.setWorldPosition(
                              SM.x,
                              SM.y,
                              1e3
                            );
                        }
                      }
                      _getViewPriority() {
                        if (this._cameraComponent) {
                          var t;
                          let e =
                            null === (t = this.cameraComponent) || void 0 === t
                              ? void 0
                              : t.priority;
                          return (
                            (e =
                              this._renderMode === EM.OVERLAY
                                ? e | (1 << 30)
                                : e & ~(1 << 30)),
                            e
                          );
                        }
                        return 0;
                      }
                    }).prototype,
                    "cameraComponent",
                    [lM],
                    Object.getOwnPropertyDescriptor(
                      dM.prototype,
                      "cameraComponent"
                    ),
                    dM.prototype
                  ),
                  (pM = fa(dM.prototype, "_cameraComponent", [cM], function () {
                    return null;
                  })),
                  (mM = fa(
                    dM.prototype,
                    "_alignCanvasWithScreen",
                    [Na],
                    function () {
                      return !0;
                    }
                  )),
                  (fM = fa(
                    dM.prototype,
                    "_overrideDesignResolution",
                    [Na],
                    function () {
                      return !1;
                    }
                  )),
                  (gM = fa(
                    dM.prototype,
                    "_designResolution",
                    [Na],
                    function () {
                      return new ws();
                    }
                  )),
                  (yM = fa(
                    dM.prototype,
                    "_overrideResolutionPolicy",
                    [Na],
                    function () {
                      return !1;
                    }
                  )),
                  (TM = fa(
                    dM.prototype,
                    "_resolutionPolicy",
                    [Na],
                    function () {
                      return vM.NO_BORDER;
                    }
                  )),
                  s(
                    dM.prototype,
                    "resolutionPolicy",
                    [uM],
                    Object.getOwnPropertyDescriptor(
                      dM.prototype,
                      "resolutionPolicy"
                    ),
                    dM.prototype
                  ),
                  (_M = dM))
                ) || _M)
            ) || _M)
        ) || _M);
      var AM;
      function CM(t, e, i) {
        const s = t.o,
          n = t.d,
          r = 1 / n.x,
          a = 1 / n.y,
          o = 1 / n.z,
          h = (e.x - s.x) * r,
          l = (i.x - s.x) * r,
          c = (e.y - s.y) * a,
          u = (i.y - s.y) * a,
          _ = (e.z - s.z) * o,
          d = (i.z - s.z) * o,
          p = Math.max(
            Math.max(Math.min(h, l), Math.min(c, u)),
            Math.min(_, d)
          ),
          m = Math.min(
            Math.min(Math.max(h, l), Math.max(c, u)),
            Math.max(_, d)
          );
        return m < 0 || p > m ? 0 : p > 0 ? p : m;
      }
      t({ Canvas: bM, CanvasComponent: bM }),
        (a.Canvas = bM),
        Z(
          t(
            "UIComponent",
            Ca("cc.UIComponent")(
              (AM =
                Oa(CI)(
                  (AM =
                    Ia(110)(
                      (AM =
                        wa(
                          (AM = class extends np {
                            constructor() {
                              super(),
                                (this._lastParent = null),
                                (this.stencilStage = QO.DISABLED);
                            }
                            __preload() {
                              this.node._uiProps.uiComp = this;
                            }
                            onEnable() {}
                            onDisable() {}
                            onDestroy() {
                              this.node._uiProps.uiComp === this &&
                                (this.node._uiProps.uiComp = null);
                            }
                            postUpdateAssembler(t) {}
                            markForUpdateRenderData(t = !0) {}
                            setNodeDirty() {}
                            setTextureDirty() {}
                          })
                        ) || AM)
                    ) || AM)
                ) || AM)
            ) || AM
          ).prototype,
          "UIComponent",
          [{ name: "_visibility" }, { name: "setVisibility" }]
        ),
        $(bM.prototype, "Canvas.prototype", [
          {
            name: "camera",
            newName: "cameraComponent.camera",
            customGetter() {
              var t;
              return null === (t = this._cameraComponent) || void 0 === t
                ? void 0
                : t.camera;
            },
          },
          {
            name: "clearFlag",
            newName: "cameraComponent.clearFlags",
            customGetter() {
              return this._cameraComponent
                ? this._cameraComponent.clearFlags
                : 0;
            },
            customSetter(t) {
              this._cameraComponent && (this._cameraComponent.clearFlags = t);
            },
          },
          {
            name: "color",
            newName: "cameraComponent.clearColor",
            customGetter() {
              return this._cameraComponent
                ? this._cameraComponent.clearColor
                : Qi.BLACK;
            },
            customSetter(t) {
              this._cameraComponent && (this._cameraComponent.clearColor = t);
            },
          },
          {
            name: "priority",
            newName: "cameraComponent.priority",
            customGetter() {
              return this._cameraComponent ? this._cameraComponent.priority : 0;
            },
            customSetter(t) {
              this._cameraComponent && (this._cameraComponent.priority = t);
            },
          },
          {
            name: "targetTexture",
            newName: "cameraComponent.targetTexture",
            customGetter() {
              return this._cameraComponent
                ? this._cameraComponent.targetTexture
                : null;
            },
            customSetter(t) {
              this._cameraComponent &&
                (this._cameraComponent.targetTexture = t);
            },
          },
          {
            name: "visibility",
            newName: "cameraComponent.visibility",
            customGetter() {
              return this._cameraComponent
                ? this._cameraComponent.visibility
                : 0;
            },
          },
        ]),
        Q(CI.prototype, "UITransform.prototype", [
          {
            name: "priority",
            suggest:
              "Please use setSiblingIndex to change index of the current node in its parent's children array.",
          },
        ]),
        (a.UITransformComponent = CI),
        Vt(CI, "cc.UITransformComponent"),
        Vt(ew, "cc.RenderComponent"),
        (a.CanvasComponent = bM),
        Vt(bM, "cc.CanvasComponent"),
        (a.internal.Renderable2D = ew),
        Vt(ew, "cc.Renderable2D");
      const OM = (function () {
          const t = Gn.create(),
            e = { distance: 1 / 0, doubleSided: !1, mode: Hl.ANY };
          let i = 0;
          const s = (t, e, s, n, r, a) => {
            t === Hl.CLOSEST
              ? (i > e || 0 === i) &&
                ((i = e),
                a &&
                  (0 === a.length
                    ? a.push({
                        distance: e,
                        vertexIndex0: s / 3,
                        vertexIndex1: n / 3,
                        vertexIndex2: r / 3,
                      })
                    : ((a[0].distance = e),
                      (a[0].vertexIndex0 = s / 3),
                      (a[0].vertexIndex1 = n / 3),
                      (a[0].vertexIndex2 = r / 3))))
              : ((i = e),
                a &&
                  a.push({
                    distance: e,
                    vertexIndex0: s / 3,
                    vertexIndex1: n / 3,
                    vertexIndex2: r / 3,
                  }));
          };
          return function (n, r, a) {
            if (((i = 0), 0 === r.geometricInfo.positions.length)) return i;
            const o = void 0 === a ? e : a;
            if (
              CM(
                n,
                r.geometricInfo.boundingBox.min,
                r.geometricInfo.boundingBox.max
              )
            ) {
              const e = r.primitiveMode,
                { positions: i, indices: a } = r.geometricInfo;
              ((e, i, n, r, a) => {
                if (n === Gc.TRIANGLE_LIST) {
                  const n = i.length;
                  for (let o = 0; o < n; o += 3) {
                    const n = 3 * i[o],
                      h = 3 * i[o + 1],
                      l = 3 * i[o + 2];
                    Yi.set(t.a, e[n], e[n + 1], e[n + 2]),
                      Yi.set(t.b, e[h], e[h + 1], e[h + 2]),
                      Yi.set(t.c, e[l], e[l + 1], e[l + 2]);
                    const c = Bn.rayTriangle(r, t, a.doubleSided);
                    if (
                      !(0 === c || c > a.distance) &&
                      (s(a.mode, c, n, h, l, a.result), a.mode === Hl.ANY)
                    )
                      return c;
                  }
                } else if (n === Gc.TRIANGLE_STRIP) {
                  const n = i.length - 2;
                  let o = 0;
                  for (let h = 0; h < n; h += 1) {
                    const n = 3 * i[h - o],
                      l = 3 * i[h + o + 1],
                      c = 3 * i[h + 2];
                    Yi.set(t.a, e[n], e[n + 1], e[n + 2]),
                      Yi.set(t.b, e[l], e[l + 1], e[l + 2]),
                      Yi.set(t.c, e[c], e[c + 1], e[c + 2]),
                      (o = ~o);
                    const u = Bn.rayTriangle(r, t, a.doubleSided);
                    if (
                      !(0 === u || u > a.distance) &&
                      (s(a.mode, u, n, l, c, a.result), a.mode === Hl.ANY)
                    )
                      return u;
                  }
                } else if (n === Gc.TRIANGLE_FAN) {
                  const n = i.length - 1,
                    o = 3 * i[0];
                  Yi.set(t.a, e[o], e[o + 1], e[o + 2]);
                  for (let h = 1; h < n; h += 1) {
                    const n = 3 * i[h],
                      l = 3 * i[h + 1];
                    Yi.set(t.b, e[n], e[n + 1], e[n + 2]),
                      Yi.set(t.c, e[l], e[l + 1], e[l + 2]);
                    const c = Bn.rayTriangle(r, t, a.doubleSided);
                    if (
                      !(0 === c || c > a.distance) &&
                      (s(a.mode, c, o, n, l, a.result), a.mode === Hl.ANY)
                    )
                      return c;
                  }
                }
              })(i, a, e, n, o);
            }
            return i;
          };
        })(),
        IM = (function () {
          let t = 0;
          const e = { distance: 1 / 0, doubleSided: !1, mode: Hl.ANY };
          return function (i, s, n) {
            t = 0;
            const r = void 0 === n ? e : n,
              a = s.renderingSubMeshes.length,
              o = s.struct.minPosition,
              h = s.struct.maxPosition;
            if (o && h && !CM(i, o, h)) return t;
            for (let e = 0; e < a; e++) {
              const n = s.renderingSubMeshes[e],
                a = OM(i, n, r);
              if (a)
                if (r.mode === Hl.CLOSEST)
                  (0 === t || t > a) &&
                    ((t = a), r.subIndices && (r.subIndices[0] = e));
                else if (
                  ((t = a),
                  r.subIndices && r.subIndices.push(e),
                  r.mode === Hl.ANY)
                )
                  return a;
            }
            return (
              t &&
                r.mode === Hl.CLOSEST &&
                (r.result &&
                  ((r.result[0].distance = t), (r.result.length = 1)),
                r.subIndices && (r.subIndices.length = 1)),
              t
            );
          };
        })(),
        wM = (function () {
          let t = 0;
          const e = { distance: 1 / 0, doubleSided: !1, mode: Hl.ANY },
            i = new qs(),
            s = new ms();
          return function (n, r, a) {
            t = 0;
            const o = void 0 === a ? e : a,
              h = r.worldBounds;
            if (h && !Bn.rayAABB(n, h)) return t;
            qs.copy(i, n),
              r.node &&
                (ms.invert(s, r.node.getWorldMatrix(s)),
                Yi.transformMat4(i.o, n.o, s),
                Yi.transformMat4Normal(i.d, n.d, s));
            const l = r.subModels;
            for (let e = 0; e < l.length; e++) {
              const s = l[e].subMesh,
                n = OM(i, s, o);
              if (n)
                if (o.mode === Hl.CLOSEST)
                  (0 === t || t > n) &&
                    ((t = n), o.subIndices && (o.subIndices[0] = e));
                else if (
                  ((t = n),
                  o.subIndices && o.subIndices.push(e),
                  o.mode === Hl.ANY)
                )
                  return n;
            }
            return (
              t &&
                o.mode === Hl.CLOSEST &&
                (o.result &&
                  ((o.result[0].distance = t), (o.result.length = 1)),
                o.subIndices && (o.subIndices.length = 1)),
              t
            );
          };
        })();
      var RM, DM, xM;
      (Bn.rayModel = wM),
        (Bn.raySubMesh = OM),
        (Bn.rayMesh = IM),
        DA("specular-pass");
      let MM =
        Ca("cc.ModelRenderer")(
          ((DM = class extends HI {
            constructor() {
              super(),
                (this._visFlags = xM && xM()),
                (this._models = []),
                (this._priority = 0);
            }
            get visibility() {
              return this._visFlags;
            }
            set visibility(t) {
              (this._visFlags = t), this._onVisibilityChange(t);
            }
            get priority() {
              return this._priority;
            }
            set priority(t) {
              t !== this._priority &&
                ((this._priority = t), this._updatePriority());
            }
            _collectModels() {
              return this._models;
            }
            onEnable() {
              this._updatePriority();
            }
            _attachToScene() {}
            _detachFromScene() {}
            _onVisibilityChange(t) {}
            _updatePriority() {
              if (this._models.length > 0)
                for (let t = 0; t < this._models.length; t++)
                  this._models[t].priority = this._priority;
            }
          }),
          (xM = fa(DM.prototype, "_visFlags", [Na], function () {
            return Rf.Enum.NONE;
          })),
          (RM = DM))
        ) || RM;
      var PM, NM, LM, BM, FM;
      t({ ModelRenderer: MM, RenderableComponent: MM });
      const { ccclass: UM, serializable: kM, type: zM, visible: HM } = go;
      var GM,
        VM,
        jM,
        WM,
        XM,
        YM,
        KM,
        qM,
        $M,
        ZM,
        QM,
        JM,
        tP,
        eP,
        iP,
        sP,
        nP,
        rP,
        aP,
        oP,
        hP,
        lP,
        cP,
        uP,
        _P,
        dP,
        pP,
        mP,
        fP,
        gP,
        yP,
        TP,
        SP,
        EP,
        vP,
        bP,
        AP;
      t(
        "PrefabLink",
        ((PM = UM("cc.PrefabLink")),
        (NM = zM(eE)),
        PM(
          ((BM = class extends np {
            constructor() {
              super(), (this.prefab = FM && FM());
            }
          }),
          (FM = fa(BM.prototype, "prefab", [NM, kM], function () {
            return null;
          })),
          (LM = BM))
        ) || LM)
      ),
        $(nM, "Camera", [{ name: "CameraClearFlag", newName: "ClearFlag" }]),
        $(nM.prototype, "Camera.prototype", [
          { name: "color", newName: "clearColor" },
          { name: "depth", newName: "clearDepth" },
          { name: "stencil", newName: "clearStencil" },
        ]),
        Q(HI.prototype, "Renderer.prototype", [
          {
            name: "getMaterial",
            suggest: "please use renderer.getSharedMaterial instead.",
          },
        ]),
        (a.CameraComponent = nM),
        Vt(nM, "cc.CameraComponent"),
        (a.RenderableComponent = MM),
        Vt(MM, "cc.RenderableComponent"),
        (function (t) {
          (t[(t.SIMPLE = 0)] = "SIMPLE"),
            (t[(t.SLICED = 1)] = "SLICED"),
            (t[(t.TILED = 2)] = "TILED");
        })(JM || (JM = {})),
        t(
          "SpriteRenderer",
          ((GM = Ca("cc.SpriteRenderer")),
          (VM = Ia(100)),
          (jM = ao(uC)),
          GM(
            (WM =
              VM(
                (s(
                  (XM = class extends MM {
                    constructor() {
                      super(),
                        (this._spriteFrame = YM && YM()),
                        (this._mode = KM && KM()),
                        (this._color = qM && qM()),
                        (this._flipX = $M && $M()),
                        (this._flipY = ZM && ZM()),
                        (this._size = QM && QM()),
                        (this._model = null);
                    }
                    get spriteFrame() {
                      return this._spriteFrame;
                    }
                    set spriteFrame(t) {
                      this._spriteFrame !== t &&
                        (this._spriteFrame,
                        (this._spriteFrame = t),
                        this._spriteFrame &&
                          (this._spriteFrame.ensureMeshData(),
                          this._spriteFrame.mesh.initialize()),
                        this._updateModels(),
                        this.enabledInHierarchy && this._attachToScene());
                    }
                    get model() {
                      return this._model;
                    }
                    onLoad() {
                      this._spriteFrame &&
                        (this._spriteFrame.mesh ||
                          this._spriteFrame.ensureMeshData(),
                        this._spriteFrame.mesh.initialize()),
                        this._updateModels();
                    }
                    onRestore() {
                      this._updateModels(),
                        this.enabledInHierarchy && this._attachToScene();
                    }
                    onEnable() {
                      super.onEnable(),
                        this._model || this._updateModels(),
                        this._attachToScene();
                    }
                    onDisable() {
                      this._model && this._detachFromScene();
                    }
                    onDestroy() {
                      this._model &&
                        (a.director.root.destroyModel(this._model),
                        (this._model = null),
                        (this._models.length = 0));
                    }
                    _updateModels() {
                      if (!this._spriteFrame) return;
                      const t = this._model;
                      if (
                        (t
                          ? (t.destroy(),
                            t.initialize(),
                            (t.node = t.transform = this.node))
                          : this._createModel(),
                        this._model)
                      ) {
                        const t = this._spriteFrame.mesh;
                        this._model.createBoundingShape(
                          t.struct.minPosition,
                          t.struct.maxPosition
                        ),
                          this._updateModelParams(),
                          this._onUpdateLocalDescriptorSet();
                      }
                    }
                    _createModel() {
                      const t = (this._model = a.director.root.createModel(tg));
                      (t.visFlags = this.visibility),
                        (t.node = t.transform = this.node),
                        (this._models.length = 0),
                        this._models.push(this._model);
                    }
                    _updateModelParams() {
                      if (!this._spriteFrame || !this._model) return;
                      this._spriteFrame.ensureMeshData();
                      const t = this._spriteFrame.mesh;
                      (this.node.hasChangedFlags |= Cf.POSITION),
                        (this._model.transform.hasChangedFlags |= Cf.POSITION);
                      const e = t ? t.renderingSubMeshes : null;
                      if (e) {
                        const t = e.length;
                        for (let i = 0; i < t; ++i) {
                          let t = this.getRenderMaterial(i);
                          t && !t.isValid && (t = null);
                          const s = e[i];
                          s &&
                            this._model.initSubModel(
                              i,
                              s,
                              t || this._getBuiltinMaterial()
                            );
                        }
                      }
                      this._model.enabled = !0;
                    }
                    _getBuiltinMaterial() {
                      return Pv.get("missing-material");
                    }
                    _onMaterialModified(t, e) {
                      super._onMaterialModified(t, e),
                        this._spriteFrame &&
                          this._model &&
                          this._model.inited &&
                          this._onRebuildPSO(
                            t,
                            e || this._getBuiltinMaterial()
                          );
                    }
                    _onRebuildPSO(t, e) {
                      this._model &&
                        this._model.inited &&
                        (this._model.setSubModelMaterial(t, e),
                        this._onUpdateLocalDescriptorSet());
                    }
                    _onUpdateLocalDescriptorSet() {
                      if (
                        !this._spriteFrame ||
                        !this._model ||
                        !this._model.inited
                      )
                        return;
                      const t = this._spriteFrame.getGFXTexture(),
                        e = this._spriteFrame.getGFXSampler(),
                        i = this._model.subModels,
                        s = ab.SAMPLER_SPRITE;
                      for (let n = 0; n < i.length; n++) {
                        const { descriptorSet: r } = i[n];
                        r.bindTexture(s, t), r.bindSampler(s, e), r.update();
                      }
                    }
                    _attachToScene() {
                      if (!this.node.scene || !this._model) return;
                      const t = this._getRenderScene();
                      null !== this._model.scene && this._detachFromScene(),
                        t.addModel(this._model);
                    }
                    _detachFromScene() {
                      this._model &&
                        this._model.scene &&
                        this._model.scene.removeModel(this._model);
                    }
                  }).prototype,
                  "spriteFrame",
                  [jM],
                  Object.getOwnPropertyDescriptor(XM.prototype, "spriteFrame"),
                  XM.prototype
                ),
                (YM = fa(XM.prototype, "_spriteFrame", [Na], function () {
                  return null;
                })),
                (KM = fa(XM.prototype, "_mode", [Na], function () {
                  return JM.SIMPLE;
                })),
                (qM = fa(XM.prototype, "_color", [Na], function () {
                  return Qi.WHITE.clone();
                })),
                ($M = fa(XM.prototype, "_flipX", [Na], function () {
                  return !1;
                })),
                (ZM = fa(XM.prototype, "_flipY", [Na], function () {
                  return !1;
                })),
                (QM = fa(XM.prototype, "_size", [Na], function () {
                  return new Ss();
                })),
                (WM = XM))
              ) || WM)
          ) || WM)
        );
      const CP = new lO(),
        OP = "RICHTEXT_CHILD",
        IP = "RICHTEXT_Image_CHILD",
        wP = new Ss(),
        RP = new Ss(),
        DP = new $t((t) => {
          if (!a.isValid(t.node)) return !1;
          {
            const e = t.node.getComponent(Ww);
            e && (e.outlineWidth = 0);
          }
          return !0;
        }, 20),
        xP = new $t((t) => a.isValid(t.node), 10);
      function MP(t) {
        return {
          node: new Pf(t),
          comp: null,
          lineCount: 0,
          styleIndex: 0,
          imageOffset: "",
          clickParam: "",
          clickHandler: "",
          type: t,
        };
      }
      function PP(t, e) {
        let i;
        t === OP ? (i = DP._get()) : t === IP && (i = xP._get()),
          (i = i || MP(t));
        let s = i.node;
        return (
          s || (s = new Pf(t)),
          (s.hideFlags |= $n.Flags.DontSave | $n.Flags.HideInHierarchy),
          (s.active = !0),
          t === IP
            ? ((i.comp = s.getComponent(XD) || s.addComponent(XD)),
              (i.comp.spriteFrame = e),
              (i.comp.type = XD.Type.SLICED),
              (i.comp.sizeMode = XD.SizeMode.CUSTOM))
            : ((i.comp = s.getComponent(Ww) || s.addComponent(Ww)),
              (i.comp.string = e),
              (i.comp.horizontalAlign = Hw.LEFT),
              (i.comp.verticalAlign = Gw.TOP),
              (i.comp.underlineHeight = 2)),
          s.setPosition(0, 0, 0),
          s._uiProps.uiTransformComp.setAnchorPoint(0.5, 0.5),
          (i.node = s),
          (i.lineCount = 0),
          (i.styleIndex = 0),
          (i.imageOffset = ""),
          (i.clickParam = ""),
          (i.clickHandler = ""),
          i
        );
      }
      let NP =
        ((tP = Ca("cc.RichText")),
        (eP = Ia(110)),
        (iP = ao(Hw)),
        (sP = ao(Gw)),
        (nP = ao(Qi)),
        (rP = ao(bC)),
        (aP = ao(jw)),
        (oP = ao(EC)),
        tP(
          (hP =
            eP(
              (((AP = class extends np {
                get string() {
                  return this._string;
                }
                set string(t) {
                  this._string !== t &&
                    ((this._string = t), this._updateRichTextStatus());
                }
                get horizontalAlign() {
                  return this._horizontalAlign;
                }
                set horizontalAlign(t) {
                  this.horizontalAlign !== t &&
                    ((this._horizontalAlign = t),
                    (this._layoutDirty = !0),
                    this._updateRichTextStatus());
                }
                get verticalAlign() {
                  return this._verticalAlign;
                }
                set verticalAlign(t) {
                  this._verticalAlign !== t &&
                    ((this._verticalAlign = t),
                    (this._layoutDirty = !0),
                    this._updateRichTextStatus());
                }
                get fontSize() {
                  return this._fontSize;
                }
                set fontSize(t) {
                  this._fontSize !== t &&
                    ((this._fontSize = t),
                    (this._layoutDirty = !0),
                    this._updateRichTextStatus());
                }
                get fontColor() {
                  return this._fontColor;
                }
                set fontColor(t) {
                  this._fontColor !== t &&
                    ((this._fontColor = t), this._updateTextDefaultColor());
                }
                get fontFamily() {
                  return this._fontFamily;
                }
                set fontFamily(t) {
                  this._fontFamily !== t &&
                    ((this._fontFamily = t),
                    (this._layoutDirty = !0),
                    this._updateRichTextStatus());
                }
                get font() {
                  return this._font;
                }
                set font(t) {
                  this._font !== t &&
                    ((this._font = t),
                    (this._layoutDirty = !0),
                    this._font
                      ? ((this.useSystemFont = !1), this._onTTFLoaded())
                      : (this.useSystemFont = !0),
                    this._updateRichTextStatus());
                }
                get useSystemFont() {
                  return this._isSystemFontUsed;
                }
                set useSystemFont(t) {
                  this._isSystemFontUsed !== t &&
                    ((this._isSystemFontUsed = t),
                    (this._layoutDirty = !0),
                    this._updateRichTextStatus());
                }
                get cacheMode() {
                  return this._cacheMode;
                }
                set cacheMode(t) {
                  this._cacheMode !== t &&
                    ((this._cacheMode = t), this._updateRichTextStatus());
                }
                get maxWidth() {
                  return this._maxWidth;
                }
                set maxWidth(t) {
                  this._maxWidth !== t &&
                    ((this._maxWidth = t),
                    (this._layoutDirty = !0),
                    this._updateRichTextStatus());
                }
                get lineHeight() {
                  return this._lineHeight;
                }
                set lineHeight(t) {
                  this._lineHeight !== t &&
                    ((this._lineHeight = t),
                    (this._layoutDirty = !0),
                    this._updateRichTextStatus());
                }
                get imageAtlas() {
                  return this._imageAtlas;
                }
                set imageAtlas(t) {
                  this._imageAtlas !== t &&
                    ((this._imageAtlas = t),
                    (this._layoutDirty = !0),
                    this._updateRichTextStatus());
                }
                get handleTouchEvent() {
                  return this._handleTouchEvent;
                }
                set handleTouchEvent(t) {
                  this._handleTouchEvent !== t &&
                    ((this._handleTouchEvent = t),
                    this.enabledInHierarchy &&
                      (this.handleTouchEvent
                        ? this._addEventListeners()
                        : this._removeEventListeners()));
                }
                constructor() {
                  super(),
                    (this._lineHeight = cP && cP()),
                    (this._string = uP && uP()),
                    (this._horizontalAlign = _P && _P()),
                    (this._verticalAlign = dP && dP()),
                    (this._fontSize = pP && pP()),
                    (this._fontColor = mP && mP()),
                    (this._maxWidth = fP && fP()),
                    (this._fontFamily = gP && gP()),
                    (this._font = yP && yP()),
                    (this._isSystemFontUsed = TP && TP()),
                    (this._userDefinedFont = SP && SP()),
                    (this._cacheMode = EP && EP()),
                    (this._imageAtlas = vP && vP()),
                    (this._handleTouchEvent = bP && bP()),
                    (this._textArray = []),
                    (this._segments = []),
                    (this._labelSegmentsCache = []),
                    (this._linesWidth = []),
                    (this._lineCount = 1),
                    (this._labelWidth = 0),
                    (this._labelHeight = 0),
                    (this._layoutDirty = !0),
                    (this._lineOffsetX = 0),
                    (this._labelChildrenNum = 0),
                    (this._updateRichTextStatus = this._updateRichText);
                }
                onLoad() {
                  this.node.on(bf.LAYER_CHANGED, this._applyLayer, this),
                    this.node.on(
                      bf.ANCHOR_CHANGED,
                      this._updateRichTextPosition,
                      this
                    );
                }
                onEnable() {
                  this.handleTouchEvent && this._addEventListeners(),
                    this._updateRichText(),
                    this._activateChildren(!0);
                }
                onDisable() {
                  this.handleTouchEvent && this._removeEventListeners(),
                    this._activateChildren(!1);
                }
                onRestore() {}
                onDestroy() {
                  for (const t of this._segments)
                    t.node.removeFromParent(),
                      t.type === OP ? DP.put(t) : t.type === IP && xP.put(t);
                  this.node.off(
                    bf.ANCHOR_CHANGED,
                    this._updateRichTextPosition,
                    this
                  ),
                    this.node.off(bf.LAYER_CHANGED, this._applyLayer, this);
                }
                _addEventListeners() {
                  this.node.on(bf.TOUCH_END, this._onTouchEnded, this);
                }
                _removeEventListeners() {
                  this.node.off(bf.TOUCH_END, this._onTouchEnded, this);
                }
                _updateLabelSegmentTextAttributes() {
                  this._segments.forEach((t) => {
                    this._applyTextAttribute(t);
                  });
                }
                _createFontLabel(t) {
                  return PP(OP, t);
                }
                _createImage(t) {
                  return PP(IP, t);
                }
                _onTTFLoaded() {
                  this._font, (this._layoutDirty = !0), this._updateRichText();
                }
                getLineCount() {
                  return this._lineCount;
                }
                splitLongStringApproximatelyIn2048(t, e) {
                  t.length, this.fontSize;
                  const i = [];
                  return i.push(t), i;
                }
                splitLongStringOver2048(t, e) {
                  const i = [],
                    s = t;
                  let n = 0,
                    r = s.length / 2,
                    a = s.substring(n, r),
                    o = s.substring(r);
                  const h = this._calculateSize(wP, e, a),
                    l = this._calculateSize(RP, e, o);
                  let c = this._maxWidth;
                  0 === this._maxWidth && (c = 2047.9);
                  const u = 1 * c;
                  for (; h.x > u; ) {
                    if (((r /= 2), r < 1)) {
                      r *= 2;
                      break;
                    }
                    (a = a.substring(n, r)),
                      (o = s.substring(r)),
                      this._calculateSize(h, e, a);
                  }
                  let _ = 1e3,
                    d = 1;
                  for (; _ && n < t.length; ) {
                    for (; _ && h.x < u; ) {
                      const t = YC(o);
                      t && t.length > 0 && (d = t[0].length),
                        (r += d),
                        (a = s.substring(n, r)),
                        (o = s.substring(r)),
                        this._calculateSize(h, e, a),
                        _--;
                    }
                    for (; _ && a.length >= 2 && h.x > u; )
                      (r -= d),
                        (a = s.substring(n, r)),
                        this._calculateSize(h, e, a),
                        (d = 1),
                        _--;
                    if (a.length >= 2) {
                      const t = KC(a);
                      t &&
                        t.length > 0 &&
                        a !== t[0] &&
                        ((r -= t[0].length), (a = s.substring(n, r)));
                    }
                    if (
                      (i.push(a),
                      (n = r),
                      (r += a.length),
                      (a = s.substring(n, r)),
                      (o = s.substring(r)),
                      this._calculateSize(l, e, o),
                      this._calculateSize(h, e, a),
                      _--,
                      l.x < 2048 && h.x < u)
                    ) {
                      i.push(a),
                        (n = t.length),
                        (r = t.length),
                        (a = o),
                        "" !== o && i.push(a);
                      break;
                    }
                  }
                  return i;
                }
                _measureText(t, e) {
                  const i = (e) => this._calculateSize(wP, t, e).x;
                  return e ? i(e) : i;
                }
                _calculateSize(t, e, i) {
                  let s;
                  0 === this._labelSegmentsCache.length
                    ? ((s = this._createFontLabel(i)),
                      this._labelSegmentsCache.push(s))
                    : ((s = this._labelSegmentsCache[0]),
                      (s.node.getComponent(Ww).string = i)),
                    (s.styleIndex = e),
                    this._applyTextAttribute(s);
                  const n = s.node._uiProps.uiTransformComp.contentSize;
                  return Ss.set(t, n.x, n.y), t;
                }
                _onTouchEnded(t) {
                  const e = this.node.getComponents(np);
                  for (const i of this._segments) {
                    const s = i.clickHandler,
                      n = i.clickParam;
                    s &&
                      this._containsTouchLocation(i, t.touch.getUILocation()) &&
                      (e.forEach((e) => {
                        const i = e[s];
                        e.enabledInHierarchy && i && i.call(e, t, n);
                      }),
                      (t.propagationStopped = !0));
                  }
                }
                _containsTouchLocation(t, e) {
                  const i = t.node.getComponent(CI);
                  return !!i && i.getBoundingBoxToWorld().contains(e);
                }
                _resetState() {
                  const t = this.node.children;
                  for (let e = t.length - 1; e >= 0; e--) {
                    const i = t[e];
                    if (i.name === OP || i.name === IP) {
                      i.parent = null;
                      const t = MP(i.name);
                      (t.node = i),
                        i.name === OP
                          ? ((t.comp = i.getComponent(Ww)), DP.put(t))
                          : ((t.comp = i.getComponent(XD)), xP.put(t)),
                        this._labelChildrenNum--;
                    }
                  }
                  (this._segments.length = 0),
                    (this._labelSegmentsCache.length = 0),
                    (this._linesWidth.length = 0),
                    (this._lineOffsetX = 0),
                    (this._lineCount = 1),
                    (this._labelWidth = 0),
                    (this._labelHeight = 0),
                    (this._layoutDirty = !0);
                }
                _activateChildren(t) {
                  for (let e = this.node.children.length - 1; e >= 0; e--) {
                    const i = this.node.children[e];
                    (i.name !== OP && i.name !== IP) || (i.active = t);
                  }
                }
                _addLabelSegment(t, e) {
                  let i;
                  if (0 === this._labelSegmentsCache.length)
                    i = this._createFontLabel(t);
                  else {
                    i = this._labelSegmentsCache.pop();
                    const e = i.node.getComponent(Ww);
                    e && (e.string = t);
                  }
                  const s = i.comp;
                  return (
                    s.verticalAlign !== this._verticalAlign &&
                      (s.verticalAlign = this._verticalAlign),
                    (i.styleIndex = e),
                    (i.lineCount = this._lineCount),
                    i.node._uiProps.uiTransformComp.setAnchorPoint(0, 0),
                    (i.node.layer = this.node.layer),
                    this.node.insertChild(i.node, this._labelChildrenNum++),
                    this._applyTextAttribute(i),
                    this._segments.push(i),
                    i
                  );
                }
                _updateRichTextWithMaxWidth(t, e, i) {
                  let s,
                    n = e;
                  if (
                    this._lineOffsetX > 0 &&
                    n + this._lineOffsetX > this._maxWidth
                  ) {
                    let e = 0;
                    for (; this._lineOffsetX <= this._maxWidth; ) {
                      const s = this._getFirstWordLen(t, e, t.length),
                        r = t.substr(e, s),
                        a = this._measureText(i, r);
                      if (!(this._lineOffsetX + a <= this._maxWidth)) {
                        if (e > 0) {
                          const s = t.substr(0, e);
                          this._addLabelSegment(s, i),
                            (t = t.substr(e, t.length)),
                            (n = this._measureText(i, t));
                        }
                        this._updateLineInfo();
                        break;
                      }
                      (this._lineOffsetX += a), (e += s);
                    }
                  }
                  if (n > this._maxWidth) {
                    const e = qC(t, n, this._maxWidth, this._measureText(i));
                    for (let t = 0; t < e.length; ++t) {
                      const n = e[t];
                      s = this._addLabelSegment(n, i);
                      const r = s.node._uiProps.uiTransformComp.contentSize;
                      (this._lineOffsetX += r.width),
                        e.length > 1 &&
                          t < e.length - 1 &&
                          this._updateLineInfo();
                    }
                  } else (this._lineOffsetX += n), this._addLabelSegment(t, i);
                }
                _isLastComponentCR(t) {
                  return t.length - 1 === t.lastIndexOf("\n");
                }
                _updateLineInfo() {
                  this._linesWidth.push(this._lineOffsetX),
                    (this._lineOffsetX = 0),
                    this._lineCount++;
                }
                _needsUpdateTextLayout(t) {
                  if (this._layoutDirty || !this._textArray || !t) return !0;
                  if (this._textArray.length !== t.length) return !0;
                  for (let e = 0; e < this._textArray.length; e++) {
                    const i = this._textArray[e],
                      s = t[e];
                    if (i.text !== s.text) return !0;
                    {
                      const t = i.style,
                        e = s.style;
                      if (t) {
                        if (e) {
                          if (!!e.outline != !!t.outline) return !0;
                          if (
                            t.size !== e.size ||
                            t.italic !== e.italic ||
                            t.isImage !== e.isImage
                          )
                            return !0;
                          if (
                            t.src !== e.src ||
                            t.imageAlign !== e.imageAlign ||
                            t.imageHeight !== e.imageHeight ||
                            t.imageWidth !== e.imageWidth ||
                            t.imageOffset !== e.imageOffset
                          )
                            return !0;
                        } else if (t.size || t.italic || t.isImage || t.outline)
                          return !0;
                      } else if (
                        e &&
                        (e.size || e.italic || e.isImage || e.outline)
                      )
                        return !0;
                    }
                  }
                  return !1;
                }
                _addRichTextImageElement(t) {
                  if (!t.style) return;
                  const e = t.style,
                    i = e.src,
                    s =
                      this._imageAtlas &&
                      i &&
                      this._imageAtlas.getSpriteFrame(i);
                  if (s) {
                    const t = this._createImage(s);
                    switch ((t.comp, e.imageAlign)) {
                      case "top":
                        t.node._uiProps.uiTransformComp.setAnchorPoint(0, 1);
                        break;
                      case "center":
                        t.node._uiProps.uiTransformComp.setAnchorPoint(0, 0.5);
                        break;
                      default:
                        t.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);
                    }
                    e.imageOffset && (t.imageOffset = e.imageOffset),
                      (t.node.layer = this.node.layer),
                      this.node.insertChild(t.node, this._labelChildrenNum++),
                      this._segments.push(t);
                    const i = s.rect.clone();
                    let n = 1,
                      r = i.width,
                      a = i.height;
                    const o = e.imageWidth || 0,
                      h = e.imageHeight || 0;
                    h > 0
                      ? ((n = h / a), (r *= n), (a *= n))
                      : ((n = this._lineHeight / a), (r *= n), (a *= n)),
                      o > 0 && (r = o),
                      this._maxWidth > 0
                        ? (this._lineOffsetX + r > this._maxWidth &&
                            this._updateLineInfo(),
                          (this._lineOffsetX += r))
                        : ((this._lineOffsetX += r),
                          this._lineOffsetX > this._labelWidth &&
                            (this._labelWidth = this._lineOffsetX)),
                      t.node._uiProps.uiTransformComp.setContentSize(r, a),
                      (t.lineCount = this._lineCount),
                      (t.clickHandler = ""),
                      (t.clickParam = "");
                    const l = e.event;
                    l && ((t.clickHandler = l.click), (t.clickParam = l.param));
                  } else z(4400);
                }
                _updateTextDefaultColor() {
                  for (let i = 0; i < this._segments.length; ++i) {
                    var t, e;
                    const s = this._segments[i],
                      n = s.node.getComponent(Ww);
                    n &&
                      ((null !== (t = this._textArray[s.styleIndex]) &&
                        void 0 !== t &&
                        null !== (e = t.style) &&
                        void 0 !== e &&
                        e.color) ||
                        (n.color = this._fontColor));
                  }
                }
                _updateRichText() {
                  if (!this.enabledInHierarchy) return;
                  const t = CP.parse(this._string);
                  if (!this._needsUpdateTextLayout(t))
                    return (
                      (this._textArray = t.slice()),
                      void this._updateLabelSegmentTextAttributes()
                    );
                  (this._textArray = t.slice()), this._resetState();
                  let e,
                    i = !1;
                  for (let t = 0; t < this._textArray.length; ++t) {
                    const s = this._textArray[t];
                    let n = s.text;
                    if (void 0 === n) continue;
                    if ("" === n) {
                      if (s.style && s.style.isNewLine) {
                        this._updateLineInfo();
                        continue;
                      }
                      if (s.style && s.style.isImage && this._imageAtlas) {
                        this._addRichTextImageElement(s);
                        continue;
                      }
                    }
                    n = this.splitLongStringApproximatelyIn2048(n, t).join(
                      "\n"
                    );
                    const r = n.split("\n");
                    for (let s = 0; s < r.length; ++s) {
                      const a = r[s];
                      if ("" !== a)
                        if (((i = !1), this._maxWidth > 0)) {
                          const e = this._measureText(t, a);
                          this._updateRichTextWithMaxWidth(a, e, t),
                            r.length > 1 &&
                              s < r.length - 1 &&
                              this._updateLineInfo();
                        } else
                          (e = this._addLabelSegment(a, t)),
                            (this._lineOffsetX +=
                              e.node._uiProps.uiTransformComp.width),
                            this._lineOffsetX > this._labelWidth &&
                              (this._labelWidth = this._lineOffsetX),
                            r.length > 1 &&
                              s < r.length - 1 &&
                              this._updateLineInfo();
                      else {
                        if (this._isLastComponentCR(n) && s === r.length - 1)
                          continue;
                        this._updateLineInfo(), (i = !0);
                      }
                    }
                  }
                  i || this._linesWidth.push(this._lineOffsetX),
                    this._maxWidth > 0 && (this._labelWidth = this._maxWidth),
                    (this._labelHeight =
                      (this._lineCount + wC) * this._lineHeight),
                    this.node._uiProps.uiTransformComp.setContentSize(
                      this._labelWidth,
                      this._labelHeight
                    ),
                    this._updateRichTextPosition(),
                    (this._layoutDirty = !1);
                }
                _getFirstWordLen(t, e, i) {
                  let s = GC(t, e);
                  if (UC(s) || kC(s)) return 1;
                  let n = 1;
                  for (
                    let r = e + 1;
                    r < i && ((s = GC(t, r)), !kC(s) && !UC(s));
                    ++r
                  )
                    n++;
                  return n;
                }
                _updateRichTextPosition() {
                  let t = 0,
                    e = 1;
                  const i = this._lineCount,
                    s = this.node._uiProps.uiTransformComp,
                    n = s.anchorX,
                    r = s.anchorY;
                  for (let s = 0; s < this._segments.length; ++s) {
                    const a = this._segments[s],
                      o = a.lineCount;
                    o > e && ((t = 0), (e = o));
                    let h =
                      this._labelWidth * (0.5 * this._horizontalAlign - n);
                    switch (this._horizontalAlign) {
                      case Hw.LEFT:
                        break;
                      case Hw.CENTER:
                        h -= this._linesWidth[o - 1] / 2;
                        break;
                      case Hw.RIGHT:
                        h -= this._linesWidth[o - 1];
                    }
                    const l = a.node.position;
                    if (
                      (a.node.setPosition(
                        t + h,
                        this._lineHeight * (i - o) - this._labelHeight * r,
                        l.z
                      ),
                      o === e && (t += a.node._uiProps.uiTransformComp.width),
                      a.node.getComponent(XD))
                    ) {
                      const t = a.node.position.clone(),
                        e = this._lineHeight,
                        i = this._lineHeight * (1 + wC);
                      switch (a.node._uiProps.uiTransformComp.anchorY) {
                        case 1:
                          t.y += e + (i - e) / 2;
                          break;
                        case 0.5:
                          t.y += i / 2;
                          break;
                        default:
                          t.y += (i - e) / 2;
                      }
                      if (a.imageOffset) {
                        const e = a.imageOffset.split(",");
                        if (1 === e.length && e[0]) {
                          const i = parseFloat(e[0]);
                          Number.isInteger(i) && (t.y += i);
                        } else if (2 === e.length) {
                          const i = parseFloat(e[0]),
                            s = parseFloat(e[1]);
                          Number.isInteger(i) && (t.x += i),
                            Number.isInteger(s) && (t.y += s);
                        }
                      }
                      a.node.position = t;
                    }
                    const c = a.node.getComponent(Ww);
                    if (c && c.enableOutline) {
                      const t = a.node.position.clone();
                      (t.y -= c.outlineWidth), (a.node.position = t);
                    }
                  }
                }
                _convertLiteralColorValue(t) {
                  const e = t.toUpperCase();
                  return Qi[e] ? Qi[e] : new Qi().fromHEX(t);
                }
                _applyTextAttribute(t) {
                  const e = t.node.getComponent(Ww);
                  if (!e) return;
                  this._resetLabelState(e);
                  const i = t.styleIndex;
                  let s;
                  if (
                    (this._textArray[i] && (s = this._textArray[i].style), s)
                  ) {
                    if (
                      (s.color
                        ? (e.color = this._convertLiteralColorValue(s.color))
                        : (e.color = this._fontColor),
                      (e.isBold = !!s.bold),
                      (e.isItalic = !!s.italic),
                      (e.isUnderline = !!s.underline),
                      s.outline)
                    ) {
                      let e = t.node.getComponent(Ww);
                      e || (e = t.node.addComponent(Ww)),
                        (e.enableOutline = !0),
                        (e.outlineColor = this._convertLiteralColorValue(
                          s.outline.color
                        )),
                        (e.outlineWidth = s.outline.width);
                    }
                    (e.fontSize = s.size || this._fontSize),
                      (t.clickHandler = ""),
                      (t.clickParam = "");
                    const i = s.event;
                    i &&
                      ((t.clickHandler = i.click || ""),
                      (t.clickParam = i.param || ""));
                  }
                  (e.cacheMode = this._cacheMode),
                    this._font instanceof bC && !this._isSystemFontUsed
                      ? (e.font = this._font)
                      : (e.fontFamily = this._fontFamily),
                    (e.useSystemFont = this._isSystemFontUsed),
                    (e.lineHeight = this._lineHeight),
                    e.updateRenderData(!0);
                }
                _applyLayer() {
                  for (const t of this._segments)
                    t.node.layer = this.node.layer;
                }
                _resetLabelState(t) {
                  (t.fontSize = this._fontSize),
                    (t.color = this._fontColor),
                    (t.isBold = !1),
                    (t.isItalic = !1),
                    (t.isUnderline = !1);
                }
              }).HorizontalAlign = Hw),
              (AP.VerticalAlign = Gw),
              s(
                (lP = AP).prototype,
                "horizontalAlign",
                [iP],
                Object.getOwnPropertyDescriptor(
                  lP.prototype,
                  "horizontalAlign"
                ),
                lP.prototype
              ),
              s(
                lP.prototype,
                "verticalAlign",
                [sP],
                Object.getOwnPropertyDescriptor(lP.prototype, "verticalAlign"),
                lP.prototype
              ),
              s(
                lP.prototype,
                "fontColor",
                [nP],
                Object.getOwnPropertyDescriptor(lP.prototype, "fontColor"),
                lP.prototype
              ),
              s(
                lP.prototype,
                "font",
                [rP],
                Object.getOwnPropertyDescriptor(lP.prototype, "font"),
                lP.prototype
              ),
              s(
                lP.prototype,
                "cacheMode",
                [aP],
                Object.getOwnPropertyDescriptor(lP.prototype, "cacheMode"),
                lP.prototype
              ),
              s(
                lP.prototype,
                "imageAtlas",
                [oP],
                Object.getOwnPropertyDescriptor(lP.prototype, "imageAtlas"),
                lP.prototype
              ),
              (cP = fa(lP.prototype, "_lineHeight", [Na], function () {
                return 40;
              })),
              (uP = fa(lP.prototype, "_string", [Na], function () {
                return "<color=#00ff00>Rich</color><color=#0fffff>Text</color>";
              })),
              (_P = fa(lP.prototype, "_horizontalAlign", [Na], function () {
                return Hw.LEFT;
              })),
              (dP = fa(lP.prototype, "_verticalAlign", [Na], function () {
                return Gw.TOP;
              })),
              (pP = fa(lP.prototype, "_fontSize", [Na], function () {
                return 40;
              })),
              (mP = fa(lP.prototype, "_fontColor", [Na], function () {
                return Qi.WHITE.clone();
              })),
              (fP = fa(lP.prototype, "_maxWidth", [Na], function () {
                return 0;
              })),
              (gP = fa(lP.prototype, "_fontFamily", [Na], function () {
                return "Arial";
              })),
              (yP = fa(lP.prototype, "_font", [Na], function () {
                return null;
              })),
              (TP = fa(lP.prototype, "_isSystemFontUsed", [Na], function () {
                return !0;
              })),
              (SP = fa(lP.prototype, "_userDefinedFont", [Na], function () {
                return null;
              })),
              (EP = fa(lP.prototype, "_cacheMode", [Na], function () {
                return jw.NONE;
              })),
              (vP = fa(lP.prototype, "_imageAtlas", [Na], function () {
                return null;
              })),
              (bP = fa(lP.prototype, "_handleTouchEvent", [Na], function () {
                return !0;
              })),
              (hP = lP))
            ) || hP)
        ) || hP);
      var LP;
      t({ RichText: NP, RichTextComponent: NP }), (a.RichText = NP);
      let BP =
        Ca("cc.UIMeshRenderer")(
          (LP =
            Ia(110)(
              (LP = class extends np {
                constructor() {
                  super(),
                    (this._modelComponent = null),
                    (this._dirtyVersion = -1),
                    (this._internalId = -1),
                    (this.stencilStage = QO.DISABLED),
                    (this._renderData = null),
                    (this._renderEntity = new oI(tI.DYNAMIC)),
                    (this._UIModelNativeProxy = new GO());
                }
                get modelComponent() {
                  return this._modelComponent;
                }
                __preload() {
                  this.node._uiProps.uiComp = this;
                }
                onEnable() {
                  iE.addRenderer(this), this.markForUpdateRenderData();
                }
                onDisable() {
                  iE.removeRenderer(this),
                    (this.renderEntity.enabled = this._canRender());
                }
                onLoad() {
                  this.node._uiProps.uiTransformComp ||
                    this.node.addComponent("cc.UITransform"),
                    (this._modelComponent =
                      this.getComponent("cc.ModelRenderer")),
                    this._modelComponent
                      ? (this._UIModelNativeProxy.attachNode(this.node),
                        this.renderEntity.setNode(this.node))
                      : z(16378, this.node ? this.node.name : "");
                }
                onDestroy() {
                  this.renderEntity.setNode(null),
                    this.node._uiProps.uiComp === this &&
                      (this.node._uiProps.uiComp = null),
                    (this._modelComponent =
                      this.getComponent("cc.ModelRenderer")),
                    this._modelComponent &&
                      (this._modelComponent._sceneGetter = null);
                }
                _render(t) {
                  if (this._modelComponent) {
                    const e = this._modelComponent._collectModels();
                    this._modelComponent._detachFromScene();
                    for (let i = 0; i < e.length; i++)
                      e[i].enabled &&
                        t.commitModel(
                          this,
                          e[i],
                          this._modelComponent.material
                        );
                    return !0;
                  }
                  return !1;
                }
                fillBuffers(t) {
                  this.enabled && this._render(t);
                }
                updateRenderer() {
                  if (
                    ((this.renderEntity.enabled = this._canRender()),
                    this._modelComponent)
                  ) {
                    const t = this._modelComponent._collectModels();
                    this._modelComponent._detachFromScene(),
                      this._UIModelNativeProxy.clearModels(),
                      this._renderEntity.clearDynamicRenderDrawInfos();
                    for (let e = 0; e < t.length; e++)
                      t[e].enabled &&
                        (this._uploadRenderData(e),
                        this._UIModelNativeProxy.updateModels(t[e]));
                    this._UIModelNativeProxy.attachDrawInfo();
                  }
                }
                _uploadRenderData(t) {
                  {
                    const e = uI.add();
                    e.initRenderDrawInfo(this, ZO.MODEL),
                      (this._renderData = e),
                      (this._renderData.material =
                        this._modelComponent.getMaterialInstance(t));
                  }
                }
                postUpdateAssembler(t) {}
                update() {
                  this._modelComponent && this.markForUpdateRenderData(),
                    this._fitUIRenderQueue();
                }
                _fitUIRenderQueue() {
                  if (!this._modelComponent) return;
                  const t = this._modelComponent.sharedMaterials.length;
                  for (let e = 0; e < t; e++) {
                    const t = this._modelComponent.getMaterialInstance(e);
                    if (null == t) continue;
                    const i = t.passes,
                      s = i.length;
                    for (let e = 0; e < s; e++)
                      i[e].setPriority(tb.MAX - 11),
                        t.recompileShaders({ CC_FORCE_FORWARD_SHADING: !0 }, e);
                  }
                }
                markForUpdateRenderData(t = !0) {
                  iE.markDirtyRenderer(this);
                }
                setNodeDirty() {}
                setTextureDirty() {}
                _canRender() {
                  return this.enabled && null !== this._modelComponent;
                }
                get renderEntity() {
                  return this._renderEntity;
                }
                get renderData() {
                  return this._renderData;
                }
              })
            ) || LP)
        ) || LP;
      var FP;
      t({ UIMeshRenderer: BP, UIModelComponent: BP }), (a.UIMeshRenderer = BP);
      let UP =
        Ca("cc.LabelOutline")(
          (FP =
            Ia(110)(
              (FP =
                Oa(Ww)(
                  (FP = class extends np {
                    get color() {
                      return this.node.getComponent(Ww).outlineColor;
                    }
                    set color(t) {
                      this.node.getComponent(Ww).outlineColor = t;
                    }
                    get width() {
                      return this.node.getComponent(Ww).outlineWidth;
                    }
                    set width(t) {
                      this.node.getComponent(Ww).outlineWidth = t;
                    }
                    onEnable() {
                      this.node.getComponent(Ww).enableOutline = !0;
                    }
                    onDisable() {
                      this.node.getComponent(Ww).enableOutline = !1;
                    }
                  })
                ) || FP)
            ) || FP)
        ) || FP;
      t({ LabelOutline: UP, LabelOutlineComponent: UP }), (a.LabelOutline = UP);
      const kP = Rf.Enum.NONE | Rf.Enum.UI_3D;
      class zP {
        constructor() {
          (this.model = null),
            (this.texture = null),
            (this.sampler = null),
            (this.useLocalData = null),
            (this.isStatic = !1),
            (this.textureHash = 0),
            (this.samplerHash = 0),
            (this._passes = []),
            (this._shaders = []),
            (this._visFlags = kP),
            (this._inputAssembler = null),
            (this._descriptorSet = null);
        }
        get inputAssembler() {
          return this._inputAssembler;
        }
        set inputAssembler(t) {
          this._inputAssembler = t;
        }
        get descriptorSet() {
          return this._descriptorSet;
        }
        set descriptorSet(t) {
          this._descriptorSet = t;
        }
        get visFlags() {
          return this._visFlags;
        }
        set visFlags(t) {
          this._visFlags = t;
        }
        get passes() {
          return this._passes;
        }
        get shaders() {
          return this._shaders;
        }
        destroy(t) {
          this._passes = [];
        }
        clear() {
          (this._inputAssembler = null),
            (this._descriptorSet = null),
            (this.texture = null),
            (this.sampler = null),
            (this.textureHash = 0),
            (this.samplerHash = 0),
            (this.model = null),
            (this.isStatic = !1),
            (this.useLocalData = null),
            (this.visFlags = kP);
        }
        fillPasses(t, e, i, s) {
          if (t) {
            const n = t.passes;
            if (!n) return;
            this._shaders.length = n.length;
            for (let t = 0; t < n.length; t++) {
              this._passes[t] || (this._passes[t] = new hR(a.director.root));
              const r = n[t],
                o = this._passes[t];
              r.update(),
                e || ((e = r.depthStencilState), (i = 0)),
                o._initPassFromTarget(r, e, i),
                (this._shaders[t] = o.getShaderVariant(s));
            }
          }
        }
      }
      var HP, GP;
      let VP =
        Ca("cc.UIStaticBatch")(
          (HP =
            Ia(110)(
              (s(
                (GP = class extends ew {
                  constructor() {
                    super(),
                      (this._init = !1),
                      (this._bufferAccessor = null),
                      (this._dirty = !0),
                      (this._uiDrawBatchList = []);
                  }
                  get color() {
                    return this._color;
                  }
                  set color(t) {
                    this._color !== t && this._color.set(t);
                  }
                  get drawBatchList() {
                    return this._uiDrawBatchList;
                  }
                  postUpdateAssembler(t) {}
                  markAsDirty() {}
                  _requireDrawBatch() {
                    const t = new zP();
                    return (t.isStatic = !0), this._uiDrawBatchList.push(t), t;
                  }
                  _clearData() {
                    if (this._bufferAccessor) {
                      this._bufferAccessor.reset();
                      const t = this._getBatcher();
                      for (let e = 0; e < this._uiDrawBatchList.length; e++)
                        this._uiDrawBatchList[e].destroy(t);
                    }
                    (this._uiDrawBatchList.length = 0), (this._init = !1);
                  }
                  _getBatcher() {
                    return Lv.root && Lv.root.batcher2D
                      ? Lv.root.batcher2D
                      : (z(9301), null);
                  }
                }).prototype,
                "color",
                [oo],
                Object.getOwnPropertyDescriptor(GP.prototype, "color"),
                GP.prototype
              ),
              (HP = GP))
            ) || HP)
        ) || HP;
      var jP;
      t({ UIStaticBatch: VP, UIStaticBatchComponent: VP });
      let WP = t(
        "LabelShadow",
        Ca("cc.LabelShadow")(
          (jP =
            Ia(110)(
              (jP =
                Oa(Ww)(
                  (jP = class extends np {
                    get color() {
                      return this.node.getComponent(Ww).shadowColor;
                    }
                    set color(t) {
                      this.node.getComponent(Ww).shadowColor = t;
                    }
                    get offset() {
                      return this.node.getComponent(Ww).shadowOffset;
                    }
                    set offset(t) {
                      this.node.getComponent(Ww).shadowOffset = t;
                    }
                    get blur() {
                      return this.node.getComponent(Ww).shadowBlur;
                    }
                    set blur(t) {
                      this.node.getComponent(Ww).shadowBlur = t;
                    }
                    onEnable() {
                      this.node.getComponent(Ww).enableShadow = !0;
                    }
                    onDisable() {
                      this.node.getComponent(Ww).enableShadow = !1;
                    }
                  })
                ) || jP)
            ) || jP)
        ) || jP
      );
      var XP, YP, KP;
      let qP =
        Ca("cc.UIOpacity")(
          (XP =
            Ia(110)(
              (XP =
                wa(
                  ((YP = class t extends np {
                    constructor() {
                      super(),
                        (this._parentOpacity = 1),
                        (this._parentOpacityResetFlag = !0),
                        (this._opacity = KP && KP());
                    }
                    get opacity() {
                      return this._opacity;
                    }
                    set opacity(t) {
                      this._opacity !== t &&
                        ((t = Si(t, 0, 255)),
                        (this._opacity = t),
                        (this.node._uiProps.localOpacity = t / 255),
                        this.setEntityLocalOpacityDirtyRecursively(!0));
                    }
                    setEntityLocalOpacityDirtyRecursively(e) {
                      t.setEntityLocalOpacityDirtyRecursively(
                        this.node,
                        e,
                        this._parentOpacity,
                        !1
                      );
                    }
                    static setEntityLocalOpacityDirtyRecursively(e, i, s, n) {
                      if (!e.isValid) return;
                      const r = e.getComponent(t);
                      if (r && n) return void (r._parentOpacity = s);
                      let a = e._uiProps.uiComp;
                      if ((a || (a = e.getComponent(ew)), a && a.color))
                        return (
                          (a.renderEntity.colorDirty = i),
                          r
                            ? ((r._parentOpacity = s),
                              (a.renderEntity.localOpacity =
                                (s * r.opacity) / 255))
                            : (a.renderEntity.localOpacity = s),
                          void (a.node._uiProps.localOpacity =
                            a.renderEntity.localOpacity)
                        );
                      r &&
                        ((r._parentOpacity = s), (s = (s * r.opacity) / 255));
                      const o = e.children;
                      for (let e = 0, r = o.length; e < r; ++e)
                        t.setEntityLocalOpacityDirtyRecursively(
                          o[e],
                          i || s < 1,
                          s,
                          n
                        );
                    }
                    _getParentOpacity(e) {
                      if (null == e || !e.isValid) return 1;
                      const i = e._uiProps.uiComp,
                        s = e.getComponent(t);
                      return i && i.color
                        ? 1
                        : s
                        ? s._parentOpacity * (s._opacity / 255)
                        : this._getParentOpacity(e.getParent());
                    }
                    _parentChanged() {
                      const e = this.node.getParent();
                      let i = 1;
                      e
                        ? ((this._parentOpacity = this._getParentOpacity(e)),
                          (i = this._parentOpacity))
                        : (this._parentOpacityResetFlag = !0),
                        t.setEntityLocalOpacityDirtyRecursively(
                          this.node,
                          !0,
                          i,
                          !1
                        );
                    }
                    _setEntityLocalOpacityRecursively(e) {
                      const i = this.node._uiProps.uiComp;
                      if (i && i.color)
                        return (
                          (i.renderEntity.colorDirty = !0),
                          (i.renderEntity.localOpacity = e),
                          void (i.node._uiProps.localOpacity = e)
                        );
                      for (const i of this.node.children)
                        t.setEntityLocalOpacityDirtyRecursively(i, !0, e, !0);
                    }
                    onEnable() {
                      this.node.on(
                        bf.PARENT_CHANGED,
                        this._parentChanged,
                        this
                      ),
                        (this.node._uiProps.localOpacity =
                          (this._parentOpacity * this._opacity) / 255),
                        this._parentOpacityResetFlag
                          ? (this._parentChanged(),
                            (this._parentOpacityResetFlag = !1))
                          : this._setEntityLocalOpacityRecursively(
                              this.node._uiProps.localOpacity
                            );
                    }
                    onDisable() {
                      this.node.off(
                        bf.PARENT_CHANGED,
                        this._parentChanged,
                        this
                      ),
                        (this.node._uiProps.localOpacity = 1),
                        this._setEntityLocalOpacityRecursively(
                          this.node._uiProps.localOpacity
                        );
                    }
                  }),
                  (KP = fa(YP.prototype, "_opacity", [Na], function () {
                    return 255;
                  })),
                  (XP = YP))
                ) || XP)
            ) || XP)
        ) || XP;
      t({ UIOpacity: qP, UIOpacityComponent: qP }),
        (a.MaskComponent = hx),
        Vt(hx, "cc.MaskComponent"),
        (a.LabelComponent = Ww),
        Vt(Ww, "cc.LabelComponent"),
        (a.LabelOutlineComponent = UP),
        Vt(UP, "cc.LabelOutlineComponent"),
        (a.RichTextComponent = NP),
        Vt(NP, "cc.RichTextComponent"),
        (a.SpriteComponent = XD),
        Vt(XD, "cc.SpriteComponent"),
        (a.UIModelComponent = BP),
        Vt(BP, "cc.UIModelComponent"),
        (a.GraphicsComponent = ED),
        Vt(ED, "cc.GraphicsComponent"),
        Vt(VP, "cc.UIStaticBatchComponent"),
        Vt(qP, "cc.UIOpacityComponent"),
        $(hx.prototype, "Mask", [
          {
            name: "graphics",
            newName: "subComp",
            target: hx.prototype,
            targetName: "Mask",
          },
        ]),
        $(ox, "MaskType", [
          {
            name: "RECT",
            newName: "GRAPHICS_RECT",
            target: ox,
            targetName: "MaskType",
          },
          {
            name: "ELLIPSE",
            newName: "GRAPHICS_ELLIPSE",
            target: ox,
            targetName: "MaskType",
          },
          {
            name: "IMAGE_STENCIL",
            newName: "SPRITE_STENCIL",
            target: ox,
            targetName: "MaskType",
          },
        ]),
        Q(UP.prototype, "LabelOutline", [
          { name: "width", suggest: "Please use Label.outlineWidth instead." },
          { name: "color", suggest: "Please use Label.outlineColor instead." },
        ]),
        Q(WP.prototype, "LabelShadow", [
          { name: "color", suggest: "Please use Label.shadowColor instead." },
          { name: "offset", suggest: "Please use Label.shadowOffset instead." },
          { name: "blur", suggest: "Please use Label.shadowBlur instead." },
        ]);
      class $P {
        constructor(t, e, i) {
          (this.prev = null),
            (this.next = null),
            (this.z = null),
            (this.prevZ = null),
            (this.nextZ = null),
            (this.steiner = !1),
            (this.i = t),
            (this.x = e),
            (this.y = i);
        }
      }
      function ZP(t, e, i, s, n) {
        let r = 0,
          a = null;
        if (
          n ===
          (function (t, e, i, s) {
            let n = 0;
            for (let r = e, a = i - s; r < i; r += s)
              (n += (t[a] - t[r]) * (t[r + 1] + t[a + 1])), (a = r);
            return n;
          })(t, e, i, s) >
            0
        )
          for (r = e; r < i; r += s) a = mN(r, t[r], t[r + 1], a);
        else for (r = i - s; r >= e; r -= s) a = mN(r, t[r], t[r + 1], a);
        return a && uN(a, a.next) && (fN(a), (a = a.next)), a;
      }
      function QP(t, e = null) {
        if (!t) return t;
        e || (e = t);
        let i = t,
          s = !1;
        do {
          if (
            ((s = !1),
            i.steiner || (!uN(i, i.next) && 0 !== cN(i.prev, i, i.next)))
          )
            i = i.next;
          else {
            if ((fN(i), (i = e = i.prev), i === i.next)) return null;
            s = !0;
          }
        } while (s || i !== e);
        return e;
      }
      function JP(t, e, i, s, n, r, a = 0) {
        if (!t) return;
        !a &&
          r &&
          (function (t, e, i, s) {
            let n = t;
            do {
              null === n.z && (n.z = aN(n.x, n.y, e, i, s)),
                (n.prevZ = n.prev),
                (n.nextZ = n.next),
                (n = n.next);
            } while (n !== t);
            (n.prevZ.nextZ = null),
              (n.prevZ = null),
              (function (t) {
                let e = 0,
                  i = null,
                  s = null,
                  n = null,
                  r = null,
                  a = 0,
                  o = 0,
                  h = 0,
                  l = 1;
                do {
                  for (i = t, t = null, r = null, a = 0; i; ) {
                    for (
                      a++, s = i, o = 0, e = 0;
                      e < l && (o++, (s = s.nextZ), s);
                      e++
                    );
                    for (h = l; o > 0 || (h > 0 && s); )
                      0 === o
                        ? ((n = s), (s = s.nextZ), h--)
                        : 0 !== h && s
                        ? i.z <= s.z
                          ? ((n = i), (i = i.nextZ), o--)
                          : ((n = s), (s = s.nextZ), h--)
                        : ((n = i), (i = i.nextZ), o--),
                        r ? (r.nextZ = n) : (t = n),
                        (n.prevZ = r),
                        (r = n);
                    i = s;
                  }
                  (r.nextZ = null), (l *= 2);
                } while (a > 1);
              })(n);
          })(t, s, n, r);
        let o = t,
          h = null,
          l = null;
        for (; t.prev !== t.next; )
          if (((h = t.prev), (l = t.next), r ? eN(t, s, n, r) : tN(t)))
            e.push(h.i / i),
              e.push(t.i / i),
              e.push(l.i / i),
              fN(t),
              (t = l.next),
              (o = l.next);
          else if ((t = l) === o) {
            a
              ? 1 === a
                ? JP((t = iN(t, e, i)), e, i, s, n, r, 2)
                : 2 === a && sN(t, e, i, s, n, r)
              : JP(QP(t), e, i, s, n, r, 1);
            break;
          }
      }
      function tN(t) {
        const e = t.prev,
          i = t,
          s = t.next;
        if (cN(e, i, s) >= 0) return !1;
        let n = t.next.next;
        for (; n !== t.prev; ) {
          if (
            hN(e.x, e.y, i.x, i.y, s.x, s.y, n.x, n.y) &&
            cN(n.prev, n, n.next) >= 0
          )
            return !1;
          n = n.next;
        }
        return !0;
      }
      function eN(t, e, i, s) {
        const n = t.prev,
          r = t,
          a = t.next;
        if (cN(n, r, a) >= 0) return !1;
        const o = n.x < r.x ? (n.x < a.x ? n.x : a.x) : r.x < a.x ? r.x : a.x,
          h = n.y < r.y ? (n.y < a.y ? n.y : a.y) : r.y < a.y ? r.y : a.y,
          l = n.x > r.x ? (n.x > a.x ? n.x : a.x) : r.x > a.x ? r.x : a.x,
          c = n.y > r.y ? (n.y > a.y ? n.y : a.y) : r.y > a.y ? r.y : a.y,
          u = aN(o, h, e, i, s),
          _ = aN(l, c, e, i, s);
        let d = t.nextZ;
        for (; d && d.z <= _; ) {
          if (
            d !== t.prev &&
            d !== t.next &&
            hN(n.x, n.y, r.x, r.y, a.x, a.y, d.x, d.y) &&
            cN(d.prev, d, d.next) >= 0
          )
            return !1;
          d = d.nextZ;
        }
        for (d = t.prevZ; d && d.z >= u; ) {
          if (
            d !== t.prev &&
            d !== t.next &&
            hN(n.x, n.y, r.x, r.y, a.x, a.y, d.x, d.y) &&
            cN(d.prev, d, d.next) >= 0
          )
            return !1;
          d = d.prevZ;
        }
        return !0;
      }
      function iN(t, e, i) {
        let s = t;
        do {
          const n = s.prev,
            r = s.next.next;
          !uN(n, r) &&
            _N(n, s, s.next, r) &&
            dN(n, r) &&
            dN(r, n) &&
            (e.push(n.i / i),
            e.push(s.i / i),
            e.push(r.i / i),
            fN(s),
            fN(s.next),
            (s = t = r)),
            (s = s.next);
        } while (s !== t);
        return s;
      }
      function sN(t, e, i, s, n, r) {
        let a = t;
        do {
          let t = a.next.next;
          for (; t !== a.prev; ) {
            if (a.i !== t.i && lN(a, t)) {
              let o = pN(a, t);
              return (
                (a = QP(a, a.next)),
                (o = QP(o, o.next)),
                JP(a, e, i, s, n, r),
                void JP(o, e, i, s, n, r)
              );
            }
            t = t.next;
          }
          a = a.next;
        } while (a !== t);
      }
      function nN(t, e) {
        return t.x - e.x;
      }
      function rN(t, e) {
        if (
          (e = (function (t, e) {
            let i = e;
            const s = t.x,
              n = t.y;
            let r = -1 / 0,
              a = null;
            do {
              if (n <= i.y && n >= i.next.y) {
                const t =
                  i.x + ((n - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
                if (t <= s && t > r) {
                  if (((r = t), t === s)) {
                    if (n === i.y) return i;
                    if (n === i.next.y) return i.next;
                  }
                  a = i.x < i.next.x ? i : i.next;
                }
              }
              i = i.next;
            } while (i !== e);
            if (!a) return null;
            if (s === r) return a.prev;
            const o = a,
              h = a.x,
              l = a.y;
            let c,
              u = 1 / 0;
            for (i = a.next; i !== o; )
              s >= i.x &&
                i.x >= h &&
                hN(n < l ? s : r, n, h, l, n < l ? r : s, n, i.x, i.y) &&
                ((c = Math.abs(n - i.y) / (s - i.x)),
                (c < u || (c === u && i.x > a.x)) &&
                  dN(i, t) &&
                  ((a = i), (u = c))),
                (i = i.next);
            return a;
          })(t, e))
        ) {
          const i = pN(e, t);
          QP(i, i.next);
        }
      }
      function aN(t, e, i, s, n) {
        return (
          (t =
            1431655765 &
            ((t =
              858993459 &
              ((t =
                252645135 &
                ((t = 16711935 & ((t = (32767 * (t - i)) / n) | (t << 8))) |
                  (t << 4))) |
                (t << 2))) |
              (t << 1))) |
          ((e =
            1431655765 &
            ((e =
              858993459 &
              ((e =
                252645135 &
                ((e = 16711935 & ((e = (32767 * (e - s)) / n) | (e << 8))) |
                  (e << 4))) |
                (e << 2))) |
              (e << 1))) <<
            1)
        );
      }
      function oN(t) {
        let e = t,
          i = t;
        do {
          e.x < i.x && (i = e), (e = e.next);
        } while (e !== t);
        return i;
      }
      function hN(t, e, i, s, n, r, a, o) {
        return (
          (n - a) * (e - o) - (t - a) * (r - o) >= 0 &&
          (t - a) * (s - o) - (i - a) * (e - o) >= 0 &&
          (i - a) * (r - o) - (n - a) * (s - o) >= 0
        );
      }
      function lN(t, e) {
        return (
          t.next.i !== e.i &&
          t.prev.i !== e.i &&
          !(function (t, e) {
            let i = t;
            do {
              if (
                i.i !== t.i &&
                i.next.i !== t.i &&
                i.i !== e.i &&
                i.next.i !== e.i &&
                _N(i, i.next, t, e)
              )
                return !0;
              i = i.next;
            } while (i !== t);
            return !1;
          })(t, e) &&
          dN(t, e) &&
          dN(e, t) &&
          (function (t, e) {
            let i = t,
              s = !1;
            const n = (t.x + e.x) / 2,
              r = (t.y + e.y) / 2;
            do {
              i.y > r != i.next.y > r &&
                n < ((i.next.x - i.x) * (r - i.y)) / (i.next.y - i.y) + i.x &&
                (s = !s),
                (i = i.next);
            } while (i !== t);
            return s;
          })(t, e)
        );
      }
      function cN(t, e, i) {
        return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
      }
      function uN(t, e) {
        return t.x === e.x && t.y === e.y;
      }
      function _N(t, e, i, s) {
        return (
          !!((uN(t, e) && uN(i, s)) || (uN(t, s) && uN(i, e))) ||
          (cN(t, e, i) > 0 != cN(t, e, s) > 0 &&
            cN(i, s, t) > 0 != cN(i, s, e) > 0)
        );
      }
      function dN(t, e) {
        return cN(t.prev, t, t.next) < 0
          ? cN(t, e, t.next) >= 0 && cN(t, t.prev, e) >= 0
          : cN(t, e, t.prev) < 0 || cN(t, t.next, e) < 0;
      }
      function pN(t, e) {
        const i = new $P(t.i, t.x, t.y),
          s = new $P(e.i, e.x, e.y),
          n = t.next,
          r = e.prev;
        return (
          (t.next = e),
          (e.prev = t),
          (i.next = n),
          (n.prev = i),
          (s.next = i),
          (i.prev = s),
          (r.next = s),
          (s.prev = r),
          s
        );
      }
      function mN(t, e, i, s) {
        const n = new $P(t, e, i);
        return (
          s
            ? ((n.next = s.next), (n.prev = s), (s.next.prev = n), (s.next = n))
            : ((n.prev = n), (n.next = n)),
          n
        );
      }
      function fN(t) {
        (t.next.prev = t.prev),
          (t.prev.next = t.next),
          t.prevZ && (t.prevZ.nextZ = t.nextZ),
          t.nextZ && (t.nextZ.prevZ = t.prevZ);
      }
      function gN(t, e, i) {
        i = i || 3;
        const s = e ? e.length : 0,
          n = s ? e[0] * i : t.length;
        let r = ZP(t, 0, n, i, !0);
        const a = [];
        if (!r) return a;
        let o = 0,
          h = 0,
          l = 0,
          c = 0,
          u = 0,
          _ = 0,
          d = 0;
        if (
          (s &&
            (r = (function (t, e, i, s) {
              const n = [];
              let r = 0,
                a = 0,
                o = 0,
                h = 0,
                l = null;
              for (r = 0, a = e.length; r < a; r++)
                (o = e[r] * s),
                  (h = r < a - 1 ? e[r + 1] * s : t.length),
                  (l = ZP(t, o, h, s, !1)),
                  l && (l === l.next && (l.steiner = !0), n.push(oN(l)));
              if ((n.sort(nN), !i)) return i;
              for (r = 0; r < n.length; r++) rN(n[r], i), (i = QP(i, i.next));
              return i;
            })(t, e, r, i)),
          t.length > 80 * i)
        ) {
          (o = l = t[0]), (h = c = t[1]);
          for (let e = i; e < n; e += i)
            (u = t[e]),
              (_ = t[e + 1]),
              u < o && (o = u),
              _ < h && (h = _),
              u > l && (l = u),
              _ > c && (c = _);
          d = Math.max(l - o, c - h);
        }
        return JP(r, a, i, o, h, d), a;
      }
      const yN = Math.PI,
        TN = Math.min,
        SN = Math.max,
        EN = Math.ceil,
        vN = Math.acos,
        bN = Math.cos,
        AN = Math.sin,
        CN = Math.atan2;
      let ON = null,
        IN = null;
      const wN = new Qi(),
        RN = [];
      for (let t = 0; t < 4; t++) RN.push(new Yi());
      function DN(t, e, i) {
        return t < e ? e : t > i ? i : t;
      }
      const xN = {
          useModel: !0,
          updateRenderData(t) {
            t.renderData && (t.renderData.material = t.getMaterialInstance(0));
          },
          fillBuffers(t, e) {},
          renderIA(t, e) {},
          getRenderData(t, e) {
            if (!IN) return null;
            const i = IN.getRenderDataList();
            let s = i[IN.dataOffset];
            if (!s) return null;
            let n = s;
            const r = n ? n.vertexStart + e : 0;
            return (
              (r > 65535 || 3 * r > 131070) &&
                (++IN.dataOffset,
                IN.dataOffset < i.length
                  ? (s = i[IN.dataOffset])
                  : ((s = IN.requestRenderData()), (i[IN.dataOffset] = s)),
                (n = s)),
              n && n.vertexCount < r && n.request(e, 3 * e),
              s
            );
          },
          stroke(t) {
            Qi.copy(wN, t.strokeColor),
              t.impl &&
                (this._flattenPaths(t.impl),
                this._expandStroke(t),
                (t.impl.updatePathOffset = !0),
                this.end(t));
          },
          fill(t) {
            Qi.copy(wN, t.fillColor),
              this._expandFill(t),
              t.impl && (t.impl.updatePathOffset = !0),
              this.end(t);
          },
          end(t) {
            t.markForUpdateRenderData();
          },
          _expandStroke(t) {
            const e = 0.5 * t.lineWidth,
              i = t.lineCap,
              s = t.lineJoin,
              n = t.miterLimit;
            if (((IN = t.impl), !IN)) return;
            const r = (function (t, e, i) {
              const s = 2 * vN(t / (t + i));
              return SN(2, EN(e / s));
            })(e, yN, IN.tessTol);
            this._calculateJoins(IN, e, s, n);
            const a = IN.paths;
            let o = 0;
            for (let t = IN.pathOffset, e = IN.pathLength; t < e; t++) {
              const e = a[t],
                n = e.points.length;
              s === jR.ROUND
                ? (o += 2 * (n + e.bevel * (r + 2) + 1))
                : (o += 2 * (n + 5 * e.bevel + 1)),
                e.closed ||
                  (i === VR.ROUND ? (o += 2 * (2 * r + 2)) : (o += 12));
            }
            const h = (ON = this.getRenderData(t, o));
            if (!h) return;
            const l = h.vData,
              c = h.iData;
            for (let t = IN.pathOffset, n = IN.pathLength; t < n; t++) {
              const n = a[t],
                o = n.points,
                u = o.length,
                _ = h.vertexStart;
              let d,
                p,
                m = 0,
                f = 0;
              const g = n.closed;
              if (
                (g
                  ? ((d = o[u - 1]), (p = o[0]), (m = 0), (f = u))
                  : ((d = o[0]), (p = o[1]), (m = 1), (f = u - 1)),
                (p = p || d),
                !g)
              ) {
                const t = new iD(p.x, p.y);
                t.subtract(d), t.normalize();
                const s = t.x,
                  n = t.y;
                i === VR.BUTT
                  ? this._buttCapStart(d, s, n, e, 0)
                  : i === VR.SQUARE
                  ? this._buttCapStart(d, s, n, e, e)
                  : i === VR.ROUND && this._roundCapStart(d, s, n, e, r);
              }
              for (let t = m; t < f; ++t)
                s === jR.ROUND
                  ? this._roundJoin(d, p, e, e, r)
                  : 0 != (p.flags & (WR.PT_BEVEL | WR.PT_INNERBEVEL))
                  ? this._bevelJoin(d, p, e, e)
                  : (this._vSet(p.x + p.dmx * e, p.y + p.dmy * e, 1),
                    this._vSet(p.x - p.dmx * e, p.y - p.dmy * e, -1)),
                  (d = p),
                  (p = o[t + 1]);
              if (g) {
                const t = 8 * _;
                this._vSet(l[t], l[t + 1], 1),
                  this._vSet(l[t + 8], l[t + 8 + 1], -1);
              } else {
                const t = new iD(p.x, p.y);
                t.subtract(d), t.normalize();
                const s = t.x,
                  n = t.y;
                i === VR.BUTT
                  ? this._buttCapEnd(p, s, n, e, 0)
                  : i === VR.SQUARE
                  ? this._buttCapEnd(p, s, n, e, e)
                  : i === VR.ROUND && this._roundCapEnd(p, s, n, e, r);
              }
              let y = h.indexStart;
              for (let t = _ + 2, e = h.vertexStart; t < e; t++)
                (c[y++] = t - 2), (c[y++] = t - 1), (c[y++] = t);
              h.indexStart = y;
            }
            (ON = null), (IN = null);
          },
          _expandFill(t) {
            if (((IN = t.impl), !IN)) return;
            const e = IN.paths;
            let i = 0;
            for (let t = IN.pathOffset, s = IN.pathLength; t < s; t++)
              i += e[t].points.length;
            const s = (ON = this.getRenderData(t, i));
            if (!s) return;
            const n = s,
              r = n.vData,
              a = n.iData;
            for (let t = IN.pathOffset, i = IN.pathLength; t < i; t++) {
              const i = e[t],
                o = i.points,
                h = o.length;
              if (0 === h) continue;
              const l = s.vertexStart;
              for (let t = 0; t < h; ++t) this._vSet(o[t].x, o[t].y);
              let c = s.indexStart;
              if (i.complex) {
                const t = [];
                for (let e = l, i = s.vertexStart; e < i; e++) {
                  let i = 8 * e;
                  t.push(r[i++]), t.push(r[i++]), t.push(r[i++]);
                }
                const e = gN(t, null, 3);
                if (!e || 0 === e.length) continue;
                for (let t = 0, i = e.length; t < i; t++) a[c++] = e[t] + l;
              } else {
                const t = l;
                for (let e = l + 2, i = n.vertexStart; e < i; e++)
                  (a[c++] = t), (a[c++] = e - 1), (a[c++] = e);
              }
              n.indexStart = c;
            }
            (ON = null), (IN = null);
          },
          _calculateJoins(t, e, i, s) {
            let n = 0;
            e > 0 && (n = 1 / e);
            const r = t.paths;
            for (let e = t.pathOffset, a = t.pathLength; e < a; e++) {
              const t = r[e],
                a = t.points,
                o = a.length;
              let h = a[o - 1],
                l = a[0];
              t.bevel = 0;
              for (let e = 0; e < o; e++) {
                let r = 0,
                  o = 0,
                  c = 0;
                const u = h.dy,
                  _ = -h.dx,
                  d = l.dy,
                  p = -l.dx;
                if (
                  ((l.dmx = 0.5 * (u + d)),
                  (l.dmy = 0.5 * (_ + p)),
                  (r = l.dmx * l.dmx + l.dmy * l.dmy),
                  r > 1e-6)
                ) {
                  let t = 1 / r;
                  t > 600 && (t = 600), (l.dmx *= t), (l.dmy *= t);
                }
                (o = l.dx * h.dy - h.dx * l.dy),
                  o > 0 && (l.flags |= WR.PT_LEFT),
                  (c = SN(11, TN(h.len, l.len) * n)),
                  r * c * c < 1 && (l.flags |= WR.PT_INNERBEVEL),
                  l.flags & WR.PT_CORNER &&
                    (r * s * s < 1 || i === jR.BEVEL || i === jR.ROUND) &&
                    (l.flags |= WR.PT_BEVEL),
                  0 != (l.flags & (WR.PT_BEVEL | WR.PT_INNERBEVEL)) &&
                    t.bevel++,
                  (h = l),
                  (l = a[e + 1]);
              }
            }
          },
          _flattenPaths(t) {
            const e = t.paths;
            for (let i = t.pathOffset, s = t.pathLength; i < s; i++) {
              const t = e[i],
                s = t.points;
              let n = s[s.length - 1],
                r = s[0];
              s.length > 2 &&
                n.equals(r) &&
                ((t.closed = !0), s.pop(), (n = s[s.length - 1]));
              for (let t = 0, e = s.length; t < e; t++) {
                const e = new iD(r.x, r.y);
                e.subtract(n),
                  (n.len = e.length()),
                  (e.x || e.y) && e.normalize(),
                  (n.dx = e.x),
                  (n.dy = e.y),
                  (n = r),
                  (r = s[t + 1]);
              }
            }
          },
          _chooseBevel(t, e, i, s) {
            const n = i.x,
              r = i.y;
            let a = 0,
              o = 0,
              h = 0,
              l = 0;
            return (
              0 !== t
                ? ((a = n + e.dy * s),
                  (o = r - e.dx * s),
                  (h = n + i.dy * s),
                  (l = r - i.dx * s))
                : ((a = h = n + i.dmx * s), (o = l = r + i.dmy * s)),
              [a, o, h, l]
            );
          },
          _buttCapStart(t, e, i, s, n) {
            const r = t.x - e * n,
              a = t.y - i * n,
              o = i,
              h = -e;
            this._vSet(r + o * s, a + h * s, 1),
              this._vSet(r - o * s, a - h * s, -1);
          },
          _buttCapEnd(t, e, i, s, n) {
            const r = t.x + e * n,
              a = t.y + i * n,
              o = i,
              h = -e;
            this._vSet(r + o * s, a + h * s, 1),
              this._vSet(r - o * s, a - h * s, -1);
          },
          _roundCapStart(t, e, i, s, n) {
            const r = t.x,
              a = t.y,
              o = i,
              h = -e;
            for (let t = 0; t < n; t++) {
              const l = (t / (n - 1)) * yN,
                c = bN(l) * s,
                u = AN(l) * s;
              this._vSet(r - o * c - e * u, a - h * c - i * u, 1),
                this._vSet(r, a, 0);
            }
            this._vSet(r + o * s, a + h * s, 1),
              this._vSet(r - o * s, a - h * s, -1);
          },
          _roundCapEnd(t, e, i, s, n) {
            const r = t.x,
              a = t.y,
              o = i,
              h = -e;
            this._vSet(r + o * s, a + h * s, 1),
              this._vSet(r - o * s, a - h * s, -1);
            for (let t = 0; t < n; t++) {
              const l = (t / (n - 1)) * yN,
                c = bN(l) * s,
                u = AN(l) * s;
              this._vSet(r, a, 0),
                this._vSet(r - o * c + e * u, a - h * c + i * u, 1);
            }
          },
          _roundJoin(t, e, i, s, n) {
            const r = t.dy,
              a = -t.dx,
              o = e.dy,
              h = -e.dx,
              l = e.x,
              c = e.y;
            if (0 != (e.flags & WR.PT_LEFT)) {
              const u = this._chooseBevel(e.flags & WR.PT_INNERBEVEL, t, e, i),
                _ = u[0],
                d = u[1],
                p = u[2],
                m = u[3],
                f = CN(-a, -r);
              let g = CN(-h, -o);
              g > f && (g -= 2 * yN),
                this._vSet(_, d, 1),
                this._vSet(l - r * s, e.y - a * s, -1);
              const y = DN(EN((f - g) / yN) * n, 2, n);
              for (let t = 0; t < y; t++) {
                const e = f + (t / (y - 1)) * (g - f),
                  i = l + bN(e) * s,
                  n = c + AN(e) * s;
                this._vSet(l, c, 0), this._vSet(i, n, -1);
              }
              this._vSet(p, m, 1), this._vSet(l - o * s, c - h * s, -1);
            } else {
              const u = this._chooseBevel(e.flags & WR.PT_INNERBEVEL, t, e, -s),
                _ = u[0],
                d = u[1],
                p = u[2],
                m = u[3],
                f = CN(a, r);
              let g = CN(h, o);
              g < f && (g += 2 * yN),
                this._vSet(l + r * s, c + a * s, 1),
                this._vSet(_, d, -1);
              const y = DN(EN((g - f) / yN) * n, 2, n);
              for (let t = 0; t < y; t++) {
                const e = f + (t / (y - 1)) * (g - f),
                  s = l + bN(e) * i,
                  n = c + AN(e) * i;
                this._vSet(s, n, 1), this._vSet(l, c, 0);
              }
              this._vSet(l + o * s, c + h * s, 1), this._vSet(p, m, -1);
            }
          },
          _bevelJoin(t, e, i, s) {
            let n = 0,
              r = 0,
              a = 0,
              o = 0,
              h = 0,
              l = 0,
              c = 0,
              u = 0;
            const _ = t.dy,
              d = -t.dx,
              p = e.dy,
              m = -e.dx;
            if (e.flags & WR.PT_LEFT) {
              const n = this._chooseBevel(e.flags & WR.PT_INNERBEVEL, t, e, i);
              (h = n[0]),
                (l = n[1]),
                (c = n[2]),
                (u = n[3]),
                this._vSet(h, l, 1),
                this._vSet(e.x - _ * s, e.y - d * s, -1),
                this._vSet(c, u, 1),
                this._vSet(e.x - p * s, e.y - m * s, -1);
            } else {
              const h = this._chooseBevel(e.flags & WR.PT_INNERBEVEL, t, e, -s);
              (n = h[0]),
                (r = h[1]),
                (a = h[2]),
                (o = h[3]),
                this._vSet(e.x + _ * i, e.y + d * i, 1),
                this._vSet(n, r, -1),
                this._vSet(e.x + p * i, e.y + m * i, 1),
                this._vSet(a, o, -1);
            }
          },
          _vSet(t, e, i = 0) {
            if (!ON) return;
            const s = ON;
            let n = 8 * s.vertexStart;
            const r = s.vData;
            (r[n++] = t),
              (r[n++] = e),
              (r[n++] = 0),
              Qi.toArray(r, wN, n),
              (n += 4),
              (r[n++] = i),
              s.vertexStart++;
          },
        },
        MN = t("graphicsAssembler", { getAssembler: () => xN });
      ED.Assembler = MN;
      const PN = ["left", "center", "right"],
        NN = 2048;
      class LN {
        constructor() {
          (this.char = ""),
            (this.valid = !0),
            (this.x = 0),
            (this.y = 0),
            (this.line = 0),
            (this.hash = "");
        }
      }
      class BN {
        constructor() {
          (this._context = null),
            (this._canvas = null),
            (this._canvasData = null),
            (this._lettersInfo = []),
            (this._tmpRect = new Ds()),
            (this._maxFontSize = 100),
            (this._fontScale = 1),
            (this._canvasData = AO.getInstance().get()),
            (this._canvas = this._canvasData.canvas),
            (this._context = this._canvasData.context);
        }
        destroy() {
          AO.getInstance().put(this._canvasData),
            (this._lettersInfo.length = 0);
        }
        processingString(t, e, i, s, n, r) {
          if (t)
            e.fntConfig
              ? (this._fontScale = 1)
              : (this._fontScale = this._getStyleFontScale(
                  e.originFontSize,
                  e.fontScale
                )),
              (DO.fontScale = this._fontScale),
              this._setupBMFontOverflowMetrics(i, s),
              this._updateFontScale(e),
              this._computeHorizontalKerningForText(e, i, n),
              this._alignText(e, i, s, n);
          else {
            let t = 0;
            for (
              this._fontScale = this._getStyleFontScale(
                e.fontSize,
                e.fontScale
              ),
                this._updatePaddingRect(e, s),
                this._calculateLabelFont(e, i, s, n);
              (s.canvasSize.width > NN || s.canvasSize.height > NN) && t <= 3;

            ) {
              if ((t++, t > 3)) this._fontScale = 1;
              else {
                const t = Math.max(s.canvasSize.width, s.canvasSize.height),
                  e = NN / t;
                (this._fontScale *= e),
                  (this._fontScale = Math.max(1, this._fontScale));
              }
              this._updatePaddingRect(e, s),
                this._calculateLabelFont(e, i, s, n);
            }
          }
          r && (r = s.parsedString);
        }
        generateRenderInfo(t, e, i, s, n, r, a) {
          t
            ? (this._computeAlignmentOffset(e, i, s),
              this.generateVertexData(t, e, i, s, n, r, a))
            : (this._updateLabelDimensions(e, i, s),
              this._updateTexture(e, i, s, n),
              this.generateVertexData(t, e, i, s, n, r, a));
        }
        setCanvasUsed(t, e) {
          (this._canvas = t), (this._context = e);
        }
        _getStyleFontScale(t, e) {
          let i = e;
          return (
            i * t > this._maxFontSize &&
              t < this._maxFontSize &&
              (i = this._maxFontSize / t),
            i < 1 && (i = 1),
            i
          );
        }
        _calculateLabelFont(t, e, i, s) {
          if (!this._context) return;
          t.actualFontSize = t.fontSize * this._fontScale;
          const n = s.split("\n"),
            r = (i.parsedString = n),
            a = this._getFontDesc(
              t.actualFontSize,
              t.fontFamily,
              t.isBold,
              t.isItalic
            );
          switch (((this._context.font = t.fontDesc = a), e.overFlow)) {
            case Vw.NONE: {
              let s = 0,
                o = 0;
              for (let t = 0; t < n.length; ++t) {
                const e = zC(this._context, n[t], a);
                s = s > e ? s : e;
              }
              o =
                (r.length + wC) *
                this._getLineHeight(e.lineHeight, t.actualFontSize, t.fontSize);
              const h = s,
                l = o;
              (i.canvasSize.width =
                h + i.canvasPadding.width * this._fontScale),
                (i.canvasSize.height =
                  l + i.canvasPadding.height * this._fontScale),
                (i.nodeContentSize.width =
                  (h + i.contentSizeExtend.width * this._fontScale) /
                  this._fontScale),
                (i.nodeContentSize.height =
                  (l + i.contentSizeExtend.height * this._fontScale) /
                  this._fontScale);
              break;
            }
            case Vw.SHRINK:
              this._calculateShrinkFont(n, t, e, i),
                this._calculateWrapText(n, t, e, i),
                (i.canvasSize.width =
                  i.nodeContentSize.width * this._fontScale),
                (i.canvasSize.height =
                  i.nodeContentSize.height * this._fontScale);
              break;
            case Vw.CLAMP:
              this._calculateWrapText(n, t, e, i),
                (i.canvasSize.width =
                  i.nodeContentSize.width * this._fontScale),
                (i.canvasSize.height =
                  i.nodeContentSize.height * this._fontScale);
              break;
            case Vw.RESIZE_HEIGHT: {
              this._calculateWrapText(n, t, e, i);
              const s =
                (i.parsedString.length + wC) *
                this._getLineHeight(e.lineHeight, t.actualFontSize, t.fontSize);
              (i.canvasSize.width = i.nodeContentSize.width * this._fontScale),
                (i.canvasSize.height =
                  s + i.canvasPadding.height * this._fontScale),
                (i.nodeContentSize.height =
                  (s + i.contentSizeExtend.height * this._fontScale) /
                  this._fontScale);
              break;
            }
          }
        }
        _getFontDesc(t, e, i, s) {
          let n = `${t.toString()}px `;
          return (n += e), i && (n = `bold ${n}`), s && (n = `italic ${n}`), n;
        }
        _getLineHeight(t, e, i) {
          let s = t;
          return (s = 0 === s ? e : (s * e) / i), s;
        }
        _calculateShrinkFont(t, e, i, s) {
          if (!this._context) return;
          let n = this._getFontDesc(
            e.actualFontSize,
            e.fontFamily,
            e.isBold,
            e.isItalic
          );
          this._context.font = n;
          const r = this._calculateParagraphLength(t, this._context, n);
          let a = 0,
            o = 0,
            h = 0,
            l = e.actualFontSize;
          if (i.wrapping) {
            const r = s.nodeContentSize.width * this._fontScale,
              h = s.nodeContentSize.height * this._fontScale;
            if (r < 0 || h < 0) return;
            o = h + 1;
            let c = [],
              u = 0,
              _ = 0 | (e.actualFontSize + 1),
              d = 0;
            for (; u < _; ) {
              if (((d = (u + _ + 1) >> 1), d <= 0)) {
                B(4003);
                break;
              }
              (l = d),
                (n = this._getFontDesc(l, e.fontFamily, e.isBold, e.isItalic)),
                (this._context.font = n);
              const s = this._getLineHeight(i.lineHeight, l, e.fontSize);
              for (o = 0, a = 0; a < t.length; ++a) {
                const e = zC(this._context, t[a], n);
                (c = qC(t[a], e, r, this._measureText(this._context, n))),
                  (o += c.length * s);
              }
              o > h ? (_ = d - 1) : (u = d);
            }
            0 === u
              ? B(4003)
              : ((l = u),
                (n = this._getFontDesc(l, e.fontFamily, e.isBold, e.isItalic)),
                (this._context.font = n));
          } else {
            for (
              o = t.length * this._getLineHeight(i.lineHeight, l, e.fontSize),
                a = 0;
              a < t.length;
              ++a
            )
              h < r[a] && (h = r[a]);
            const c =
                ((s.canvasSize.width - s.canvasPadding.width) *
                  this._fontScale) /
                h,
              u = (s.canvasSize.height * this._fontScale) / o;
            (l = (e.actualFontSize * Math.min(1, c, u)) | 0),
              (n = this._getFontDesc(l, e.fontFamily, e.isBold, e.isItalic)),
              (this._context.font = n);
          }
          (e.actualFontSize = l), (e.fontDesc = n);
        }
        _calculateWrapText(t, e, i, s) {
          if (!i.wrapping || !this._context) return;
          let n = [];
          const r = s.nodeContentSize.width * this._fontScale,
            a = this._getFontDesc(
              e.actualFontSize,
              e.fontFamily,
              e.isBold,
              e.isItalic
            );
          this._context.font = a;
          for (let e = 0; e < t.length; ++e) {
            const i = zC(this._context, t[e], a),
              s = qC(t[e], i, r, this._measureText(this._context, a));
            n = n.concat(s);
          }
          (s.parsedString = n), (e.fontDesc = a);
        }
        _measureText(t, e) {
          return (i) => zC(t, i, e);
        }
        _calculateParagraphLength(t, e, i) {
          const s = [];
          for (const n of t) {
            const t = zC(e, n, i);
            s.push(t);
          }
          return s;
        }
        _updatePaddingRect(t, e) {
          let i = 0,
            s = 0,
            n = 0,
            r = 0,
            a = 0;
          if (
            ((e.contentSizeExtend.width = e.contentSizeExtend.height = 0),
            t.isOutlined &&
              ((a = t.outlineWidth),
              (i = s = n = r = a),
              (e.contentSizeExtend.width = e.contentSizeExtend.height = 2 * a)),
            t.hasShadow)
          ) {
            const e = t.shadowBlur + a,
              o = t.shadowOffsetX,
              h = t.shadowOffsetY;
            (n = Math.max(n, -o + e)),
              (r = Math.max(r, o + e)),
              (i = Math.max(i, h + e)),
              (s = Math.max(s, -h + e));
          }
          if (t.isItalic) {
            const i = t.fontSize * Math.tan(0.20943951);
            (r += i), (e.contentSizeExtend.width += i);
          }
          (e.canvasPadding.x = n),
            (e.canvasPadding.y = i),
            (e.canvasPadding.width = n + r),
            (e.canvasPadding.height = i + s);
        }
        _updateLabelDimensions(t, e, i) {
          (i.canvasSize.width = Math.min(i.canvasSize.width, NN)),
            (i.canvasSize.height = Math.min(i.canvasSize.height, NN)),
            (this._canvas.width = i.canvasSize.width),
            (this._canvas.height = i.canvasSize.height),
            (this._context.font = t.fontDesc),
            (this._context.textAlign = PN[e.horizontalAlign]),
            (this._context.textBaseline = "alphabetic");
        }
        _calculateFillTextStartPosition(t, e, i) {
          let s = 0;
          e.horizontalAlign === Hw.RIGHT
            ? (s = i.canvasSize.width - i.canvasPadding.width)
            : e.horizontalAlign === Hw.CENTER &&
              (s = (i.canvasSize.width - i.canvasPadding.width) / 2);
          const n =
            this._getLineHeight(e.lineHeight, t.actualFontSize, t.fontSize) *
            (i.parsedString.length - 1);
          let r = t.actualFontSize * (1 - wC / 2);
          if (e.verticalAlign !== Gw.TOP) {
            let s =
              n +
              i.canvasPadding.height +
              t.actualFontSize -
              i.canvasSize.height;
            e.verticalAlign === Gw.BOTTOM
              ? ((s += (wC / 2) * t.actualFontSize), (r -= s))
              : (r -= s / 2);
          }
          (r += 0 * t.actualFontSize),
            i.startPosition.set(s + i.canvasPadding.x, r + i.canvasPadding.y);
        }
        _updateTexture(t, e, i, s) {
          if (!this._context || !this._canvas) return;
          this._context.clearRect(
            0,
            0,
            this._canvas.width,
            this._canvas.height
          ),
            (this._context.font = t.fontDesc),
            this._calculateFillTextStartPosition(t, e, i);
          const n = this._getLineHeight(
            e.lineHeight,
            t.actualFontSize,
            t.fontSize
          );
          (this._context.lineJoin = "round"),
            t.isOutlined
              ? ((this._context.fillStyle = `rgba(${t.outlineColor.r}, ${t.outlineColor.g}, ${t.outlineColor.b}, 0)`),
                this._context.fillRect(
                  0,
                  0,
                  this._canvas.width,
                  this._canvas.height
                ))
              : ((this._context.fillStyle = `rgba(${t.color.r}, ${t.color.g}, ${t.color.b}, 0)`),
                this._context.fillRect(
                  0,
                  0,
                  this._canvas.width,
                  this._canvas.height
                )),
            (this._context.fillStyle = `rgb(${t.color.r}, ${t.color.g}, ${t.color.b})`);
          const r = new Ss(i.startPosition.x, i.startPosition.y),
            a = r.x;
          let o = 0;
          this._drawTextEffect(r, n, t, e, i);
          for (let e = 0; e < i.parsedString.length; ++e)
            (o = r.y + e * n),
              t.hasShadow &&
                (this._setupShadow(t),
                this._context.fillText(i.parsedString[e], a, o)),
              t.isOutlined &&
                (this._setupOutline(t),
                this._context.strokeText(i.parsedString[e], a, o)),
              (t.hasShadow && !t.isOutlined) ||
                this._context.fillText(i.parsedString[e], a, o);
          t.hasShadow && (this._context.shadowColor = "transparent"),
            this._uploadTexture(s);
        }
        _uploadTexture(t) {
          if (t.texture && this._canvas) {
            let e;
            if (
              ((e = t.texture instanceof uC ? t.texture.texture : t.texture),
              0 !== this._canvas.width && 0 !== this._canvas.height)
            ) {
              const i = e.getGFXTexture(),
                s = e.getGFXSampler();
              e.reset({
                width: this._canvas.width,
                height: this._canvas.height,
                mipmapLevel: 1,
              }),
                e.uploadData(this._canvas),
                e.setWrapMode(Od.CLAMP_TO_EDGE, Od.CLAMP_TO_EDGE),
                t.texture instanceof uC &&
                  ((t.texture.rect = new Ds(
                    0,
                    0,
                    this._canvas.width,
                    this._canvas.height
                  )),
                  t.texture._calculateUV()),
                a.director.root &&
                  a.director.root.batcher2D &&
                  a.director.root.batcher2D._releaseDescriptorSetCache(i, s);
            }
          }
        }
        _drawTextEffect(t, e, i, s, n) {
          if (!i.hasShadow && !i.isOutlined && !i.isUnderline) return;
          const r = n.parsedString.length > 1 && i.hasShadow,
            a = this._measureText(this._context, i.fontDesc);
          let o = 0,
            h = 0;
          for (let l = 0; l < n.parsedString.length; ++l)
            if (
              ((o = t.x),
              (h = t.y + l * e),
              r &&
                (i.hasShadow &&
                  (this._setupShadow(i),
                  this._context.fillText(n.parsedString[l], o, h)),
                i.isOutlined &&
                  (this._setupOutline(i),
                  this._context.strokeText(n.parsedString[l], o, h)),
                (i.hasShadow && !i.isOutlined) ||
                  this._context.fillText(n.parsedString[l], o, h)),
              i.isUnderline)
            ) {
              const e = a(n.parsedString[l]),
                r = new Ss();
              s.horizontalAlign === Hw.RIGHT
                ? (r.x = t.x - e)
                : s.horizontalAlign === Hw.CENTER
                ? (r.x = t.x - e / 2)
                : (r.x = t.x),
                (r.y = h + i.actualFontSize / 8),
                this._context.fillRect(
                  r.x,
                  r.y,
                  e,
                  i.underlineHeight * this._fontScale
                );
            }
          r && (this._context.shadowColor = "transparent");
        }
        _setupOutline(t) {
          (this._context.shadowBlur = 0),
            (this._context.shadowOffsetX = 0),
            (this._context.shadowOffsetY = 0),
            (this._context.strokeStyle = `rgba(${t.outlineColor.r}, ${
              t.outlineColor.g
            }, ${t.outlineColor.b}, ${t.outlineColor.a / 255})`),
            (this._context.lineWidth = 2 * t.outlineWidth * this._fontScale);
        }
        _setupShadow(t) {
          const e = this._fontScale;
          (this._context.shadowColor = `rgba(${t.shadowColor.r}, ${
            t.shadowColor.g
          }, ${t.shadowColor.b}, ${t.shadowColor.a / 255})`),
            (this._context.shadowBlur = t.shadowBlur * e),
            (this._context.shadowOffsetX = t.shadowOffsetX * e),
            (this._context.shadowOffsetY = -t.shadowOffsetY * e);
        }
        generateVertexData(t, e, i, s, n, r, a) {
          t
            ? this._updateQuads(e, i, s, n, r, a)
            : (this.updateQuatCount(n), a(e, s, n));
        }
        updateQuatCount(t) {
          const e = t.vertexBuffer,
            i = t.quadCount;
          if (e.length !== i) {
            for (let t = e.length; t < i; t++)
              e.push({ x: 0, y: 0, z: 0, u: 0, v: 0, color: Qi.WHITE.clone() });
            e.length = i;
          }
        }
        _setupBMFontOverflowMetrics(t, e) {
          let i = e.nodeContentSize.width,
            s = e.nodeContentSize.height;
          t.overFlow === Vw.RESIZE_HEIGHT && (s = 0),
            t.overFlow === Vw.NONE && ((i = 0), (s = 0)),
            (t.textWidthTemp = i),
            (t.textHeightTemp = s),
            (t.textDimensions.width = i),
            (t.textDimensions.height = s),
            (t.maxLineWidth = i);
        }
        _updateFontScale(t) {
          t.bmfontScale =
            t.actualFontSize / (t.originFontSize * this._fontScale);
        }
        _computeHorizontalKerningForText(t, e, i) {
          const s = i,
            n = s.length;
          if (!t.fntConfig) return;
          const r = t.fntConfig.kerningDict,
            a = e.horizontalKerning;
          if (!r || 0 === r.length) return;
          let o = -1;
          for (let t = 0; t < n; ++t) {
            const e = s.charCodeAt(t),
              i = r[(o << 16) | (65535 & e)] || 0;
            (a[t] = t < n - 1 ? i : 0), (o = e);
          }
        }
        _alignText(t, e, i, s) {
          this._multilineTextWrap(t, e, i, s, this._getFirstWordLen),
            e.overFlow === Vw.SHRINK &&
              (t.fontSize > 0 &&
                this._isVerticalClamp(t, e, i, s, this) &&
                this._shrinkLabelToContentSize(
                  t,
                  e,
                  i,
                  s,
                  this._isVerticalClamp
                ),
              t.fontSize > 0 &&
                this._isHorizontalNeedShrink(e, i) &&
                this._shrinkLabelToContentSize(
                  t,
                  e,
                  i,
                  s,
                  this._isHorizontalClamp
                )),
            this._parsedString(i, s);
        }
        _parsedString(t, e) {
          let i = [],
            s = "";
          for (let t = 0, n = 0, r = HC(e); t < r; ++t) {
            const e = this._lettersInfo[t];
            e.valid &&
              (n === e.line
                ? (s += e.char)
                : ((i = i.concat(s)), (n = e.line), (s = "")));
          }
          (i = i.concat(s)), (t.parsedString = i);
        }
        _multilineTextWrap(t, e, i, s, n) {
          e.linesWidth.length = 0;
          const r = s,
            a = r.length;
          let o = 0,
            h = 0,
            l = 0,
            c = 0,
            u = 0,
            _ = 0,
            d = 0,
            p = null;
          for (let i = 0; i < a; ) {
            let s = GC(r, i);
            if ("\n" === s) {
              e.linesWidth.push(u),
                (u = 0),
                o++,
                (h = 0),
                (l -= e.lineHeight * this._getFontScale(t, e) + 0),
                this._recordPlaceholderInfo(i, s),
                i++;
              continue;
            }
            const m = n(t, e, r, i, a);
            let f = _,
              g = d,
              y = u,
              T = h,
              S = !1;
            const E = new Ss();
            for (let n = 0; n < m; ++n) {
              const c = i + n;
              if (((s = GC(r, c)), "\r" === s)) {
                this._recordPlaceholderInfo(c, s);
                continue;
              }
              if (((p = DO.fontAtlas.getLetterDefinitionForChar(s, DO)), !p)) {
                this._recordPlaceholderInfo(c, s),
                  null != t.fntConfig
                    ? B(16354, t.fntConfig.atlasName, s)
                    : B(16355, t.fontFamily, s);
                continue;
              }
              const _ = T + p.offsetX * t.bmfontScale - DO.margin;
              if (
                e.wrapping &&
                e.maxLineWidth > 0 &&
                h > 0 &&
                _ + p.w * t.bmfontScale > e.maxLineWidth &&
                !kC(s)
              ) {
                e.linesWidth.push(u),
                  (u = 0),
                  o++,
                  (h = 0),
                  (l -= e.lineHeight * this._getFontScale(t, e) + 0),
                  (S = !0);
                break;
              }
              (E.x = _),
                (E.y = l - p.offsetY * t.bmfontScale),
                this._recordLetterInfo(E, s, c, o),
                c + 1 < e.horizontalKerning.length &&
                  c < a - 1 &&
                  (T += e.horizontalKerning[c + 1] * t.bmfontScale),
                (T += p.xAdvance * t.bmfontScale + e.spacingX),
                (y = E.x + p.w * t.bmfontScale),
                f < E.y && (f = E.y),
                g > E.y - p.h * t.bmfontScale &&
                  (g = E.y - p.h * t.bmfontScale);
            }
            S ||
              ((h = T),
              (u = y),
              _ < f && (_ = f),
              d > g && (d = g),
              c < u && (c = u),
              (i += m));
          }
          return (
            e.linesWidth.push(u),
            (e.numberOfLines = o + 1),
            (e.textDesiredHeight =
              e.numberOfLines * e.lineHeight * this._getFontScale(t, e)),
            e.numberOfLines > 1 &&
              (e.textDesiredHeight += 0 * (e.numberOfLines - 1)),
            (i.nodeContentSize.width = e.textWidthTemp),
            (i.nodeContentSize.height = e.textHeightTemp),
            e.textWidthTemp <= 0 &&
              (i.nodeContentSize.width =
                parseFloat(c.toFixed(2)) + 2 * DO.margin),
            e.textHeightTemp <= 0 &&
              (i.nodeContentSize.height =
                parseFloat(e.textDesiredHeight.toFixed(2)) + 2 * DO.margin),
            (e.tailoredTopY = i.nodeContentSize.height),
            (e.tailoredBottomY = 0),
            _ > 0 && (e.tailoredTopY = i.nodeContentSize.height + _),
            d < -e.textDesiredHeight &&
              (e.tailoredBottomY = e.textDesiredHeight + d),
            !0
          );
        }
        _recordPlaceholderInfo(t, e) {
          if (t >= this._lettersInfo.length) {
            const t = new LN();
            this._lettersInfo.push(t);
          }
          (this._lettersInfo[t].char = e),
            (this._lettersInfo[t].hash = `${VC(e, 0)}${DO.hash}`),
            (this._lettersInfo[t].valid = !1);
        }
        _recordLetterInfo(t, e, i, s) {
          if (i >= this._lettersInfo.length) {
            const t = new LN();
            this._lettersInfo.push(t);
          }
          const n = `${VC(e, 0)}${DO.hash}`;
          (this._lettersInfo[i].line = s),
            (this._lettersInfo[i].char = e),
            (this._lettersInfo[i].hash = n),
            (this._lettersInfo[i].valid = DO.fontAtlas.getLetter(n).valid),
            (this._lettersInfo[i].x = t.x),
            (this._lettersInfo[i].y = t.y);
        }
        _getFirstWordLen(t, e, i, s, n) {
          let r = GC(i, s);
          if (UC(r) || "\n" === r || kC(r)) return 1;
          let a = 1,
            o = DO.fontAtlas.getLetterDefinitionForChar(r, DO);
          if (!o) return a;
          let h = o.xAdvance * t.bmfontScale + e.spacingX,
            l = 0;
          for (
            let c = s + 1;
            c < n &&
            ((r = GC(i, c)),
            (o = DO.fontAtlas.getLetterDefinitionForChar(r, DO)),
            o);
            ++c
          ) {
            if (
              ((l = h + o.offsetX * t.bmfontScale),
              l + o.w * t.bmfontScale > e.maxLineWidth &&
                !kC(r) &&
                e.maxLineWidth > 0)
            )
              return a;
            if (
              ((h += o.xAdvance * t.bmfontScale + e.spacingX),
              "\n" === r || kC(r) || UC(r))
            )
              break;
            a++;
          }
          return a;
        }
        _computeAlignmentOffset(t, e, i) {
          switch (
            ((e.linesOffsetX.length = 0),
            (e.letterOffsetY = 0),
            e.horizontalAlign)
          ) {
            case Hw.LEFT:
              for (let t = 0; t < e.numberOfLines; ++t) e.linesOffsetX.push(0);
              break;
            case Hw.CENTER:
              for (let t = 0, s = e.linesWidth.length; t < s; t++)
                e.linesOffsetX.push(
                  (i.nodeContentSize.width - e.linesWidth[t]) / 2
                );
              break;
            case Hw.RIGHT:
              for (let t = 0, s = e.linesWidth.length; t < s; t++)
                e.linesOffsetX.push(i.nodeContentSize.width - e.linesWidth[t]);
          }
          if (
            ((e.letterOffsetY = i.nodeContentSize.height),
            e.verticalAlign !== Gw.TOP)
          ) {
            const s =
              i.nodeContentSize.height -
              e.textDesiredHeight +
              e.lineHeight * this._getFontScale(t, e) -
              t.originFontSize * this._fontScale * t.bmfontScale;
            e.verticalAlign === Gw.BOTTOM
              ? (e.letterOffsetY -= s)
              : (e.letterOffsetY -= s / 2);
          }
        }
        _getFontScale(t, e) {
          return e.overFlow === Vw.SHRINK ? t.bmfontScale : 1;
        }
        _isVerticalClamp(t, e, i, s, n) {
          return e.textDesiredHeight > i.nodeContentSize.height;
        }
        _isHorizontalClamp(t, e, i, s, n) {
          let r = !1;
          for (let a = 0, o = HC(s); a < o; ++a) {
            const s = n._lettersInfo[a];
            if (s.valid) {
              const n = DO.fontAtlas.getLetterDefinitionForChar(s.char, DO);
              if (!n) continue;
              const a = s.x + n.w * t.bmfontScale,
                o = s.line;
              if (e.textWidthTemp > 0)
                if (e.wrapping) {
                  if (
                    e.linesWidth[o] > i.nodeContentSize.width &&
                    (a > i.nodeContentSize.width || a < 0)
                  ) {
                    r = !0;
                    break;
                  }
                } else if (a > i.nodeContentSize.width) {
                  r = !0;
                  break;
                }
            }
          }
          return r;
        }
        _isHorizontalNeedShrink(t, e) {
          let i = 0;
          for (let s = 0, n = t.linesWidth.length; s < n; ++s)
            if (((i = t.linesWidth[s]), i > e.nodeContentSize.width)) return !0;
          return !1;
        }
        _shrinkLabelToContentSize(t, e, i, s, n) {
          let r = 0,
            a = 0 | t.actualFontSize,
            o = 0;
          for (; r < a; ) {
            o = (r + a + 1) >> 1;
            const h = o;
            if (h <= 0) break;
            (t.bmfontScale = h / (t.originFontSize * this._fontScale)),
              this._multilineTextWrap(t, e, i, s, this._getFirstWordLen),
              this._computeAlignmentOffset(t, e, i),
              n(t, e, i, s, this) ? (a = o - 1) : (r = o);
          }
          r >= 0 && this._scaleFontSizeDown(t, e, i, s, r);
        }
        _scaleFontSizeDown(t, e, i, s, n) {
          let r = !0;
          n || ((n = 0.1), (r = !1)),
            (t.actualFontSize = n),
            r &&
              (this._updateFontScale(t),
              this._multilineTextWrap(t, e, i, s, this._getFirstWordLen));
        }
        _updateQuads(t, e, i, s, n, r) {
          const a = t.spriteFrame
              ? t.spriteFrame.texture
              : DO.fontAtlas.getTexture(),
            o = s.uiTransAnchorX * i.nodeContentSize.width,
            h = s.uiTransAnchorY * i.nodeContentSize.height;
          for (let l = 0, c = HC(n); l < c; ++l) {
            const n = this._lettersInfo[l];
            if (!n.valid) continue;
            const c = DO.fontAtlas.getLetter(n.hash);
            if (!c) {
              z(16353);
              continue;
            }
            (this._tmpRect.height = c.h),
              (this._tmpRect.width = c.w),
              (this._tmpRect.x = c.u),
              (this._tmpRect.y = c.v);
            let u = n.y + e.letterOffsetY;
            if (e.textHeightTemp > 0) {
              if (u > e.tailoredTopY) {
                const t = u - e.tailoredTopY;
                (this._tmpRect.y += t), (this._tmpRect.height -= t), (u -= t);
              }
              u - this._tmpRect.height * t.bmfontScale < e.tailoredBottomY &&
                e.overFlow === Vw.CLAMP &&
                (this._tmpRect.height =
                  u < e.tailoredBottomY
                    ? 0
                    : (u - e.tailoredBottomY) / t.bmfontScale);
            }
            const _ = n.line,
              d = n.x + (c.w / 2) * t.bmfontScale + e.linesOffsetX[_];
            if (
              (e.textWidthTemp > 0 &&
                this._isHorizontalClamped(e, i, d, _) &&
                e.overFlow === Vw.CLAMP &&
                (this._tmpRect.width = 0),
              this._tmpRect.height > 0 && this._tmpRect.width > 0)
            ) {
              const l = this._determineRect(t),
                c = n.x + e.linesOffsetX[n.line],
                _ = s.quadCount;
              (s.quadCount += 4),
                this.updateQuatCount(s),
                r(t, i, s, _, a, this._tmpRect, l, c - o, u - h);
            }
          }
          return !0;
        }
        _isHorizontalClamped(t, e, i, s) {
          const n = t.linesWidth[s],
            r = i > e.nodeContentSize.width || i < 0;
          return t.wrapping ? n > e.nodeContentSize.width && r : r;
        }
        _determineRect(t) {
          const e = t.spriteFrame;
          if (!e) return !1;
          const i = e.isRotated(),
            s = e.getOriginalSize(),
            n = e.getRect(),
            r = e.getOffset(),
            a = r.x + (s.width - n.width) / 2,
            o = r.y - (s.height - n.height) / 2;
          if (i) {
            const t = this._tmpRect.x;
            (this._tmpRect.x =
              n.x + n.height - this._tmpRect.y - this._tmpRect.height - o),
              (this._tmpRect.y = t + n.y - a),
              this._tmpRect.y < 0 && (this._tmpRect.height += o);
          } else (this._tmpRect.x += n.x - a), (this._tmpRect.y += n.y + o);
          return i;
        }
      }
      (BN.instance = void 0), (BN.instance = new BN());
      const FN = new RO(64, 64),
        UN = new TO(null);
      let kN = null,
        zN = null,
        HN = null,
        GN = null,
        VN = null;
      const jN = {
          updateProcessingData(t, e, i, s, n, r) {
            (t.fontSize = n.fontSize),
              (t.actualFontSize = n.fontSize),
              (t.originFontSize = HN ? HN.fontSize : n.fontSize),
              (e.horizontalAlign = n.horizontalAlign),
              (e.verticalAlign = n.verticalAlign),
              (e.spacingX = n.spacingX);
            const a = n.overflow;
            (e.overFlow = a),
              (e.lineHeight = n.lineHeight),
              (i.nodeContentSize.width = r.width),
              (i.nodeContentSize.height = r.height),
              a === Vw.NONE
                ? ((e.wrapping = !1),
                  (i.nodeContentSize.width += 2 * DO.margin),
                  (i.nodeContentSize.height += 2 * DO.margin))
                : a === Vw.RESIZE_HEIGHT
                ? ((e.wrapping = !0),
                  (i.nodeContentSize.height += 2 * DO.margin))
                : (e.wrapping = n.enableWrapText),
              (s.uiTransAnchorX = r.anchorX),
              (s.uiTransAnchorY = r.anchorY),
              (DO.lineHeight = n.lineHeight),
              (DO.fontSize = n.fontSize),
              (t.spriteFrame = GN),
              (t.fntConfig = HN),
              (t.fontFamily = DO.fontFamily),
              t.color.set(n.color);
          },
          updateRenderData(t) {
            if (t.renderData && kN !== t) {
              if (t.renderData.vertDirty) {
                (kN = t), (zN = kN.node._uiProps.uiTransformComp);
                const e = t.renderData,
                  i = BN.instance,
                  s = t.textStyle,
                  n = t.textLayout,
                  r = t.textLayoutData,
                  a = t.textRenderData;
                (s.fontScale = GA.getScaleX()),
                  this._updateFontFamily(t),
                  this.updateProcessingData(s, n, r, a, t, zN),
                  this._updateLabelInfo(t),
                  (s.fontDesc = DO.fontDesc),
                  i.processingString(!0, s, n, r, t.string),
                  (a.quadCount = 0),
                  i.generateRenderInfo(
                    !0,
                    s,
                    n,
                    r,
                    a,
                    t.string,
                    this.generateVertexData
                  );
                let o = !1;
                e.dataLength !== a.quadCount &&
                  (this.resetRenderData(t),
                  (e.dataLength = a.quadCount),
                  e.resize(e.dataLength, (e.dataLength / 2) * 3),
                  (o = !0));
                const h = e.data;
                for (let t = 0, e = a.quadCount; t < e; t++)
                  h[t] = a.vertexBuffer[t];
                const l = e.indexCount;
                this.createQuadIndices(l),
                  e.chunk.setIndexBuffer(VN),
                  (kN.actualFontSize = s.actualFontSize),
                  zN.setContentSize(r.nodeContentSize),
                  this.updateUVs(t),
                  (kN.renderEntity.colorDirty || o) &&
                    (this.updateColor(t), (kN.node._uiProps.colorDirty = !1)),
                  (e.vertDirty = !1),
                  (kN = null),
                  this._resetProperties();
              }
              t.spriteFrame && t.renderData.updateRenderData(t, t.spriteFrame);
            }
          },
          updateUVs(t) {
            const e = t.renderData,
              i = e.chunk.vb,
              s = e.vertexCount,
              n = e.data;
            let r = 3;
            for (let t = 0; t < s; t++) {
              const e = n[t];
              (i[r] = e.u), (i[r + 1] = e.v), (r += 9);
            }
          },
          updateColor(t) {
            {
              const e = t.renderData,
                i = e.vertexCount;
              if (0 === i) return;
              const s = e.chunk.vb,
                n = e.floatStride;
              let r = 5;
              const a = t.color,
                o = a.r / 255,
                h = a.g / 255,
                l = a.b / 255,
                c = a.a / 255;
              for (let t = 0; t < i; t++)
                (s[r] = o),
                  (s[r + 1] = h),
                  (s[r + 2] = l),
                  (s[r + 3] = c),
                  (r += n);
            }
          },
          resetRenderData(t) {
            const e = t.renderData;
            (e.dataLength = 0), e.resize(0, 0);
          },
          generateVertexData(t, e, i, s, n, r, a, o, h) {
            const l = s,
              c = t.bmfontScale,
              u = i.vertexBuffer,
              _ = n.width,
              d = n.height,
              p = r.width,
              m = r.height;
            let f = 0,
              g = 0,
              y = 0,
              T = 0;
            a
              ? ((f = r.x / _),
                (T = (r.x + m) / _),
                (g = (r.y + p) / d),
                (y = r.y / d),
                (u[l].u = f),
                (u[l].v = y),
                (u[l + 1].u = f),
                (u[l + 1].v = g),
                (u[l + 2].u = T),
                (u[l + 2].v = y),
                (u[l + 3].u = T),
                (u[l + 3].v = g))
              : ((f = r.x / _),
                (T = (r.x + p) / _),
                (g = (r.y + m) / d),
                (y = r.y / d),
                (u[l].u = f),
                (u[l].v = g),
                (u[l + 1].u = T),
                (u[l + 1].v = g),
                (u[l + 2].u = f),
                (u[l + 2].v = y),
                (u[l + 3].u = T),
                (u[l + 3].v = y)),
              (u[l].x = o),
              (u[l].y = h - m * c),
              (u[l + 1].x = o + p * c),
              (u[l + 1].y = h - m * c),
              (u[l + 2].x = o),
              (u[l + 2].y = h),
              (u[l + 3].x = o + p * c),
              (u[l + 3].y = h);
          },
          _updateFontFamily(t) {
            const e = t.font;
            (GN = e.spriteFrame),
              (HN = e.fntConfig),
              (DO.fontAtlas = e.fontDefDictionary),
              DO.fontAtlas ||
                (t.cacheMode === jw.CHAR
                  ? (DO.fontAtlas = FN)
                  : (DO.fontAtlas = UN)),
              qA.packToDynamicAtlas(t, GN);
          },
          _updateLabelInfo(t) {
            (DO.hash = ""), (DO.margin = 0);
          },
          _resetProperties() {
            (HN = null), (GN = null), (DO.hash = ""), (DO.margin = 0);
          },
          createQuadIndices(t) {
            if (t % 6 != 0) return void G(16308);
            const e = t / 6;
            VN = new Uint16Array(t);
            let i = 0;
            for (let t = 0; t < e; t++)
              (VN[i++] = 0 + 4 * t),
                (VN[i++] = 1 + 4 * t),
                (VN[i++] = 2 + 4 * t),
                (VN[i++] = 1 + 4 * t),
                (VN[i++] = 3 + 4 * t),
                (VN[i++] = 2 + 4 * t);
          },
        },
        WN = new Qi(255, 255, 255, 255),
        XN = {
          createData(t) {
            const e = t.requestRenderData();
            return e.resize(0, 0), e;
          },
          fillBuffers(t, e) {
            const i = t.node;
            WN.set(t.color),
              (WN.a = 255 * i._uiProps.opacity),
              K_(i, 0, t.renderData, WN);
          },
          appendQuad(t, e, i, s, n, r, a) {
            const o = t.renderData;
            if (!o) return;
            const h = o.dataLength;
            (o.dataLength += 4), o.resize(o.dataLength, (o.dataLength / 2) * 3);
            const l = o.data,
              c = e.width,
              u = e.height,
              _ = i.width,
              d = i.height;
            let p = 0,
              m = 0,
              f = 0,
              g = 0;
            s
              ? ((p = i.x / c),
                (g = (i.x + d) / c),
                (m = (i.y + _) / u),
                (f = i.y / u),
                (l[h].u = p),
                (l[h].v = f),
                (l[h + 1].u = p),
                (l[h + 1].v = m),
                (l[h + 2].u = g),
                (l[h + 2].v = f),
                (l[h + 3].u = g),
                (l[h + 3].v = m))
              : ((p = i.x / c),
                (g = (i.x + _) / c),
                (m = (i.y + d) / u),
                (f = i.y / u),
                (l[h].u = p),
                (l[h].v = m),
                (l[h + 1].u = g),
                (l[h + 1].v = m),
                (l[h + 2].u = p),
                (l[h + 2].v = f),
                (l[h + 3].u = g),
                (l[h + 3].v = f)),
              (l[h].x = n),
              (l[h].y = r - d * a),
              (l[h + 1].x = n + _ * a),
              (l[h + 1].y = r - d * a),
              (l[h + 2].x = n),
              (l[h + 2].y = r),
              (l[h + 3].x = n + _ * a),
              (l[h + 3].y = r);
          },
        };
      xt(XN, jN);
      let YN = null;
      const KN = Mt(jN, {
          getAssemblerData: () => (
            YN || (YN = new RO(1024, 1024)), YN.getTexture()
          ),
          _updateFontFamily(t) {
            (DO.fontAtlas = YN),
              (DO.fontFamily = this._getFontFamily(t)),
              t.enableOutline && t.outlineWidth > 0
                ? ((DO.isOutlined = !0),
                  (DO.margin = t.outlineWidth),
                  (DO.out = t.outlineColor.clone()),
                  (DO.out.a = (t.outlineColor.a * t.color.a) / 255))
                : ((DO.isOutlined = !1), (DO.margin = 0));
          },
          _getFontFamily(t) {
            let e = "Arial";
            return (
              t.useSystemFont
                ? (e = t.fontFamily || "Arial")
                : t.font && (e = t.font._nativeAsset || "Arial"),
              e
            );
          },
          _updateLabelInfo(t) {
            (DO.fontDesc = this._getFontDesc()),
              (DO.color = t.color),
              (DO.hash = (function (t) {
                const e = t.color.toHEX();
                let i = "";
                return (
                  t.isOutlined &&
                    t.margin > 0 &&
                    (i = i + t.margin + t.out.toHEX()),
                  "" + t.fontSize + t.fontFamily + e + i
                );
              })(DO));
          },
          _getFontDesc() {
            let t = `${DO.fontSize.toString()}px `;
            return (t += DO.fontFamily), t;
          },
        }),
        qN = new Qi(255, 255, 255, 255),
        $N = {
          createData(t) {
            const e = t.requestRenderData();
            return e.resize(0, 0), e;
          },
          fillBuffers(t, e) {
            if (!t.renderData) return;
            const i = t.node;
            (qN.a = 255 * i._uiProps.opacity), K_(i, 0, t.renderData, qN);
          },
          updateColor(t) {
            {
              const e = t.renderData,
                i = e.vertexCount;
              if (0 === i) return;
              const s = e.chunk.vb,
                n = e.floatStride;
              let r = 5;
              for (let t = 0; t < i; t++)
                (s[r] = 1),
                  (s[r + 1] = 1),
                  (s[r + 2] = 1),
                  (s[r + 3] = 1),
                  (r += n);
            }
          },
        };
      xt($N, KN);
      const ZN = Ww.Overflow,
        QN = {
          updateProcessingData(t, e, i, s, n, r) {
            (t.isSystemFontUsed = n.useSystemFont),
              (t.fontSize = n.fontSize),
              (i.nodeContentSize.width = i.canvasSize.width = r.width),
              (i.nodeContentSize.height = i.canvasSize.height = r.height),
              (e.lineHeight = n.lineHeight),
              (e.overFlow = n.overflow),
              n.overflow === ZN.NONE
                ? (e.wrapping = !1)
                : n.overflow === ZN.RESIZE_HEIGHT
                ? (e.wrapping = !0)
                : (e.wrapping = n.enableWrapText),
              (t.isBold = n.isBold),
              (t.isItalic = n.isItalic),
              (t.isUnderline = n.isUnderline),
              (t.underlineHeight = n.underlineHeight),
              n.enableOutline && n.outlineWidth > 0
                ? ((t.isOutlined = !0),
                  t.outlineColor.set(n.outlineColor),
                  (t.outlineWidth = n.outlineWidth))
                : (t.isOutlined = !1),
              n.enableShadow &&
              (n.shadowBlur > 0 ||
                !Ti(n.shadowOffset.x, 0) ||
                !Ti(n.shadowOffset.y, 0))
                ? ((t.hasShadow = !1),
                  t.shadowColor.set(n.shadowColor),
                  (t.shadowBlur = n.shadowBlur),
                  (t.shadowOffsetX = n.shadowOffset.x),
                  (t.shadowOffsetY = n.shadowOffset.y))
                : (t.hasShadow = !1),
              t.color.set(n.color),
              (s.texture = n.spriteFrame),
              (s.uiTransAnchorX = r.anchorX),
              (s.uiTransAnchorY = r.anchorY),
              (e.horizontalAlign = n.horizontalAlign),
              (e.verticalAlign = n.verticalAlign);
          },
          getAssemblerData() {
            const t = Ww._canvasPool.get();
            return (t.canvas.width = t.canvas.height = 1), t;
          },
          resetAssemblerData(t) {
            t && Ww._canvasPool.put(t);
          },
          updateRenderData(t) {
            if (t.renderData) {
              if (t.renderData.vertDirty) {
                const e = t.node._uiProps.uiTransformComp,
                  i = BN.instance,
                  s = t.textStyle,
                  n = t.textLayout,
                  r = t.textLayoutData,
                  a = t.textRenderData;
                (s.fontScale = GA.getScaleX()),
                  this.updateProcessingData(s, n, r, a, t, e),
                  i.setCanvasUsed(
                    t.assemblerData.canvas,
                    t.assemblerData.context
                  ),
                  (s.fontFamily = this._updateFontFamily(t)),
                  this._resetDynamicAtlas(t),
                  i.processingString(!1, s, n, r, t.string),
                  i.generateRenderInfo(
                    !1,
                    s,
                    n,
                    r,
                    a,
                    t.string,
                    this.generateVertexData
                  );
                const o = t.renderData;
                (o.textureDirty = !0),
                  this._calDynamicAtlas(t, r),
                  (t.actualFontSize = s.actualFontSize),
                  e.setContentSize(r.nodeContentSize);
                const h = o.data;
                (h[0] = a.vertexBuffer[0]),
                  (h[1] = a.vertexBuffer[1]),
                  (h[2] = a.vertexBuffer[2]),
                  (h[3] = a.vertexBuffer[3]),
                  this.updateUVs(t),
                  (t.renderData.vertDirty = !1),
                  (t.contentWidth = r.nodeContentSize.width);
              }
              t.spriteFrame && t.renderData.updateRenderData(t, t.spriteFrame);
            }
          },
          generateVertexData(t, e, i) {
            const s = i.vertexBuffer,
              n = e.nodeContentSize.width,
              r = e.nodeContentSize.height,
              a = i.uiTransAnchorX * n,
              o = i.uiTransAnchorY * r;
            (s[0].x = -a),
              (s[0].y = -o),
              (s[1].x = n - a),
              (s[1].y = -o),
              (s[2].x = -a),
              (s[2].y = r - o),
              (s[3].x = n - a),
              (s[3].y = r - o);
          },
          updateVertexData(t) {},
          updateUVs(t) {},
          _updateFontFamily(t) {
            let e = "";
            return (
              (e = t.useSystemFont
                ? t.fontFamily || "Arial"
                : (t.font && t.font._nativeAsset) || "Arial"),
              e
            );
          },
          _calDynamicAtlas(t, e) {
            if (
              t.cacheMode !== Ww.CacheMode.BITMAP ||
              e.canvasSize.width <= 0 ||
              e.canvasSize.height <= 0
            )
              return;
            const i = t.ttfSpriteFrame;
            qA.packToDynamicAtlas(t, i);
          },
          _resetDynamicAtlas(t) {
            if (t.cacheMode !== Ww.CacheMode.BITMAP) return;
            const e = t.ttfSpriteFrame;
            qA.deleteAtlasSpriteFrame(e), e._resetDynamicAtlasFrame();
          },
        },
        JN = Qi.WHITE.clone(),
        tL = Uint16Array.from([0, 1, 2, 1, 3, 2]),
        eL = {
          createData(t) {
            const e = t.requestRenderData();
            (e.dataLength = 4),
              e.resize(4, 6),
              (t.textRenderData.quadCount = 4);
            const i = e.chunk.vb;
            (i[3] = i[21] = i[22] = i[31] = 0),
              (i[4] = i[12] = i[13] = i[30] = 1);
            let s = 5;
            for (let t = 0; t < 4; t++) Qi.toArray(i, JN, s), (s += 9);
            return e.chunk.setIndexBuffer(tL), e;
          },
          fillBuffers(t, e) {
            const i = t.renderData,
              s = i.chunk,
              n = i.data,
              r = t.node,
              a = s.vb,
              o = r.worldMatrix,
              h = i.floatStride;
            let l = 0;
            const c = n.length;
            for (let t = 0; t < c; t++) {
              const e = n[t],
                i = e.x,
                s = e.y;
              let r = o.m03 * i + o.m07 * s + o.m15;
              (r = r ? 1 / r : 1),
                (l = t * h),
                (a[l + 0] = (o.m00 * i + o.m04 * s + o.m12) * r),
                (a[l + 1] = (o.m01 * i + o.m05 * s + o.m13) * r),
                (a[l + 2] = (o.m02 * i + o.m06 * s + o.m14) * r);
            }
            const u = s.vertexOffset,
              _ = s.meshBuffer,
              d = s.meshBuffer.iData;
            let p = _.indexOffset;
            (d[p++] = u),
              (d[p++] = u + 1),
              (d[p++] = u + 2),
              (d[p++] = u + 2),
              (d[p++] = u + 1),
              (d[p++] = u + 3),
              (_.indexOffset += 6);
          },
          updateVertexData(t) {
            const e = t.renderData;
            if (!e) return;
            const i = t.node._uiProps.uiTransformComp,
              s = i.width,
              n = i.height,
              r = i.anchorX * s,
              a = i.anchorY * n,
              o = e.data;
            (o[0].x = -r),
              (o[0].y = -a),
              (o[1].x = s - r),
              (o[1].y = -a),
              (o[2].x = -r),
              (o[2].y = n - a),
              (o[3].x = s - r),
              (o[3].y = n - a);
          },
          updateUVs(t) {
            const e = t.renderData;
            if (!e || !t.ttfSpriteFrame) return;
            const i = e.chunk.vb,
              s = t.ttfSpriteFrame.uv;
            (i[3] = s[0]),
              (i[4] = s[1]),
              (i[12] = s[2]),
              (i[13] = s[3]),
              (i[21] = s[4]),
              (i[22] = s[5]),
              (i[30] = s[6]),
              (i[31] = s[7]);
          },
          updateColor(t) {},
        };
      xt(eL, QN);
      const iL = t("labelAssembler", {
        getAssembler(t) {
          let e = eL;
          return (
            t.font instanceof SO
              ? (e = XN)
              : t.cacheMode === Ww.CacheMode.CHAR && (e = $N),
            e
          );
        },
      });
      Ww.Assembler = iL;
      const sL = XD.FillType,
        nL = new ms(),
        rL = Uint16Array.from([0, 1, 2, 1, 3, 2]),
        aL = {
          updateRenderData(t) {
            const e = t.spriteFrame;
            qA.packToDynamicAtlas(t, e);
            const i = t.renderData;
            if (i && e) {
              if (!i.vertDirty) return;
              let s = t.fillStart,
                n = t.fillRange;
              n < 0 && ((s += n), (n = -n)),
                (n = s + n),
                (s = s > 1 ? 1 : s),
                (s = s < 0 ? 0 : s),
                (n = n > 1 ? 1 : n),
                (n = n < 0 ? 0 : n),
                (n -= s),
                (n = n < 0 ? 0 : n);
              let r = s + n;
              (r = r > 1 ? 1 : r),
                this.updateUVs(t, s, r),
                this.updateVertexData(t, s, r),
                i.updateRenderData(t, e);
            }
          },
          updateUVs(t, e, i) {
            const s = t.spriteFrame,
              n = t.renderData.chunk.vb,
              r = s.width,
              a = s.height,
              o = s.rect;
            let h = 0,
              l = 0,
              c = 0,
              u = 0,
              _ = 0,
              d = 0,
              p = 0,
              m = 0,
              f = 0,
              g = 0,
              y = 0,
              T = 0;
            switch (
              (s.isRotated()
                ? ((h = o.x / r),
                  (l = (o.y + o.width) / a),
                  (c = (o.x + o.height) / r),
                  (u = o.y / a),
                  (_ = p = h),
                  (f = y = c),
                  (m = T = l),
                  (d = g = u))
                : ((h = o.x / r),
                  (l = (o.y + o.height) / a),
                  (c = (o.x + o.width) / r),
                  (u = o.y / a),
                  (_ = f = h),
                  (p = y = c),
                  (d = m = l),
                  (g = T = u)),
              t.fillType)
            ) {
              case sL.HORIZONTAL:
                (n[3] = _ + (p - _) * e),
                  (n[4] = d + (m - d) * e),
                  (n[12] = _ + (p - _) * i),
                  (n[13] = d + (m - d) * i),
                  (n[21] = f + (y - f) * e),
                  (n[22] = g + (T - g) * e),
                  (n[30] = f + (y - f) * i),
                  (n[31] = g + (T - g) * i);
                break;
              case sL.VERTICAL:
                (n[3] = _ + (f - _) * e),
                  (n[4] = d + (g - d) * e),
                  (n[12] = p + (y - p) * e),
                  (n[13] = m + (T - m) * e),
                  (n[21] = _ + (f - _) * i),
                  (n[22] = d + (g - d) * i),
                  (n[30] = p + (y - p) * i),
                  (n[31] = m + (T - m) * i);
                break;
              default:
                G(2626);
            }
          },
          updateVertexData(t, e, i) {
            const s = t.renderData.data,
              n = t.node._uiProps.uiTransformComp,
              r = n.width,
              a = n.height,
              o = n.anchorX * r,
              h = n.anchorY * a;
            let l = -o,
              c = -h,
              u = r - o,
              _ = a - h,
              d = 0,
              p = 0;
            switch (t.fillType) {
              case sL.HORIZONTAL:
                (d = l + (u - l) * e), (p = l + (u - l) * i), (l = d), (u = p);
                break;
              case sL.VERTICAL:
                (d = c + (_ - c) * e), (p = c + (_ - c) * i), (c = d), (_ = p);
                break;
              default:
                G(2626);
            }
            (s[0].x = l),
              (s[0].y = c),
              (s[1].x = u),
              (s[1].y = c),
              (s[2].x = l),
              (s[2].y = _),
              (s[3].x = u),
              (s[3].y = _);
          },
          createData(t) {
            const e = t.requestRenderData();
            (e.dataLength = 4), e.resize(4, 6), e.chunk.setIndexBuffer(rL);
            const i = e.data;
            for (const t of i) t.z = 0;
            return e;
          },
          updateWorldVertexData(t, e) {
            t.node.getWorldMatrix(nL);
            const i = t.renderData.floatStride,
              s = t.renderData.data,
              n = e.vb;
            let r = 0;
            for (let t = 0; t < 4; t++) {
              const e = s[t],
                a = e.x,
                o = e.y;
              let h = nL.m03 * a + nL.m07 * o + nL.m15;
              (h = h ? 1 / h : 1),
                (r = t * i),
                (n[r] = (nL.m00 * a + nL.m04 * o + nL.m12) * h),
                (n[r + 1] = (nL.m01 * a + nL.m05 * o + nL.m13) * h),
                (n[r + 2] = (nL.m02 * a + nL.m06 * o + nL.m14) * h);
            }
          },
          fillBuffers(t, e) {
            const i = t.renderData,
              s = i.chunk;
            (t._flagChangedVersion !== t.node.flagChangedVersion ||
              i.vertDirty) &&
              (this.updateWorldVertexData(t, s),
              (i.vertDirty = !1),
              (t._flagChangedVersion = t.node.flagChangedVersion)),
              s.bufferId;
            const n = s.vertexOffset,
              r = s.meshBuffer,
              a = s.meshBuffer.iData;
            let o = r.indexOffset;
            (a[o++] = n),
              (a[o++] = n + 1),
              (a[o++] = n + 2),
              (a[o++] = n + 2),
              (a[o++] = n + 1),
              (a[o++] = n + 3),
              (r.indexOffset += 6);
          },
          updateColor(t) {
            const e = t.renderData,
              i = e.chunk.vb,
              s = e.floatStride;
            let n = 5;
            const r = t.color,
              a = r.r / 255,
              o = r.g / 255,
              h = r.b / 255,
              l = t.node._uiProps.opacity;
            for (let t = 0; t < 4; t++)
              (i[n] = a),
                (i[n + 1] = o),
                (i[n + 2] = h),
                (i[n + 3] = l),
                (n += s);
          },
        },
        oL = 2 * Math.PI,
        hL = 1e-6,
        lL = new ms(),
        cL = [new Ss(), new Ss(), new Ss(), new Ss()],
        uL = new Array(4),
        _L = new Array(8),
        dL = [new Ss(), new Ss(), new Ss(), new Ss()],
        pL = [new Ss(), new Ss(), new Ss(), new Ss()],
        mL = new Ss(),
        fL = [new Ss(), new Ss(), new Ss(), new Ss()];
      let gL = null;
      function yL(t, e, i, s, n, r, a) {
        let o = Math.sin(r);
        o = Math.abs(o) > hL ? o : 0;
        let h = Math.cos(r);
        h = Math.abs(h) > hL ? h : 0;
        let l = 0,
          c = 0;
        if (0 !== h) {
          if (((l = o / h), (t - n.x) * h > 0)) {
            const e = n.y + l * (t - n.x);
            (a[0].x = t), (a[0].y = e);
          }
          if ((e - n.x) * h > 0) {
            const t = n.y + l * (e - n.x);
            (a[2].x = e), (a[2].y = t);
          }
        }
        if (0 !== o) {
          if (((c = h / o), (s - n.y) * o > 0)) {
            const t = n.x + c * (s - n.y);
            (a[3].x = t), (a[3].y = s);
          }
          if ((i - n.y) * o > 0) {
            const t = n.x + c * (i - n.y);
            (a[1].x = t), (a[1].y = i);
          }
        }
      }
      function TL(t, e) {
        const i = e.x - t.x,
          s = e.y - t.y;
        if (0 === i && 0 === s) return 0;
        if (0 === i) return s > 0 ? 0.5 * Math.PI : 1.5 * Math.PI;
        {
          let t = Math.atan(s / i);
          return i < 0 && (t += Math.PI), t;
        }
      }
      function SL(t, e, i, s, n) {
        const r = uL,
          a = r[0],
          o = r[1],
          h = r[2],
          l = r[3];
        (t[e].x = i.x),
          (t[e].y = i.y),
          (t[e + 1].x = s.x),
          (t[e + 1].y = s.y),
          (t[e + 2].x = n.x),
          (t[e + 2].y = n.y);
        let c = 0,
          u = 0;
        (c = (i.x - a) / (h - a)),
          (u = (i.y - o) / (l - o)),
          EL(c, u, t, e),
          (c = (s.x - a) / (h - a)),
          (u = (s.y - o) / (l - o)),
          EL(c, u, t, e + 1),
          (c = (n.x - a) / (h - a)),
          (u = (n.y - o) / (l - o)),
          EL(c, u, t, e + 2);
      }
      function EL(t, e, i, s) {
        const n = _L,
          r = n[0] + (n[2] - n[0]) * t,
          a = n[4] + (n[6] - n[4]) * t,
          o = n[1] + (n[3] - n[1]) * t,
          h = n[5] + (n[7] - n[5]) * t,
          l = i[s];
        (l.u = r + (a - r) * e), (l.v = o + (h - o) * e);
      }
      const vL = {
          useModel: !1,
          createData: (t) => t.requestRenderData(),
          updateRenderData(t) {
            const e = t.spriteFrame;
            qA.packToDynamicAtlas(t, e), this.updateUVs(t);
            const i = t.renderData;
            if (i && e) {
              if (!i.vertDirty) return;
              const s = i.data;
              let n = t.fillStart,
                r = t.fillRange;
              for (r < 0 && ((n += r), (r = -r)); n >= 1; ) n -= 1;
              for (; n < 0; ) n += 1;
              (n *= oL), (r *= oL);
              const a = n + r;
              !(function (t) {
                const e = t.node._uiProps.uiTransformComp,
                  i = e.width,
                  s = e.height,
                  n = e.anchorX * i,
                  r = e.anchorY * s,
                  a = -n,
                  o = -r,
                  h = i - n,
                  l = s - r,
                  c = uL;
                (c[0] = a), (c[1] = o), (c[2] = h), (c[3] = l);
                const u = t.fillCenter,
                  _ = (mL.x = Math.min(Math.max(0, u.x), 1) * (h - a) + a),
                  d = (mL.y = Math.min(Math.max(0, u.y), 1) * (l - o) + o);
                (cL[0].x = cL[3].x = a),
                  (cL[1].x = cL[2].x = h),
                  (cL[0].y = cL[1].y = o),
                  (cL[2].y = cL[3].y = l);
                for (const t of fL) Ss.set(t, 0, 0);
                _ !== c[0] && Ss.set(fL[0], 3, 0),
                  _ !== c[2] && Ss.set(fL[2], 1, 2),
                  d !== c[1] && Ss.set(fL[1], 0, 1),
                  d !== c[3] && Ss.set(fL[3], 2, 3);
              })(t),
                (function (t) {
                  const e = t.width,
                    i = t.height,
                    s = t.getRect();
                  let n = 0,
                    r = 0,
                    a = 0,
                    o = 0;
                  const h = _L;
                  t.isRotated()
                    ? ((n = s.x / e),
                      (r = (s.x + s.height) / e),
                      (a = s.y / i),
                      (o = (s.y + s.width) / i),
                      (h[0] = h[2] = n),
                      (h[4] = h[6] = r),
                      (h[3] = h[7] = o),
                      (h[1] = h[5] = a))
                    : ((n = s.x / e),
                      (r = (s.x + s.width) / e),
                      (a = s.y / i),
                      (o = (s.y + s.height) / i),
                      (h[0] = h[4] = n),
                      (h[2] = h[6] = r),
                      (h[1] = h[3] = o),
                      (h[5] = h[7] = a));
                })(e),
                yL(uL[0], uL[2], uL[1], uL[3], mL, n, dL),
                yL(uL[0], uL[2], uL[1], uL[3], mL, n + r, pL);
              let o = 0;
              for (let t = 0; t < 4; ++t) {
                const e = fL[t];
                if (!e) continue;
                if (r >= oL) {
                  (i.dataLength = o + 3),
                    SL(s, o, mL, cL[e.x], cL[e.y]),
                    (o += 3);
                  continue;
                }
                let h = TL(mL, cL[e.x]),
                  l = TL(mL, cL[e.y]);
                l < h && (l += oL), (h -= oL), (l -= oL);
                for (let r = 0; r < 3; ++r)
                  h >= a ||
                    (h >= n
                      ? ((i.dataLength = o + 3),
                        SL(s, o, mL, cL[e.x], l >= a ? pL[t] : cL[e.y]),
                        (o += 3))
                      : l > n &&
                        (l <= a
                          ? ((i.dataLength = o + 3),
                            SL(s, o, mL, dL[t], cL[e.y]),
                            (o += 3))
                          : ((i.dataLength = o + 3),
                            SL(s, o, mL, dL[t], pL[t]),
                            (o += 3)))),
                    (h += oL),
                    (l += oL);
              }
              0 === o && (i.dataLength = 0), i.resize(o, o);
              {
                const e = i.indexCount;
                this.createQuadIndices(e),
                  i.chunk.setIndexBuffer(gL),
                  this.updateWorldUVData(t),
                  (t.renderEntity.colorDirty = !0);
              }
              i.updateRenderData(t, e);
            }
          },
          createQuadIndices(t) {
            (gL = null), (gL = new Uint16Array(t));
            let e = 0;
            for (let i = 0; i < t; i++) gL[e++] = i;
          },
          fillBuffers(t, e) {
            const i = t.node,
              s = t.renderData,
              n = s.chunk;
            (t._flagChangedVersion !== i.flagChangedVersion || s.vertDirty) &&
              (this.updateWorldVertexAndUVData(t, n),
              (s.vertDirty = !1),
              (t._flagChangedVersion = i.flagChangedVersion)),
              this.updateColorLate(t),
              n.bufferId;
            const r = n.vertexOffset,
              a = n.meshBuffer,
              o = n.meshBuffer.iData,
              h = a.indexOffset;
            for (let t = 0; t < s.indexCount; t++) o[h + t] = r + t;
            (a.indexOffset += s.indexCount), a.setDirty();
          },
          updateWorldUVData(t, e) {
            const i = t.renderData,
              s = i.floatStride,
              n = i.data,
              r = i.chunk.vb;
            for (let t = 0; t < n.length; t++) {
              const e = t * s;
              (r[e + 3] = n[t].u), (r[e + 4] = n[t].v);
            }
          },
          updateWorldVertexAndUVData(t, e) {
            t.node.getWorldMatrix(lL);
            const i = t.renderData,
              s = i.floatStride,
              n = t.renderData.data,
              r = e.vb,
              a = i.vertexCount;
            let o = 0;
            for (let t = 0; t < a; t++) {
              const e = n[t],
                i = e.x,
                a = e.y;
              let h = lL.m03 * i + lL.m07 * a + lL.m15;
              (h = h ? 1 / h : 1),
                (r[o + 0] = (lL.m00 * i + lL.m04 * a + lL.m12) * h),
                (r[o + 1] = (lL.m01 * i + lL.m05 * a + lL.m13) * h),
                (r[o + 2] = (lL.m02 * i + lL.m06 * a + lL.m14) * h),
                (r[o + 3] = e.u),
                (r[o + 4] = e.v),
                (o += s);
            }
          },
          updateUVs(t) {
            (t.renderData.vertDirty = !0), t.markForUpdateRenderData();
          },
          updateColorLate(t) {
            const e = t.renderData,
              i = e.chunk.vb,
              s = e.floatStride,
              n = e.vertexCount;
            let r = 5;
            const a = t.color,
              o = a.r / 255,
              h = a.g / 255,
              l = a.b / 255,
              c = t.node._uiProps.opacity;
            for (let t = 0; t < n; t++)
              (i[r] = o),
                (i[r + 1] = h),
                (i[r + 2] = l),
                (i[r + 3] = c),
                (r += s);
          },
          updateColor(t) {},
        },
        bL = Uint16Array.from([0, 1, 2, 1, 3, 2]),
        AL = {
          createData(t) {
            const e = t.requestRenderData();
            return (
              (e.dataLength = 4), e.resize(4, 6), e.chunk.setIndexBuffer(bL), e
            );
          },
          updateRenderData(t) {
            const e = t.spriteFrame;
            qA.packToDynamicAtlas(t, e), this.updateUVs(t);
            const i = t.renderData;
            i &&
              e &&
              (i.vertDirty && this.updateVertexData(t),
              i.updateRenderData(t, e));
          },
          updateWorldVerts(t, e) {
            const i = t.renderData,
              s = e.vb,
              n = i.data,
              r = t.node.worldMatrix,
              a = r.m00,
              o = r.m01,
              h = r.m02,
              l = r.m03,
              c = r.m04,
              u = r.m05,
              _ = r.m06,
              d = r.m07,
              p = r.m12,
              m = r.m13,
              f = r.m14,
              g = r.m15,
              y = i.floatStride;
            let T = 0;
            const S = n.length;
            for (let t = 0; t < S; ++t) {
              const e = n[t],
                i = e.x,
                r = e.y;
              let S = l * i + d * r + g;
              (S = S ? 1 / S : 1),
                (T = t * y),
                (s[T + 0] = (a * i + c * r + p) * S),
                (s[T + 1] = (o * i + u * r + m) * S),
                (s[T + 2] = (h * i + _ * r + f) * S);
            }
          },
          fillBuffers(t, e) {
            if (null === t) return;
            const i = t.renderData,
              s = i.chunk;
            (t._flagChangedVersion !== t.node.flagChangedVersion ||
              i.vertDirty) &&
              (this.updateWorldVerts(t, s),
              (i.vertDirty = !1),
              (t._flagChangedVersion = t.node.flagChangedVersion));
            const n = s.vertexOffset,
              r = s.meshBuffer,
              a = s.meshBuffer.iData;
            let o = r.indexOffset;
            const h = n;
            (a[o++] = h),
              (a[o++] = h + 1),
              (a[o++] = h + 2),
              (a[o++] = h + 1),
              (a[o++] = h + 3),
              (a[o++] = h + 2),
              (r.indexOffset += 6);
          },
          updateVertexData(t) {
            const e = t.renderData;
            if (!e) return;
            const i = t.node._uiProps.uiTransformComp,
              s = e.data,
              n = i.width,
              r = i.height,
              a = i.anchorX * n,
              o = i.anchorY * r;
            let h = 0,
              l = 0,
              c = 0,
              u = 0;
            if (t.trim) (h = -a), (l = -o), (c = n - a), (u = r - o);
            else {
              const e = t.spriteFrame,
                i = e.originalSize,
                s = n / i.width,
                _ = r / i.height,
                d = e.trimmedBorder;
              (h = d.x * s - a),
                (l = d.z * _ - o),
                (c = n + d.y * s - a),
                (u = r + d.w * _ - o);
            }
            (s[0].x = h),
              (s[0].y = l),
              (s[1].x = c),
              (s[1].y = l),
              (s[2].x = h),
              (s[2].y = u),
              (s[3].x = c),
              (s[3].y = u),
              (e.vertDirty = !0);
          },
          updateUVs(t) {
            if (!t.spriteFrame) return;
            const e = t.renderData.chunk.vb,
              i = t.spriteFrame.uv;
            (e[3] = i[0]),
              (e[4] = i[1]),
              (e[12] = i[2]),
              (e[13] = i[3]),
              (e[21] = i[4]),
              (e[22] = i[5]),
              (e[30] = i[6]),
              (e[31] = i[7]);
          },
          updateColor(t) {
            const e = t.renderData,
              i = e.chunk.vb;
            let s = 5;
            const n = t.color,
              r = n.r / 255,
              a = n.g / 255,
              o = n.b / 255,
              h = n.a / 255;
            for (let t = 0; t < 4; t++, s += e.floatStride)
              (i[s] = r), (i[s + 1] = a), (i[s + 2] = o), (i[s + 3] = h);
          },
        },
        CL = [];
      for (let t = 0; t < 4; t++)
        CL.push({ x: 0, y: 0, z: 0, u: 0, v: 0, color: new Qi() });
      const OL = {
          createData(t) {
            const e = t.requestRenderData();
            return (
              (e.dataLength = 16),
              e.resize(16, 54),
              (this.QUAD_INDICES = new Uint16Array(54)),
              this.createQuadIndices(4, 4),
              e.chunk.setIndexBuffer(this.QUAD_INDICES),
              e
            );
          },
          createQuadIndices(t, e) {
            let i = 0;
            for (let s = 0; s < t - 1; s++)
              for (let t = 0; t < e - 1; t++) {
                const n = s * e + t;
                (this.QUAD_INDICES[i++] = n),
                  (this.QUAD_INDICES[i++] = n + 1),
                  (this.QUAD_INDICES[i++] = n + e),
                  (this.QUAD_INDICES[i++] = n + 1),
                  (this.QUAD_INDICES[i++] = n + 1 + e),
                  (this.QUAD_INDICES[i++] = n + e);
              }
          },
          updateRenderData(t) {
            const e = t.spriteFrame;
            qA.packToDynamicAtlas(t, e), this.updateUVs(t);
            const i = t.renderData;
            i &&
              e &&
              (i.vertDirty && this.updateVertexData(t),
              i.updateRenderData(t, e));
          },
          updateVertexData(t) {
            const e = t.renderData,
              i = e.data,
              s = t.node._uiProps.uiTransformComp,
              n = s.width,
              r = s.height,
              a = s.anchorX * n,
              o = s.anchorY * r,
              h = t.spriteFrame,
              l = h.insetLeft,
              c = h.insetRight,
              u = h.insetTop,
              _ = h.insetBottom;
            let d = n - l - c,
              p = r - u - _,
              m = n / (l + c),
              f = r / (u + _);
            (m = Number.isNaN(m) || m > 1 ? 1 : m),
              (f = Number.isNaN(f) || f > 1 ? 1 : f),
              (d = d < 0 ? 0 : d),
              (p = p < 0 ? 0 : p),
              (CL[0].x = -a),
              (CL[0].y = -o),
              (CL[1].x = l * m - a),
              (CL[1].y = _ * f - o),
              (CL[2].x = CL[1].x + d),
              (CL[2].y = CL[1].y + p),
              (CL[3].x = n - a),
              (CL[3].y = r - o);
            for (let t = 0; t < 4; t++)
              for (let s = 0; s < 4; s++) {
                const n = 4 * t + s;
                n < e.dataLength &&
                  t < CL.length &&
                  s < CL.length &&
                  ((i[n].x = CL[s].x), (i[n].y = CL[t].y));
              }
          },
          fillBuffers(t, e) {
            const i = t.renderData,
              s = i.chunk;
            (t._flagChangedVersion !== t.node.flagChangedVersion ||
              i.vertDirty) &&
              (this.updateWorldVertexData(t, s),
              (i.vertDirty = !1),
              (t._flagChangedVersion = t.node.flagChangedVersion)),
              s.bufferId;
            const n = s.vertexOffset,
              r = s.meshBuffer,
              a = s.meshBuffer.iData;
            let o = r.indexOffset;
            for (let t = 0; t < 3; ++t)
              for (let e = 0; e < 3; ++e) {
                const i = n + 4 * t + e;
                (a[o++] = i),
                  (a[o++] = i + 1),
                  (a[o++] = i + 4),
                  (a[o++] = i + 1),
                  (a[o++] = i + 5),
                  (a[o++] = i + 4);
              }
            r.indexOffset = o;
          },
          updateWorldVertexData(t, e) {
            const i = t.renderData,
              s = i.floatStride,
              n = i.data,
              r = e.vb,
              a = t.node.worldMatrix,
              o = a.m00,
              h = a.m01,
              l = a.m02,
              c = a.m03,
              u = a.m04,
              _ = a.m05,
              d = a.m06,
              p = a.m07,
              m = a.m12,
              f = a.m13,
              g = a.m14,
              y = a.m15;
            let T = 0;
            for (let t = 0; t < 4; ++t) {
              const e = n[4 * t];
              for (let i = 0; i < 4; ++i) {
                const a = n[i].x,
                  S = e.y;
                let E = c * a + p * S + y;
                (E = E ? 1 / E : 1),
                  (T = (4 * t + i) * s),
                  (r[T + 0] = (o * a + u * S + m) * E),
                  (r[T + 1] = (h * a + _ * S + f) * E),
                  (r[T + 2] = (l * a + d * S + g) * E);
              }
            }
          },
          updateUVs(t) {
            if (!t.spriteFrame) return;
            const e = t.renderData,
              i = e.chunk.vb,
              s = e.floatStride,
              n = t.spriteFrame.uvSliced;
            let r = 3;
            for (let t = 0; t < 16; t++)
              (i[r] = n[t].u), (i[r + 1] = n[t].v), (r += s);
          },
          updateColor(t) {
            const e = t.renderData,
              i = e.chunk.vb,
              s = e.floatStride;
            let n = 5;
            const r = t.color,
              a = r.r / 255,
              o = r.g / 255,
              h = r.b / 255,
              l = t.node._uiProps.opacity;
            for (let t = 0; t < 16; t++)
              (i[n] = a),
                (i[n + 1] = o),
                (i[n + 2] = h),
                (i[n + 3] = l),
                (n += s);
          },
        },
        IL = new ms();
      let wL,
        RL,
        DL,
        xL,
        ML,
        PL,
        NL,
        LL = 0;
      const BL = [];
      let FL = null;
      function UL(t) {
        return t &&
          (t.insetTop > 0 ||
            t.insetBottom > 0 ||
            t.insetLeft > 0 ||
            t.insetRight > 0)
          ? 2
          : 0;
      }
      const kL = {
          createData: (t) => t.requestRenderData(),
          updateRenderData(t) {
            const e = t.renderData,
              i = t.spriteFrame;
            if (!i || !e) return;
            if (!e.vertDirty) return;
            const s = t.node._uiProps.uiTransformComp,
              n = Math.abs(s.width),
              r = Math.abs(s.height),
              a = i.getRect(),
              o = i.insetLeft,
              h = i.insetRight,
              l = a.width - o - h,
              c = i.insetTop,
              u = i.insetBottom,
              _ = a.height - c - u;
            let d = n - o - h,
              p = r - c - u;
            (d = d > 0 ? d : 0), (p = p > 0 ? p : 0);
            const m = 0 === l ? d : d / l,
              f = 0 === _ ? p : p / _,
              g = UL(i),
              y = Math.ceil(f + g),
              T = Math.ceil(m + g);
            (e.dataLength = 4 * y * T),
              this.updateVerts(t, d, p, y, T),
              e.vertexCount !== y * T * 4 && (t.renderEntity.colorDirty = !0),
              e.resize(y * T * 4, y * T * 6);
            {
              const i = e.indexCount;
              this.createQuadIndices(i),
                e.chunk.setIndexBuffer(FL),
                this.updateWorldUVData(t);
            }
            e.updateRenderData(t, i);
          },
          createQuadIndices(t) {
            if (t % 6 != 0) return void G(16308);
            const e = t / 6;
            FL = new Uint16Array(t);
            let i = 0;
            for (let t = 0; t < e; t++)
              (FL[i++] = 0 + 4 * t),
                (FL[i++] = 1 + 4 * t),
                (FL[i++] = 2 + 4 * t),
                (FL[i++] = 1 + 4 * t),
                (FL[i++] = 3 + 4 * t),
                (FL[i++] = 2 + 4 * t);
          },
          updateUVs(t) {
            (t.renderData.vertDirty = !0), t.markForUpdateRenderData();
          },
          fillBuffers(t, e) {
            const i = t.node,
              s = t.renderData,
              n = s.chunk;
            if (null === n) return;
            (t._flagChangedVersion !== i.flagChangedVersion || s.vertDirty) &&
              (this.updateWorldVertexAndUVData(t, n),
              (s.vertDirty = !1),
              (t._flagChangedVersion = i.flagChangedVersion)),
              this.updateColorLate(t),
              n.bufferId;
            let r = n.vertexOffset;
            const a = n.meshBuffer,
              o = n.meshBuffer.iData;
            let h = a.indexOffset;
            for (let t = 0; t < s.indexCount; t += 6)
              (o[h++] = r),
                (o[h++] = r + 1),
                (o[h++] = r + 2),
                (o[h++] = r + 1),
                (o[h++] = r + 3),
                (o[h++] = r + 2),
                (r += 4),
                (a.indexOffset += 6);
            a.setDirty();
          },
          updateWorldUVData(t) {
            const e = t.renderData,
              i = e.floatStride,
              s = e.data,
              n = e.chunk.vb;
            for (let t = 0; t < s.length; t++) {
              const e = t * i;
              (n[e + 3] = s[t].u), (n[e + 4] = s[t].v);
            }
          },
          updateWorldVertexAndUVData(t, e) {
            t.node.getWorldMatrix(IL);
            const i = t.renderData,
              s = i.floatStride,
              n = i.data,
              r = e.vb,
              a = n.length;
            for (let t = 0; t < a; t++) {
              const e = n[t].x,
                i = n[t].y,
                a = n[t].z;
              let o = IL.m03 * e + IL.m07 * i + IL.m11 * a + IL.m15;
              o = o ? 1 / o : 1;
              const h = t * s;
              (r[h] = (IL.m00 * e + IL.m04 * i + IL.m08 * a + IL.m12) * o),
                (r[h + 1] =
                  (IL.m01 * e + IL.m05 * i + IL.m09 * a + IL.m13) * o),
                (r[h + 2] =
                  (IL.m02 * e + IL.m06 * i + IL.m10 * a + IL.m14) * o);
            }
            this.updateWorldUVData(t);
          },
          updateVerts(t, e, i, s, n) {
            const r = t.node._uiProps.uiTransformComp,
              a = t.renderData.data,
              o = t.spriteFrame,
              h = o.rect,
              l = Math.abs(r.width),
              c = Math.abs(r.height),
              u = r.anchorX * l,
              _ = r.anchorY * c,
              d = o.insetLeft,
              p = o.insetRight,
              m = h.width - d - p,
              f = o.insetTop,
              g = o.insetBottom,
              y = h.height - f - g,
              T = r.width / (d + p) > 1 ? 1 : r.width / (d + p),
              S = r.height / (f + g) > 1 ? 1 : r.height / (f + g);
            let E = 0,
              v = 0;
            (E =
              m > 0 ? ((Math.floor(1e3 * e) / 1e3) % m == 0 ? m : e % m) : e),
              (v =
                y > 0 ? ((Math.floor(1e3 * i) / 1e3) % y == 0 ? y : i % y) : i),
              (BL.length = 0),
              (LL = Math.max(s + 1, n + 1));
            for (let t = 0; t < LL; t++)
              BL.push({ x: 0, y: 0, z: 0, u: 0, v: 0, color: new Qi() });
            const b = UL(o);
            if (0 === b)
              for (let t = 0; t < LL; t++)
                (BL[t].x = t >= n ? l - u : t * m - u),
                  (BL[t].y = t >= s ? c - _ : t * y - _);
            else
              for (let t = 0; t < LL; t++)
                0 === t
                  ? (BL[t].x = -u)
                  : 1 === t
                  ? (BL[t].x = d * T - u)
                  : t > 1 && t < n - 1
                  ? (BL[t].x = m > 0 ? d * T - u + m * (t - 1) : d + e - u)
                  : t === n - 1
                  ? (BL[t].x = d * T - u + E + m * (t - 2))
                  : t >= n && (BL[t].x = Math.min(d + e + p, l) - u),
                  0 === t
                    ? (BL[t].y = -_)
                    : 1 === t
                    ? (BL[t].y = g * S - _)
                    : t > 1 && t < s - 1
                    ? (BL[t].y = y > 0 ? g * S - _ + y * (t - 1) : g + i - _)
                    : t === s - 1
                    ? (BL[t].y = g * S - _ + v + y * (t - 2))
                    : t >= s && (BL[t].y = Math.min(g + i + f, c) - _);
            let A = 0,
              C = 0,
              O = 0,
              I = 0;
            for (let t = 0; t < s; ++t) {
              (O = BL[t].y), (I = BL[t + 1].y);
              for (let e = 0; e < n; ++e) {
                (A = BL[e].x), (C = BL[e + 1].x);
                const i = 4 * (t * n + e);
                (a[i].x = A),
                  (a[i].y = O),
                  (a[i + 1].x = C),
                  (a[i + 1].y = O),
                  (a[i + 2].x = A),
                  (a[i + 2].y = I),
                  (a[i + 3].x = C),
                  (a[i + 3].y = I);
              }
            }
            const w = o.rotated;
            o.uv;
            const R = o.uvSliced;
            (wL = R[0]),
              (RL = R[1]),
              (DL = R[2]),
              (xL = R[3]),
              (ML = R[4]),
              (PL = R[8]),
              (NL = R[12]);
            let D = 0,
              x = 0;
            const M = 0 === m ? e : e / m,
              P = 0 === y ? i : i / y,
              N = [],
              L = [];
            for (let t = 0; t < s; ++t) {
              x = i > y ? (i >= (b > 0 ? t : t + 1) * y ? 1 : P % 1) : P;
              for (let i = 0; i < n; ++i) {
                (D = e > m ? (e >= (b > 0 ? i : i + 1) * m ? 1 : M % 1) : M),
                  w
                    ? (0 === b
                        ? ((N[0] = ML.u),
                          (N[1] = ML.u),
                          (N[2] = ML.u + (PL.u - ML.u) * x),
                          (L[0] = RL.v),
                          (L[1] = RL.v + (DL.v - RL.v) * D),
                          (L[2] = RL.v))
                        : (0 === t
                            ? ((N[0] = wL.u), (N[1] = wL.u), (N[2] = ML.u))
                            : t < s - 1
                            ? ((N[0] = ML.u),
                              (N[1] = ML.u),
                              (N[2] = ML.u + (PL.u - ML.u) * x))
                            : t === s - 1 &&
                              ((N[0] = PL.u), (N[1] = PL.u), (N[2] = NL.u)),
                          0 === i
                            ? ((L[0] = wL.v), (L[1] = RL.v), (L[2] = wL.v))
                            : i < n - 1
                            ? ((L[0] = RL.v),
                              (L[1] = RL.v + (DL.v - RL.v) * D),
                              (L[2] = RL.v))
                            : i === n - 1 &&
                              ((L[0] = DL.v), (L[1] = xL.v), (L[2] = DL.v))),
                      (N[3] = N[2]),
                      (L[3] = L[1]))
                    : (0 === b
                        ? ((N[0] = RL.u),
                          (N[1] = RL.u + (DL.u - RL.u) * D),
                          (N[2] = RL.u),
                          (L[0] = ML.v),
                          (L[1] = ML.v),
                          (L[2] = ML.v + (PL.v - ML.v) * x))
                        : (0 === i
                            ? ((N[0] = wL.u), (N[1] = RL.u), (N[2] = wL.u))
                            : i < n - 1
                            ? ((N[0] = RL.u),
                              (N[1] = RL.u + (DL.u - RL.u) * D),
                              (N[2] = RL.u))
                            : i === n - 1 &&
                              ((N[0] = DL.u), (N[1] = xL.u), (N[2] = DL.u)),
                          0 === t
                            ? ((L[0] = wL.v), (L[1] = wL.v), (L[2] = ML.v))
                            : t < s - 1
                            ? ((L[0] = ML.v),
                              (L[1] = ML.v),
                              (L[2] = ML.v + (PL.v - ML.v) * x))
                            : t === s - 1 &&
                              ((L[0] = PL.v), (L[1] = PL.v), (L[2] = NL.v))),
                      (N[3] = N[1]),
                      (L[3] = L[2]));
                const r = 4 * (t * n + i);
                (a[r].u = N[0]),
                  (a[r].v = L[0]),
                  (a[r + 1].u = N[1]),
                  (a[r + 1].v = L[1]),
                  (a[r + 2].u = N[2]),
                  (a[r + 2].v = L[2]),
                  (a[r + 3].u = N[3]),
                  (a[r + 3].v = L[3]);
              }
            }
          },
          updateColorLate(t) {
            const e = t.renderData,
              i = e.chunk.vb,
              s = e.floatStride,
              n = e.vertexCount;
            let r = 5;
            const a = t.color,
              o = a.r / 255,
              h = a.g / 255,
              l = a.b / 255,
              c = t.node._uiProps.opacity;
            for (let t = 0; t < n; t++)
              (i[r] = o),
                (i[r + 1] = h),
                (i[r + 2] = l),
                (i[r + 3] = c),
                (r += s);
          },
          updateColor(t) {},
        },
        zL = XD.Type,
        HL = XD.FillType,
        GL = t("spriteAssembler", {
          getAssembler(t) {
            let e = AL;
            const i = t;
            switch (i.type) {
              case zL.SLICED:
                e = OL;
                break;
              case zL.TILED:
                e = kL;
                break;
              case zL.FILLED:
                e = i.fillType === HL.RADIAL ? vL : aL;
            }
            return e;
          },
        });
      XD.Assembler = GL;
      const VL = [
          uf.EventType.MOUSE_DOWN,
          uf.EventType.MOUSE_MOVE,
          uf.EventType.MOUSE_UP,
          uf.EventType.MOUSE_WHEEL,
          uf.EventType.MOUSE_LEAVE,
          uf.EventType.MOUSE_ENTER,
        ],
        jL = [
          uf.EventType.TOUCH_START,
          uf.EventType.TOUCH_MOVE,
          uf.EventType.TOUCH_END,
          uf.EventType.TOUCH_CANCEL,
        ];
      new (class {
        constructor() {
          (this.priority = hf.UI),
            (this._isListDirty = !1),
            (this._inDispatchCount = 0),
            (this._pointerEventProcessorList = []),
            (this._processorListToAdd = []),
            (this._processorListToRemove = []),
            _f._registerEventDispatcher(this),
            Yf.callbacksInvoker.on(
              Xf.ADD_POINTER_EVENT_PROCESSOR,
              this.addPointerEventProcessor,
              this
            ),
            Yf.callbacksInvoker.on(
              Xf.REMOVE_POINTER_EVENT_PROCESSOR,
              this.removePointerEventProcessor,
              this
            ),
            Yf.callbacksInvoker.on(
              Xf.MARK_LIST_DIRTY,
              this._markListDirty,
              this
            );
        }
        onThrowException() {
          this._inDispatchCount = 0;
        }
        dispatchEvent(t) {
          const e = t.type;
          return jL.includes(e)
            ? this.dispatchEventTouch(t)
            : !VL.includes(e) || this.dispatchEventMouse(t);
        }
        addPointerEventProcessor(t) {
          0 === this._inDispatchCount
            ? this._pointerEventProcessorList.includes(t) ||
              (this._pointerEventProcessorList.push(t),
              (this._isListDirty = !0))
            : this._processorListToAdd.includes(t) ||
              this._processorListToAdd.push(t),
            te(this._processorListToRemove, t);
        }
        removePointerEventProcessor(t) {
          0 === this._inDispatchCount
            ? (te(this._pointerEventProcessorList, t), (this._isListDirty = !0))
            : this._processorListToRemove.includes(t) ||
              this._processorListToRemove.push(t),
            te(this._processorListToAdd, t);
        }
        dispatchEventMouse(t) {
          this._inDispatchCount++, this._sortPointerEventProcessorList();
          const e = this._pointerEventProcessorList,
            i = e.length;
          let s = !0;
          for (let n = 0; n < i; ++n) {
            const i = e[n];
            if (
              i.isEnabled &&
              i.shouldHandleEventMouse &&
              i._handleEventMouse(t)
            ) {
              if (((s = !1), !t.preventSwallow)) break;
              t.preventSwallow = !1;
            }
          }
          return (
            --this._inDispatchCount <= 0 &&
              this._updatePointerEventProcessorList(),
            s
          );
        }
        dispatchEventTouch(t) {
          this._inDispatchCount++, this._sortPointerEventProcessorList();
          const e = this._pointerEventProcessorList,
            i = e.length,
            s = t.touch;
          let n = !0;
          for (let r = 0; r < i; ++r) {
            const i = e[r];
            if (i.isEnabled && i.shouldHandleEventTouch)
              if (t.type === um.TOUCH_START) {
                if (i._handleEventTouch(t)) {
                  if (i.isEnabled) i.claimedTouchIdList.push(s.getID());
                  else {
                    const e = new fm([t.touch], !0, um.TOUCH_CANCEL);
                    (e.touch = t.touch),
                      i.dispatchEvent(e),
                      (i.claimedTouchIdList.length = 0);
                  }
                  if (((n = !1), !t.preventSwallow)) break;
                  t.preventSwallow = !1;
                }
              } else if (i.claimedTouchIdList.length > 0) {
                const e = i.claimedTouchIdList.indexOf(s.getID());
                if (-1 !== e) {
                  if (
                    (i._handleEventTouch(t),
                    (t.type !== um.TOUCH_END && t.type !== um.TOUCH_CANCEL) ||
                      (Qt(i.claimedTouchIdList, e),
                      t.preventSwallow ||
                        this._removeClaimedTouch(r + 1, s.getID())),
                    (n = !1),
                    !t.preventSwallow)
                  )
                    break;
                  t.preventSwallow = !1;
                }
              }
          }
          return (
            --this._inDispatchCount <= 0 &&
              this._updatePointerEventProcessorList(),
            n
          );
        }
        _removeClaimedTouch(t, e) {
          const i = this._pointerEventProcessorList,
            s = i.length;
          for (let n = t; n < s; ++n) {
            const t = i[n],
              s = t.claimedTouchIdList.indexOf(e);
            -1 !== s && Qt(t.claimedTouchIdList, s);
          }
        }
        _updatePointerEventProcessorList() {
          const t = this._processorListToAdd,
            e = t.length;
          for (let i = 0; i < e; ++i) this.addPointerEventProcessor(t[i]);
          t.length = 0;
          const i = this._processorListToRemove,
            s = i.length;
          for (let t = 0; t < s; ++t) this.removePointerEventProcessor(i[t]);
          i.length = 0;
        }
        _sortPointerEventProcessorList() {
          if (!this._isListDirty) return;
          const t = this._pointerEventProcessorList,
            e = t.length;
          for (let i = 0; i < e; ++i) {
            const e = t[i],
              s = e.node;
            if (s._uiProps) {
              const t = s._uiProps.uiTransformComp;
              e.cachedCameraPriority = t.cameraPriority;
            }
          }
          t.sort(this._sortByPriority), (this._isListDirty = !1);
        }
        _sortByPriority(t, e) {
          const i = t.node,
            s = e.node;
          if (
            i &&
            i.scene &&
            s &&
            s.scene &&
            i.scene.windowID != s.scene.windowID
          )
            return e && s && s.activeInHierarchy && s._uiProps.uiTransformComp
              ? t &&
                i &&
                i.activeInHierarchy &&
                i._uiProps.uiTransformComp &&
                i.scene.windowID > s.scene.windowID
                ? -1
                : 1
              : -1;
          if (!(e && s && s.activeInHierarchy && s._uiProps.uiTransformComp))
            return -1;
          if (!(t && i && i.activeInHierarchy && i._uiProps.uiTransformComp))
            return 1;
          if (t.cachedCameraPriority !== e.cachedCameraPriority)
            return e.cachedCameraPriority - t.cachedCameraPriority;
          let n = i,
            r = s,
            a = !1;
          for (
            ;
            (null === (o = n.parent) || void 0 === o ? void 0 : o.uuid) !==
            (null === (h = r.parent) || void 0 === h ? void 0 : h.uuid);

          ) {
            var o, h, l, c, u, _;
            (n =
              null ===
              (null === (l = n) ||
              void 0 === l ||
              null === (c = l.parent) ||
              void 0 === c
                ? void 0
                : c.parent)
                ? (a = !0) && s
                : n && n.parent),
              (r =
                null ===
                (null === (u = r) ||
                void 0 === u ||
                null === (_ = u.parent) ||
                void 0 === _
                  ? void 0
                  : _.parent)
                  ? (a = !0) && i
                  : r && r.parent);
          }
          if (n.uuid === r.uuid) {
            if (n.uuid === s.uuid) return -1;
            if (n.uuid === i.uuid) return 1;
          }
          const d = n ? n.getSiblingIndex() : 0,
            p = r ? r.getSiblingIndex() : 0;
          return a ? d - p : p - d;
        }
        _markListDirty() {
          this._isListDirty = !0;
        }
      })();
      const WL = new qu(null),
        XL = new ms();
      class YL {
        get nativeObj() {
          return this._nativeObj;
        }
        get currBufferAccessor() {
          return (
            this._staticVBBuffer ||
              (this._staticVBBuffer = this.switchBufferAccessor()),
            this._staticVBBuffer
          );
        }
        get batches() {
          return this._batches;
        }
        set currStaticRoot(t) {
          this._currStaticRoot = t;
        }
        set currIsStatic(t) {
          this._currIsStatic = t;
        }
        constructor(t) {
          (this._screens = []),
            (this._staticVBBuffer = null),
            (this._bufferAccessors = new Map()),
            (this._currBID = -1),
            (this._indexStart = 0),
            (this._emptyMaterial = new ey()),
            (this._currRenderData = null),
            (this._currMaterial = this._emptyMaterial),
            (this._currTexture = null),
            (this._currSampler = null),
            (this._currStaticRoot = null),
            (this._currComponent = null),
            (this._currTransform = null),
            (this._currTextureHash = 0),
            (this._currSamplerHash = 0),
            (this._currLayer = 0),
            (this._currDepthStencilStateStage = null),
            (this._currIsStatic = !1),
            (this._currHash = 0),
            (this._currIsMiddleware = !1),
            (this._middlewareEnableBatch = !1),
            (this._middlewareBuffer = null),
            (this._middlewareIndexStart = 0),
            (this._middlewareIndexCount = 0),
            (this._pOpacity = 1),
            (this._opacityDirty = 0),
            (this._descriptorSetCache = new qL()),
            (this._meshDataArray = []),
            (this._maskClearModel = null),
            (this._maskClearMtl = null),
            (this._maskModelMesh = null),
            (this._root = t),
            (this.device = t.device),
            (this._batches = new Yn(64)),
            (this._drawBatchPool = new Wn(
              () => new zP(),
              128,
              (t) => t.destroy(this)
            ));
        }
        initialize() {
          return !0;
        }
        destroy() {
          for (let t = 0; t < this._batches.length; t++)
            this._batches.array[t] && this._batches.array[t].destroy(this);
          this._batches.destroy();
          for (const t of this._bufferAccessors.values()) t.destroy();
          this._bufferAccessors.clear(),
            this._drawBatchPool && this._drawBatchPool.destroy(),
            this._descriptorSetCache.destroy(),
            aI.sharedManager.destroy(),
            this._maskClearModel &&
              this._maskModelMesh &&
              (a.director.root.destroyModel(this._maskClearModel),
              this._maskModelMesh.destroy()),
            this._maskClearMtl && this._maskClearMtl.destroy();
        }
        syncRootNodesToNative() {
          {
            const t = [];
            for (const e of this._screens) t.push(e.node);
            this._nativeObj.syncRootNodesToNative(t);
          }
        }
        addScreen(t) {
          this._screens.push(t),
            this._screens.sort(this._screenSort),
            this.syncRootNodesToNative();
        }
        removeScreen(t) {
          const e = this._screens.indexOf(t);
          -1 !== e &&
            (this._screens.splice(e, 1), this.syncRootNodesToNative());
        }
        sortScreens() {
          this._screens.sort(this._screenSort), this.syncRootNodesToNative();
        }
        getFirstRenderCamera(t) {
          if (t.scene && t.scene.renderScene) {
            const e = t.scene.renderScene.cameras;
            for (let i = 0; i < e.length; i++) {
              const s = e[i];
              if (s.visibility & t.layer) return s;
            }
          }
          return null;
        }
        update() {}
        uploadBuffers() {
          this._nativeObj.uploadBuffers();
        }
        reset() {
          this._nativeObj.reset();
        }
        switchBufferAccessor(t = PO) {
          const e = t === PO ? 36 : UO(t);
          if (
            !this._staticVBBuffer ||
            this._staticVBBuffer.vertexFormatBytes !== e
          ) {
            let i = this._bufferAccessors.get(e);
            i ||
              ((i = new YO(this.device, t)), this._bufferAccessors.set(e, i)),
              (this._staticVBBuffer = i),
              (this._currBID = -1);
          }
          return this._staticVBBuffer;
        }
        registerBufferAccessor(t, e) {
          this._bufferAccessors.set(t, e);
        }
        updateBuffer(t, e) {
          const i = this.switchBufferAccessor(t);
          this._currBID !== e &&
            ((this._currBID = e),
            (this._indexStart = i.getMeshBuffer(e).indexOffset));
        }
        commitComp(t, e, i, s, n) {
          let r,
            a = 0,
            o = -1;
          if (e && e.chunk) {
            if (!e.isValid()) return;
            (a = e.dataHash), (r = e.material), (o = e.chunk.bufferId);
          }
          t.stencilStage === QO.ENTER_LEVEL ||
          t.stencilStage === QO.ENTER_LEVEL_INVERTED
            ? this._insertMaskBatch(t)
            : (t.stencilStage = aI.sharedManager.stage);
          const h = t.stencilStage;
          (this._currHash === a &&
            0 !== a &&
            this._currMaterial === r &&
            this._currDepthStencilStateStage === h) ||
            (this.autoMergeBatches(this._currComponent),
            e && !e._isMeshBuffer && this.updateBuffer(e.vertexFormat, o),
            (this._currRenderData = e),
            (this._currHash = e ? e.dataHash : 0),
            (this._currComponent = t),
            (this._currTransform = n),
            (this._currMaterial = t.getRenderMaterial(0)),
            (this._currDepthStencilStateStage = h),
            (this._currLayer = t.node.layer),
            i
              ? ((this._currTexture = i.getGFXTexture()),
                (this._currSampler = i.getGFXSampler()),
                (this._currTextureHash = i.getHash()),
                (this._currSamplerHash = this._currSampler.hash))
              : ((this._currTexture = null),
                (this._currSampler = null),
                (this._currTextureHash = 0),
                (this._currSamplerHash = 0))),
            s.fillBuffers(t, this);
        }
        commitIA(t, e, i, s, n) {
          this._currMaterial !== this._emptyMaterial &&
            (this.autoMergeBatches(this._currComponent),
            this.resetRenderStates());
          let r = null,
            a = 0;
          t &&
            ((t.stencilStage = aI.sharedManager.stage),
            (r =
              null !== t.customMaterial
                ? aI.sharedManager.getStencilStage(t.stencilStage, s)
                : aI.sharedManager.getStencilStage(t.stencilStage)),
            (a = aI.sharedManager.getStencilHash(t.stencilStage)));
          const o = this._currStaticRoot
            ? this._currStaticRoot._requireDrawBatch()
            : this._drawBatchPool.alloc();
          (o.visFlags = t.node.layer),
            (o.inputAssembler = e),
            (o.useLocalData = n || null),
            i &&
              ((o.texture = i.getGFXTexture()),
              (o.sampler = i.getGFXSampler()),
              (o.textureHash = i.getHash()),
              (o.samplerHash = o.sampler.hash)),
            o.fillPasses(s || null, r, a, null),
            this._batches.push(o);
        }
        commitMiddleware(t, e, i, s, n, r, a) {
          const o = n.getGFXTexture();
          a &&
          this._middlewareEnableBatch &&
          this._middlewareBuffer === e &&
          this._currTexture === o &&
          this._currMaterial.hash === r.hash &&
          this._middlewareIndexStart + this._middlewareIndexCount === i &&
          this._currLayer === t.node.layer
            ? (this._middlewareIndexCount += s)
            : (this.autoMergeBatches(this._currComponent),
              this.resetRenderStates(),
              (this._currComponent = t),
              (this._currTexture = o),
              (this._currSampler = n.getGFXSampler()),
              (this._currTextureHash = n.getHash()),
              (this._currLayer = t.node.layer),
              (this._currSamplerHash = this._currSampler.hash),
              (this._currHash = 0),
              (this._currTransform = a ? null : t.node),
              (this._middlewareEnableBatch = a),
              (this._middlewareBuffer = e),
              (this._currMaterial = r),
              (this._middlewareIndexStart = i),
              (this._middlewareIndexCount = s)),
            (this._currIsMiddleware = !0);
        }
        commitModel(t, e, i) {
          this._currMaterial !== this._emptyMaterial &&
            (this.autoMergeBatches(this._currComponent),
            this.resetRenderStates());
          let s = null,
            n = 0;
          i &&
            (t.stencilStage === QO.ENTER_LEVEL ||
            t.stencilStage === QO.ENTER_LEVEL_INVERTED
              ? this._insertMaskBatch(t)
              : (t.stencilStage = aI.sharedManager.stage),
            (s = aI.sharedManager.getStencilStage(t.stencilStage, i)),
            (n = aI.sharedManager.getStencilHash(t.stencilStage)));
          const r = a.director.getTotalFrames();
          e && (e.updateTransform(r), e.updateUBOs(r));
          for (let r = 0; r < e.subModels.length; r++) {
            const a = this._drawBatchPool.alloc(),
              o = e.subModels[r];
            (a.visFlags = t.node.layer),
              (a.model = e),
              (a.texture = null),
              (a.sampler = null),
              (a.useLocalData = null),
              s || (s = null),
              a.fillPasses(i, s, n, o.patches),
              (a.inputAssembler = o.inputAssembler),
              (a.model.visFlags = a.visFlags),
              (a.descriptorSet = o.descriptorSet),
              this._batches.push(a);
          }
        }
        setupStaticBatch(t, e) {
          this.finishMergeBatches(),
            (this._staticVBBuffer = e),
            (this.currStaticRoot = t);
        }
        endStaticBatch() {
          this.finishMergeBatches(),
            (this.currStaticRoot = null),
            (this._staticVBBuffer = null),
            this.switchBufferAccessor();
        }
        commitStaticBatch(t) {
          this._batches.concat(t.drawBatchList), this.finishMergeBatches();
        }
        autoMergeBatches(t) {
          if (this._currIsMiddleware)
            return void this.mergeBatchesForMiddleware(t);
          const e = this._currMaterial;
          if (!e) return;
          let i;
          const s = this._currRenderData,
            n = this._staticVBBuffer;
          if (s && s._isMeshBuffer)
            (i = s.requestIA(this.device)),
              -1 === this._meshDataArray.indexOf(s) &&
                this._meshDataArray.push(s);
          else if (n) {
            const t = this._currBID,
              e = n.getMeshBuffer(t);
            if (!e) return;
            const s = e.indexOffset - this._indexStart;
            if (s <= 0) return;
            this._indexStart,
              e.indexOffset,
              e.setDirty(),
              (i = e.requireFreeIA(this.device)),
              (i.firstIndex = this._indexStart),
              (i.indexCount = s),
              (this._indexStart = e.indexOffset);
          }
          if (((this._currBID = -1), !i || !this._currTexture)) return;
          let r = null,
            a = 0;
          t &&
            ((r =
              null !== t.customMaterial
                ? aI.sharedManager.getStencilStage(t.stencilStage, e)
                : aI.sharedManager.getStencilStage(t.stencilStage)),
            (a = aI.sharedManager.getStencilHash(t.stencilStage)));
          const o = this._currStaticRoot
            ? this._currStaticRoot._requireDrawBatch()
            : this._drawBatchPool.alloc();
          (o.visFlags = this._currLayer),
            (o.texture = this._currTexture),
            (o.sampler = this._currSampler),
            (o.inputAssembler = i),
            (o.useLocalData = this._currTransform),
            (o.textureHash = this._currTextureHash),
            (o.samplerHash = this._currSamplerHash),
            o.fillPasses(e, r, a, null),
            this._batches.push(o);
        }
        mergeBatchesForMiddleware(t) {
          let e = null,
            i = 0;
          (t.stencilStage = aI.sharedManager.stage),
            (e =
              null !== t.customMaterial
                ? aI.sharedManager.getStencilStage(
                    t.stencilStage,
                    this._currMaterial
                  )
                : aI.sharedManager.getStencilStage(t.stencilStage)),
            (i = aI.sharedManager.getStencilHash(t.stencilStage));
          const s = this._currStaticRoot
            ? this._currStaticRoot._requireDrawBatch()
            : this._drawBatchPool.alloc();
          s.visFlags = t.node.layer;
          const n = this._middlewareBuffer.requireFreeIA(this.device);
          (n.firstIndex = this._middlewareIndexStart),
            (n.indexCount = this._middlewareIndexCount),
            (s.inputAssembler = n),
            (s.useLocalData = this._currTransform),
            (s.texture = this._currTexture),
            (s.sampler = this._currSampler),
            (s.textureHash = this._currTextureHash),
            (s.samplerHash = this._currSamplerHash),
            s.fillPasses(this._currMaterial || null, e, i, null),
            this._batches.push(s),
            (this._currIsMiddleware = !1),
            (this._middlewareBuffer = null);
        }
        forceMergeBatches(t, e, i) {
          (this._currMaterial = t),
            e
              ? ((this._currTexture = e.getGFXTexture()),
                (this._currSampler = e.getGFXSampler()),
                (this._currTextureHash = e.getHash()),
                (this._currSamplerHash = this._currSampler.hash))
              : ((this._currTexture = this._currSampler = null),
                (this._currTextureHash = this._currSamplerHash = 0)),
            (this._currLayer = i.node.layer),
            this.autoMergeBatches(i);
        }
        resetRenderStates() {
          (this._currMaterial = this._emptyMaterial),
            (this._currRenderData = null),
            (this._currTexture = null),
            (this._currComponent = null),
            (this._currTransform = null),
            (this._currTextureHash = 0),
            (this._currSamplerHash = 0),
            (this._currLayer = 0);
        }
        finishMergeBatches() {
          this.autoMergeBatches(), this.resetRenderStates();
        }
        flushMaterial(t) {
          this._currMaterial = t;
        }
        walk(t, e = 0) {
          if (!t.activeInHierarchy) return;
          const i = t.children,
            s = t._uiProps,
            n = s.uiComp,
            r = this._pOpacity;
          let a = r;
          const o = n && n.color ? n.color.a / 255 : 1;
          if (
            ((this._pOpacity = a *= o * s.localOpacity),
            s.setOpacity(a),
            !Ti(a, 0, gi))
          ) {
            if (
              (s.colorDirty && this._opacityDirty++,
              n && n.enabledInHierarchy && n.fillBuffers(this),
              this._opacityDirty &&
                n &&
                !n.useVertexOpacity &&
                n.renderData &&
                n.renderData.vertexCount > 0)
            ) {
              !(function (t, e) {
                const i = t.vertexFormat,
                  s = t.chunk.vb;
                let n,
                  r,
                  a,
                  o = 0;
                for (let h = 0; h < i.length; ++h) {
                  if (((n = i[h]), (r = a_[n.format]), r.hasAlpha))
                    if (((a = t.floatStride), r.size / r.count == 1)) {
                      const t = ~~Si(Math.round(255 * e), 0, 255);
                      for (let e = o; e < s.length; e += a)
                        s[e] = ((4294967040 & s[e]) | t) >>> 0;
                    } else if (r.size / r.count == 4)
                      for (let t = o + 3; t < s.length; t += a) s[t] = e;
                  o += r.size >> 2;
                }
              })(n.renderData, a);
              const t = n.renderData.getMeshBuffer();
              t && t.setDirty();
            }
            if (i.length > 0 && !t._static)
              for (let t = 0; t < i.length; ++t) {
                const s = i[t];
                this.walk(s, e);
              }
            s.colorDirty && (this._opacityDirty--, (s.colorDirty = !1));
          }
          (this._pOpacity = r),
            n &&
              n.enabledInHierarchy &&
              (n.postUpdateAssembler(this),
              (n.stencilStage === QO.ENTER_LEVEL ||
                n.stencilStage === QO.ENTER_LEVEL_INVERTED) &&
                aI.sharedManager.getMaskStackSize() > 0 &&
                (this.autoMergeBatches(this._currComponent),
                this.resetRenderStates(),
                aI.sharedManager.exitMask())),
            (e += 1);
        }
        _screenSort(t, e) {
          return t.node.getSiblingIndex() - e.node.getSiblingIndex();
        }
        _releaseDescriptorSetCache(t, e = null) {
          this._nativeObj.releaseDescriptorSetCache(t, e);
        }
        _createClearModel() {
          if (!this._maskClearModel) {
            (this._maskClearMtl = Pv.get("default-clear-stencil")),
              (this._maskClearModel = a.director.root.createModel(tg));
            const t = UO(xO),
              e = I_.gfxDevice,
              i = e.createBuffer(
                new yu(Tc.VERTEX | Tc.TRANSFER_DST, vc.DEVICE, 4 * t, t)
              ),
              s = new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]);
            i.update(s);
            const n = e.createBuffer(
                new yu(
                  Tc.INDEX | Tc.TRANSFER_DST,
                  vc.DEVICE,
                  6 * Uint16Array.BYTES_PER_ELEMENT,
                  Uint16Array.BYTES_PER_ELEMENT
                )
              ),
              r = new Uint16Array([0, 1, 2, 2, 1, 3]);
            n.update(r),
              (this._maskModelMesh = new fC([i], xO, Gc.TRIANGLE_LIST, n)),
              (this._maskModelMesh.subMeshIdx = 0),
              this._maskClearModel.initSubModel(
                0,
                this._maskModelMesh,
                this._maskClearMtl
              );
          }
        }
        _insertMaskBatch(t) {
          this.autoMergeBatches(this._currComponent),
            this.resetRenderStates(),
            this._createClearModel(),
            (this._maskClearModel.node = this._maskClearModel.transform =
              t.node);
          const e = aI.sharedManager;
          e.pushMask(1);
          const i = e.clear(t);
          let s = null,
            n = 0;
          const r = this._maskClearMtl;
          r && ((s = e.getStencilStage(i, r)), (n = e.getStencilHash(i)));
          const o = this._maskClearModel,
            h = a.director.getTotalFrames();
          o && (o.updateTransform(h), o.updateUBOs(h));
          for (let e = 0; e < o.subModels.length; e++) {
            const i = this._drawBatchPool.alloc(),
              a = o.subModels[e];
            (i.visFlags = t.node.layer),
              (i.model = o),
              (i.texture = null),
              (i.sampler = null),
              (i.useLocalData = null),
              s || (s = null),
              i.fillPasses(r, s, n, a.patches),
              (i.inputAssembler = a.inputAssembler),
              (i.model.visFlags = i.visFlags),
              (i.descriptorSet = a.descriptorSet),
              this._batches.push(i);
          }
          e.enableMask();
        }
        syncMeshBuffersToNative(t, e) {
          {
            const i = e.map((t) => t.nativeObj);
            this._nativeObj.syncMeshBuffersToNative(t, i);
          }
        }
      }
      t("UI", YL);
      class KL {
        get descriptorSet() {
          return this._descriptorSet;
        }
        constructor() {
          (this._descriptorSet = null),
            (this._transform = null),
            (this._textureHash = 0),
            (this._samplerHash = 0),
            (this._localBuffer = null),
            (this._transformUpdate = !0);
          const t = I_.gfxDevice;
          (this._localData = new Float32Array(wb.COUNT)),
            (this._localBuffer = t.createBuffer(
              new yu(
                Tc.UNIFORM | Tc.TRANSFER_DST,
                vc.HOST | vc.DEVICE,
                wb.SIZE,
                wb.SIZE
              )
            ));
        }
        initialize(t) {
          const e = I_.gfxDevice;
          (this._transform = t.useLocalData),
            (this._textureHash = t.textureHash),
            (this._samplerHash = t.samplerHash),
            (WL.layout = t.passes[0].localSetLayout),
            (this._descriptorSet = e.createDescriptorSet(WL)),
            this._descriptorSet.bindBuffer(wb.BINDING, this._localBuffer);
          const i = ab.SAMPLER_SPRITE;
          this._descriptorSet.bindTexture(i, t.texture),
            this._descriptorSet.bindSampler(i, t.sampler),
            this._descriptorSet.update(),
            (this._transformUpdate = !0);
        }
        updateTransform(t) {
          t !== this._transform &&
            ((this._transform = t),
            (this._transformUpdate = !0),
            this.uploadLocalData());
        }
        equals(t, e, i) {
          return (
            this._transform === t &&
            this._textureHash === e &&
            this._samplerHash === i
          );
        }
        reset() {
          (this._transform = null),
            (this._textureHash = 0),
            (this._samplerHash = 0);
        }
        destroy() {
          this._localBuffer &&
            (this._localBuffer.destroy(), (this._localBuffer = null)),
            this._descriptorSet &&
              (this._descriptorSet.destroy(), (this._descriptorSet = null)),
            (this._localData = null);
        }
        isValid() {
          return this._transform && this._transform.isValid;
        }
        uploadLocalData() {
          const t = this._transform;
          if (
            ((t.hasChangedFlags || t.isTransformDirty()) &&
              (t.updateWorldTransform(), (this._transformUpdate = !0)),
            this._transformUpdate)
          ) {
            const e = t.worldMatrix;
            ms.toArray(this._localData, e, wb.MAT_WORLD_OFFSET),
              ms.invert(XL, e),
              ms.transpose(XL, XL),
              ms.toArray(this._localData, XL, wb.MAT_WORLD_IT_OFFSET),
              this._localBuffer.update(this._localData),
              (this._transformUpdate = !1);
          }
        }
      }
      class qL {
        constructor() {
          (this._descriptorSetCache = new Map()),
            (this._dsCacheHashByTexture = new Map()),
            (this._localDescriptorSetCache = []),
            (this._localCachePool = new Wn(
              () => new KL(),
              16,
              (t) => t.destroy()
            ));
        }
        getDescriptorSet(t) {
          if ((a.director.root, t.useLocalData)) {
            const e = this._localDescriptorSetCache;
            for (let i = 0, s = e.length; i < s; i++) {
              const s = e[i];
              if (s.equals(t.useLocalData, t.textureHash, t.samplerHash))
                return s.descriptorSet;
            }
            const i = this._localCachePool.alloc();
            return (
              i.initialize(t),
              this._localDescriptorSetCache.push(i),
              i.descriptorSet
            );
          }
          {
            const e = t.textureHash ^ t.samplerHash;
            if (this._descriptorSetCache.has(e))
              return this._descriptorSetCache.get(e);
            {
              WL.layout = t.passes[0].localSetLayout;
              const i = I_.gfxDevice.createDescriptorSet(WL),
                s = ab.SAMPLER_SPRITE;
              return (
                i.bindTexture(s, t.texture),
                i.bindSampler(s, t.sampler),
                i.update(),
                this._descriptorSetCache.set(e, i),
                this._dsCacheHashByTexture.set(t.textureHash, e),
                i
              );
            }
          }
        }
        update() {
          const t = this._localDescriptorSetCache,
            e = t.length;
          if (0 === e) return;
          const i = [];
          for (let s = 0; s < e; s++) {
            const e = t[s];
            if (e.isValid()) e.uploadLocalData();
            else {
              e.reset();
              const s = t.indexOf(e);
              i.push(s);
            }
          }
          for (let e = i.length - 1; e >= 0; e--) {
            const s = i[e],
              n = t[s];
            t.splice(s, 1), this._localCachePool.free(n);
          }
        }
        reset() {
          const t = this._localDescriptorSetCache,
            e = t.length;
          for (let i = 0; i < e; i++) {
            const e = t[i];
            this._localCachePool.free(e);
          }
          this._localDescriptorSetCache.length = 0;
        }
        releaseDescriptorSetCache(t) {
          const e = this._dsCacheHashByTexture.get(t);
          e &&
            this._descriptorSetCache.has(e) &&
            (this._descriptorSetCache.get(e).destroy(),
            this._descriptorSetCache.delete(e),
            this._dsCacheHashByTexture.delete(t));
        }
        destroy() {
          for (const t of this._descriptorSetCache.values()) t.destroy();
          this._descriptorSetCache.clear(),
            this._dsCacheHashByTexture.clear(),
            (this._localDescriptorSetCache.length = 0),
            this._localCachePool.destroy();
        }
      }
      (a.internal.Batcher2D = YL),
        t("UIDrawBatch", class extends zP {}),
        Q(
          jO.prototype,
          "MeshBuffer",
          ["byteStart", "vertexStart", "indicesStart", "request"].map((t) => ({
            name: t,
            suggest: `please use meshBuffer.accessor.${t} instead`,
          }))
        ),
        $(jO.prototype, "MeshBuffer", [
          { name: "indicesOffset", newName: "indexOffset" },
        ]),
        Z(jO.prototype, "MeshBuffer", [
          { name: "vertexBuffers" },
          { name: "indexBuffer" },
        ]),
        $(YL.prototype, "Batcher2D", [
          { name: "currBufferBatch", newName: "currBufferAccessor" },
          { name: "acquireBufferBatch", newName: "switchBufferAccessor" },
        ]),
        Z(uI.prototype, "MeshRenderData", [
          { name: "formatByte" },
          { name: "byteStart" },
          { name: "byteCount" },
        ]),
        $(uI.prototype, "MeshRenderData", [
          { name: "indicesStart", newName: "indexStart" },
        ]),
        t(
          "QuadRenderData",
          class extends uI {
            constructor(t) {
              super(t), z(9006);
            }
          }
        ),
        (a.UI = {
          MeshBuffer: jO,
          spriteAssembler: GL,
          graphicsAssembler: MN,
          labelAssembler: iL,
          RenderData: cI,
          MeshRenderData: uI,
        }),
        YA.on(XA.EVENT_POST_SUBSYSTEM_INIT, () => {
          $L.init();
        });
      class $L {
        static getSortingPriority(t = 0, e = 0) {
          return (((t + 32768) << 16) | (e + 32768)) >>> 0;
        }
        static getLayerIndex(t = 0) {
          let e = 0;
          return this.indexMap.has(t) ? (e = this.indexMap.get(t)) : G(2105), e;
        }
        static getLayerIndexByName(t) {
          const e = this.getLayerByName(t);
          return this.getLayerIndex(e);
        }
        static getLayerName(t = 0) {
          let e = "";
          return this.nameMap.has(t) ? (e = this.nameMap.get(t)) : G(2105), e;
        }
        static getLayerByName(t) {
          const e = this.nameMap.size,
            i = this.nameMap.keys();
          let s = 0;
          for (let n = 0; n < e; n++)
            if (((s = i.next().value), this.nameMap.get(s) === t)) return s;
          return G(2106), 0;
        }
        static isLayerValid(t) {
          return !!this.indexMap.has(t) || (G(2105), !1);
        }
        static getBuiltinLayers() {
          return [{ id: 0, name: "default", value: 0 }];
        }
        static init() {
          let t = ge.querySettings(fe.Category.ENGINE, "sortingLayers");
          (t && 0 !== t.length) || (t = this.getBuiltinLayers()),
            $L.resetState();
          for (let e = 0; e < t.length; e++) {
            const i = t[e];
            $L.setLayer(i.id, i.name, i.value), ($L.Enum[i.name] = i.id);
          }
          ce.update($L.Enum),
            ce.sortList(
              $L.Enum,
              (t, e) => $L.getLayerIndex(t.value) - $L.getLayerIndex(e.value)
            );
        }
        static setLayer(t, e, i) {
          this.nameMap.set(t, e), this.indexMap.set(t, i);
        }
        static resetState() {
          const t = Object.keys($L.Enum);
          for (let e = 0; e < t.length; e++)
            delete $L.Enum[$L.Enum[t[e]]], delete $L.Enum[t[e]];
          $L.indexMap.clear(), $L.nameMap.clear();
        }
      }
      var ZL, QL, JL, tB, eB, iB;
      t("SortingLayers", $L),
        ($L.nameMap = new Map()),
        ($L.indexMap = new Map()),
        ($L.Enum = ce({ default: 0 })),
        t(
          "Sorting",
          ((ZL = Ca("cc.Sorting")),
          (QL = ao($L.Enum)),
          ZL(
            (JL =
              wa(
                (s(
                  (tB = class extends np {
                    constructor() {
                      super(),
                        (this._sortingLayer = eB && eB()),
                        (this._sortingOrder = iB && iB()),
                        (this._modelRenderer = null);
                    }
                    get sortingLayer() {
                      return this._sortingLayer;
                    }
                    set sortingLayer(t) {
                      t !== this._sortingLayer &&
                        $L.isLayerValid(t) &&
                        ((this._sortingLayer = t),
                        this._updateSortingPriority());
                    }
                    get sortingOrder() {
                      return this._sortingOrder;
                    }
                    set sortingOrder(t) {
                      t !== this._sortingOrder &&
                        ((this._sortingOrder = Si(t, -32768, 32767)),
                        this._updateSortingPriority());
                    }
                    __preload() {
                      (this._modelRenderer =
                        this.getComponent("cc.ModelRenderer")),
                        this._modelRenderer || z(16301, this.node.name),
                        this._updateSortingPriority();
                    }
                    _updateSortingPriority() {
                      const t = $L.getLayerIndex(this._sortingLayer),
                        e = $L.getSortingPriority(t, this._sortingOrder);
                      this._modelRenderer &&
                        this._modelRenderer.isValid &&
                        (this._modelRenderer.priority = e);
                    }
                  }).prototype,
                  "sortingLayer",
                  [QL],
                  Object.getOwnPropertyDescriptor(tB.prototype, "sortingLayer"),
                  tB.prototype
                ),
                (eB = fa(tB.prototype, "_sortingLayer", [Na], function () {
                  return $L.Enum.default;
                })),
                (iB = fa(tB.prototype, "_sortingOrder", [Na], function () {
                  return 0;
                })),
                (JL = tB))
              ) || JL)
          ) || JL)
        );
      const sB = t("Mesh", jsb.Mesh),
        nB = jsb.Mesh.IStruct.prototype;
      Object.defineProperty(nB, "minPosition", {
        configurable: !0,
        enumerable: !0,
        get() {
          const t = this.getMinPosition();
          return (
            t
              ? this._minPositionCache
                ? this._minPositionCache.set(t.x, t.y, t.z)
                : (this._minPositionCache = new Yi(t.x, t.y, t.z))
              : (this._minPositionCache = void 0),
            this._minPositionCache
          );
        },
        set(t) {
          this.setMinPosition(t);
        },
      }),
        Object.defineProperty(nB, "maxPosition", {
          configurable: !0,
          enumerable: !0,
          get() {
            const t = this.getMaxPosition();
            return (
              t
                ? this._maxPositionCache
                  ? this._maxPositionCache.set(t.x, t.y, t.z)
                  : (this._maxPositionCache = new Yi(t.x, t.y, t.z))
                : (this._maxPositionCache = void 0),
              this._maxPositionCache
            );
          },
          set(t) {
            this.setMaxPosition(t);
          },
        });
      const rB = jsb.Mesh.prototype;
      rB.createNode = null;
      const aB = rB.onLoaded;
      (rB._ctor = function () {
        jsb.Asset.prototype._ctor.apply(this, arguments),
          (this._struct = { vertexBundles: [], primitives: [] }),
          (this._minPosition = void 0),
          (this._maxPosition = void 0);
      }),
        Object.defineProperty(rB, "struct", {
          configurable: !0,
          enumerable: !0,
          get() {
            return this.getStruct();
          },
        }),
        Object.defineProperty(rB, "minPosition", {
          configurable: !0,
          enumerable: !0,
          get() {
            const t = this.getMinPosition();
            return (
              t
                ? this._minPosition
                  ? this._minPosition.set(t.x, t.y, t.z)
                  : (this._minPosition = new Yi(t.x, t.y, t.z))
                : (this._minPosition = void 0),
              this._minPosition
            );
          },
        }),
        Object.defineProperty(rB, "maxPosition", {
          configurable: !0,
          enumerable: !0,
          get() {
            const t = this.getMaxPosition();
            return (
              t
                ? this._maxPosition
                  ? this._maxPosition.set(t.x, t.y, t.z)
                  : (this._maxPosition = new Yi(t.x, t.y, t.z))
                : (this._maxPosition = void 0),
              this._maxPosition
            );
          },
        }),
        (rB.onLoaded = function () {
          const t = this._struct;
          t &&
            ((0 === t.vertexBundles.length && 0 === t.primitives.length) ||
              this.setStruct(this._struct)),
            (this._struct = null),
            aB.apply(this);
        }),
        (a.Mesh = jsb.Mesh),
        (function (t, e = vd) {
          const { Mesh: i } = { ...t };
          e(
            () => {
              Na(i.prototype, "_struct", () => ({
                vertexBundles: [],
                primitives: [],
              }));
            },
            "serializable",
            "_struct"
          ),
            e(
              () => {
                Na(i.prototype, "_hash", () => 0);
              },
              "serializable",
              "_hash"
            ),
            e(
              () => {
                Na(i.prototype, "_allowDataAccess", () => !0);
              },
              "serializable",
              "_allowDataAccess"
            ),
            e(
              () => {
                Ca("cc.Mesh")(i);
              },
              "ccclass",
              null
            );
        })({ Mesh: sB });
      const oB = jsb.MorphModel;
      let hB;
      var lB,
        cB,
        uB,
        _B,
        dB,
        pB,
        mB,
        fB,
        gB,
        yB,
        TB,
        SB,
        EB,
        vB,
        bB,
        AB,
        CB,
        OB,
        IB,
        wB,
        RB,
        DB,
        xB,
        MB,
        PB,
        NB,
        LB,
        BB,
        FB,
        UB,
        kB,
        zB,
        HB,
        GB,
        VB,
        jB,
        WB,
        XB,
        YB,
        KB,
        qB,
        $B;
      (a.MorphModel = jsb.MorphModel),
        t("ReflectionProbeType", hB),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.BAKED_CUBEMAP = 1)] = "BAKED_CUBEMAP"),
            (t[(t.PLANAR_REFLECTION = 2)] = "PLANAR_REFLECTION"),
            (t[(t.BLEND_PROBES = 3)] = "BLEND_PROBES"),
            (t[(t.BLEND_PROBES_AND_SKYBOX = 4)] = "BLEND_PROBES_AND_SKYBOX");
        })(hB || t("ReflectionProbeType", (hB = {})));
      const {
        ccclass: ZB,
        help: QB,
        executeInEditMode: JB,
        executionOrder: tF,
        menu: eF,
        visible: iF,
        type: sF,
        formerlySerializedAs: nF,
        serializable: rF,
        editable: aF,
        disallowAnimation: oF,
      } = go;
      let hF = DA("specular-pass");
      function lF(t) {
        const e = t.passes,
          i = a.rendering;
        RA() && (hF = i.getPhaseID(i.getPassID("specular-pass"), "default"));
        for (let t = 0; t < e.length; t++)
          if (
            ((!i || !i.enableEffectImport) && e[t].phase === hF) ||
            (RA() && e[t].phaseID === hF)
          )
            return t;
        return -1;
      }
      const cF = ce({ OFF: 0, ON: 1 }),
        uF = ce({ OFF: 0, ON: 1 });
      let _F =
          ((lB = ZB("cc.ModelBakeSettings")),
          (cB = nF("_recieveShadow")),
          (uB = sF(ke)),
          (_B = sF(He)),
          (dB = sF(He)),
          (pB = sF(ce(hB))),
          (mB = sF(He)),
          lB(
            (((wB = class t extends hr {
              constructor() {
                super(),
                  (this.texture = yB && yB()),
                  (this.uvParam = TB && TB()),
                  (this._bakeable = SB && SB()),
                  (this._castShadow = EB && EB()),
                  (this._receiveShadow = vB && vB()),
                  (this._lightmapSize = bB && bB()),
                  (this._useLightProbe = AB && AB()),
                  (this._bakeToLightProbe = CB && CB()),
                  (this._reflectionProbeType = OB && OB()),
                  (this._bakeToReflectionProbe = IB && IB()),
                  (this.probeCubemap = null),
                  (this.probeBlendCubemap = null),
                  (this.probePlanarmap = null);
              }
              get bakeable() {
                return this._bakeable;
              }
              set bakeable(t) {
                this._bakeable = t;
              }
              get castShadow() {
                return this._castShadow;
              }
              set castShadow(t) {
                this._castShadow = t;
              }
              get receiveShadow() {
                return this._receiveShadow;
              }
              set receiveShadow(t) {
                this._receiveShadow = t;
              }
              get lightmapSize() {
                return this._lightmapSize;
              }
              set lightmapSize(t) {
                this._lightmapSize = t;
              }
              get useLightProbe() {
                return this._useLightProbe;
              }
              set useLightProbe(e) {
                (this._useLightProbe = e), this.emit(t.USE_LIGHT_PROBE_CHANGED);
              }
              get bakeToLightProbe() {
                return this._bakeToLightProbe;
              }
              set bakeToLightProbe(t) {
                this._bakeToLightProbe = t;
              }
              get reflectionProbe() {
                return this._reflectionProbeType;
              }
              set reflectionProbe(e) {
                (this._reflectionProbeType = e),
                  this.emit(t.REFLECTION_PROBE_CHANGED);
              }
              get bakeToReflectionProbe() {
                return this._bakeToReflectionProbe;
              }
              set bakeToReflectionProbe(e) {
                (this._bakeToReflectionProbe = e),
                  this.emit(t.BAKE_TO_REFLECTION_PROBE_CHANGED);
              }
            }).USE_LIGHT_PROBE_CHANGED = "use_light_probe_changed"),
            (wB.REFLECTION_PROBE_CHANGED = "reflection_probe_changed"),
            (wB.BAKE_TO_REFLECTION_PROBE_CHANGED =
              "bake_to_reflection_probe_changed"),
            (yB = fa((gB = wB).prototype, "texture", [rF], function () {
              return null;
            })),
            (TB = fa(gB.prototype, "uvParam", [rF], function () {
              return new Wi();
            })),
            (SB = fa(gB.prototype, "_bakeable", [rF], function () {
              return !1;
            })),
            (EB = fa(gB.prototype, "_castShadow", [rF], function () {
              return !1;
            })),
            (vB = fa(gB.prototype, "_receiveShadow", [cB], function () {
              return !1;
            })),
            (bB = fa(gB.prototype, "_lightmapSize", [rF], function () {
              return 64;
            })),
            (AB = fa(gB.prototype, "_useLightProbe", [rF], function () {
              return !1;
            })),
            (CB = fa(gB.prototype, "_bakeToLightProbe", [rF], function () {
              return !0;
            })),
            (OB = fa(gB.prototype, "_reflectionProbeType", [rF], function () {
              return hB.NONE;
            })),
            (IB = fa(gB.prototype, "_bakeToReflectionProbe", [rF], function () {
              return !0;
            })),
            s(
              gB.prototype,
              "lightmapSize",
              [uB],
              Object.getOwnPropertyDescriptor(gB.prototype, "lightmapSize"),
              gB.prototype
            ),
            s(
              gB.prototype,
              "useLightProbe",
              [_B],
              Object.getOwnPropertyDescriptor(gB.prototype, "useLightProbe"),
              gB.prototype
            ),
            s(
              gB.prototype,
              "bakeToLightProbe",
              [dB],
              Object.getOwnPropertyDescriptor(gB.prototype, "bakeToLightProbe"),
              gB.prototype
            ),
            s(
              gB.prototype,
              "reflectionProbe",
              [pB],
              Object.getOwnPropertyDescriptor(gB.prototype, "reflectionProbe"),
              gB.prototype
            ),
            s(
              gB.prototype,
              "bakeToReflectionProbe",
              [mB],
              Object.getOwnPropertyDescriptor(
                gB.prototype,
                "bakeToReflectionProbe"
              ),
              gB.prototype
            ),
            (fB = gB))
          ) || fB),
        dF =
          ((RB = ZB("cc.MeshRenderer")),
          (DB = tF(100)),
          (xB = sF(ze)),
          (MB = sF(ze)),
          (PB = sF(cF)),
          (NB = sF(uF)),
          (LB = sF(sB)),
          (BB = sF(He)),
          RB(
            (FB =
              DB(
                ((($B = class extends MM {
                  get shadowBias() {
                    return this._shadowBias;
                  }
                  set shadowBias(t) {
                    (this._shadowBias = t),
                      this._updateShadowBias(),
                      this._onUpdateLocalShadowBiasAndProbeId();
                  }
                  get shadowNormalBias() {
                    return this._shadowNormalBias;
                  }
                  set shadowNormalBias(t) {
                    (this._shadowNormalBias = t),
                      this._updateShadowNormalBias(),
                      this._onUpdateLocalShadowBiasAndProbeId();
                  }
                  get shadowCastingMode() {
                    return this._shadowCastingMode;
                  }
                  set shadowCastingMode(t) {
                    (this._shadowCastingMode = t), this._updateCastShadow();
                  }
                  get shadowCastingModeForInspector() {
                    return this.shadowCastingMode === cF.ON;
                  }
                  set shadowCastingModeForInspector(t) {
                    this.shadowCastingMode = !0 === t ? cF.ON : cF.OFF;
                  }
                  onUpdateReceiveDirLight(t, e = !1) {
                    this._model &&
                      (e
                        ? (this._model.receiveDirLight = !1)
                        : (this.node &&
                            (t & this.node.layer) === this.node.layer) ||
                          t & this._model.visFlags
                        ? (this._model.receiveDirLight = !0)
                        : (this._model.receiveDirLight = !1));
                  }
                  get receiveShadow() {
                    return this._shadowReceivingMode;
                  }
                  set receiveShadow(t) {
                    (this._shadowReceivingMode = t),
                      this._updateReceiveShadow();
                  }
                  get receiveShadowForInspector() {
                    return this._shadowReceivingMode === uF.ON;
                  }
                  set receiveShadowForInspector(t) {
                    (this._shadowReceivingMode = !0 === t ? uF.ON : uF.OFF),
                      this._updateReceiveShadow();
                  }
                  get mesh() {
                    return this._mesh;
                  }
                  set mesh(t) {
                    const e = this._mesh,
                      i = (this._mesh = t);
                    null == i || i.initialize(),
                      this._initSubMeshShapesWeights(),
                      this._watchMorphInMesh(),
                      this._onMeshChanged(e),
                      this._updateModels(),
                      this.enabledInHierarchy && this._attachToScene(),
                      this._updateCastShadow(),
                      this._updateReceiveShadow(),
                      this._updateUseLightProbe(),
                      this._updateUseReflectionProbe(),
                      this._updateReceiveDirLight();
                  }
                  get model() {
                    return this._model;
                  }
                  get enableMorph() {
                    return this._enableMorph;
                  }
                  set enableMorph(t) {
                    this._enableMorph = t;
                  }
                  get isGlobalStandardSkinObject() {
                    return this._enabledGlobalStandardSkinObject;
                  }
                  set isGlobalStandardSkinObject(t) {
                    (a.director.root.pipeline.pipelineSceneData.standardSkinMeshRenderer =
                      t ? this : null),
                      (this._enabledGlobalStandardSkinObject = t);
                  }
                  clearGlobalStandardSkinObjectFlag() {
                    this._enabledGlobalStandardSkinObject = !1;
                  }
                  constructor() {
                    super(),
                      (this.bakeSettings = kB && kB()),
                      (this._mesh = zB && zB()),
                      (this._shadowCastingMode = HB && HB()),
                      (this._shadowReceivingMode = GB && GB()),
                      (this._shadowBias = VB && VB()),
                      (this._shadowNormalBias = jB && jB()),
                      (this._reflectionProbeId = WB && WB()),
                      (this._reflectionProbeBlendId = XB && XB()),
                      (this._reflectionProbeBlendWeight = YB && YB()),
                      (this._enabledGlobalStandardSkinObject = KB && KB()),
                      (this._reflectionProbeDataMap = null),
                      (this._subMeshShapesWeights = []),
                      (this._modelType = tg),
                      (this._model = null),
                      (this._morphInstance = null),
                      (this._enableMorph = qB && qB()),
                      ge.querySettings(
                        fe.Category.RENDERING,
                        "highQualityMode"
                      ) &&
                        ((this._shadowCastingMode = cF.ON),
                        (this.bakeSettings.castShadow = !0),
                        (this.bakeSettings.receiveShadow = !0));
                  }
                  onLoad() {
                    this._mesh && this._mesh.initialize(),
                      this._validateShapeWeights() ||
                        this._initSubMeshShapesWeights(),
                      this._watchMorphInMesh(),
                      this._updateModels(),
                      this._updateCastShadow(),
                      this._updateReceiveShadow(),
                      this._updateShadowBias(),
                      this._updateShadowNormalBias(),
                      this._updateUseLightProbe(),
                      this._updateBakeToReflectionProbe(),
                      this._updateUseReflectionProbe(),
                      this._updateReceiveDirLight(),
                      this._updateStandardSkin();
                  }
                  onRestore() {
                    this._updateModels(),
                      this.enabledInHierarchy && this._attachToScene(),
                      this._updateCastShadow(),
                      this._updateReceiveShadow(),
                      this._updateShadowBias(),
                      this._updateShadowNormalBias(),
                      this._updateUseLightProbe(),
                      this._updateBakeToReflectionProbe(),
                      this._updateUseReflectionProbe(),
                      this._updateReceiveDirLight(),
                      this._updateStandardSkin();
                  }
                  onEnable() {
                    super.onEnable(),
                      this.node.on(
                        bf.MOBILITY_CHANGED,
                        this.onMobilityChanged,
                        this
                      ),
                      this.node.on(
                        bf.LIGHT_PROBE_BAKING_CHANGED,
                        this.onLightProbeBakingChanged,
                        this
                      ),
                      this.bakeSettings.on(
                        _F.USE_LIGHT_PROBE_CHANGED,
                        this.onUseLightProbeChanged,
                        this
                      ),
                      this.bakeSettings.on(
                        _F.REFLECTION_PROBE_CHANGED,
                        this.onReflectionProbeChanged,
                        this
                      ),
                      this.bakeSettings.on(
                        _F.BAKE_TO_REFLECTION_PROBE_CHANGED,
                        this.onBakeToReflectionProbeChanged,
                        this
                      ),
                      this._model || this._updateModels(),
                      this._model.onGlobalPipelineStateChanged(),
                      this._updateCastShadow(),
                      this._updateReceiveShadow(),
                      this._updateShadowBias(),
                      this._updateShadowNormalBias(),
                      this._updateBakeToReflectionProbe(),
                      this._updateUseReflectionProbe(),
                      this._onUpdateLocalShadowBiasAndProbeId(),
                      this._updateUseLightProbe(),
                      this._updateReceiveDirLight(),
                      this._onUpdateReflectionProbeDataMap(),
                      this._onUpdateLocalReflectionProbeData(),
                      this._updateStandardSkin(),
                      this._attachToScene();
                  }
                  onDisable() {
                    this._model && this._detachFromScene(),
                      this.node.off(
                        bf.MOBILITY_CHANGED,
                        this.onMobilityChanged,
                        this
                      ),
                      this.node.off(
                        bf.LIGHT_PROBE_BAKING_CHANGED,
                        this.onLightProbeBakingChanged,
                        this
                      ),
                      this.bakeSettings.off(
                        _F.USE_LIGHT_PROBE_CHANGED,
                        this.onUseLightProbeChanged,
                        this
                      ),
                      this.bakeSettings.off(
                        _F.REFLECTION_PROBE_CHANGED,
                        this.onReflectionProbeChanged,
                        this
                      ),
                      this.bakeSettings.off(
                        _F.BAKE_TO_REFLECTION_PROBE_CHANGED,
                        this.onBakeToReflectionProbeChanged,
                        this
                      );
                  }
                  onDestroy() {
                    this._model &&
                      (a.director.root.destroyModel(this._model),
                      (this._model = null),
                      (this._models.length = 0)),
                      this._morphInstance && this._morphInstance.destroy();
                  }
                  onGeometryChanged() {
                    if (this._model && this._mesh) {
                      const t = this._mesh.struct;
                      this._model.createBoundingShape(
                        t.minPosition,
                        t.maxPosition
                      ),
                        this._model.updateWorldBound(),
                        this._model.onGeometryChanged();
                    }
                  }
                  getWeight(t, e) {
                    const { _subMeshShapesWeights: i } = this;
                    i.length;
                    const s = this._subMeshShapesWeights[t];
                    return s.length, s[e];
                  }
                  setWeights(t, e) {
                    const { _subMeshShapesWeights: i } = this;
                    e >= i.length ||
                      (i[e].length === t.length &&
                        ((i[e] = t.slice(0)),
                        this._uploadSubMeshShapesWeights(e)));
                  }
                  setWeight(t, e, i) {
                    const { _subMeshShapesWeights: s } = this;
                    if (e >= s.length) return;
                    const n = s[e];
                    i >= n.length ||
                      ((n[i] = t), this._uploadSubMeshShapesWeights(e));
                  }
                  setInstancedAttribute(t, e) {
                    this.model && this.model._setInstancedAttribute(t, e);
                  }
                  _updateLightmap(t, e, i, s, n) {
                    (this.bakeSettings.texture = t),
                      (this.bakeSettings.uvParam.x = e),
                      (this.bakeSettings.uvParam.y = i),
                      (this.bakeSettings.uvParam.z = s),
                      (this.bakeSettings.uvParam.w = n),
                      this._onUpdateLightingmap(),
                      this._updateReceiveDirLight();
                  }
                  updateProbeCubemap(t) {
                    (this.bakeSettings.probeCubemap &&
                      this.bakeSettings.probeCubemap === t) ||
                      ((this.bakeSettings.probeCubemap = t),
                      null !== this.model &&
                        this.model.updateReflectionProbeCubemap(
                          this.bakeSettings.probeCubemap
                        ));
                  }
                  updateProbeBlendCubemap(t) {
                    (this.bakeSettings.probeBlendCubemap &&
                      this.bakeSettings.probeBlendCubemap === t) ||
                      ((this.bakeSettings.probeBlendCubemap = t),
                      null !== this.model &&
                        this.model.updateReflectionProbeBlendCubemap(
                          this.bakeSettings.probeBlendCubemap
                        ));
                  }
                  updateProbePlanarMap(t) {
                    this.bakeSettings.probePlanarmap !== t &&
                      ((this.bakeSettings.probePlanarmap = t),
                      null !== this.model &&
                        this.model.updateReflectionProbePlanarMap(
                          this.bakeSettings.probePlanarmap
                        ));
                  }
                  updateReflectionProbeDataMap(t) {
                    (this._reflectionProbeDataMap = t),
                      null !== this.model &&
                        this.model.updateReflectionProbeDataMap(t);
                  }
                  updateReflectionProbeId(t) {
                    (this._reflectionProbeId = t),
                      this.model && (this.model.reflectionProbeId = t),
                      this._onUpdateLocalShadowBiasAndProbeId();
                  }
                  updateReflectionProbeBlendId(t) {
                    (this._reflectionProbeBlendId = t),
                      this.model && (this.model.reflectionProbeBlendId = t),
                      this._onUpdateLocalShadowBiasAndProbeId();
                  }
                  updateReflectionProbeBlendWeight(t) {
                    (this._reflectionProbeBlendWeight = t),
                      this.model && (this.model.reflectionProbeBlendWeight = t),
                      this._onUpdateLocalReflectionProbeData();
                  }
                  _updateReflectionProbeTexture() {
                    if (!this.model) return;
                    const t = this.bakeSettings,
                      e = t.reflectionProbe,
                      i = t.probeBlendCubemap,
                      s = t.probePlanarmap,
                      n = t.probeCubemap;
                    e === hB.BAKED_CUBEMAP
                      ? (this.model.updateReflectionProbeCubemap(n),
                        this.model.updateReflectionProbePlanarMap(null),
                        this.model.updateReflectionProbeBlendCubemap(null))
                      : e === hB.BLEND_PROBES ||
                        e === hB.BLEND_PROBES_AND_SKYBOX
                      ? (this.model.updateReflectionProbeCubemap(n),
                        this.model.updateReflectionProbeBlendCubemap(i),
                        this.model.updateReflectionProbePlanarMap(null))
                      : e === hB.PLANAR_REFLECTION
                      ? (this.model.updateReflectionProbePlanarMap(s),
                        this.model.updateReflectionProbeCubemap(null),
                        this.model.updateReflectionProbeBlendCubemap(null))
                      : (this.model.updateReflectionProbeCubemap(null),
                        this.model.updateReflectionProbePlanarMap(null),
                        this.model.updateReflectionProbeBlendCubemap(null));
                  }
                  _updateModels() {
                    if (!this.enabledInHierarchy) return;
                    const t = this._model;
                    if (
                      (t
                        ? (t.destroy(),
                          t.initialize(),
                          (t.node = t.transform = this.node))
                        : this._createModel(),
                      this._model)
                    ) {
                      if (this._mesh) {
                        const t = this._mesh.struct;
                        this._model.createBoundingShape(
                          t.minPosition,
                          t.maxPosition
                        ),
                          this._model.updateWorldBound();
                      }
                      this._model.initLightingmap(
                        this.bakeSettings.texture,
                        this.bakeSettings.uvParam
                      ),
                        this._updateUseLightProbe(),
                        this._updateUseReflectionProbeType(),
                        this._updateModelParams(),
                        this._onUpdateLightingmap(),
                        this._onUpdateLocalShadowBiasAndProbeId(),
                        this._updateUseReflectionProbe(),
                        this._updateReceiveDirLight(),
                        this._onUpdateReflectionProbeDataMap(),
                        this._onUpdateLocalReflectionProbeData();
                    }
                  }
                  _updateReceiveDirLight() {
                    if (!this._model) return;
                    const t = this.node.scene;
                    if (!t || !t.renderScene) return;
                    const e = t.renderScene.mainLight;
                    if (!e) return;
                    const i = e.visibility;
                    if (e.node)
                      if (e.node.mobility === If.Static) {
                        let t = !1;
                        this.bakeSettings.texture &&
                          !this.node.scene.globals.disableLightmap &&
                          (t = !0),
                          this.node.scene.globals.lightProbeInfo.data &&
                            this.node.scene.globals.lightProbeInfo.data.hasCoefficients() &&
                            this._model.useLightProbe &&
                            (t = !0),
                          this.onUpdateReceiveDirLight(i, t);
                      } else this.onUpdateReceiveDirLight(i);
                  }
                  _createModel() {
                    const t =
                        this._morphInstance && this._modelType === tg
                          ? oB
                          : this._modelType,
                      e = (this._model = a.director.root.createModel(t));
                    (e.visFlags = this.visibility),
                      (e.node = e.transform = this.node),
                      (this._models.length = 0),
                      this._models.push(this._model),
                      this._morphInstance &&
                        e instanceof oB &&
                        e.setMorphRendering(this._morphInstance);
                  }
                  _attachToScene() {
                    if (!this.node.scene || !this._model) return;
                    const t = this._getRenderScene();
                    null !== this._model.scene && this._detachFromScene(),
                      t.addModel(this._model);
                  }
                  _detachFromScene() {
                    this._model &&
                      this._model.scene &&
                      this._model.scene.removeModel(this._model);
                  }
                  _updateModelParams() {
                    if (!this._mesh || !this._model) return;
                    (this.node.hasChangedFlags |= Cf.POSITION),
                      (this._model.transform.hasChangedFlags |= Cf.POSITION),
                      (this._model.isDynamicBatching =
                        this._isBatchingEnabled());
                    const t = this._mesh
                        ? this._mesh.renderingSubMeshes.length
                        : 0,
                      e = this._mesh.renderingSubMeshes;
                    if (e)
                      for (let i = 0; i < t; ++i) {
                        let t = this.getRenderMaterial(i);
                        t && !t.isValid && (t = null);
                        const s = e[i];
                        s &&
                          this._model.initSubModel(
                            i,
                            s,
                            t || this._getBuiltinMaterial()
                          );
                      }
                    this._model.enabled = !0;
                  }
                  _onUpdateLightingmap() {
                    null !== this.model &&
                      this.model.updateLightingmap(
                        this.bakeSettings.texture,
                        this.bakeSettings.uvParam
                      ),
                      this.setInstancedAttribute("a_lightingMapUVParam", [
                        this.bakeSettings.uvParam.x,
                        this.bakeSettings.uvParam.y,
                        this.bakeSettings.uvParam.z,
                        this.bakeSettings.uvParam.w,
                      ]);
                  }
                  _onUpdateLocalShadowBiasAndProbeId() {
                    null !== this.model &&
                      (this.model.updateLocalShadowBias(),
                      this.model.updateReflectionProbeId()),
                      this.setInstancedAttribute(
                        "a_localShadowBiasAndProbeId",
                        [
                          this._shadowBias,
                          this._shadowNormalBias,
                          this._reflectionProbeId,
                          this._reflectionProbeBlendId,
                        ]
                      );
                  }
                  _onUpdateLocalReflectionProbeData() {
                    (this.bakeSettings.reflectionProbe !== hB.BAKED_CUBEMAP &&
                      this.bakeSettings.reflectionProbe !== hB.BLEND_PROBES &&
                      this.bakeSettings.reflectionProbe !==
                        hB.BLEND_PROBES_AND_SKYBOX) ||
                      (null !== this.model &&
                        this.model.updateReflectionProbeId(),
                      this.setInstancedAttribute("a_reflectionProbeData", [
                        this._reflectionProbeBlendWeight,
                        0,
                        0,
                        0,
                      ]));
                  }
                  _onUpdateReflectionProbeDataMap() {
                    null !== this.model &&
                      this.model.updateReflectionProbeDataMap(
                        this._reflectionProbeDataMap
                      );
                  }
                  _onMaterialModified(t, e) {
                    this._model &&
                      this._model.inited &&
                      (this._onRebuildPSO(t, e || this._getBuiltinMaterial()),
                      this._updateStandardSkin());
                  }
                  _onRebuildPSO(t, e) {
                    this._model &&
                      this._model.inited &&
                      ((this._model.isDynamicBatching =
                        this._isBatchingEnabled()),
                      this._model.setSubModelMaterial(t, e),
                      this._onUpdateLightingmap(),
                      this._onUpdateLocalShadowBiasAndProbeId(),
                      this._updateReflectionProbeTexture(),
                      this._onUpdateReflectionProbeDataMap(),
                      this._onUpdateLocalReflectionProbeData());
                  }
                  _onMeshChanged(t) {}
                  _clearMaterials() {
                    if (!this._model) return;
                    const t = this._model.subModels;
                    for (let e = 0; e < t.length; ++e)
                      this._onMaterialModified(e, null);
                  }
                  _getBuiltinMaterial() {
                    return Pv.get("missing-material");
                  }
                  _onVisibilityChange(t) {
                    this._model && (this._model.visFlags = t);
                  }
                  _updateShadowBias() {
                    this._model && (this._model.shadowBias = this._shadowBias);
                  }
                  _updateShadowNormalBias() {
                    this._model &&
                      (this._model.shadowNormalBias = this._shadowNormalBias);
                  }
                  _updateCastShadow() {
                    this._model &&
                      (this._shadowCastingMode === cF.OFF
                        ? (this._model.castShadow = !1)
                        : (this._shadowCastingMode,
                          cF.ON,
                          this._shadowCastingMode,
                          (this._model.castShadow = !0)));
                  }
                  _updateReceiveShadow() {
                    this._model &&
                      (this._shadowReceivingMode === uF.OFF
                        ? (this._model.receiveShadow = !1)
                        : (this._model.receiveShadow = !0));
                  }
                  onMobilityChanged() {
                    this._updateUseLightProbe(), this._updateReceiveDirLight();
                  }
                  onLightProbeBakingChanged() {
                    this._updateReceiveDirLight();
                  }
                  onUseLightProbeChanged() {
                    this._updateUseLightProbe();
                  }
                  onReflectionProbeChanged() {
                    this._updateUseReflectionProbe(),
                      this._onUpdateLocalShadowBiasAndProbeId(),
                      this.bakeSettings.reflectionProbe === hB.BAKED_CUBEMAP ||
                      this.bakeSettings.reflectionProbe === hB.BLEND_PROBES ||
                      this.bakeSettings.reflectionProbe ===
                        hB.BLEND_PROBES_AND_SKYBOX
                        ? (a.internal.reflectionProbeManager.selectReflectionProbe(
                            this._model
                          ),
                          a.internal.reflectionProbeManager.getUsedReflectionProbe(
                            this._model,
                            !1
                          ) || z(16302))
                        : this.bakeSettings.reflectionProbe ===
                            hB.PLANAR_REFLECTION &&
                          (a.internal.reflectionProbeManager.selectPlanarReflectionProbe(
                            this._model
                          ),
                          a.internal.reflectionProbeManager.getUsedReflectionProbe(
                            this._model,
                            !0
                          ) || z(16302));
                  }
                  onBakeToReflectionProbeChanged() {
                    this._updateBakeToReflectionProbe();
                  }
                  _updateUseLightProbe() {
                    if (!this._model) return;
                    const t = this.node;
                    this._mesh &&
                    t &&
                    t.mobility === If.Movable &&
                    this.bakeSettings.useLightProbe
                      ? (this._model.useLightProbe = !0)
                      : (this._model.useLightProbe = !1);
                  }
                  _isBatchingEnabled() {
                    for (let t = 0; t < this._materials.length; ++t) {
                      const e = this._materials[t];
                      if (e)
                        for (let t = 0; t < e.passes.length; ++t)
                          if (e.passes[t].batchingScheme) return !0;
                    }
                    return !1;
                  }
                  _updateUseReflectionProbe() {
                    this._model &&
                      ((this._model.reflectionProbeType =
                        this.bakeSettings.reflectionProbe),
                      this._updateReflectionProbeTexture());
                  }
                  _updateUseReflectionProbeType() {
                    this._model &&
                      (this._model.reflectionProbeType =
                        this.bakeSettings.reflectionProbe);
                  }
                  _updateBakeToReflectionProbe() {
                    this._model &&
                      (this._model.bakeToReflectionProbe =
                        this.bakeSettings.bakeToReflectionProbe);
                  }
                  _watchMorphInMesh() {
                    if (
                      (this._morphInstance &&
                        (this._morphInstance.destroy(),
                        (this._morphInstance = null)),
                      !this._enableMorph)
                    )
                      return;
                    if (
                      !this._mesh ||
                      !this._mesh.struct.morph ||
                      !this._mesh.morphRendering
                    )
                      return;
                    this._morphInstance =
                      this._mesh.morphRendering.createInstance();
                    const t = this._mesh.struct.primitives.length;
                    for (let e = 0; e < t; ++e)
                      this._uploadSubMeshShapesWeights(e);
                    this._model &&
                      this._model instanceof oB &&
                      this._model.setMorphRendering(this._morphInstance);
                  }
                  _initSubMeshShapesWeights() {
                    const { _mesh: t } = this;
                    if (((this._subMeshShapesWeights.length = 0), !t)) return;
                    const e = t.struct.morph;
                    if (!e) return;
                    const i = e.weights;
                    this._subMeshShapesWeights = e.subMeshMorphs.map((t) =>
                      t
                        ? t.weights
                          ? t.weights.slice(0)
                          : i
                          ? (i.length, t.targets.length, i.slice(0))
                          : new Array(t.targets.length).fill(0)
                        : []
                    );
                  }
                  _validateShapeWeights() {
                    const { _mesh: t, _subMeshShapesWeights: e } = this;
                    if (!t || !t.struct.morph) return 0 === e.length;
                    const { morph: i } = t.struct;
                    return (
                      i.subMeshMorphs.length === e.length &&
                      e.every(({ length: t }, e) => {
                        var s, n;
                        return (
                          (null !==
                            (s =
                              null === (n = i.subMeshMorphs[e]) || void 0 === n
                                ? void 0
                                : n.targets.length) && void 0 !== s
                            ? s
                            : 0) === t
                        );
                      })
                    );
                  }
                  _uploadSubMeshShapesWeights(t) {
                    var e;
                    null === (e = this._morphInstance) ||
                      void 0 === e ||
                      e.setWeights(t, this._subMeshShapesWeights[t]);
                  }
                  _updateStandardSkin() {
                    const t = a.director.root.pipeline.pipelineSceneData;
                    if (
                      (this._enabledGlobalStandardSkinObject &&
                        ((t.standardSkinMeshRenderer = this),
                        (t.standardSkinModel = this.model)),
                      !t.skinMaterialModel && this._model)
                    ) {
                      const e = this._model.subModels;
                      for (let i = 0; i < e.length; i++)
                        if (!(lF(e[i]) < 0))
                          return void (t.skinMaterialModel = this._model);
                    }
                  }
                }).ShadowCastingMode = cF),
                ($B.ShadowReceivingMode = uF),
                (kB = fa(
                  (UB = $B).prototype,
                  "bakeSettings",
                  [rF],
                  function () {
                    return new _F();
                  }
                )),
                (zB = fa(UB.prototype, "_mesh", [rF], function () {
                  return null;
                })),
                (HB = fa(UB.prototype, "_shadowCastingMode", [rF], function () {
                  return cF.OFF;
                })),
                (GB = fa(
                  UB.prototype,
                  "_shadowReceivingMode",
                  [rF],
                  function () {
                    return uF.ON;
                  }
                )),
                (VB = fa(UB.prototype, "_shadowBias", [rF], function () {
                  return 0;
                })),
                (jB = fa(UB.prototype, "_shadowNormalBias", [rF], function () {
                  return 0;
                })),
                (WB = fa(UB.prototype, "_reflectionProbeId", [rF], function () {
                  return -1;
                })),
                (XB = fa(
                  UB.prototype,
                  "_reflectionProbeBlendId",
                  [rF],
                  function () {
                    return -1;
                  }
                )),
                (YB = fa(
                  UB.prototype,
                  "_reflectionProbeBlendWeight",
                  [rF],
                  function () {
                    return 0;
                  }
                )),
                (KB = fa(
                  UB.prototype,
                  "_enabledGlobalStandardSkinObject",
                  [rF],
                  function () {
                    return !1;
                  }
                )),
                s(
                  UB.prototype,
                  "shadowBias",
                  [xB],
                  Object.getOwnPropertyDescriptor(UB.prototype, "shadowBias"),
                  UB.prototype
                ),
                s(
                  UB.prototype,
                  "shadowNormalBias",
                  [MB],
                  Object.getOwnPropertyDescriptor(
                    UB.prototype,
                    "shadowNormalBias"
                  ),
                  UB.prototype
                ),
                s(
                  UB.prototype,
                  "shadowCastingMode",
                  [PB],
                  Object.getOwnPropertyDescriptor(
                    UB.prototype,
                    "shadowCastingMode"
                  ),
                  UB.prototype
                ),
                s(
                  UB.prototype,
                  "receiveShadow",
                  [NB],
                  Object.getOwnPropertyDescriptor(
                    UB.prototype,
                    "receiveShadow"
                  ),
                  UB.prototype
                ),
                s(
                  UB.prototype,
                  "mesh",
                  [LB],
                  Object.getOwnPropertyDescriptor(UB.prototype, "mesh"),
                  UB.prototype
                ),
                s(
                  UB.prototype,
                  "isGlobalStandardSkinObject",
                  [BB],
                  Object.getOwnPropertyDescriptor(
                    UB.prototype,
                    "isGlobalStandardSkinObject"
                  ),
                  UB.prototype
                ),
                (qB = fa(UB.prototype, "_enableMorph", [rF], function () {
                  return !0;
                })),
                (FB = UB))
              ) || FB)
          ) || FB);
      function pF(t, e) {
        const i = t.sharedMaterials.length;
        if (i !== e.sharedMaterials.length) return !1;
        for (let s = 0; s < i; s++)
          if (t.getRenderMaterial(s) !== e.getRenderMaterial(s)) return !1;
        return !0;
      }
      t({ MeshRenderer: dF, ModelComponent: dF }),
        t(
          "BatchingUtility",
          class {
            static batchStaticModel(t, e) {
              const i = t.getComponentsInChildren(dF);
              if (i.length < 2)
                return (
                  console.error(
                    "the number of static models to batch is less than 2,it needn't batch."
                  ),
                  !1
                );
              for (let t = 1; t < i.length; t++) {
                if (!i[0].mesh.validateMergingMesh(i[t].mesh))
                  return (
                    console.error(
                      `the meshes of ${i[0].node.name} and ${i[t].node.name} can't be merged`
                    ),
                    !1
                  );
                if (!pF(i[0], i[t]))
                  return (
                    console.error(
                      `the materials of ${i[0].node.name} and ${i[t].node.name} can't be merged`
                    ),
                    !1
                  );
              }
              const s = new sB(),
                n = new ms(),
                r = new ms();
              t.getWorldMatrix(r), ms.invert(r, r);
              for (let t = 0; t < i.length; t++) {
                const e = i[t];
                e.node.getWorldMatrix(n),
                  ms.multiply(n, r, n),
                  s.merge(i[t].mesh, n),
                  (e.enabled = !1);
              }
              const a = e.addComponent(dF);
              return (
                (a.mesh = s), (a.sharedMaterials = i[0].sharedMaterials), !0
              );
            }
            static unbatchStaticModel(t, e) {
              const i = t.getComponentsInChildren(dF);
              for (let t = 0; t < i.length; t++) i[t].enabled = !0;
              const s = e.getComponent(dF);
              return (
                s && (s.mesh && s.mesh.destroyRenderingMesh(), s.destroy()), !0
              );
            }
          }
        ),
        $(sB.prototype, "Mesh.prototype", [
          { name: "renderingMesh", newName: "renderingSubMeshes" },
        ]),
        Z(sB.prototype, "Mesh.prototype", [
          { name: "hasFlatBuffers" },
          { name: "destroyFlatBuffers" },
        ]);
      const mF = t("Skeleton", jsb.Skeleton);
      a.Skeleton = mF;
      const fF = mF.prototype;
      Object.defineProperty(fF, "bindposes", {
        enumerable: !0,
        configurable: !0,
        get() {
          return this._bindposes;
        },
        set(t) {
          (this._bindposes = t), this._setBindposes(t);
        },
      }),
        (fF._ctor = function () {
          jsb.Asset.prototype._ctor.apply(this, arguments),
            (this._bindposes = []);
        }),
        (fF.destroy = function () {
          var t, e;
          return (
            null === (t = a.director.root) ||
              void 0 === t ||
              null === (e = t.dataPoolManager) ||
              void 0 === e ||
              e.releaseSkeleton(this),
            Ad.prototype.destroy.call(this)
          );
        });
      const gF = fF.onLoaded;
      var yF, TF, SF, EF, vF, bF, AF, CF, OF, IF, wF, RF, DF, xF, MF, PF;
      (fF.onLoaded = function () {
        this._setBindposes(this._bindposes), gF.call(this);
      }),
        (function (t, e = vd) {
          const { Skeleton: i, CCString: s, Mat4: n } = { ...t };
          e(
            () => {
              ao([s])(i.prototype, "_joints", () => []);
            },
            "type",
            "_joints"
          ),
            e(
              () => {
                ao([n])(i.prototype, "_bindposes", () => []);
              },
              "type",
              "_bindposes"
            ),
            e(
              () => {
                Na(i.prototype, "_hash", () => 0);
              },
              "serializable",
              "_hash"
            ),
            e(
              () => {
                Ca("cc.Skeleton")(i);
              },
              "ccclass",
              null
            );
        })({ Skeleton: mF, CCString: Ge, Mat4: ms }),
        Z(dF.prototype, "MeshRenderer.prototype", [
          { name: "enableDynamicBatching" },
          { name: "recieveShadows" },
        ]),
        (a.ModelComponent = dF),
        Vt(dF, "cc.ModelComponent");
      const NF = new Yi(),
        LF = ce({ LUMINOUS_FLUX: 0, LUMINANCE: 1 });
      let BF =
          Ca("cc.StaticLightSettings")(
            ((TF = class {
              constructor() {
                (this._baked = SF && SF()),
                  (this._editorOnly = EF && EF()),
                  (this._castShadow = vF && vF());
              }
              get editorOnly() {
                return this._editorOnly;
              }
              set editorOnly(t) {
                this._editorOnly = t;
              }
              get baked() {
                return this._baked;
              }
              set baked(t) {
                this._baked = t;
              }
              get castShadow() {
                return this._castShadow;
              }
              set castShadow(t) {
                this._castShadow = t;
              }
            }),
            (SF = fa(TF.prototype, "_baked", [Na], function () {
              return !1;
            })),
            (EF = fa(TF.prototype, "_editorOnly", [Na], function () {
              return !1;
            })),
            (vF = fa(TF.prototype, "_castShadow", [Na], function () {
              return !1;
            })),
            (yF = TF))
          ) || yF,
        FF =
          ((bF = Ca("cc.Light")),
          (AF = ao(BF)),
          (CF = ao(Rf.BitMask)),
          bF(
            (((PF = class extends np {
              get color() {
                return this._color;
              }
              set color(t) {
                (this._color = t.clone()),
                  this._light &&
                    ((NF.x = t.r / 255),
                    (NF.y = t.g / 255),
                    (NF.z = t.b / 255),
                    (this._light.color = NF));
              }
              get useColorTemperature() {
                return this._useColorTemperature;
              }
              set useColorTemperature(t) {
                (this._useColorTemperature = t),
                  this._light && (this._light.useColorTemperature = t);
              }
              get colorTemperature() {
                return this._colorTemperature;
              }
              set colorTemperature(t) {
                (this._colorTemperature = t),
                  this._light && (this._light.colorTemperature = t);
              }
              get staticSettings() {
                return this._staticSettings;
              }
              set staticSettings(t) {
                this._staticSettings = t;
              }
              get type() {
                return this._type;
              }
              get baked() {
                return this.staticSettings.baked;
              }
              set baked(t) {
                (this.staticSettings.baked = t),
                  null !== this._light && (this._light.baked = t);
              }
              set visibility(t) {
                (this._visibility = t),
                  this._light && (this._light.visibility = t),
                  this._onUpdateReceiveDirLight();
              }
              get visibility() {
                return this._visibility;
              }
              constructor() {
                super(),
                  (this._color = wF && wF()),
                  (this._useColorTemperature = RF && RF()),
                  (this._colorTemperature = DF && DF()),
                  (this._staticSettings = xF && xF()),
                  (this._visibility = MF && MF()),
                  (this._type = Og.UNKNOWN),
                  (this._lightType = void 0),
                  (this._light = null),
                  (this._lightType = wg);
              }
              onLoad() {
                this._createLight();
              }
              onEnable() {
                this._attachToScene();
              }
              onDisable() {
                this._detachFromScene();
              }
              onDestroy() {
                this._destroyLight();
              }
              _createLight() {
                this._light ||
                  (this._light = a.director.root.createLight(this._lightType)),
                  (this.color = this._color),
                  (this.useColorTemperature = this._useColorTemperature),
                  (this.colorTemperature = this._colorTemperature),
                  (this._light.node = this.node),
                  (this._light.baked = this.baked),
                  (this._light.visibility = this.visibility);
              }
              _destroyLight() {
                this._light &&
                  (a.director.root.recycleLight(this._light),
                  (this._light = null));
              }
              _attachToScene() {
                if (
                  (this._detachFromScene(),
                  this._light && !this._light.scene && this.node.scene)
                ) {
                  const t = this._getRenderScene();
                  switch (this._type) {
                    case Og.DIRECTIONAL:
                      t.addDirectionalLight(this._light),
                        t.setMainLight(this._light);
                      break;
                    case Og.SPHERE:
                      t.addSphereLight(this._light);
                      break;
                    case Og.SPOT:
                      t.addSpotLight(this._light);
                      break;
                    case Og.POINT:
                      t.addPointLight(this._light);
                      break;
                    case Og.RANGED_DIRECTIONAL:
                      t.addRangedDirLight(this._light);
                  }
                }
              }
              _detachFromScene() {
                if (this._light && this._light.scene) {
                  const t = this._light.scene;
                  switch (this._type) {
                    case Og.DIRECTIONAL:
                      t.removeDirectionalLight(this._light),
                        t.unsetMainLight(this._light);
                      break;
                    case Og.SPHERE:
                      t.removeSphereLight(this._light);
                      break;
                    case Og.SPOT:
                      t.removeSpotLight(this._light);
                      break;
                    case Og.POINT:
                      t.removePointLight(this._light);
                      break;
                    case Og.RANGED_DIRECTIONAL:
                      t.removeRangedDirLight(this._light);
                  }
                }
              }
              _onUpdateReceiveDirLight() {}
            }).Type = Og),
            (PF.PhotometricTerm = LF),
            (wF = fa((IF = PF).prototype, "_color", [Na], function () {
              return Qi.WHITE.clone();
            })),
            (RF = fa(IF.prototype, "_useColorTemperature", [Na], function () {
              return !1;
            })),
            (DF = fa(IF.prototype, "_colorTemperature", [Na], function () {
              return 6550;
            })),
            (xF = fa(IF.prototype, "_staticSettings", [Na], function () {
              return new BF();
            })),
            (MF = fa(IF.prototype, "_visibility", [Na], function () {
              return AA;
            })),
            s(
              IF.prototype,
              "staticSettings",
              [AF],
              Object.getOwnPropertyDescriptor(IF.prototype, "staticSettings"),
              IF.prototype
            ),
            s(
              IF.prototype,
              "visibility",
              [CF],
              Object.getOwnPropertyDescriptor(IF.prototype, "visibility"),
              IF.prototype
            ),
            (OF = IF))
          ) || OF);
      var UF,
        kF,
        zF,
        HF,
        GF,
        VF,
        jF,
        WF,
        XF,
        YF,
        KF,
        qF,
        $F,
        ZF,
        QF,
        JF,
        tU,
        eU,
        iU,
        sU,
        nU,
        rU,
        aU,
        oU,
        hU,
        lU,
        cU,
        uU,
        _U,
        dU,
        pU,
        mU,
        fU,
        gU,
        yU,
        TU,
        SU,
        EU,
        vU,
        bU,
        AU,
        CU,
        OU,
        IU,
        wU,
        RU,
        DU,
        xU,
        MU,
        PU,
        NU,
        LU,
        BU,
        FU,
        UU,
        kU,
        zU,
        HU,
        GU,
        VU;
      t({ Light: FF, LightComponent: FF });
      const {
        ccclass: jU,
        menu: WU,
        executeInEditMode: XU,
        property: YU,
        serializable: KU,
        formerlySerializedAs: qU,
        tooltip: $U,
        help: ZU,
        visible: QU,
        type: JU,
        editable: tk,
        slide: ek,
        range: ik,
      } = go;
      let sk =
        ((UF = jU("cc.DirectionalLight")),
        (kF = qU("_illuminance")),
        (zF = JU(ke)),
        (HF = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 1 },
        })),
        (GF = JU(He)),
        (VF = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 5 },
        })),
        (jF = JU(zg)),
        (WF = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 6 },
        })),
        (XF = JU(ze)),
        (YF = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 7 },
        })),
        (KF = JU(ze)),
        (qF = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 8 },
        })),
        ($F = JU(ze)),
        (ZF = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 9 },
        })),
        (QF = JU(ze)),
        (JF = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 22 },
        })),
        (tU = JU(ze)),
        (eU = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 10 },
        })),
        (iU = JU(Hg)),
        (sU = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 11 },
        })),
        (nU = JU(He)),
        (rU = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 12 },
        })),
        (aU = JU(ze)),
        (oU = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 13 },
        })),
        (hU = JU(Gg)),
        (lU = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 14 },
        })),
        (cU = JU(He)),
        (uU = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 15 },
        })),
        (_U = JU(ze)),
        (dU = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 16 },
        })),
        (pU = JU(ze)),
        (mU = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 17 },
        })),
        (fU = JU(ze)),
        (gU = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 19 },
        })),
        (yU = JU(He)),
        (TU = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 20 },
        })),
        (SU = JU(He)),
        (EU = YU({
          group: { name: "DynamicShadowSettings", displayOrder: 21 },
        })),
        (vU = JU(ze)),
        UF(
          ((AU = class extends FF {
            get illuminance() {
              return a.director.root.pipeline.pipelineSceneData.isHDR
                ? this._illuminanceHDR
                : this._illuminanceLDR;
            }
            set illuminance(t) {
              a.director.root.pipeline.pipelineSceneData.isHDR
                ? ((this._illuminanceHDR = t),
                  this._light &&
                    (this._light.illuminanceHDR = this._illuminanceHDR))
                : ((this._illuminanceLDR = t),
                  this._light &&
                    (this._light.illuminanceLDR = this._illuminanceLDR));
            }
            get shadowEnabled() {
              return this._shadowEnabled;
            }
            set shadowEnabled(t) {
              (this._shadowEnabled = t),
                this._light &&
                  (this._light.shadowEnabled = this._shadowEnabled);
            }
            get shadowPcf() {
              return this._shadowPcf;
            }
            set shadowPcf(t) {
              (this._shadowPcf = t),
                this._light && (this._light.shadowPcf = this._shadowPcf);
            }
            get shadowBias() {
              return this._shadowBias;
            }
            set shadowBias(t) {
              (this._shadowBias = t),
                this._light && (this._light.shadowBias = this._shadowBias);
            }
            get shadowNormalBias() {
              return this._shadowNormalBias;
            }
            set shadowNormalBias(t) {
              (this._shadowNormalBias = t),
                this._light &&
                  (this._light.shadowNormalBias = this._shadowNormalBias);
            }
            get shadowSaturation() {
              return this._shadowSaturation;
            }
            set shadowSaturation(t) {
              (this._shadowSaturation = Si(t, 0, 1)),
                this._light &&
                  (this._light.shadowSaturation = this._shadowSaturation);
            }
            get shadowDistance() {
              return this._shadowDistance;
            }
            set shadowDistance(t) {
              (this._shadowDistance = Math.min(t, Xg.MAX_FAR)),
                this._shadowDistance / 0.1 < 10 &&
                  z(15003, this._shadowDistance),
                this._light &&
                  ((this._light.shadowDistance = this._shadowDistance),
                  (this._light.csmNeedUpdate = !0));
            }
            get shadowInvisibleOcclusionRange() {
              return this._shadowInvisibleOcclusionRange;
            }
            set shadowInvisibleOcclusionRange(t) {
              (this._shadowInvisibleOcclusionRange = Math.min(t, Xg.MAX_FAR)),
                this._light &&
                  (this._light.shadowInvisibleOcclusionRange =
                    this._shadowInvisibleOcclusionRange);
            }
            get csmLevel() {
              return this._csmLevel;
            }
            set csmLevel(t) {
              (this._csmLevel = t),
                this._light &&
                  ((this._light.csmLevel = this._csmLevel),
                  (this._light.csmNeedUpdate = !0));
            }
            get enableCSM() {
              return this._csmLevel > Hg.LEVEL_1;
            }
            set enableCSM(t) {
              (this._csmLevel = t ? Hg.LEVEL_4 : Hg.LEVEL_1),
                this._light &&
                  ((this._light.csmLevel = this._csmLevel),
                  (this._light.csmNeedUpdate = !0));
            }
            get csmLayerLambda() {
              return this._csmLayerLambda;
            }
            set csmLayerLambda(t) {
              (this._csmLayerLambda = t),
                this._light &&
                  ((this._light.csmLayerLambda = this._csmLayerLambda),
                  (this._light.csmNeedUpdate = !0));
            }
            get csmOptimizationMode() {
              return this._csmOptimizationMode;
            }
            set csmOptimizationMode(t) {
              (this._csmOptimizationMode = t),
                this._light &&
                  (this._light.csmOptimizationMode = this._csmOptimizationMode);
            }
            get shadowFixedArea() {
              return this._shadowFixedArea;
            }
            set shadowFixedArea(t) {
              (this._shadowFixedArea = t),
                this._light &&
                  (this._light.shadowFixedArea = this._shadowFixedArea);
            }
            get shadowNear() {
              return this._shadowNear;
            }
            set shadowNear(t) {
              (this._shadowNear = t),
                this._light && (this._light.shadowNear = this._shadowNear);
            }
            get shadowFar() {
              return this._shadowFar;
            }
            set shadowFar(t) {
              (this._shadowFar = Math.min(t, Xg.MAX_FAR)),
                this._light && (this._light.shadowFar = this._shadowFar);
            }
            get shadowOrthoSize() {
              return this._shadowOrthoSize;
            }
            set shadowOrthoSize(t) {
              (this._shadowOrthoSize = t),
                this._light &&
                  (this._light.shadowOrthoSize = this._shadowOrthoSize);
            }
            get csmAdvancedOptions() {
              return this._csmAdvancedOptions;
            }
            set csmAdvancedOptions(t) {
              this._csmAdvancedOptions = t;
            }
            get csmLayersTransition() {
              return this._csmLayersTransition;
            }
            set csmLayersTransition(t) {
              (this._csmLayersTransition = t),
                this._light && (this._light.csmLayersTransition = t);
            }
            get csmTransitionRange() {
              return this._csmTransitionRange;
            }
            set csmTransitionRange(t) {
              (this._csmTransitionRange = t),
                this._light && (this._light.csmTransitionRange = t);
            }
            constructor() {
              super(),
                (this._illuminanceHDR = CU && CU()),
                (this._illuminanceLDR = OU && OU()),
                (this._shadowEnabled = IU && IU()),
                (this._shadowPcf = wU && wU()),
                (this._shadowBias = RU && RU()),
                (this._shadowNormalBias = DU && DU()),
                (this._shadowSaturation = xU && xU()),
                (this._shadowDistance = MU && MU()),
                (this._shadowInvisibleOcclusionRange = PU && PU()),
                (this._csmLevel = NU && NU()),
                (this._csmLayerLambda = LU && LU()),
                (this._csmOptimizationMode = BU && BU()),
                (this._csmAdvancedOptions = FU && FU()),
                (this._csmLayersTransition = UU && UU()),
                (this._csmTransitionRange = kU && kU()),
                (this._shadowFixedArea = zU && zU()),
                (this._shadowNear = HU && HU()),
                (this._shadowFar = GU && GU()),
                (this._shadowOrthoSize = VU && VU()),
                (this._lightType = Rg),
                ge.querySettings(fe.Category.RENDERING, "highQualityMode") &&
                  ((this._shadowPcf = zg.SOFT_2X),
                  (this._shadowDistance = 50),
                  (this.enableCSM = !0),
                  (this.staticSettings.castShadow = !0));
            }
            _createLight() {
              if (
                (super._createLight(),
                (this._type = Og.DIRECTIONAL),
                this._light)
              ) {
                const t = this._light;
                (t.illuminanceHDR = this._illuminanceHDR),
                  (t.illuminanceLDR = this._illuminanceLDR),
                  (t.shadowEnabled = this._shadowEnabled),
                  (t.shadowPcf = this._shadowPcf),
                  (t.shadowBias = this._shadowBias),
                  (t.shadowNormalBias = this._shadowNormalBias),
                  (t.shadowSaturation = this._shadowSaturation),
                  (t.shadowDistance = this._shadowDistance),
                  (t.shadowInvisibleOcclusionRange =
                    this._shadowInvisibleOcclusionRange),
                  (t.shadowFixedArea = this._shadowFixedArea),
                  (t.shadowNear = this._shadowNear),
                  (t.shadowFar = this._shadowFar),
                  (t.shadowOrthoSize = this._shadowOrthoSize),
                  (t.csmLevel = this._csmLevel),
                  (t.csmLayerLambda = this._csmLayerLambda),
                  (t.csmOptimizationMode = this._csmOptimizationMode),
                  (t.csmLayersTransition = this._csmLayersTransition),
                  (t.csmTransitionRange = this._csmTransitionRange);
              }
            }
            _onUpdateReceiveDirLight() {
              if (!this._light) return;
              super._onUpdateReceiveDirLight();
              const t = this.node.scene;
              if (!t || !t.renderScene) return;
              if (t.renderScene.mainLight !== this._light) return;
              const e = t.renderScene.models;
              for (let t = 0; t < e.length; t++) {
                const i = e[t];
                if (!i.node) continue;
                const s = i.node.getComponent(dF);
                s && s.onUpdateReceiveDirLight(this._visibility);
              }
            }
          }),
          (CU = fa(AU.prototype, "_illuminanceHDR", [YU, kF], function () {
            return 65e3;
          })),
          (OU = fa(AU.prototype, "_illuminanceLDR", [KU], function () {
            return 65e3 * dg.standardExposureValue;
          })),
          (IU = fa(AU.prototype, "_shadowEnabled", [KU], function () {
            return !1;
          })),
          (wU = fa(AU.prototype, "_shadowPcf", [KU], function () {
            return zg.HARD;
          })),
          (RU = fa(AU.prototype, "_shadowBias", [KU], function () {
            return 1e-5;
          })),
          (DU = fa(AU.prototype, "_shadowNormalBias", [KU], function () {
            return 0;
          })),
          (xU = fa(AU.prototype, "_shadowSaturation", [KU], function () {
            return 1;
          })),
          (MU = fa(AU.prototype, "_shadowDistance", [KU], function () {
            return 50;
          })),
          (PU = fa(
            AU.prototype,
            "_shadowInvisibleOcclusionRange",
            [KU],
            function () {
              return 200;
            }
          )),
          (NU = fa(AU.prototype, "_csmLevel", [KU], function () {
            return Hg.LEVEL_4;
          })),
          (LU = fa(AU.prototype, "_csmLayerLambda", [KU], function () {
            return 0.75;
          })),
          (BU = fa(AU.prototype, "_csmOptimizationMode", [KU], function () {
            return Gg.RemoveDuplicates;
          })),
          (FU = fa(AU.prototype, "_csmAdvancedOptions", [KU], function () {
            return !1;
          })),
          (UU = fa(AU.prototype, "_csmLayersTransition", [KU], function () {
            return !1;
          })),
          (kU = fa(AU.prototype, "_csmTransitionRange", [KU], function () {
            return 0.05;
          })),
          (zU = fa(AU.prototype, "_shadowFixedArea", [KU], function () {
            return !1;
          })),
          (HU = fa(AU.prototype, "_shadowNear", [KU], function () {
            return 0.1;
          })),
          (GU = fa(AU.prototype, "_shadowFar", [KU], function () {
            return 10;
          })),
          (VU = fa(AU.prototype, "_shadowOrthoSize", [KU], function () {
            return 5;
          })),
          s(
            AU.prototype,
            "illuminance",
            [zF],
            Object.getOwnPropertyDescriptor(AU.prototype, "illuminance"),
            AU.prototype
          ),
          s(
            AU.prototype,
            "shadowEnabled",
            [HF, GF],
            Object.getOwnPropertyDescriptor(AU.prototype, "shadowEnabled"),
            AU.prototype
          ),
          s(
            AU.prototype,
            "shadowPcf",
            [VF, jF],
            Object.getOwnPropertyDescriptor(AU.prototype, "shadowPcf"),
            AU.prototype
          ),
          s(
            AU.prototype,
            "shadowBias",
            [WF, XF],
            Object.getOwnPropertyDescriptor(AU.prototype, "shadowBias"),
            AU.prototype
          ),
          s(
            AU.prototype,
            "shadowNormalBias",
            [YF, KF],
            Object.getOwnPropertyDescriptor(AU.prototype, "shadowNormalBias"),
            AU.prototype
          ),
          s(
            AU.prototype,
            "shadowSaturation",
            [qF, $F],
            Object.getOwnPropertyDescriptor(AU.prototype, "shadowSaturation"),
            AU.prototype
          ),
          s(
            AU.prototype,
            "shadowDistance",
            [ZF, QF],
            Object.getOwnPropertyDescriptor(AU.prototype, "shadowDistance"),
            AU.prototype
          ),
          s(
            AU.prototype,
            "shadowInvisibleOcclusionRange",
            [JF, tU],
            Object.getOwnPropertyDescriptor(
              AU.prototype,
              "shadowInvisibleOcclusionRange"
            ),
            AU.prototype
          ),
          s(
            AU.prototype,
            "csmLevel",
            [eU, iU],
            Object.getOwnPropertyDescriptor(AU.prototype, "csmLevel"),
            AU.prototype
          ),
          s(
            AU.prototype,
            "enableCSM",
            [sU, nU],
            Object.getOwnPropertyDescriptor(AU.prototype, "enableCSM"),
            AU.prototype
          ),
          s(
            AU.prototype,
            "csmLayerLambda",
            [rU, aU],
            Object.getOwnPropertyDescriptor(AU.prototype, "csmLayerLambda"),
            AU.prototype
          ),
          s(
            AU.prototype,
            "csmOptimizationMode",
            [oU, hU],
            Object.getOwnPropertyDescriptor(
              AU.prototype,
              "csmOptimizationMode"
            ),
            AU.prototype
          ),
          s(
            AU.prototype,
            "shadowFixedArea",
            [lU, cU],
            Object.getOwnPropertyDescriptor(AU.prototype, "shadowFixedArea"),
            AU.prototype
          ),
          s(
            AU.prototype,
            "shadowNear",
            [uU, _U],
            Object.getOwnPropertyDescriptor(AU.prototype, "shadowNear"),
            AU.prototype
          ),
          s(
            AU.prototype,
            "shadowFar",
            [dU, pU],
            Object.getOwnPropertyDescriptor(AU.prototype, "shadowFar"),
            AU.prototype
          ),
          s(
            AU.prototype,
            "shadowOrthoSize",
            [mU, fU],
            Object.getOwnPropertyDescriptor(AU.prototype, "shadowOrthoSize"),
            AU.prototype
          ),
          s(
            AU.prototype,
            "csmAdvancedOptions",
            [gU, yU],
            Object.getOwnPropertyDescriptor(AU.prototype, "csmAdvancedOptions"),
            AU.prototype
          ),
          s(
            AU.prototype,
            "csmLayersTransition",
            [TU, SU],
            Object.getOwnPropertyDescriptor(
              AU.prototype,
              "csmLayersTransition"
            ),
            AU.prototype
          ),
          s(
            AU.prototype,
            "csmTransitionRange",
            [EU, vU],
            Object.getOwnPropertyDescriptor(AU.prototype, "csmTransitionRange"),
            AU.prototype
          ),
          (bU = AU))
        ) || bU);
      var nk, rk, ak, ok, hk, lk, ck, uk, _k, dk, pk, mk, fk, gk;
      t({ DirectionalLight: sk, DirectionalLightComponent: sk });
      let yk =
        ((nk = Ca("cc.SphereLight")),
        (rk = La("_luminance")),
        (ak = ao(ke)),
        (ok = ao(ke)),
        (hk = ao(LF)),
        (lk = ao(ze)),
        (ck = ao(ze)),
        nk(
          ((_k = class extends FF {
            get luminousFlux() {
              return a.director.root.pipeline.pipelineSceneData.isHDR
                ? this._luminanceHDR * Ig(this._size)
                : this._luminanceLDR;
            }
            set luminousFlux(t) {
              let e = 0;
              a.director.root.pipeline.pipelineSceneData.isHDR
                ? ((this._luminanceHDR = t / Ig(this._size)),
                  (e = this._luminanceHDR))
                : ((this._luminanceLDR = t), (e = this._luminanceLDR)),
                this._light && (this._light.luminance = e);
            }
            get luminance() {
              return a.director.root.pipeline.pipelineSceneData.isHDR
                ? this._luminanceHDR
                : this._luminanceLDR;
            }
            set luminance(t) {
              a.director.root.pipeline.pipelineSceneData.isHDR
                ? ((this._luminanceHDR = t),
                  this._light &&
                    (this._light.luminanceHDR = this._luminanceHDR))
                : ((this._luminanceLDR = t),
                  this._light &&
                    (this._light.luminanceLDR = this._luminanceLDR));
            }
            get term() {
              return this._term;
            }
            set term(t) {
              this._term = t;
            }
            get size() {
              return this._size;
            }
            set size(t) {
              (this._size = t), this._light && (this._light.size = t);
            }
            get range() {
              return this._range;
            }
            set range(t) {
              (this._range = t), this._light && (this._light.range = t);
            }
            constructor() {
              super(),
                (this._size = dk && dk()),
                (this._luminanceHDR = pk && pk()),
                (this._luminanceLDR = mk && mk()),
                (this._term = fk && fk()),
                (this._range = gk && gk()),
                (this._lightType = xg);
            }
            _createLight() {
              super._createLight(),
                (this._type = Og.SPHERE),
                (this.size = this._size),
                (this.range = this._range),
                this._light &&
                  ((this._light.luminanceHDR = this._luminanceHDR),
                  (this._light.luminanceLDR = this._luminanceLDR));
            }
          }),
          (dk = fa(_k.prototype, "_size", [Na], function () {
            return 0.15;
          })),
          (pk = fa(_k.prototype, "_luminanceHDR", [Na, rk], function () {
            return 1700 / Ig(0.15);
          })),
          (mk = fa(_k.prototype, "_luminanceLDR", [Na], function () {
            return (
              (1700 / Ig(0.15)) *
              dg.standardExposureValue *
              dg.standardLightMeterScale
            );
          })),
          (fk = fa(_k.prototype, "_term", [Na], function () {
            return LF.LUMINOUS_FLUX;
          })),
          (gk = fa(_k.prototype, "_range", [Na], function () {
            return 1;
          })),
          s(
            _k.prototype,
            "luminousFlux",
            [ak],
            Object.getOwnPropertyDescriptor(_k.prototype, "luminousFlux"),
            _k.prototype
          ),
          s(
            _k.prototype,
            "luminance",
            [ok],
            Object.getOwnPropertyDescriptor(_k.prototype, "luminance"),
            _k.prototype
          ),
          s(
            _k.prototype,
            "term",
            [hk],
            Object.getOwnPropertyDescriptor(_k.prototype, "term"),
            _k.prototype
          ),
          s(
            _k.prototype,
            "size",
            [lk],
            Object.getOwnPropertyDescriptor(_k.prototype, "size"),
            _k.prototype
          ),
          s(
            _k.prototype,
            "range",
            [ck],
            Object.getOwnPropertyDescriptor(_k.prototype, "range"),
            _k.prototype
          ),
          (uk = _k))
        ) || uk);
      var Tk,
        Sk,
        Ek,
        vk,
        bk,
        Ak,
        Ck,
        Ok,
        Ik,
        wk,
        Rk,
        Dk,
        xk,
        Mk,
        Pk,
        Nk,
        Lk,
        Bk,
        Fk,
        Uk,
        kk,
        zk,
        Hk,
        Gk,
        Vk;
      t({ SphereLight: yk, SphereLightComponent: yk });
      const {
        ccclass: jk,
        range: Wk,
        slide: Xk,
        type: Yk,
        editable: Kk,
        displayOrder: qk,
        help: $k,
        executeInEditMode: Zk,
        menu: Qk,
        tooltip: Jk,
        serializable: tz,
        formerlySerializedAs: ez,
        visible: iz,
        property: sz,
      } = go;
      let nz =
        ((Tk = jk("cc.SpotLight")),
        (Sk = ez("_luminance")),
        (Ek = Yk(LF)),
        (vk = Yk(ze)),
        (bk = sz({
          group: { name: "DynamicShadowSettings", displayOrder: 1 },
        })),
        (Ak = Yk(He)),
        (Ck = sz({
          group: { name: "DynamicShadowSettings", displayOrder: 2 },
        })),
        (Ok = Yk(zg)),
        (Ik = sz({
          group: { name: "DynamicShadowSettings", displayOrder: 3 },
        })),
        (wk = Yk(ze)),
        (Rk = sz({
          group: { name: "DynamicShadowSettings", displayOrder: 4 },
        })),
        (Dk = Yk(ze)),
        Tk(
          ((Mk = class extends FF {
            get luminousFlux() {
              return a.director.root.pipeline.pipelineSceneData.isHDR
                ? this._luminanceHDR * Ig(this._size)
                : this._luminanceLDR;
            }
            set luminousFlux(t) {
              let e = 0;
              a.director.root.pipeline.pipelineSceneData.isHDR
                ? ((this._luminanceHDR = t / Ig(this._size)),
                  (e = this._luminanceHDR))
                : ((this._luminanceLDR = t), (e = this._luminanceLDR)),
                this._light && (this._light.luminance = e);
            }
            get luminance() {
              return a.director.root.pipeline.pipelineSceneData.isHDR
                ? this._luminanceHDR
                : this._luminanceLDR;
            }
            set luminance(t) {
              a.director.root.pipeline.pipelineSceneData.isHDR
                ? ((this._luminanceHDR = t),
                  this._light &&
                    (this._light.luminanceHDR = this._luminanceHDR))
                : ((this._luminanceLDR = t),
                  this._light &&
                    (this._light.luminanceLDR = this._luminanceLDR));
            }
            get term() {
              return this._term;
            }
            set term(t) {
              this._term = t;
            }
            get size() {
              return this._size;
            }
            set size(t) {
              (this._size = t), this._light && (this._light.size = t);
            }
            get range() {
              return this._range;
            }
            set range(t) {
              (this._range = t), this._light && (this._light.range = t);
            }
            get spotAngle() {
              return this._spotAngle;
            }
            set spotAngle(t) {
              (this._spotAngle = t),
                this._light && (this._light.spotAngle = bi(t));
            }
            get angleAttenuationStrength() {
              return this._angleAttenuationStrength;
            }
            set angleAttenuationStrength(t) {
              (this._angleAttenuationStrength = t),
                this._light && (this._light.angleAttenuationStrength = t);
            }
            get shadowEnabled() {
              return this._shadowEnabled;
            }
            set shadowEnabled(t) {
              (this._shadowEnabled = t),
                this._light && (this._light.shadowEnabled = t);
            }
            get shadowPcf() {
              return this._shadowPcf;
            }
            set shadowPcf(t) {
              (this._shadowPcf = t), this._light && (this._light.shadowPcf = t);
            }
            get shadowBias() {
              return this._shadowBias;
            }
            set shadowBias(t) {
              (this._shadowBias = t),
                this._light && (this._light.shadowBias = t);
            }
            get shadowNormalBias() {
              return this._shadowNormalBias;
            }
            set shadowNormalBias(t) {
              (this._shadowNormalBias = t),
                this._light && (this._light.shadowNormalBias = t);
            }
            constructor() {
              super(),
                (this._size = Pk && Pk()),
                (this._luminanceHDR = Nk && Nk()),
                (this._luminanceLDR = Lk && Lk()),
                (this._term = Bk && Bk()),
                (this._range = Fk && Fk()),
                (this._spotAngle = Uk && Uk()),
                (this._angleAttenuationStrength = kk && kk()),
                (this._shadowEnabled = zk && zk()),
                (this._shadowPcf = Hk && Hk()),
                (this._shadowBias = Gk && Gk()),
                (this._shadowNormalBias = Vk && Vk()),
                (this._lightType = Dg);
            }
            _createLight() {
              if (
                (super._createLight(),
                (this._type = Og.SPOT),
                (this.size = this._size),
                (this.range = this._range),
                (this.spotAngle = this._spotAngle),
                (this.angleAttenuationStrength =
                  this._angleAttenuationStrength),
                this._light)
              ) {
                const t = this._light;
                (t.luminanceHDR = this._luminanceHDR),
                  (t.luminanceLDR = this._luminanceLDR),
                  (t.shadowEnabled = this._shadowEnabled),
                  (t.shadowPcf = this._shadowPcf),
                  (t.shadowBias = this._shadowBias),
                  (t.shadowNormalBias = this._shadowNormalBias);
              }
            }
          }),
          (Pk = fa(Mk.prototype, "_size", [tz], function () {
            return 0.15;
          })),
          (Nk = fa(Mk.prototype, "_luminanceHDR", [tz, Sk], function () {
            return 1700 / Ig(0.15);
          })),
          (Lk = fa(Mk.prototype, "_luminanceLDR", [tz], function () {
            return (
              (1700 / Ig(0.15)) *
              dg.standardExposureValue *
              dg.standardLightMeterScale
            );
          })),
          (Bk = fa(Mk.prototype, "_term", [tz], function () {
            return LF.LUMINOUS_FLUX;
          })),
          (Fk = fa(Mk.prototype, "_range", [tz], function () {
            return 1;
          })),
          (Uk = fa(Mk.prototype, "_spotAngle", [tz], function () {
            return 60;
          })),
          (kk = fa(
            Mk.prototype,
            "_angleAttenuationStrength",
            [tz],
            function () {
              return 0;
            }
          )),
          (zk = fa(Mk.prototype, "_shadowEnabled", [tz], function () {
            return !1;
          })),
          (Hk = fa(Mk.prototype, "_shadowPcf", [tz], function () {
            return zg.HARD;
          })),
          (Gk = fa(Mk.prototype, "_shadowBias", [tz], function () {
            return 1e-5;
          })),
          (Vk = fa(Mk.prototype, "_shadowNormalBias", [tz], function () {
            return 0;
          })),
          s(
            Mk.prototype,
            "term",
            [Ek],
            Object.getOwnPropertyDescriptor(Mk.prototype, "term"),
            Mk.prototype
          ),
          s(
            Mk.prototype,
            "size",
            [vk],
            Object.getOwnPropertyDescriptor(Mk.prototype, "size"),
            Mk.prototype
          ),
          s(
            Mk.prototype,
            "shadowEnabled",
            [bk, Ak],
            Object.getOwnPropertyDescriptor(Mk.prototype, "shadowEnabled"),
            Mk.prototype
          ),
          s(
            Mk.prototype,
            "shadowPcf",
            [Ck, Ok],
            Object.getOwnPropertyDescriptor(Mk.prototype, "shadowPcf"),
            Mk.prototype
          ),
          s(
            Mk.prototype,
            "shadowBias",
            [Ik, wk],
            Object.getOwnPropertyDescriptor(Mk.prototype, "shadowBias"),
            Mk.prototype
          ),
          s(
            Mk.prototype,
            "shadowNormalBias",
            [Rk, Dk],
            Object.getOwnPropertyDescriptor(Mk.prototype, "shadowNormalBias"),
            Mk.prototype
          ),
          (xk = Mk))
        ) || xk);
      var rz,
        az,
        oz,
        hz,
        lz,
        cz,
        uz,
        _z,
        dz,
        pz,
        mz,
        fz,
        gz,
        yz,
        Tz,
        Sz,
        Ez,
        vz,
        bz;
      t({ SpotLight: nz, SpotLightComponent: nz }),
        t(
          "PointLight",
          ((rz = Ca("cc.PointLight")),
          (az = La("_luminance")),
          (oz = ao(ke)),
          (hz = ao(ke)),
          (lz = ao(LF)),
          (cz = ao(ze)),
          rz(
            ((_z = class extends FF {
              get luminousFlux() {
                return a.director.root.pipeline.pipelineSceneData.isHDR
                  ? this._luminanceHDR * Ig(1)
                  : this._luminanceLDR;
              }
              set luminousFlux(t) {
                let e = 0;
                a.director.root.pipeline.pipelineSceneData.isHDR
                  ? ((this._luminanceHDR = t / Ig(1)), (e = this._luminanceHDR))
                  : ((this._luminanceLDR = t), (e = this._luminanceLDR)),
                  this._light && (this._light.luminance = e);
              }
              get luminance() {
                return a.director.root.pipeline.pipelineSceneData.isHDR
                  ? this._luminanceHDR
                  : this._luminanceLDR;
              }
              set luminance(t) {
                a.director.root.pipeline.pipelineSceneData.isHDR
                  ? ((this._luminanceHDR = t),
                    this._light &&
                      (this._light.luminanceHDR = this._luminanceHDR))
                  : ((this._luminanceLDR = t),
                    this._light &&
                      (this._light.luminanceLDR = this._luminanceLDR));
              }
              get term() {
                return this._term;
              }
              set term(t) {
                this._term = t;
              }
              get range() {
                return this._range;
              }
              set range(t) {
                (this._range = t), this._light && (this._light.range = t);
              }
              constructor() {
                super(),
                  (this._luminanceHDR = dz && dz()),
                  (this._luminanceLDR = pz && pz()),
                  (this._term = mz && mz()),
                  (this._range = fz && fz()),
                  (this._lightType = Mg);
              }
              _createLight() {
                super._createLight(),
                  (this._type = Og.POINT),
                  (this.range = this._range),
                  this._light &&
                    ((this._light.luminanceHDR = this._luminanceHDR),
                    (this._light.luminanceLDR = this._luminanceLDR));
              }
            }),
            (dz = fa(_z.prototype, "_luminanceHDR", [Na, az], function () {
              return 1700 / Ig(0.15);
            })),
            (pz = fa(_z.prototype, "_luminanceLDR", [Na], function () {
              return (
                (1700 / Ig(0.15)) *
                dg.standardExposureValue *
                dg.standardLightMeterScale
              );
            })),
            (mz = fa(_z.prototype, "_term", [Na], function () {
              return LF.LUMINOUS_FLUX;
            })),
            (fz = fa(_z.prototype, "_range", [Na], function () {
              return 1;
            })),
            s(
              _z.prototype,
              "luminousFlux",
              [oz],
              Object.getOwnPropertyDescriptor(_z.prototype, "luminousFlux"),
              _z.prototype
            ),
            s(
              _z.prototype,
              "luminance",
              [hz],
              Object.getOwnPropertyDescriptor(_z.prototype, "luminance"),
              _z.prototype
            ),
            s(
              _z.prototype,
              "term",
              [lz],
              Object.getOwnPropertyDescriptor(_z.prototype, "term"),
              _z.prototype
            ),
            s(
              _z.prototype,
              "range",
              [cz],
              Object.getOwnPropertyDescriptor(_z.prototype, "range"),
              _z.prototype
            ),
            (uz = _z))
          ) || uz)
        ),
        t(
          "RangedDirectionalLight",
          ((gz = Ca("cc.RangedDirectionalLight")),
          (yz = La("_illuminance")),
          (Tz = ao(ke)),
          gz(
            ((Ez = class extends FF {
              get illuminance() {
                return a.director.root.pipeline.pipelineSceneData.isHDR
                  ? this._illuminanceHDR
                  : this._illuminanceLDR;
              }
              set illuminance(t) {
                a.director.root.pipeline.pipelineSceneData.isHDR
                  ? ((this._illuminanceHDR = t),
                    this._light &&
                      (this._light.illuminanceHDR = this._illuminanceHDR))
                  : ((this._illuminanceLDR = t),
                    this._light &&
                      (this._light.illuminanceLDR = this._illuminanceLDR));
              }
              constructor() {
                super(),
                  (this._illuminanceHDR = vz && vz()),
                  (this._illuminanceLDR = bz && bz()),
                  (this._lightType = Pg);
              }
              _createLight() {
                super._createLight(),
                  (this._type = Og.RANGED_DIRECTIONAL),
                  this._light &&
                    ((this._light.illuminanceHDR = this._illuminanceHDR),
                    (this._light.illuminanceLDR = this._illuminanceLDR));
              }
            }),
            (vz = fa(Ez.prototype, "_illuminanceHDR", [Ra, yz], function () {
              return 65e3;
            })),
            (bz = fa(Ez.prototype, "_illuminanceLDR", [Na], function () {
              return 65e3 * dg.standardExposureValue;
            })),
            s(
              Ez.prototype,
              "illuminance",
              [Tz],
              Object.getOwnPropertyDescriptor(Ez.prototype, "illuminance"),
              Ez.prototype
            ),
            (Sz = Ez))
          ) || Sz)
        ),
        (a.LightComponent = FF),
        Vt(FF, "cc.LightComponent"),
        (a.DirectionalLightComponent = sk),
        Vt(sk, "cc.DirectionalLightComponent"),
        (a.SphereLightComponent = yk),
        Vt(yk, "cc.SphereLightComponent"),
        (a.SpotLightComponent = nz),
        Vt(nz, "cc.SpotLightComponent"),
        $(nz.prototype, "SpotLight.prototype", [
          {
            name: "luminousPower",
            newName: "luminousFlux",
            customGetter() {
              return this.luminousFlux;
            },
            customSetter(t) {
              this.luminousFlux = t;
            },
          },
        ]),
        $(yk.prototype, "SphereLight.prototype", [
          {
            name: "luminousPower",
            newName: "luminousFlux",
            customGetter() {
              return this.luminousFlux;
            },
            customSetter(t) {
              this.luminousFlux = t;
            },
          },
        ]),
        $(FF.PhotometricTerm, "Light.PhotometricTerm", [
          { name: "LUMINOUS_POWER", newName: "LUMINOUS_FLUX" },
        ]);
      const Az = jsb.SkinningModel;
      a.SkinningModel = jsb.SkinningModel;
      const Cz = jsb.BakedSkinningModel;
      (a.BakedSkinningModel = jsb.BakedSkinningModel), jsb.MorphModel;
      const Oz = Cz.prototype;
      Oz._ctor = function () {
        jsb.Model.prototype._ctor.call(this),
          (this.uploadedAnim = void 0),
          (this._dataPoolManager = a.director.root.dataPoolManager);
        const t = new Float32Array(4),
          e = this._dataPoolManager.jointAnimationInfo.getData();
        (this._jointsMedium = {
          buffer: null,
          jointTextureInfo: t,
          animInfo: e,
          texture: null,
          boundsInfo: null,
        }),
          (this._skeleton = null),
          (this._mesh = null);
      };
      const Iz = Oz.destroy;
      Oz.destroy = function () {
        (this.uploadedAnim = void 0),
          (this._jointsMedium.boundsInfo = null),
          this._applyJointTexture(),
          Iz.call(this);
      };
      const wz = Oz.bindSkeleton;
      var Rz, Dz, xz, Mz, Pz, Nz, Lz, Bz, Fz, Uz;
      (Oz.bindSkeleton = function (t = null, e = null, i = null) {
        if (((this._skeleton = t), (this._mesh = i), !t || !e || !i)) return;
        this.transform = e;
        const s = this._dataPoolManager;
        this._jointsMedium.animInfo = s.jointAnimationInfo.getData(e.uuid);
        const n = this._jointsMedium.animInfo;
        this.syncAnimInfoForJS(n.buffer, n.data, n.dirtyForJSB),
          wz.apply(this, arguments);
      }),
        (Oz.uploadAnimation = function (t) {
          var e;
          if (!this._skeleton || !this._mesh || this.uploadedAnim === t) return;
          (this.uploadedAnim = t), this.setUploadedAnimForJS(!!t);
          const i = this._dataPoolManager;
          let s = null,
            n = null;
          t
            ? ((s = i.jointTexturePool.getSequencePoseTexture(
                this._skeleton,
                t,
                this._mesh,
                this.transform
              )),
              (this._jointsMedium.boundsInfo =
                s && s.bounds.get(this._mesh.hash)),
              (n = null))
            : ((s = i.jointTexturePool.getDefaultPoseTexture(
                this._skeleton,
                this._mesh,
                this.transform
              )),
              (this._jointsMedium.boundsInfo = null),
              (n = s && s.bounds.get(this._mesh.hash)[0])),
            this._applyJointTexture(s);
          const { jointTextureInfo: r } = this._jointsMedium,
            a = null === (e = s) || void 0 === e ? void 0 : e.handle.texture;
          this.syncDataForJS(
            this._jointsMedium.boundsInfo,
            n,
            r[0],
            r[1],
            r[2],
            r[3],
            a,
            this._jointsMedium.animInfo.data
          );
        }),
        (Oz._applyJointTexture = function (t = null) {
          const e = this._jointsMedium.texture;
          if (
            (e &&
              e !== t &&
              this._dataPoolManager.jointTexturePool.releaseHandle(e),
            (this._jointsMedium.texture = t),
            !t)
          )
            return;
          const { jointTextureInfo: i } = this._jointsMedium;
          (i[0] = t.handle.texture.width),
            (i[1] = this._skeleton.joints.length),
            (i[2] = t.pixelOffset + 0.1),
            (i[3] = 1 / i[0]);
        });
      let kz =
        ((Rz = Ca("cc.SkinnedMeshRenderer")),
        (Dz = Ia(100)),
        (xz = ao(mF)),
        (Mz = ao(Pf)),
        (Pz = ao(mF)),
        (Nz = ao(Pf)),
        Rz(
          (Lz =
            Dz(
              ((Bz = class extends dF {
                get skeleton() {
                  return this._skeleton;
                }
                set skeleton(t) {
                  t !== this._skeleton &&
                    ((this._skeleton = t), this._update());
                }
                get skinningRoot() {
                  return this._skinningRoot;
                }
                set skinningRoot(t) {
                  t !== this._skinningRoot &&
                    ((this._skinningRoot = t),
                    this._tryBindAnimation(),
                    this._update());
                }
                get model() {
                  return this._model;
                }
                constructor() {
                  super(),
                    (this._skeleton = Fz && Fz()),
                    (this._skinningRoot = Uz && Uz()),
                    (this._clip = null),
                    (this.associatedAnimation = null),
                    (this._modelType = Cz);
                }
                onLoad() {
                  super.onLoad(), this._tryBindAnimation();
                }
                onDestroy() {
                  this.associatedAnimation &&
                    (this.associatedAnimation.notifySkinnedMeshRemoved(this),
                    this.associatedAnimation),
                    super.onDestroy();
                }
                uploadAnimation(t) {
                  (this._clip = t),
                    this.model &&
                      this.model.uploadAnimation &&
                      this.model.uploadAnimation(t);
                }
                setUseBakedAnimation(t = !0, e = !1) {
                  const i = t ? Cz : Az;
                  (e || this._modelType !== i) &&
                    ((this._modelType = i),
                    this._model &&
                      (a.director.root.destroyModel(this._model),
                      (this._model = null),
                      (this._models.length = 0),
                      this._updateModels(),
                      this._updateCastShadow(),
                      this._updateReceiveShadow(),
                      this._updateUseLightProbe(),
                      this.enabledInHierarchy && this._attachToScene()));
                }
                setSharedMaterial(t, e) {
                  super.setSharedMaterial(t, e),
                    this._modelType === Az && this.getMaterialInstance(e);
                }
                _updateModelParams() {
                  this._update(), super._updateModelParams();
                }
                _tryBindAnimation() {
                  const { _skinningRoot: t } = this;
                  if (!t) return;
                  let e = !1;
                  for (let i = this.node; i; i = i.parent)
                    if (i === t) {
                      e = !0;
                      break;
                    }
                  if (!e) return;
                  const i = t.getComponent("cc.SkeletalAnimation");
                  i && i.enabledInHierarchy
                    ? i.notifySkinnedMeshAdded(this)
                    : this.setUseBakedAnimation(!1);
                }
                _update() {
                  this.model &&
                    (this.model.bindSkeleton(
                      this._skeleton,
                      this._skinningRoot,
                      this._mesh
                    ),
                    this.model.uploadAnimation &&
                      this.model.uploadAnimation(this._clip));
                }
              }),
              (Fz = fa(Bz.prototype, "_skeleton", [xz], function () {
                return null;
              })),
              (Uz = fa(Bz.prototype, "_skinningRoot", [Mz], function () {
                return null;
              })),
              s(
                Bz.prototype,
                "skeleton",
                [Pz],
                Object.getOwnPropertyDescriptor(Bz.prototype, "skeleton"),
                Bz.prototype
              ),
              s(
                Bz.prototype,
                "skinningRoot",
                [Nz],
                Object.getOwnPropertyDescriptor(Bz.prototype, "skinningRoot"),
                Bz.prototype
              ),
              (Lz = Bz))
            ) || Lz)
        ) || Lz);
      t({ SkinnedMeshRenderer: kz, SkinningModelComponent: kz });
      const zz = new ms();
      function Hz(t, e, i) {
        for (ms.identity(i); t !== e; )
          ms.fromRTS(zz, t.rotation, t.position, t.scale),
            ms.multiply(i, zz, i),
            (t = t.parent);
        return i;
      }
      var Gz,
        Vz,
        jz,
        Wz,
        Xz,
        Yz,
        Kz,
        qz,
        $z,
        Zz,
        Qz,
        Jz,
        tH,
        eH,
        iH,
        sH,
        nH,
        rH,
        aH,
        oH,
        hH,
        lH;
      const cH = new Lu(eu.ATTR_BATCH_ID, fc.R32F),
        uH = new Lu(eu.ATTR_BATCH_UV, fc.RG32F),
        _H = a_[cH.format].size + a_[uH.format].size;
      let dH =
        ((Gz = Ca("cc.SkinnedMeshUnit")),
        (Vz = ao(sB)),
        (jz = ao(mF)),
        (Wz = ao(ey)),
        (Xz = ao(kz)),
        Gz(
          ((Kz = class {
            constructor() {
              (this.mesh = qz && qz()),
                (this.skeleton = $z && $z()),
                (this.material = Zz && Zz()),
                (this._localTransform = Qz && Qz()),
                (this._offset = Jz && Jz()),
                (this._size = tH && tH());
            }
            set offset(t) {
              Ss.copy(this._offset, t);
            }
            get offset() {
              return this._offset;
            }
            set size(t) {
              Ss.copy(this._size, t);
            }
            get size() {
              return this._size;
            }
            set copyFrom(t) {
              t &&
                ((this.mesh = t.mesh),
                (this.skeleton = t.skeleton),
                (this.material = t.getSharedMaterial(0)),
                t.skinningRoot &&
                  Hz(t.node, t.skinningRoot, this._localTransform));
            }
            get copyFrom() {
              return null;
            }
          }),
          (qz = fa(Kz.prototype, "mesh", [Vz], function () {
            return null;
          })),
          ($z = fa(Kz.prototype, "skeleton", [jz], function () {
            return null;
          })),
          (Zz = fa(Kz.prototype, "material", [Wz], function () {
            return null;
          })),
          (Qz = fa(Kz.prototype, "_localTransform", [Na], function () {
            return new ms();
          })),
          (Jz = fa(Kz.prototype, "_offset", [Na], function () {
            return new Ss(0, 0);
          })),
          (tH = fa(Kz.prototype, "_size", [Na], function () {
            return new Ss(1, 1);
          })),
          s(
            Kz.prototype,
            "copyFrom",
            [Xz],
            Object.getOwnPropertyDescriptor(Kz.prototype, "copyFrom"),
            Kz.prototype
          ),
          (Yz = Kz))
        ) || Yz);
      t({ SkinnedMeshUnit: dH, SkinningModelUnit: dH });
      const pH = new ms();
      new ms();
      const mH = new Yi();
      let fH =
        ((eH = Ca("cc.SkinnedMeshBatchRenderer")),
        (iH = Ia(100)),
        (sH = ao([Ge])),
        (nH = ao([dH])),
        eH(
          (rH =
            iH(
              ((aH = class extends kz {
                constructor(...t) {
                  super(...t),
                    (this.atlasSize = oH && oH()),
                    (this.batchableTextureNames = hH && hH()),
                    (this.units = lH && lH()),
                    (this._textures = {}),
                    (this._batchMaterial = null);
                }
                get mesh() {
                  return super.mesh;
                }
                set mesh(t) {
                  super.mesh = t;
                }
                get skeleton() {
                  return super.skeleton;
                }
                set skeleton(t) {
                  super.skeleton = t;
                }
                onLoad() {
                  super.onLoad(), this.cook();
                }
                onDestroy() {
                  for (const t in this._textures) this._textures[t].destroy();
                  (this._textures = {}),
                    this._mesh && (this._mesh.destroy(), (this._mesh = null)),
                    super.onDestroy();
                }
                _onMaterialModified(t, e) {
                  this.cookMaterials(),
                    super._onMaterialModified(t, this.getMaterialInstance(t));
                }
                cook() {
                  this.cookMaterials(), this.cookSkeletons(), this.cookMeshes();
                }
                cookMaterials() {
                  this._batchMaterial ||
                    (this._batchMaterial = this.getSharedMaterial(0));
                  const t = this.getMaterialInstance(0);
                  if (
                    !t ||
                    !this._batchMaterial ||
                    !this._batchMaterial.effectAsset
                  )
                    return void w("incomplete batch material!");
                  t.copy(this._batchMaterial), this.resizeAtlases();
                  const e = t.effectAsset.techniques[t.technique];
                  for (let i = 0; i < e.passes.length; i++) {
                    const s = e.passes[i];
                    if (s.properties)
                      for (const e in s.properties)
                        if (s.properties[e].type >= yc.SAMPLER1D) {
                          let s = null;
                          this.batchableTextureNames.find((t) => t === e)
                            ? ((s = this._textures[e]),
                              s || (s = this.createTexture(e)),
                              this.cookTextures(s, e, i))
                            : this.units.some(
                                (t) =>
                                  (s =
                                    t.material && t.material.getProperty(e, i))
                              ),
                            s && t.setProperty(e, s, i);
                        } else {
                          const s = [];
                          for (let t = 0; t < this.units.length; t++) {
                            const n = this.units[t];
                            n.material &&
                              s.push(n.material.getProperty(e.slice(0, -3), i));
                          }
                          t.setProperty(e, s, i);
                        }
                  }
                }
                cookSkeletons() {
                  if (!this._skinningRoot)
                    return void w("no skinning root specified!");
                  const t = [],
                    e = [];
                  for (let i = 0; i < this.units.length; i++) {
                    const s = this.units[i];
                    if (!s || !s.skeleton) continue;
                    const n = s.skeleton;
                    ms.invert(pH, s._localTransform);
                    for (let i = 0; i < n.joints.length; i++) {
                      const s = n.joints[i];
                      t.findIndex((t) => t === s) >= 0 ||
                        (t.push(s),
                        e.push(
                          ms.multiply(
                            new ms(),
                            n.bindposes[i] || ms.IDENTITY,
                            pH
                          )
                        ));
                    }
                  }
                  const i = Array.from(Array(t.length).keys()).sort((e, i) =>
                      t[e] > t[i] ? 1 : t[e] < t[i] ? -1 : 0
                    ),
                    s = new mF();
                  (s.joints = t.map((t, e, s) => s[i[e]])),
                    (s.bindposes = e.map((t, e, s) => s[i[e]])),
                    this._skeleton && this._skeleton.destroy(),
                    (this.skeleton = s);
                }
                cookMeshes() {
                  let t = !1;
                  for (let e = 0; e < this.units.length; e++)
                    if (this.units[e].mesh) {
                      t = !0;
                      break;
                    }
                  if (!t || !this._skinningRoot) return;
                  this._mesh
                    ? this._mesh.destroyRenderingMesh()
                    : (this._mesh = new sB());
                  let e = 0,
                    i = fc.UNKNOWN,
                    s = 0,
                    n = fc.UNKNOWN,
                    r = 0,
                    a = fc.UNKNOWN,
                    o = 0,
                    h = fc.UNKNOWN,
                    l = 0,
                    c = fc.UNKNOWN;
                  const u = new Array(this.units.length),
                    _ = this.units.length;
                  for (let t = 0; t < _; t++) {
                    const e = this.units[t];
                    e &&
                      e.skeleton &&
                      (u[t] = e.skeleton.joints.map((t) =>
                        this._skeleton.joints.findIndex((e) => t === e)
                      ));
                  }
                  for (let t = 0; t < _; t++) {
                    const _ = this.units[t];
                    if (!_ || !_.mesh || !_.mesh.data) continue;
                    const d = this._createUnitMesh(t, _.mesh),
                      p = new DataView(d.data.buffer);
                    ms.invert(pH, _._localTransform), ms.transpose(pH, pH);
                    const { offset: m } = _,
                      { size: f } = _;
                    for (let g = 0; g < d.struct.vertexBundles.length; g++) {
                      const y = d.struct.vertexBundles[g];
                      (e = y.view.offset), (i = fc.UNKNOWN);
                      for (let t = 0; t < y.attributes.length; t++) {
                        const s = y.attributes[t];
                        if (s.name === eu.ATTR_POSITION) {
                          i = s.format;
                          break;
                        }
                        e += a_[s.format].size;
                      }
                      if (i) {
                        const t = JA(p, i, e, y.view.length, y.view.stride);
                        for (let e = 0; e < t.length; e += 3)
                          Yi.fromArray(mH, t, e),
                            Yi.transformMat4(mH, mH, _._localTransform),
                            Yi.toArray(t, mH, e);
                        QA(p, t, i, e, y.view.stride);
                      }
                      (s = y.view.offset), (n = fc.UNKNOWN);
                      for (let t = 0; t < y.attributes.length; t++) {
                        const e = y.attributes[t];
                        if (e.name === eu.ATTR_NORMAL) {
                          n = e.format;
                          break;
                        }
                        s += a_[e.format].size;
                      }
                      if (n) {
                        const t = JA(p, n, s, y.view.length, y.view.stride);
                        for (let e = 0; e < t.length; e += 3)
                          Yi.fromArray(mH, t, e),
                            Yi.transformMat4Normal(mH, mH, pH),
                            Yi.toArray(t, mH, e);
                        QA(p, t, n, s, y.view.stride);
                      }
                      (r = y.view.offset), (a = fc.UNKNOWN);
                      for (let t = 0; t < y.attributes.length; t++) {
                        const e = y.attributes[t];
                        if (e.name === eu.ATTR_TANGENT) {
                          a = e.format;
                          break;
                        }
                        r += a_[e.format].size;
                      }
                      if (a) {
                        const t = JA(p, a, r, y.view.length, y.view.stride);
                        for (let e = 0; e < t.length; e += 3)
                          Yi.fromArray(mH, t, e),
                            Yi.transformMat4Normal(mH, mH, pH),
                            Yi.toArray(t, mH, e);
                        QA(p, t, a, r, y.view.stride);
                      }
                      (o = y.view.offset), (h = fc.UNKNOWN);
                      for (let t = 0; t < y.attributes.length; t++) {
                        const e = y.attributes[t];
                        if (e.name === eu.ATTR_BATCH_UV) {
                          h = e.format;
                          break;
                        }
                        o += a_[e.format].size;
                      }
                      h &&
                        tC(
                          p,
                          (t, e) => {
                            var i;
                            const s = 0 === e ? "x" : "y";
                            return (t = (i = t) - Math.floor(i)) * f[s] + m[s];
                          },
                          h,
                          o,
                          y.view.length,
                          y.view.stride,
                          p
                        );
                      const T = u[t];
                      if (T) {
                        (l = y.view.offset), (c = fc.UNKNOWN);
                        for (let t = 0; t < y.attributes.length; t++) {
                          const e = y.attributes[t];
                          if (e.name === eu.ATTR_JOINTS) {
                            c = e.format;
                            break;
                          }
                          l += a_[e.format].size;
                        }
                        c &&
                          tC(
                            p,
                            (t) => T[t],
                            c,
                            l,
                            y.view.length,
                            y.view.stride,
                            p
                          );
                      }
                    }
                    this._mesh.merge(d);
                  }
                  this._onMeshChanged(this._mesh), this._updateModels();
                }
                cookTextures(t, e, i) {
                  const s = [],
                    n = [],
                    r = [],
                    o = [];
                  for (let t = 0; t < this.units.length; t++) {
                    const a = this.units[t];
                    if (!a.material) continue;
                    const h = a.material.getProperty(e, i);
                    if (h && h.image && h.image.data) {
                      const t = new _u();
                      (t.texOffset.x = a.offset.x * this.atlasSize),
                        (t.texOffset.y = a.offset.y * this.atlasSize),
                        (t.texExtent.width = a.size.x * this.atlasSize),
                        (t.texExtent.height = a.size.y * this.atlasSize);
                      const { data: e } = h.image;
                      ArrayBuffer.isView(e)
                        ? (r.push(e), o.push(t))
                        : (s.push(e), n.push(t));
                    }
                  }
                  const h = t.getGFXTexture(),
                    { device: l } = a.director.root;
                  r.length > 0 && l.copyBuffersToTexture(r, h, o),
                    s.length > 0 && l.copyTexImagesToTexture(s, h, n);
                }
                createTexture(t) {
                  const e = new sm();
                  return (
                    e.setFilters(Id.LINEAR, Id.LINEAR),
                    e.setMipFilter(Id.NEAREST),
                    e.reset({
                      width: this.atlasSize,
                      height: this.atlasSize,
                      format: Cd.RGBA8888,
                    }),
                    (this._textures[t] = e),
                    e
                  );
                }
                resizeAtlases() {
                  for (const t in this._textures)
                    this._textures[t].reset({
                      width: this.atlasSize,
                      height: this.atlasSize,
                      format: Cd.RGBA8888,
                    });
                }
                _createUnitMesh(t, e) {
                  const i = JSON.parse(JSON.stringify(e.struct)),
                    s = {};
                  for (let t = 0; t < e.struct.primitives.length; t++) {
                    const n = e.struct.primitives[t];
                    let r = 0,
                      a = fc.UNKNOWN,
                      o = 0;
                    for (; o < n.vertexBundelIndices.length; o++) {
                      const t =
                        e.struct.vertexBundles[n.vertexBundelIndices[o]];
                      (r = t.view.offset), (a = fc.UNKNOWN);
                      for (let e = 0; e < t.attributes.length; e++) {
                        const i = t.attributes[e];
                        if (i.name === eu.ATTR_TEX_COORD) {
                          a = i.format;
                          break;
                        }
                        r += a_[i.format].size;
                      }
                      if (a) break;
                    }
                    if (void 0 !== s[o]) continue;
                    s[o] = [a, r];
                    const h = i.vertexBundles[o];
                    h.attributes.push(cH),
                      h.attributes.push(uH),
                      (h.view.offset = 0),
                      (h.view.length += h.view.count * _H),
                      (h.view.stride += _H);
                  }
                  let n = 0;
                  for (let t = 0; t < i.vertexBundles.length; t++)
                    n += i.vertexBundles[t].view.length;
                  for (let t = 0; t < i.primitives.length; t++) {
                    const e = i.primitives[t];
                    e.indexView &&
                      ((e.indexView.offset = n), (n += e.indexView.length));
                  }
                  const r = new Uint8Array(n),
                    o = e.data,
                    h = new DataView(r.buffer),
                    l = new DataView(o.buffer),
                    { isLittleEndian: c } = a.sys;
                  for (const n in s) {
                    const a = i.vertexBundles[n],
                      u = e.struct.vertexBundles[n],
                      [_, d] = s[n],
                      p = JA(l, _, d, u.view.length, u.view.stride),
                      m = u.view,
                      f = a.view,
                      g = m.stride,
                      y = f.stride;
                    let T = m.offset,
                      S = f.offset;
                    for (let e = 0; e < f.count; e++) {
                      const i = o.subarray(T, T + g);
                      r.set(i, S),
                        h.setFloat32(S + g, t),
                        h.setFloat32(S + g + 4, p[2 * e], c),
                        h.setFloat32(S + g + 8, p[2 * e + 1], c),
                        (S += y),
                        (T += g);
                    }
                  }
                  for (let t = 0; t < i.primitives.length; t++) {
                    const s = e.struct.primitives[t],
                      n = i.primitives[t];
                    if (s.indexView && n.indexView) {
                      const t = s.indexView.stride,
                        e = n.indexView.stride;
                      let i = s.indexView.offset,
                        a = n.indexView.offset;
                      for (let s = 0; s < n.indexView.count; s++) {
                        const s = o.subarray(i, i + t);
                        r.set(s, a), (a += e), (i += t);
                      }
                    }
                  }
                  const u = new sB();
                  return u.reset({ struct: i, data: r }), u;
                }
              }),
              (oH = fa(aH.prototype, "atlasSize", [Na], function () {
                return 1024;
              })),
              (hH = fa(
                aH.prototype,
                "batchableTextureNames",
                [sH, Na],
                function () {
                  return [];
                }
              )),
              (lH = fa(aH.prototype, "units", [nH, Na], function () {
                return [];
              })),
              s(
                aH.prototype,
                "mesh",
                [oo],
                Object.getOwnPropertyDescriptor(aH.prototype, "mesh"),
                aH.prototype
              ),
              s(
                aH.prototype,
                "skeleton",
                [oo],
                Object.getOwnPropertyDescriptor(aH.prototype, "skeleton"),
                aH.prototype
              ),
              (rH = aH))
            ) || rH)
        ) || rH);
      var gH, yH, TH, SH, EH, vH, bH, AH, CH, OH, IH, wH, RH, DH, xH, MH, PH;
      t({ SkinnedMeshBatchRenderer: fH, BatchedSkinningModelComponent: fH }),
        (a.SkinningModelComponent = kz),
        Vt(kz, "cc.SkinningModelComponent"),
        (a.SkinningModelUnit = dH),
        Vt(dH, "cc.SkinningModelUnit"),
        (a.BatchedSkinningModelComponent = fH),
        Vt(fH, "cc.BatchedSkinningModelComponent");
      const NH = [0.25, 0.125, 0.01];
      let LH = t(
        "LOD",
        ((gH = Ca("cc.LOD")),
        (yH = ao([dF])),
        (TH = ao(ze)),
        (SH = ao([dF])),
        (EH = ao([ke])),
        gH(
          ((bH = class {
            constructor() {
              (this._screenUsagePercentage = AH && AH()),
                (this._renderers = CH && CH()),
                (this._LODData = new bg()),
                (this._modelAddedCallback = void 0),
                (this._LODData.screenUsagePercentage =
                  this._screenUsagePercentage),
                (this._modelAddedCallback = null);
            }
            get screenUsagePercentage() {
              return this._screenUsagePercentage;
            }
            set screenUsagePercentage(t) {
              (this._screenUsagePercentage = t),
                (this._LODData.screenUsagePercentage = t);
            }
            get renderers() {
              return this._renderers;
            }
            set renderers(t) {
              if (t === this._renderers) return;
              let e = !1;
              (this._renderers.length = 0), this._LODData.clearModels();
              for (let s = 0; s < t.length; s++) {
                var i;
                this._renderers[s] = t[s];
                const n =
                  null === (i = t[s]) || void 0 === i ? void 0 : i.model;
                n && ((e = !0), this._LODData.addModel(n));
              }
              this._modelAddedCallback && e && this._modelAddedCallback();
            }
            get triangleCount() {
              const t = [];
              return (
                this._renderers.forEach((e) => {
                  let i = 0;
                  if (e && e.mesh) {
                    const t = e.mesh.struct.primitives;
                    null == t ||
                      t.forEach((t) => {
                        t && t.indexView && (i += t.indexView.count);
                      });
                  }
                  t.push(i / 3);
                }),
                t
              );
            }
            get rendererCount() {
              return this._renderers.length;
            }
            get lodData() {
              return this._LODData;
            }
            set modelAddedCallback(t) {
              this._modelAddedCallback = t;
            }
            insertRenderer(t, e) {
              (t < 0 || t > this._renderers.length) &&
                (t = this._renderers.length),
                this._renderers.splice(t, 0, e);
              let i = !1;
              return (
                e.model && ((i = !0), this._LODData.addModel(e.model)),
                this._modelAddedCallback && i && this._modelAddedCallback(),
                e
              );
            }
            deleteRenderer(t) {
              var e;
              const i = this._renderers.splice(t, 1),
                s =
                  i.length > 0
                    ? null === (e = i[0]) || void 0 === e
                      ? void 0
                      : e.model
                    : null;
              return s && this._LODData.eraseModel(s), i[0];
            }
            getRenderer(t) {
              return this._renderers[t] || null;
            }
            setRenderer(t, e) {
              t < 0 || t >= this.rendererCount
                ? R("setRenderer to LOD error, index out of range")
                : (this.deleteRenderer(t), this.insertRenderer(t, e));
            }
          }),
          (AH = fa(bH.prototype, "_screenUsagePercentage", [Na], function () {
            return 1;
          })),
          (CH = fa(bH.prototype, "_renderers", [yH, Na], function () {
            return [];
          })),
          s(
            bH.prototype,
            "screenUsagePercentage",
            [TH],
            Object.getOwnPropertyDescriptor(
              bH.prototype,
              "screenUsagePercentage"
            ),
            bH.prototype
          ),
          s(
            bH.prototype,
            "renderers",
            [SH],
            Object.getOwnPropertyDescriptor(bH.prototype, "renderers"),
            bH.prototype
          ),
          s(
            bH.prototype,
            "triangleCount",
            [EH],
            Object.getOwnPropertyDescriptor(bH.prototype, "triangleCount"),
            bH.prototype
          ),
          (vH = bH))
        ) || vH)
      );
      t(
        "LODGroup",
        ((OH = Ca("cc.LODGroup")),
        (IH = ao(ze)),
        (wH = ao([LH])),
        OH(
          ((DH = class extends np {
            constructor() {
              super(),
                (this._localBoundaryCenter = xH && xH()),
                (this._objectSize = MH && MH()),
                (this._LODs = PH && PH()),
                (this._lodGroup = new Ag()),
                (this._eventRegistered = !1),
                (this._forceUsedLevels = []);
            }
            set localBoundaryCenter(t) {
              this._localBoundaryCenter.set(t),
                (this._lodGroup.localBoundaryCenter = t);
            }
            get localBoundaryCenter() {
              return this._localBoundaryCenter.clone();
            }
            get lodCount() {
              return this._LODs.length;
            }
            set objectSize(t) {
              (this._objectSize = t), (this._lodGroup.objectSize = t);
            }
            get objectSize() {
              return this._objectSize;
            }
            get LODs() {
              return this._LODs;
            }
            set LODs(t) {
              t !== this._LODs
                ? ((this._LODs.length = 0),
                  this.lodGroup.clearLODs(),
                  t.forEach((t, e) => {
                    this.lodGroup.insertLOD(e, t.lodData),
                      (this._LODs[e] = t),
                      (t.modelAddedCallback =
                        this.onLodModelAddedCallback.bind(this));
                  }),
                  this._updateDataToScene())
                : this._updateDataToScene();
            }
            get lodGroup() {
              return this._lodGroup;
            }
            onLodModelAddedCallback() {
              0 === this.objectSize && this.recalculateBounds();
            }
            insertLOD(t, e, i) {
              if (
                ((t < 0 || t > this.lodCount) && (t = this.lodCount),
                i || (i = new LH()),
                (i.modelAddedCallback =
                  this.onLodModelAddedCallback.bind(this)),
                !e)
              ) {
                const i = this.getLOD(t - 1),
                  s = this.getLOD(t);
                if (i && s)
                  e = (i.screenUsagePercentage + s.screenUsagePercentage) / 2;
                else if (i && !s)
                  (e = i.screenUsagePercentage / 2) > 0.01 && (e = 0.01);
                else if (s && !i) {
                  e = s.screenUsagePercentage;
                  const i = this.getLOD(t + 1);
                  s.screenUsagePercentage =
                    (e + (i ? i.screenUsagePercentage : 0)) / 2;
                } else e = NH[0];
              }
              return (
                (i.screenUsagePercentage = e),
                this._LODs.splice(t, 0, i),
                this._lodGroup.insertLOD(t, i.lodData),
                this._updateDataToScene(),
                this.node && this._emitChangeNode(this.node),
                i
              );
            }
            eraseLOD(t) {
              if (t < 0 || t >= this.lodCount)
                return w("eraseLOD error, index out of range"), null;
              const e = this._LODs[t];
              return e
                ? (this._LODs.splice(t, 1),
                  this._lodGroup.eraseLOD(t),
                  this._updateDataToScene(),
                  this._emitChangeNode(this.node),
                  e)
                : (w("eraseLOD error, LOD not exist at specified index."),
                  null);
            }
            getLOD(t) {
              return t < 0 || t >= this.lodCount
                ? (w("getLOD error, index out of range"), null)
                : this._LODs[t];
            }
            setLOD(t, e) {
              t < 0 || t >= this.lodCount
                ? w("setLOD error, index out of range")
                : ((this._LODs[t] = e),
                  (e.modelAddedCallback =
                    this.onLodModelAddedCallback.bind(this)),
                  this.lodGroup.updateLOD(t, e.lodData),
                  this._updateDataToScene());
            }
            recalculateBounds() {
              const t = new Yi(),
                e = new Yi();
              let i = null,
                s = new Yi();
              for (let a = 0; a < this.lodCount; ++a) {
                const o = this.getLOD(a);
                if (o)
                  for (let a = 0; a < o.rendererCount; ++a) {
                    var n, r;
                    const h = o.getRenderer(a);
                    if (!h) continue;
                    null === (n = h.model) ||
                      void 0 === n ||
                      n.updateWorldBound();
                    let l =
                      null === (r = h.model) || void 0 === r
                        ? void 0
                        : r.worldBounds;
                    if (l) {
                      {
                        const t = l.center,
                          e = l.halfExtents;
                        l = Kr.create(t.x, t.y, t.z, e.x, e.y, e.z);
                      }
                      l.getBoundary(t, e),
                        i
                          ? (Yi.min(i, i, t), Yi.max(s, s, e))
                          : ((i = t.clone()), (s = e.clone()));
                    }
                  }
              }
              if (i) {
                const t = i,
                  e = new Yi(
                    0.5 * (s.x + t.x),
                    0.5 * (s.y + t.y),
                    0.5 * (s.z + t.z)
                  ),
                  n = new Yi(
                    0.5 * (s.x - t.x),
                    0.5 * (s.y - t.y),
                    0.5 * (s.z - t.z)
                  ),
                  [r, a] = (function (t, e, i) {
                    let s, n;
                    const r = new Array(
                      new Yi(t.x - e.x, t.y - e.y, t.z - e.z),
                      new Yi(t.x - e.x, t.y + e.y, t.z - e.z),
                      new Yi(t.x + e.x, t.y + e.y, t.z - e.z),
                      new Yi(t.x + e.x, t.y - e.y, t.z - e.z),
                      new Yi(t.x - e.x, t.y - e.y, t.z + e.z),
                      new Yi(t.x - e.x, t.y + e.y, t.z + e.z),
                      new Yi(t.x + e.x, t.y + e.y, t.z + e.z),
                      new Yi(t.x + e.x, t.y - e.y, t.z + e.z)
                    );
                    (s = r[0].transformMat4(i)), (n = s.clone());
                    for (let t = 1; t < 8; ++t) {
                      const e = r[t].transformMat4(i);
                      (s = Yi.min(s, s, e)), (n = Yi.max(n, n, e));
                    }
                    return [s, n];
                  })(e, n, this.node.worldMatrix.clone().invert());
                e.set(0.5 * (a.x + r.x), 0.5 * (a.y + r.y), 0.5 * (a.z + r.z)),
                  n.set(
                    0.5 * (a.x - r.x),
                    0.5 * (a.y - r.y),
                    0.5 * (a.z - r.z)
                  ),
                  (this.localBoundaryCenter = e),
                  (this.objectSize = 2 * Math.max(n.x, n.y, n.z));
              } else
                (this.localBoundaryCenter = new Yi(0, 0, 0)),
                  (this.objectSize = 0);
              this._emitChangeNode(this.node);
            }
            resetObjectSize() {
              if (1 === this.objectSize) return;
              0 === this.objectSize && (this.objectSize = 1);
              const t = 1 / this.objectSize;
              this.objectSize = 1;
              for (let e = 0; e < this.lodCount; ++e) {
                const i = this.getLOD(e);
                i && (i.screenUsagePercentage *= t);
              }
              this._emitChangeNode(this.node);
            }
            forceLOD(t) {
              (this._forceUsedLevels = t < 0 ? [] : [t]),
                this.lodGroup.lockLODLevels(this._forceUsedLevels);
            }
            forceLODs(t) {}
            onLoad() {
              (this._lodGroup.node = this.node),
                (this._lodGroup.objectSize = this._objectSize),
                (this._lodGroup.localBoundaryCenter =
                  this._localBoundaryCenter),
                this._eventRegistered ||
                  (this.node.on(bf.COMPONENT_REMOVED, this._onRemove, this),
                  (this._eventRegistered = !0)),
                this._constructLOD();
            }
            _onRemove(t) {
              t === this && this.onDisable();
            }
            _constructLOD() {
              if (this.lodCount < 1) {
                const t = NH.length;
                for (let e = 0; e < t; e++) this.insertLOD(e, NH[e]);
              }
            }
            onRestore() {
              this._constructLOD(),
                this.enabledInHierarchy && this._attachToScene();
            }
            onEnable() {
              this._attachToScene(),
                0 === this.objectSize && this.recalculateBounds(),
                this.lodGroup.lockLODLevels(this._forceUsedLevels),
                this.lodCount > 0 &&
                  this._lodGroup.lodCount < 1 &&
                  this._LODs.forEach((t, e) => {
                    t.lodData.screenUsagePercentage = t.screenUsagePercentage;
                    const i = t.renderers;
                    if (null !== i && i.length > 0)
                      for (let e = 0; e < i.length; e++) {
                        const s = t.lodData,
                          n = i[e];
                        s && n && n.model && s.addModel(n.model);
                      }
                    this._lodGroup.insertLOD(e, t.lodData);
                  });
            }
            onDisable() {
              this._detachFromScene(), this.lodGroup.lockLODLevels([]);
            }
            _attachToScene() {
              if (this.node && this.node.scene) {
                const t = this._getRenderScene();
                this._lodGroup.scene && this._detachFromScene(),
                  t.addLODGroup(this._lodGroup);
              }
            }
            _detachFromScene() {
              this._lodGroup.scene &&
                this._lodGroup.scene.removeLODGroup(this._lodGroup);
            }
            _emitChangeNode(t) {}
            _updateDataToScene() {
              this._detachFromScene(), this._attachToScene();
            }
          }),
          (xH = fa(DH.prototype, "_localBoundaryCenter", [Na], function () {
            return new Yi(0, 0, 0);
          })),
          (MH = fa(DH.prototype, "_objectSize", [Na], function () {
            return 0;
          })),
          (PH = fa(DH.prototype, "_LODs", [Na], function () {
            return [];
          })),
          s(
            DH.prototype,
            "objectSize",
            [IH],
            Object.getOwnPropertyDescriptor(DH.prototype, "objectSize"),
            DH.prototype
          ),
          s(
            DH.prototype,
            "LODs",
            [wH],
            Object.getOwnPropertyDescriptor(DH.prototype, "LODs"),
            DH.prototype
          ),
          (RH = DH))
        ) || RH)
      );
      const BH = Rf.makeMaskExclude([
        Rf.BitMask.UI_2D,
        Rf.BitMask.UI_3D,
        Rf.BitMask.GIZMOS,
        Rf.BitMask.EDITOR,
        Rf.BitMask.SCENE_GIZMO,
        Rf.BitMask.PROFILER,
        Rf.Enum.IGNORE_RAYCAST,
      ]);
      class FH {
        constructor() {
          (this._probes = []),
            (this._useCubeModels = new Map()),
            (this._usePlanarModels = new Map()),
            (this._updateForRuntime = !0),
            (this._dataTexture = null),
            (this._registeredEvent = !1);
        }
        set updateForRuntime(t) {
          this._updateForRuntime = t;
        }
        get updateForRuntime() {
          return this._updateForRuntime;
        }
        registerEvent() {
          this._registeredEvent ||
            (a.director.on(
              a.Director.EVENT_BEFORE_UPDATE,
              this.onUpdateProbes,
              this
            ),
            (this._registeredEvent = !0));
        }
        onUpdateProbes() {
          if (0 === this._probes.length) return;
          const t = a.director.getScene();
          if (!t || !t.renderScene) return;
          const e = t.renderScene.models;
          for (let t = 0; t < e.length; t++) {
            const i = e[t];
            i.node &&
              i.node.layer & BH &&
              (i.reflectionProbeType === hB.BAKED_CUBEMAP ||
              this._isUsedBlending(i)
                ? this.selectReflectionProbe(i)
                : i.reflectionProbeType === hB.PLANAR_REFLECTION &&
                  this.selectPlanarReflectionProbe(i));
          }
        }
        filterModelsForPlanarReflection() {
          if (0 === this._probes.length) return;
          const t = a.director.getScene();
          if (!t || !t.renderScene) return;
          const e = t.renderScene.models;
          for (let t = 0; t < e.length; t++) {
            const i = e[t];
            i.node &&
              i.node.layer & BH &&
              i.reflectionProbeType === hB.PLANAR_REFLECTION &&
              this.selectPlanarReflectionProbe(i);
          }
        }
        clearPlanarReflectionMap(t) {
          for (const e of this._usePlanarModels.entries())
            e[1] === t && this._updatePlanarMapOfModel(e[0], null, null);
        }
        register(t) {
          -1 === this._probes.indexOf(t) &&
            (this._probes.push(t), this.updateProbeData());
        }
        unregister(t) {
          for (let e = 0; e < this._probes.length; e++)
            if (this._probes[e] === t) {
              const t = this._probes.splice(e, 1);
              t[0] && this._removeDependentModels(t[0]);
              break;
            }
          this.updateProbeData();
        }
        exists(t) {
          if (0 === this._probes.length) return !1;
          for (let e = 0; e < this._probes.length; e++)
            if (this._probes[e].getProbeId() === t) return !0;
          return !1;
        }
        getNewReflectionProbeId() {
          let t = 0;
          for (;;) {
            if (!this.exists(t)) return t;
            t++;
          }
        }
        getProbes() {
          return this._probes;
        }
        getProbeById(t) {
          for (let e = 0; e < this._probes.length; e++)
            if (this._probes[e].getProbeId() === t) return this._probes[e];
          return null;
        }
        clearAll() {
          this._probes = [];
        }
        getProbeByCamera(t) {
          for (let e = 0; e < this._probes.length; e++)
            if (this._probes[e].camera === t) return this._probes[e];
          return null;
        }
        updateBakedCubemap(t) {
          const e = this._getModelsByProbe(t);
          if (t.cubemap) {
            for (let i = 0; i < e.length; i++) {
              const s = e[i];
              this._updateCubemapOfModel(s, t);
            }
            if (((t.needRefresh = !1), 0 === e.length))
              for (const e of this._useCubeModels.entries())
                e[0].reflectionProbeBlendId === t.getProbeId() &&
                  this._updateBlendCubemap(e[0], t);
          }
        }
        updatePlanarMap(t, e) {
          if (!t.node || !t.node.scene) return;
          const i = this._getModelsByProbe(t);
          for (let s = 0; s < i.length; s++)
            this._updatePlanarMapOfModel(i[s], e, t);
          if (t.previewPlane) {
            const i = t.previewPlane.getComponent(dF);
            i && i.updateProbePlanarMap(e);
          }
        }
        selectPlanarReflectionProbe(t) {
          if (
            t.node &&
            t.worldBounds &&
            t.reflectionProbeType === hB.PLANAR_REFLECTION
          ) {
            for (let e = 0; e < this._probes.length; e++) {
              const i = this._probes[e];
              i.probeType === Eg.PLANAR &&
                t.node.layer & BH &&
                (t.updateWorldBound(),
                Bn.aabbWithAABB(t.worldBounds, i.boundingBox)
                  ? this._usePlanarModels.set(t, i)
                  : this._usePlanarModels.has(t) &&
                    this._usePlanarModels.get(t) === i &&
                    (this._usePlanarModels.delete(t),
                    this._updatePlanarMapOfModel(t, null, null)));
            }
            for (let t = 0; t < this._probes.length; t++)
              this._probes[t].probeType === Eg.PLANAR &&
                (this._probes[t].realtimePlanarTexture
                  ? this.updatePlanarMap(
                      this._probes[t],
                      this._probes[t].realtimePlanarTexture.getGFXTexture()
                    )
                  : this.updatePlanarMap(this._probes[t], null));
          }
        }
        selectReflectionProbe(t) {
          if (t.node && t.worldBounds && t.node.layer & BH) {
            t.updateWorldBound();
            const e = this._getNearestProbe(t);
            e
              ? this._useCubeModels.has(t)
                ? (this._useCubeModels.get(t) !== e &&
                    this._useCubeModels.set(t, e),
                  (e.needRefresh = !0))
                : (this._useCubeModels.set(t, e), (e.needRefresh = !0))
              : (this._updateCubemapOfModel(t, null),
                this._useCubeModels.delete(t));
          }
          for (let e = 0; e < this._probes.length; e++)
            ((this._probes[e].needRefresh &&
              this._probes[e].probeType === Eg.CUBE) ||
              this._isUsedBlending(t)) &&
              this.updateBakedCubemap(this._probes[e]);
        }
        updatePreviewSphere(t) {
          if (!t || !t.previewSphere) return;
          const e = t.previewSphere.getComponent(dF);
          e &&
            (e.updateProbeCubemap(t.cubemap),
            e.updateReflectionProbeId(t.getProbeId()));
        }
        updatePreviewPlane(t) {
          t &&
            t.previewPlane &&
            t.previewPlane.getComponent(dF) &&
            t.realtimePlanarTexture &&
            this.updatePlanarMap(t, t.realtimePlanarTexture.getGFXTexture());
        }
        updateProbeData() {
          if (0 === this._probes.length) return;
          const t = this.getMaxProbeId(),
            e = t + 1;
          this._dataTexture && this._dataTexture.destroy();
          const i = new Float32Array(12 * e);
          let s = 0;
          for (let e = 0; e <= t; e++) {
            const t = this.getProbeById(e);
            if (t) {
              if (t.probeType === Eg.CUBE) {
                (i[s] = t.node.worldPosition.x),
                  (i[s + 1] = t.node.worldPosition.y),
                  (i[s + 2] = t.node.worldPosition.z),
                  (i[s + 3] = 0),
                  (i[s + 4] = t.size.x),
                  (i[s + 5] = t.size.y),
                  (i[s + 6] = t.size.z),
                  (i[s + 7] = 0);
                const e = t.isRGBE() ? 1e3 : 0;
                i[s + 8] = t.cubemap ? t.cubemap.mipmapLevel + e : 1 + e;
              } else
                (i[s] = t.node.up.x),
                  (i[s + 1] = t.node.up.y),
                  (i[s + 2] = t.node.up.z),
                  (i[s + 3] = 1),
                  (i[s + 4] = 1),
                  (i[s + 5] = 1),
                  (i[s + 6] = 0),
                  (i[s + 7] = 0),
                  (i[s + 8] = 1);
              s += 12;
            } else s += 12;
          }
          const n = new Uint8Array(i.buffer),
            r = new wd({
              _data: n,
              _compressed: !1,
              width: 12,
              height: e,
              format: Cd.RGBA8888,
            });
          (this._dataTexture = new sm()),
            this._dataTexture.setFilters(sm.Filter.NONE, sm.Filter.NONE),
            this._dataTexture.setMipFilter(sm.Filter.NONE),
            this._dataTexture.setWrapMode(
              sm.WrapMode.CLAMP_TO_EDGE,
              sm.WrapMode.CLAMP_TO_EDGE,
              sm.WrapMode.CLAMP_TO_EDGE
            ),
            (this._dataTexture.image = r),
            this._dataTexture.uploadData(n);
          for (let t = 0; t < this._probes.length; t++) {
            const e = this._probes[t],
              i = this._getModelsByProbe(e);
            for (let t = 0; t < i.length; t++) {
              const e = i[t].node.getComponent(dF);
              e && e.updateReflectionProbeDataMap(this._dataTexture);
            }
          }
        }
        getMaxProbeId() {
          return 0 === this._probes.length
            ? -1
            : 1 === this._probes.length
            ? this._probes[0].getProbeId()
            : (this._probes.sort((t, e) => t.getProbeId() - e.getProbeId()),
              this._probes[this._probes.length - 1].getProbeId());
        }
        getUsedReflectionProbe(t, e) {
          if (e) {
            if (this._usePlanarModels.has(t))
              return this._usePlanarModels.get(t);
          } else if (this._useCubeModels.has(t))
            return this._useCubeModels.get(t);
          return null;
        }
        setReflectionProbe(t, e, i = null) {
          e &&
            (this._useCubeModels.set(t, e),
            this._updateCubemapOfModel(t, e),
            i && this._updateBlendProbeInfo(t, e, i));
        }
        updateProbeOfModels() {
          if (0 === this._probes.length) return;
          const t = a.director.getScene();
          if (!t || !t.renderScene) return;
          const e = t.renderScene.models;
          for (let t = 0; t < e.length; t++) {
            const i = e[t];
            i.node &&
              i.node.layer & BH &&
              (i.reflectionProbeType === hB.BAKED_CUBEMAP ||
                i.reflectionProbeType === hB.PLANAR_REFLECTION ||
                this._isUsedBlending(i)) &&
              i.updateReflectionProbeId();
          }
        }
        _getNearestProbe(t) {
          if (!t.node || !t.worldBounds || 0 === this._probes.length)
            return null;
          let e = null,
            i = 1 / 0;
          for (const s of this._probes) {
            if (
              s.probeType !== Eg.CUBE ||
              !s.validate() ||
              !Bn.aabbWithAABB(t.worldBounds, s.boundingBox)
            )
              continue;
            const n = Yi.distance(t.node.worldPosition, s.node.worldPosition);
            n < i && ((i = n), (e = s));
          }
          return e;
        }
        _getBlendProbe(t) {
          if (!t || !t.node || !t.worldBounds || this._probes.length < 2)
            return null;
          const e = [];
          for (let i = 0; i < this._probes.length; i++)
            this._probes[i].probeType === Eg.CUBE &&
              this._probes[i].validate() &&
              Bn.aabbWithAABB(t.worldBounds, this._probes[i].boundingBox) &&
              e.push(this._probes[i]);
          return (
            e.sort(
              (e, i) =>
                Yi.distance(t.node.worldPosition, e.node.worldPosition) -
                Yi.distance(t.node.worldPosition, i.node.worldPosition)
            ),
            e.length > 1 ? e[1] : null
          );
        }
        _getModelsByProbe(t) {
          const e = [];
          let i = this._useCubeModels;
          t.probeType === Eg.PLANAR && (i = this._usePlanarModels);
          for (const s of i.entries()) s[1] === t && e.push(s[0]);
          return e;
        }
        _removeDependentModels(t) {
          for (const e of this._useCubeModels.keys()) {
            const i = this._useCubeModels.get(e);
            void 0 !== i &&
              i === t &&
              (this._useCubeModels.delete(e), this.selectReflectionProbe(e));
          }
          for (const e of this._usePlanarModels.keys()) {
            const i = this._usePlanarModels.get(e);
            void 0 !== i &&
              i === t &&
              (this._usePlanarModels.delete(e),
              this.selectPlanarReflectionProbe(e));
          }
        }
        _updateCubemapOfModel(t, e) {
          const i = t.node;
          if (!i) return;
          const s = i.getComponent(dF);
          if (
            s &&
            (s.updateProbeCubemap(e ? e.cubemap : null),
            s.updateReflectionProbeId(e && e.cubemap ? e.getProbeId() : -1),
            e &&
              (s.updateReflectionProbeDataMap(this._dataTexture),
              this._isUsedBlending(t)))
          ) {
            const i = this._getBlendProbe(t);
            this._updateBlendProbeInfo(t, e, i);
          }
        }
        _updatePlanarMapOfModel(t, e, i) {
          const s = t.node.getComponent(dF);
          s &&
            (s.updateProbePlanarMap(e),
            i
              ? (s.updateReflectionProbeId(i.getProbeId()),
                s.updateReflectionProbeDataMap(this._dataTexture))
              : s.updateReflectionProbeId(-1));
        }
        _isUsedBlending(t) {
          return (
            t.reflectionProbeType === hB.BLEND_PROBES ||
            t.reflectionProbeType === hB.BLEND_PROBES_AND_SKYBOX
          );
        }
        _updateBlendProbeInfo(t, e, i) {
          const s = t.node;
          if (!s) return;
          const n = s.getComponent(dF);
          n &&
            (i
              ? (n.updateReflectionProbeBlendId(i.getProbeId()),
                n.updateProbeBlendCubemap(i.cubemap),
                n.updateReflectionProbeBlendWeight(
                  this._calculateBlendWeight(t, e, i)
                ))
              : (n.updateReflectionProbeBlendId(-1),
                t.reflectionProbeType === hB.BLEND_PROBES_AND_SKYBOX &&
                  n.updateReflectionProbeBlendWeight(
                    this._calculateBlendWeight(t, e, i)
                  )));
        }
        _updateBlendCubemap(t, e) {
          const i = t.node;
          if (!i) return;
          if (!this._isUsedBlending(t)) return;
          const s = i.getComponent(dF);
          s && s.updateProbeBlendCubemap(e.cubemap);
        }
        _calculateBlendWeight(t, e, i) {
          if (i) {
            const s = Yi.distance(t.node.worldPosition, e.node.worldPosition),
              n = Yi.distance(t.node.worldPosition, i.node.worldPosition);
            return 1 - n / (s + n);
          }
          return t.reflectionProbeType === hB.BLEND_PROBES
            ? 0
            : t.reflectionProbeType === hB.BLEND_PROBES_AND_SKYBOX
            ? this._calculateBlendOfSkybox(t.worldBounds, e.boundingBox)
            : 0;
        }
        _calculateBlendOfSkybox(t, e) {
          if (!t) return 1;
          const i = new Yi(),
            s = new Yi(),
            n = new Yi(),
            r = new Yi();
          if (
            (Yi.subtract(i, t.center, t.halfExtents),
            Yi.add(s, t.center, t.halfExtents),
            Yi.subtract(n, e.center, e.halfExtents),
            Yi.add(r, e.center, e.halfExtents),
            i.x <= r.x &&
              s.x >= n.x &&
              i.y <= r.y &&
              s.y >= n.y &&
              i.z <= r.z &&
              s.z >= n.z)
          ) {
            const e = new Yi();
            Yi.multiplyScalar(e, t.halfExtents, 2);
            const a = i.x + e.x <= r.x && s.x + e.x >= n.x,
              o = i.x - e.x <= r.x && s.x - e.x >= n.x,
              h = i.y + e.y <= r.y && s.y + e.y >= n.y,
              l = i.y - e.y <= r.y && s.y - e.y >= n.y,
              c = i.z + e.z <= r.z && s.z + e.z >= n.z,
              u = i.z - e.z <= r.z && s.z - e.z >= n.z,
              _ = [];
            if (!a) {
              const t = s.x - r.x;
              _.push(t / e.x);
            }
            if (!o) {
              const t = Math.abs(i.x - n.x);
              _.push(t / e.x);
            }
            if (!h) {
              const t = s.y - r.y;
              _.push(t / e.y);
            }
            if (!l) {
              const t = Math.abs(i.y - n.y);
              _.push(t / e.y);
            }
            if (!c) {
              const t = s.z - r.z;
              _.push(t / e.z);
            }
            if (!u) {
              const t = Math.abs(i.z - n.z);
              _.push(t / e.z);
            }
            return _.length > 0 ? (_.sort((t, e) => e - t), _[0]) : 0;
          }
          return 1;
        }
      }
      var UH,
        kH,
        zH,
        HH,
        GH,
        VH,
        jH,
        WH,
        XH,
        YH,
        KH,
        qH,
        $H,
        ZH,
        QH,
        JH,
        tG,
        eG,
        iG,
        sG,
        nG,
        rG,
        aG;
      let oG;
      t("ReflectionProbeManager", FH),
        (FH.probeManager = void 0),
        (FH.probeManager = new FH()),
        (a.internal.reflectionProbeManager = FH.probeManager),
        new Yi(),
        new Yi(),
        new Yi(),
        new Yi(),
        new Yi(),
        new Yi(),
        new Yi(),
        new Yi(),
        new Yi(),
        new Yi(),
        new Yi(),
        new Yi(),
        new Yi(0, 0, 0),
        new Yi(0, 0, 0),
        new Yi(0, 0, 0),
        new Yi(0, 0, 0),
        new Yi(0, 0, 0),
        new Yi(0, 0, 0),
        new Yi(0, 0, 0),
        new Yi(0, 0, 0),
        new Yi(0, 0, 0),
        new Yi(0, 0, 0),
        new Yi(0, 0, 0),
        new Yi(),
        (function (t) {
          (t[(t.Low_256x256 = 256)] = "Low_256x256"),
            (t[(t.Medium_512x512 = 512)] = "Medium_512x512"),
            (t[(t.High_768x768 = 768)] = "High_768x768");
        })(oG || (oG = {})),
        t(
          "ReflectionProbe",
          ((UH = Ca("cc.ReflectionProbe")),
          (kH = ao(Yi)),
          (zH = ao(ce(Eg))),
          (HH = ao(ce(oG))),
          (GH = ao(ce(Sg))),
          (VH = ao(Qi)),
          (jH = ao(Rf.BitMask)),
          (WH = ao(nM)),
          (XH = ao(He)),
          (YH = ao(Zf)),
          UH(
            (((aG = class t extends np {
              constructor(...t) {
                super(...t),
                  (this._lastSize = new Yi()),
                  (this._resolution = $H && $H()),
                  (this._clearFlag = ZH && ZH()),
                  (this._backgroundColor = QH && QH()),
                  (this._visibility = JH && JH()),
                  (this._probeType = tG && tG()),
                  (this._cubemap = eG && eG()),
                  (this._size = iG && iG()),
                  (this._sourceCamera = sG && sG()),
                  (this._probeId = nG && nG()),
                  (this._fastBake = rG && rG()),
                  (this._probe = null),
                  (this._previewSphere = null),
                  (this._previewPlane = null),
                  (this._sourceCameraPos = new Yi(0, 0, 0)),
                  (this._position = new Yi(0, 0, 0));
              }
              set size(t) {
                var e;
                this._size.set(t),
                  ((e = this._size).x = Math.abs(e.x)),
                  (e.y = Math.abs(e.y)),
                  (e.z = Math.abs(e.z)),
                  (this.probe.size = this._size),
                  this.probe &&
                    (this.probe.updateBoundingBox(),
                    FH.probeManager.onUpdateProbes(),
                    FH.probeManager.updateProbeData(),
                    FH.probeManager.updateProbeOfModels());
              }
              get size() {
                return this._size;
              }
              set probeType(e) {
                if (((this.probe.probeType = e), e !== this._probeType)) {
                  const i = this._size.clone(),
                    s = Yi.equals(this._lastSize, Yi.ZERO);
                  (this._probeType = e),
                    this._probeType === Eg.CUBE
                      ? (s && this._size.set(t.DEFAULT_CUBE_SIZE),
                        this.probe.switchProbeType(e, null),
                        FH.probeManager.clearPlanarReflectionMap(this.probe))
                      : (s && this._size.set(t.DEFAULT_PLANER_SIZE),
                        this._sourceCamera
                          ? this.probe.switchProbeType(
                              e,
                              this._sourceCamera.camera
                            )
                          : w(
                              "the reflection camera is invalid, please set the reflection camera"
                            )),
                    s || this._size.set(this._lastSize),
                    this._lastSize.set(i),
                    (this.size = this._size);
                }
              }
              get probeType() {
                return this._probeType;
              }
              set resolution(t) {
                (this._resolution = t), (this.probe.resolution = t);
              }
              get resolution() {
                return this._resolution;
              }
              set clearFlag(t) {
                (this._clearFlag = t), (this.probe.clearFlag = this._clearFlag);
              }
              get clearFlag() {
                return this._clearFlag;
              }
              set backgroundColor(t) {
                (this._backgroundColor = t),
                  (this.probe.backgroundColor = this._backgroundColor);
              }
              get backgroundColor() {
                return this._backgroundColor;
              }
              get visibility() {
                return this._visibility;
              }
              set visibility(t) {
                (this._visibility = t),
                  (this.probe.visibility = this._visibility);
              }
              set sourceCamera(t) {
                (this._sourceCamera = t),
                  t &&
                    ((this.visibility = t.visibility),
                    (this.clearFlag = t.clearFlags),
                    (this.backgroundColor = t.clearColor),
                    this.probeType === Eg.PLANAR &&
                      this.probe.switchProbeType(this.probeType, t.camera));
              }
              get sourceCamera() {
                return this._sourceCamera;
              }
              get fastBake() {
                return this._fastBake;
              }
              set fastBake(t) {
                this._fastBake = t;
              }
              set cubemap(t) {
                (this._cubemap = t),
                  (this.probe.cubemap = t),
                  FH.probeManager.onUpdateProbes();
              }
              get cubemap() {
                return this._cubemap;
              }
              get probe() {
                return this._probe;
              }
              set previewSphere(t) {
                (this._previewSphere = t),
                  this.probe &&
                    ((this.probe.previewSphere = t),
                    this._previewSphere &&
                      FH.probeManager.updatePreviewSphere(this.probe));
              }
              get previewSphere() {
                return this._previewSphere;
              }
              set previewPlane(t) {
                (this._previewPlane = t),
                  this.probe &&
                    ((this.probe.previewPlane = t),
                    this._previewPlane &&
                      FH.probeManager.updatePreviewPlane(this.probe));
              }
              get previewPlane() {
                return this._previewPlane;
              }
              onLoad() {
                this._createProbe();
              }
              onEnable() {
                if (this._probe) {
                  const t = FH.probeManager.getProbeById(this._probeId);
                  null !== t &&
                    t !== this._probe &&
                    ((this._probeId =
                      FH.probeManager.getNewReflectionProbeId()),
                    this._probe.updateProbeId(this._probeId)),
                    FH.probeManager.register(this._probe),
                    FH.probeManager.onUpdateProbes(),
                    this._probe.enable();
                }
              }
              onDisable() {
                this._probe &&
                  (FH.probeManager.unregister(this._probe),
                  this._probe.disable());
              }
              start() {
                this._sourceCamera &&
                  this.probeType === Eg.PLANAR &&
                  (this.probe.renderPlanarReflection(this.sourceCamera.camera),
                  FH.probeManager.filterModelsForPlanarReflection()),
                  FH.probeManager.updateProbeData(),
                  (this._position = this.node.getWorldPosition().clone());
              }
              onDestroy() {
                this.probe && this.probe.destroy();
              }
              update(t) {
                if (this.probe) {
                  this.probeType === Eg.PLANAR &&
                    this.sourceCamera &&
                    (this.sourceCamera.node.hasChangedFlags & Cf.TRS ||
                      !this._sourceCameraPos.equals(
                        this.sourceCamera.node.getWorldPosition()
                      )) &&
                    ((this._sourceCameraPos =
                      this.sourceCamera.node.getWorldPosition()),
                    this.probe.renderPlanarReflection(
                      this.sourceCamera.camera
                    )),
                    this.node.hasChangedFlags & Cf.POSITION &&
                      (this.probe.updateBoundingBox(),
                      FH.probeManager.onUpdateProbes(),
                      FH.probeManager.updateProbeData());
                  {
                    const t = this.node.getWorldPosition();
                    this._position.equals(t) ||
                      ((this._position = t),
                      this.probe.updateBoundingBox(),
                      FH.probeManager.updateProbeData(),
                      FH.probeManager.updateProbeOfModels());
                  }
                }
              }
              clearBakedCubemap() {
                (this.cubemap = null),
                  FH.probeManager.updateBakedCubemap(this.probe),
                  FH.probeManager.updatePreviewSphere(this.probe);
              }
              _createProbe() {
                if (
                  ((-1 === this._probeId ||
                    FH.probeManager.exists(this._probeId)) &&
                    (this._probeId = FH.probeManager.getNewReflectionProbeId()),
                  (this._probe = new vg(this._probeId)),
                  this._probe)
                ) {
                  const t = new Pf("ReflectionProbeCamera");
                  (t.hideFlags |= $n.Flags.DontSave | $n.Flags.HideInHierarchy),
                    this.node.scene.addChild(t),
                    this._probe.initialize(this.node, t),
                    this.enabled && FH.probeManager.register(this._probe),
                    (this._probe.resolution = this._resolution),
                    (this._probe.clearFlag = this._clearFlag),
                    (this._probe.backgroundColor = this._backgroundColor),
                    (this._probe.visibility = this._visibility),
                    (this._probe.probeType = this._probeType),
                    (this._probe.size = this._size),
                    (this._probe.cubemap = this._cubemap);
                }
              }
            }).DEFAULT_CUBE_SIZE = new Yi(1, 1, 1)),
            (aG.DEFAULT_PLANER_SIZE = new Yi(5, 0.5, 5)),
            ($H = fa((qH = aG).prototype, "_resolution", [Na], function () {
              return 256;
            })),
            (ZH = fa(qH.prototype, "_clearFlag", [Na], function () {
              return Sg.SKYBOX;
            })),
            (QH = fa(qH.prototype, "_backgroundColor", [Na], function () {
              return new Qi(0, 0, 0, 255);
            })),
            (JH = fa(qH.prototype, "_visibility", [Na], function () {
              return AA;
            })),
            (tG = fa(qH.prototype, "_probeType", [Na], function () {
              return Eg.CUBE;
            })),
            (eG = fa(qH.prototype, "_cubemap", [Na], function () {
              return null;
            })),
            (iG = fa(qH.prototype, "_size", [Na], function () {
              return new Yi(1, 1, 1);
            })),
            (sG = fa(qH.prototype, "_sourceCamera", [Na], function () {
              return null;
            })),
            (nG = fa(qH.prototype, "_probeId", [Na], function () {
              return -1;
            })),
            (rG = fa(qH.prototype, "_fastBake", [Na], function () {
              return !1;
            })),
            s(
              qH.prototype,
              "size",
              [kH],
              Object.getOwnPropertyDescriptor(qH.prototype, "size"),
              qH.prototype
            ),
            s(
              qH.prototype,
              "probeType",
              [zH],
              Object.getOwnPropertyDescriptor(qH.prototype, "probeType"),
              qH.prototype
            ),
            s(
              qH.prototype,
              "resolution",
              [HH],
              Object.getOwnPropertyDescriptor(qH.prototype, "resolution"),
              qH.prototype
            ),
            s(
              qH.prototype,
              "clearFlag",
              [GH],
              Object.getOwnPropertyDescriptor(qH.prototype, "clearFlag"),
              qH.prototype
            ),
            s(
              qH.prototype,
              "backgroundColor",
              [VH],
              Object.getOwnPropertyDescriptor(qH.prototype, "backgroundColor"),
              qH.prototype
            ),
            s(
              qH.prototype,
              "visibility",
              [jH],
              Object.getOwnPropertyDescriptor(qH.prototype, "visibility"),
              qH.prototype
            ),
            s(
              qH.prototype,
              "sourceCamera",
              [WH],
              Object.getOwnPropertyDescriptor(qH.prototype, "sourceCamera"),
              qH.prototype
            ),
            s(
              qH.prototype,
              "fastBake",
              [XH],
              Object.getOwnPropertyDescriptor(qH.prototype, "fastBake"),
              qH.prototype
            ),
            s(
              qH.prototype,
              "cubemap",
              [YH],
              Object.getOwnPropertyDescriptor(qH.prototype, "cubemap"),
              qH.prototype
            ),
            (KH = qH))
          ) || KH)
        ),
        (a.utils = aC);
      const hG = Symbol("CreateEval");
      var lG, cG, uG, _G, dG;
      Ca("cc.animation.EmbeddedPlayer")(
        ((lG = class extends ho {
          constructor(...t) {
            super(...t),
              (this.begin = cG && cG()),
              (this.end = uG && uG()),
              (this.reconciledSpeed = _G && _G()),
              (this.playable = dG && dG());
          }
        }),
        (cG = fa(lG.prototype, "begin", [Na], function () {
          return 0;
        })),
        (uG = fa(lG.prototype, "end", [Na], function () {
          return 0;
        })),
        (_G = fa(lG.prototype, "reconciledSpeed", [Na], function () {
          return !1;
        })),
        (dG = fa(lG.prototype, "playable", [Na], function () {
          return null;
        })),
        lG)
      );
      class pG {}
      class mG {
        constructor(t) {
          this._randomAccess = t;
        }
        get randomAccess() {
          return this._randomAccess;
        }
        setTime(t) {}
      }
      class fG {
        constructor() {
          (this._isPlaying = !1), (this._isPaused = !1), (this._stepOnce = !1);
        }
        get isPlaying() {
          return this._isPlaying;
        }
        get isPaused() {
          return this._isPaused;
        }
        get isMotionless() {
          return !this.isPlaying || this.isPaused;
        }
        play() {
          this._isPlaying
            ? this._isPaused
              ? ((this._isPaused = !1), this.onResume())
              : this.onError(X(3912))
            : ((this._isPlaying = !0), this.onPlay());
        }
        stop() {
          this._isPlaying &&
            ((this._isPlaying = !1), this.onStop(), (this._isPaused = !1));
        }
        pause() {
          this._isPlaying &&
            !this._isPaused &&
            ((this._isPaused = !0), this.onPause());
        }
        resume() {
          this._isPlaying &&
            this._isPaused &&
            ((this._isPaused = !1), this.onResume());
        }
        step() {
          this.pause(), (this._stepOnce = !0), this._isPlaying || this.play();
        }
        update(t) {}
        onPlay() {}
        onPause() {}
        onResume() {}
        onStop() {}
        onError(t) {}
      }
      let gG, yG;
      !(function (t) {
        (t[(t.Default = xl.Default)] = "Default"),
          (t[(t.Normal = xl.Normal)] = "Normal"),
          (t[(t.Reverse = xl.Reverse)] = "Reverse"),
          (t[(t.Loop = xl.Loop)] = "Loop"),
          (t[(t.LoopReverse = xl.Loop | xl.Reverse)] = "LoopReverse"),
          (t[(t.PingPong = xl.PingPong)] = "PingPong"),
          (t[(t.PingPongReverse = xl.PingPong | xl.Reverse)] =
            "PingPongReverse");
      })(gG || (gG = {})),
        de(gG);
      class TG {
        constructor(t) {
          (this.ratio = 0),
            (this.time = 0),
            (this.direction = 1),
            (this.stopped = !0),
            (this.iterations = 0),
            (this.frameIndex = void 0),
            t && this.set(t);
        }
        set(t) {
          (this.ratio = t.ratio),
            (this.time = t.time),
            (this.direction = t.direction),
            (this.stopped = t.stopped),
            (this.iterations = t.iterations),
            (this.frameIndex = t.frameIndex);
        }
      }
      class SG {
        constructor(t) {
          (this.weight = 0),
            (this._pose = void 0),
            (this._blendStateWriters = []),
            (this._pose = t);
        }
        destroy() {
          for (let t = 0; t < this._blendStateWriters.length; ++t)
            this._pose.destroyWriter(this._blendStateWriters[t]);
          this._blendStateWriters.length = 0;
        }
        createPoseWriter(t, e, i) {
          const s = this._pose.createWriter(t, e, this, i);
          return this._blendStateWriters.push(s), s;
        }
      }
      function EG() {
        return a.director.getAnimationManager();
      }
      !(function (t) {
        (t.PLAY = "play"),
          (t.STOP = "stop"),
          (t.PAUSE = "pause"),
          (t.RESUME = "resume"),
          (t.LASTFRAME = "lastframe"),
          (t.FINISHED = "finished");
      })(yG || (yG = {})),
        de(yG);
      class vG extends fG {
        get clip() {
          return this._clip;
        }
        get name() {
          return this._name;
        }
        get length() {
          return this.duration;
        }
        get wrapMode() {
          return this._wrapMode;
        }
        set wrapMode(t) {
          var e;
          (this._wrapMode = t),
            (this.time = 0),
            t & xl.Loop ? (this.repeatCount = 1 / 0) : (this.repeatCount = 1),
            null === (e = this._clipEventEval) ||
              void 0 === e ||
              e.setWrapMode(t);
        }
        get repeatCount() {
          return this._repeatCount;
        }
        set repeatCount(t) {
          this._repeatCount = t;
          const e = this._wrapMode & xl.ShouldWrap,
            i = (this.wrapMode & xl.Reverse) === xl.Reverse;
          this._useSimpleProcess = t === 1 / 0 && !e && !i;
        }
        get delay() {
          return this._delay;
        }
        set delay(t) {
          this._delayTime = this._delay = t;
        }
        get playbackRange() {
          return this._playbackRange;
        }
        set playbackRange(t) {
          t.max,
            t.min,
            (this._playbackRange.min = Math.max(t.min, 0)),
            (this._playbackRange.max = Math.min(t.max, this.duration)),
            (this._playbackDuration =
              this._playbackRange.max - this._playbackRange.min),
            this.setTime(0);
        }
        get speed() {
          return this._speed;
        }
        set speed(t) {
          var e;
          (this._speed = t),
            null === (e = this._clipEmbeddedPlayerEval) ||
              void 0 === e ||
              e.notifyHostSpeedChanged(t);
        }
        get current() {
          return this.getWrappedInfo(this.time).time;
        }
        get ratio() {
          return 0 === this.duration ? 0 : this.current / this.duration;
        }
        get weight() {
          return this._weight;
        }
        set weight(t) {
          (this._weight = t), this._poseOutput && (this._poseOutput.weight = t);
        }
        constructor(t, e = "") {
          super(),
            (this.duration = 1),
            (this.time = 0),
            (this.frameRate = 0),
            (this._targetNode = null),
            (this._curveLoaded = !1),
            (this._clip = void 0),
            (this._speed = 1),
            (this._useSimpleProcess = !1),
            (this._target = null),
            (this._wrapMode = gG.Normal),
            (this._repeatCount = 1),
            (this._delay = 0),
            (this._delayTime = 0),
            (this._currentFramePlayed = !1),
            (this._name = void 0),
            (this._lastIterations = NaN),
            (this._lastWrapInfo = null),
            (this._wrappedInfo = new TG()),
            (this._allowLastFrame = !1),
            (this._blendStateWriterHost = { weight: 0 }),
            (this._playbackDuration = 0),
            (this._invDuration = 1),
            (this._poseOutput = null),
            (this._weight = 1),
            (this._clipEval = void 0),
            (this._clipEventEval = void 0),
            (this._clipEmbeddedPlayerEval = void 0),
            (this._doNotCreateEval = !1),
            (this._clip = t),
            (this._name = e || (t && t.name)),
            (this._playbackRange = { min: 0, max: t.duration }),
            (this._playbackDuration = t.duration),
            t.duration || x(`Clip ${t.name} has zero duration.`);
        }
        get curveLoaded() {
          return this._curveLoaded;
        }
        initialize(t, e, i) {
          if (this._curveLoaded) return;
          (this._curveLoaded = !0),
            this._poseOutput &&
              (this._poseOutput.destroy(), (this._poseOutput = null)),
            this._clipEval && (this._clipEval = void 0),
            this._clipEventEval && (this._clipEventEval = void 0),
            this._clipEmbeddedPlayerEval &&
              (this._clipEmbeddedPlayerEval.destroy(),
              (this._clipEmbeddedPlayerEval = void 0)),
            (this._targetNode = t);
          const s = this._clip;
          if (
            ((this.duration = s.duration),
            (this._invDuration = 1 / this.duration),
            (this._speed = s.speed),
            (this.wrapMode = s.wrapMode),
            (this.frameRate = s.sample),
            (this._playbackRange.min = 0),
            (this._playbackRange.max = s.duration),
            (this._playbackDuration = s.duration),
            (this.wrapMode & xl.Loop) === xl.Loop
              ? (this.repeatCount = 1 / 0)
              : (this.repeatCount = 1),
            !this._doNotCreateEval)
          ) {
            var n, r, a;
            const o =
              null !==
                (n =
                  null != e
                    ? e
                    : null === (r = EG()) || void 0 === r
                    ? void 0
                    : r.blendState) && void 0 !== n
                ? n
                : null;
            o && (this._poseOutput = new SG(o)),
              (this._clipEval = s.createEvaluator({
                target: t,
                pose:
                  null !== (a = this._poseOutput) && void 0 !== a ? a : void 0,
                mask: i,
              }));
          }
          s.containsAnyEvent() &&
            (this._clipEventEval = s.createEventEvaluator(this._targetNode)),
            s.containsAnyEmbeddedPlayer() &&
              ((this._clipEmbeddedPlayerEval = s.createEmbeddedPlayerEvaluator(
                this._targetNode
              )),
              this._clipEmbeddedPlayerEval.notifyHostSpeedChanged(this._speed));
        }
        destroy() {
          this.isMotionless || EG().removeAnimation(this),
            this._poseOutput &&
              (this._poseOutput.destroy(), (this._poseOutput = null)),
            (this._clipEval = void 0);
        }
        emit(...t) {
          EG().pushDelayEvent(this._emit, this, t);
        }
        on(t, e, i) {
          return this._target && this._target.isValid
            ? this._target.on(t, e, i)
            : null;
        }
        once(t, e, i) {
          return this._target && this._target.isValid
            ? this._target.once(t, e, i)
            : null;
        }
        off(t, e, i) {
          this._target && this._target.isValid && this._target.off(t, e, i);
        }
        allowLastFrameEvent(t) {
          this._allowLastFrame = t;
        }
        _setEventTarget(t) {
          this._target = t;
        }
        setTime(t) {
          (this._currentFramePlayed = !1), (this.time = t || 0);
          {
            var e;
            const i = this.getWrappedInfo(t, this._wrappedInfo);
            null === (e = this._clipEventEval) ||
              void 0 === e ||
              e.ignore(i.ratio, i.direction);
          }
        }
        update(t) {
          (this._delayTime > 0 &&
            ((this._delayTime -= t), this._delayTime > 0)) ||
            (this._currentFramePlayed
              ? (this.time += t * this._speed)
              : (this._currentFramePlayed = !0),
            this._process());
        }
        sample() {
          const t = this.getWrappedInfo(this.time, this._wrappedInfo);
          return (
            this._sampleCurves(t.time),
            this._sampleEvents(t),
            this._sampleEmbeddedPlayers(t),
            t
          );
        }
        onPlay() {
          var t;
          this.setTime(this._getPlaybackStart()),
            (this._delayTime = this._delay),
            this._onReplayOrResume(),
            this.emit(yG.PLAY, this),
            null === (t = this._clipEmbeddedPlayerEval) ||
              void 0 === t ||
              t.notifyHostPlay(this.current);
        }
        onStop() {
          var t;
          this.isPaused || this._onPauseOrStop(),
            this.emit(yG.STOP, this),
            null === (t = this._clipEmbeddedPlayerEval) ||
              void 0 === t ||
              t.notifyHostStop();
        }
        onResume() {
          var t;
          this._onReplayOrResume(),
            this.emit(yG.RESUME, this),
            null === (t = this._clipEmbeddedPlayerEval) ||
              void 0 === t ||
              t.notifyHostPlay(this.current);
        }
        onPause() {
          var t;
          this._onPauseOrStop(),
            this.emit(yG.PAUSE, this),
            null === (t = this._clipEmbeddedPlayerEval) ||
              void 0 === t ||
              t.notifyHostPause(this.current);
        }
        _sampleCurves(t) {
          const { _poseOutput: e, _clipEval: i } = this;
          e && (e.weight = this.weight), i && i.evaluate(t);
        }
        _process() {
          this._useSimpleProcess ? this.simpleProcess() : this.process();
        }
        process() {
          const t = this.sample();
          if (this._allowLastFrame) {
            let e;
            (e = this._lastWrapInfo
              ? this._lastWrapInfo
              : (this._lastWrapInfo = new TG(t))),
              this.repeatCount > 1 &&
                (0 | t.iterations) > (0 | e.iterations) &&
                this.emit(yG.LASTFRAME, this),
              e.set(t);
          }
          t.stopped && (this.stop(), this.emit(yG.FINISHED, this));
        }
        simpleProcess() {
          const t = this._playbackRange.min,
            e = this._playbackDuration;
          let i = 0,
            s = 0;
          if (
            (0 !== e &&
              ((i = this.time % e),
              i < 0 && (i += e),
              (s = (t + i) * this._invDuration)),
            this._sampleCurves(t + i),
            this._clipEventEval || this._clipEmbeddedPlayerEval)
          ) {
            const t = this.getWrappedInfo(this.time, this._wrappedInfo);
            this._sampleEvents(t), this._sampleEmbeddedPlayers(t);
          }
          this._allowLastFrame &&
            (Number.isNaN(this._lastIterations) && (this._lastIterations = s),
            ((this.time > 0 && this._lastIterations > s) ||
              (this.time < 0 && this._lastIterations < s)) &&
              this.emit(yG.LASTFRAME, this),
            (this._lastIterations = s));
        }
        _needReverse(t) {
          const e = this.wrapMode;
          let i = !1;
          return (
            (e & xl.PingPong) === xl.PingPong &&
              (t - (0 | t) == 0 && t > 0 && (t -= 1), 1 & t && (i = !i)),
            (e & xl.Reverse) === xl.Reverse && (i = !i),
            i
          );
        }
        getWrappedInfo(t, e) {
          e = e || new TG();
          const {
              _playbackRange: { min: i },
              _playbackDuration: s,
            } = this,
            n = this.repeatCount;
          if (0 === s)
            return (
              (e.time = 0),
              (e.ratio = 0),
              (e.direction = 1),
              (e.stopped = !!Number.isFinite(n)),
              (e.iterations = 0),
              e
            );
          let r = !1,
            a = (t -= i) > 0 ? t / s : -t / s;
          if (a >= n) {
            (a = n), (r = !0);
            let e = n - (0 | n);
            0 === e && (e = 1), (t = e * s * (t > 0 ? 1 : -1));
          }
          if (t > s) {
            const e = t % s;
            t = 0 === e ? s : e;
          } else t < 0 && 0 != (t %= s) && (t += s);
          let o = !1;
          const h = this._wrapMode & xl.ShouldWrap;
          h && (o = this._needReverse(a));
          let l = o ? -1 : 1;
          return (
            this.speed < 0 && (l *= -1),
            h && o && (t = s - t),
            (e.time = i + t),
            (e.ratio = e.time / this.duration),
            (e.direction = l),
            (e.stopped = r),
            (e.iterations = a),
            e
          );
        }
        _getPlaybackStart() {
          return this._playbackRange.min;
        }
        _sampleEvents(t) {
          var e;
          null === (e = this._clipEventEval) ||
            void 0 === e ||
            e.sample(t.ratio, t.direction, t.iterations);
        }
        _sampleEmbeddedPlayers(t) {
          var e;
          null === (e = this._clipEmbeddedPlayerEval) ||
            void 0 === e ||
            e.evaluate(t.time, Math.trunc(t.iterations));
        }
        _emit(t, e) {
          this._target && this._target.isValid && this._target.emit(t, t, e);
        }
        _onReplayOrResume() {
          EG().addAnimation(this);
        }
        _onPauseOrStop() {
          EG().removeAnimation(this);
        }
      }
      var bG, AG, CG, OG, IG, wG, RG, DG, xG, MG, PG;
      t("AnimationState", vG),
        (a.AnimationState = vG),
        Ca("cc.animation.EmbeddedAnimationClipPlayable")(
          ((bG = class extends pG {
            constructor(...t) {
              super(...t), (this.path = AG && AG()), (this.clip = CG && CG());
            }
            instantiate(t) {
              const { clip: e, path: i } = this;
              if (!e) return null;
              const s = t.getChildByPath(i);
              if (!s) return G(3938, i, t.getPathInHierarchy(), e.name), null;
              const n = new vG(e);
              return n.initialize(s), new NG(n);
            }
          }),
          (AG = fa(bG.prototype, "path", [Na], function () {
            return "";
          })),
          (CG = fa(bG.prototype, "clip", [Na], function () {
            return null;
          })),
          bG)
        );
      class NG extends mG {
        constructor(t) {
          super(!0),
            (this._animationState = void 0),
            (this._animationState = t);
        }
        destroy() {
          this._animationState.destroy();
        }
        play() {
          this._animationState.play();
        }
        pause() {
          this._animationState.pause();
        }
        stop() {
          this._animationState.stop();
        }
        setSpeed(t) {
          this._animationState.speed = t;
        }
        setTime(t) {
          this._animationState.time = t;
        }
      }
      Ca("cc.animation.EmbeddedParticleSystemPlayable")(
        ((OG = class extends pG {
          constructor(...t) {
            super(...t), (this.path = IG && IG());
          }
          instantiate(t) {
            const e = t.getChildByPath(this.path);
            if (!e)
              return w(`Hierarchy path ${this.path} does not exists.`), null;
            const i = Yt("cc.ParticleSystem");
            if (!i)
              return (
                w(
                  "Particle system is required for embedded particle system player."
                ),
                null
              );
            const s = e.getComponent(i);
            return s
              ? new LG(s)
              : (w(
                  `${this.path} does not includes a particle system component.`
                ),
                null);
          }
        }),
        (IG = fa(OG.prototype, "path", [Na], function () {
          return "";
        })),
        OG)
      );
      class LG extends mG {
        constructor(t) {
          super(!1),
            (this._particleSystem = void 0),
            (this._particleSystem = t);
        }
        destroy() {}
        play() {
          this._particleSystem.play();
        }
        pause() {
          this._particleSystem.stopEmitting();
        }
        stop() {
          this._particleSystem.stopEmitting();
        }
        setSpeed(t) {
          this._particleSystem.simulationSpeed = t;
        }
      }
      function BG(t) {
        return "string" == typeof t || "number" == typeof t;
      }
      let FG =
          Ca("cc.animation.HierarchyPath")(
            ((RG = class {
              constructor(t) {
                (this.path = DG && DG()), (this.path = t || "");
              }
              get(t) {
                if (!(t instanceof Pf)) return z(3925), null;
                return (
                  t.getChildByPath(this.path) ||
                  (z(3926, t.name, this.path), null)
                );
              }
            }),
            (DG = fa(RG.prototype, "path", [Na], function () {
              return "";
            })),
            (wG = RG))
          ) || wG,
        UG =
          Ca("cc.animation.ComponentPath")(
            ((MG = class {
              constructor(t) {
                (this.component = PG && PG()), (this.component = t || "");
              }
              get(t) {
                if (!(t instanceof Pf)) return z(3927), null;
                return (
                  t.getComponent(this.component) ||
                  (z(3928, t.name, this.component), null)
                );
              }
            }),
            (PG = fa(MG.prototype, "component", [Na], function () {
              return "";
            })),
            (xG = MG))
          ) || xG;
      var kG, zG, HG, GG, VG, jG, WG, XG, YG, KG, qG, $G, ZG, QG, JG, tV, eV;
      const iV = Symbol("NormalizedFollow"),
        sV = Symbol("ConvertAsTrsPath"),
        nV = Symbol("TrackBinding");
      let rV =
          Ca("cc.animation.TrackPath")(
            ((zG = class t {
              constructor() {
                this._paths = HG && HG();
              }
              get length() {
                return this._paths.length;
              }
              toProperty(t) {
                return this._paths.push(t), this;
              }
              toElement(t) {
                return this._paths.push(t), this;
              }
              toHierarchy(t) {
                return this._paths.push(new FG(t)), this;
              }
              toComponent(t) {
                const e = new UG("string" == typeof t ? t : Et(t));
                return this._paths.push(e), this;
              }
              toCustomized(t) {
                return this._paths.push(t), this;
              }
              append(...t) {
                const e = this._paths.concat(...t.map((t) => t._paths));
                return (this._paths = e), this;
              }
              isPropertyAt(t) {
                return "string" == typeof this._paths[t];
              }
              parsePropertyAt(t) {
                return this._paths[t];
              }
              isElementAt(t) {
                return "number" == typeof this._paths[t];
              }
              parseElementAt(t) {
                return this._paths[t];
              }
              isHierarchyAt(t) {
                return this._paths[t] instanceof FG;
              }
              parseHierarchyAt(t) {
                return this.isHierarchyAt(t), this._paths[t].path;
              }
              isComponentAt(t) {
                return this._paths[t] instanceof UG;
              }
              parseComponentAt(t) {
                return this.isComponentAt(t), this._paths[t].component;
              }
              slice(e, i) {
                const s = new t();
                return (s._paths = this._paths.slice(e, i)), s;
              }
              trace(t, e, i) {
                var s, n;
                return (
                  (null !== (s = e) && void 0 !== s) || (e = 0),
                  (null !== (n = i) && void 0 !== n) ||
                    (i = this._paths.length),
                  this[iV](t, e, i)
                );
              }
              [sV]() {
                const { _paths: t } = this,
                  e = t.length;
                let i,
                  s = 0,
                  n = "";
                for (; s < e; ++s) {
                  const e = t[s];
                  if (!(e instanceof FG)) break;
                  e.path && (n ? (n += `/${e.path}`) : (n = e.path));
                }
                if (s === e) return null;
                if (s !== e - 1) return null;
                switch (t[s]) {
                  case "position":
                  case "scale":
                  case "rotation":
                  case "eulerAngles":
                    i = t[s];
                    break;
                  default:
                    return null;
                }
                return { node: n, property: i };
              }
              [iV](t, e, i) {
                const { _paths: s } = this;
                let n = t;
                for (let t = e; t < i; ++t) {
                  const e = s[t];
                  if (BG(e)) {
                    if (!(e in n)) return z(3929, e), null;
                    n = n[e];
                  } else n = e.get(n);
                  if (null === n) break;
                }
                return n;
              }
            }),
            (HG = fa(zG.prototype, "_paths", [Na], function () {
              return [];
            })),
            (kG = zG))
          ) || kG,
        aV =
          Ca("cc.animation.TrackBinding")(
            (GG =
              Ua(
                (((XG = class t {
                  constructor() {
                    (this.path = jG && jG()), (this.proxy = WG && WG());
                  }
                  parseTrsPath() {
                    return this.proxy ? null : this.path[sV]();
                  }
                  createRuntimeBinding(e, i, s) {
                    const { path: n, proxy: r } = this,
                      a = n.length,
                      o = a - 1;
                    if (
                      0 === a ||
                      (!n.isPropertyAt(o) && !n.isElementAt(o)) ||
                      r
                    ) {
                      if (r) {
                        const t = n[iV](e, 0, a);
                        if (null === t) return null;
                        const i = r.forTarget(t);
                        if (!i) return null;
                        const s = {
                            setValue: (t) => {
                              i.set(t);
                            },
                          },
                          o = i.get;
                        return o && (s.getValue = () => o.call(i)), s;
                      }
                      return G(3921), null;
                    }
                    {
                      const r = n.isPropertyAt(o)
                          ? n.parsePropertyAt(o)
                          : n.parseElementAt(o),
                        h = n[iV](e, 0, a - 1);
                      if (null === h) return null;
                      if (i && h instanceof Pf && oV(r))
                        return i.createPoseWriter(h, r, s);
                      let l, c;
                      {
                        let e = t._animationFunctions.get(h.constructor);
                        e ||
                          ((e = new Map()),
                          t._animationFunctions.set(h.constructor, e));
                        let i = e.get(r);
                        i ||
                          ((i = {
                            setValue: Function(
                              "value",
                              `this.target.${r} = value;`
                            ),
                            getValue: Function(`return this.target.${r};`),
                          }),
                          e.set(r, i)),
                          (l = i.setValue),
                          (c = i.getValue);
                      }
                      return { target: h, setValue: l, getValue: c };
                    }
                  }
                  isMaskedOff(t) {
                    const e = this.parseTrsPath();
                    if (!e) return !1;
                    const i = t.joints[Symbol.iterator]();
                    for (let t = i.next(); !t.done; t = i.next()) {
                      const { value: i } = t;
                      if (i.path === e.node) return !i.enabled;
                    }
                    return !1;
                  }
                })._animationFunctions = new WeakMap()),
                (jG = fa((VG = XG).prototype, "path", [Na], function () {
                  return new rV();
                })),
                (WG = fa(VG.prototype, "proxy", [Na], null)),
                (GG = VG))
              ) || GG)
          ) || GG;
      function oV(t) {
        return (
          "position" === t ||
          "rotation" === t ||
          "scale" === t ||
          "eulerAngles" === t
        );
      }
      let hV =
          Ca("cc.animation.Track")(
            ((KG = class {
              constructor() {
                this._binding = qG && qG();
              }
              get path() {
                return this._binding.path;
              }
              set path(t) {
                this._binding.path = t;
              }
              get proxy() {
                return this._binding.proxy;
              }
              set proxy(t) {
                this._binding.proxy = t;
              }
              get [nV]() {
                return this._binding;
              }
              channels() {
                return [];
              }
              range() {
                const t = { min: 1 / 0, max: -1 / 0 };
                for (const e of this.channels())
                  (t.min = Math.min(t.min, e.curve.rangeMin)),
                    (t.max = Math.max(t.max, e.curve.rangeMax));
                return t;
              }
            }),
            (qG = fa(KG.prototype, "_binding", [Na], function () {
              return new aV();
            })),
            (YG = KG))
          ) || YG,
        lV =
          Ca("cc.animation.Channel")(
            ((ZG = class {
              constructor(t) {
                (this.name = ""), (this._curve = QG && QG()), (this._curve = t);
              }
              get curve() {
                return this._curve;
              }
            }),
            (QG = fa(ZG.prototype, "_curve", [Na], null)),
            ($G = ZG))
          ) || $G,
        cV =
          Ca("cc.animation.SingleChannelTrack")(
            ((tV = class extends hV {
              constructor() {
                super(),
                  (this._channel = eV && eV()),
                  (this._channel = new lV(this.createCurve()));
              }
              get channel() {
                return this._channel;
              }
              channels() {
                return [this._channel];
              }
              createCurve() {
                throw new Error("Not impl");
              }
              [hG]() {
                const { curve: t } = this._channel;
                return new uV(t);
              }
            }),
            (eV = fa(tV.prototype, "_channel", [Na], null)),
            (JG = tV))
          ) || JG;
      class uV {
        constructor(t) {
          this._curve = t;
        }
        get requiresDefault() {
          return !1;
        }
        evaluate(t) {
          return this._curve.evaluate(t);
        }
      }
      var _V, dV;
      const { ccclass: pV, serializable: mV } = go;
      pV("cc.animation.RealArrayTrack")(
        ((_V = class extends hV {
          constructor(...t) {
            super(...t), (this._channels = dV && dV());
          }
          get elementCount() {
            return this._channels.length;
          }
          set elementCount(t) {
            const { _channels: e } = this,
              i = e.length;
            t < i
              ? this._channels.splice(t)
              : t > i &&
                this._channels.push(
                  ...Array.from({ length: t - i }, () => new lV(new wh()))
                );
          }
          channels() {
            return this._channels;
          }
          [hG]() {
            return new fV(this._channels.map(({ curve: t }) => t));
          }
        }),
        (dV = fa(_V.prototype, "_channels", [mV], function () {
          return [];
        })),
        _V)
      );
      class fV {
        constructor(t) {
          (this._curves = t), (this._result = new Array(t.length).fill(0));
        }
        get requiresDefault() {
          return !1;
        }
        evaluate(t) {
          const { _result: e } = this,
            i = e.length;
          for (let s = 0; s < i; ++s) e[s] = this._curves[s].evaluate(t);
          return this._result;
        }
      }
      var gV, yV, TV, SV, EV;
      let vV =
        Ca("cc.animation.UniformProxyFactory")(
          ((yV = class {
            constructor(t, e) {
              (this.passIndex = TV && TV()),
                (this.uniformName = SV && SV()),
                i(this, "channelIndex", EV, this),
                (this.passIndex = e || 0),
                (this.uniformName = t || "");
            }
            forTarget(t) {
              if (!(t instanceof ey)) return void z(3940, t);
              const { passIndex: e, uniformName: i, channelIndex: s } = this;
              if (e < 0 || e >= t.passes.length) return void z(3941, t.name, e);
              const n = t.passes[e],
                r = n.getHandle(i);
              if (r) {
                if (hR.getTypeFromHandle(r) < yc.SAMPLER1D) {
                  const a = void 0 === s ? r : n.getHandle(i, s, yc.FLOAT);
                  return a
                    ? (function (t, e) {
                        for (const i of t.shaderInfo.blocks)
                          for (const t of i.members)
                            if (t.name === e) return t.count > 1;
                        return !1;
                      })(n, i)
                      ? {
                          set: (t) => {
                            n.setUniformArray(a, t);
                          },
                        }
                      : {
                          set: (t) => {
                            n.setUniform(a, t);
                          },
                        }
                    : void z(3943, t.name, e, i, s);
                }
                {
                  const t = hR.getBindingFromHandle(r),
                    e = n.properties[i],
                    s = e && e.value ? `${e.value}${rR(e.type)}` : nR(e.type);
                  let a = Pv.get(s);
                  return (
                    a ||
                      (w(`Illegal texture default value: ${s}.`),
                      (a = Pv.get("default-texture"))),
                    {
                      set: (e) => {
                        e || (e = a);
                        const i = e.getGFXTexture();
                        i &&
                          i.width &&
                          i.height &&
                          (n.bindTexture(t, i),
                          e instanceof Xp &&
                            n.bindSampler(
                              t,
                              I_.gfxDevice.getSampler(e.getSamplerInfo())
                            ));
                      },
                    }
                  );
                }
              }
              z(3942, t.name, e, i);
            }
          }),
          (TV = fa(yV.prototype, "passIndex", [Na], function () {
            return 0;
          })),
          (SV = fa(yV.prototype, "uniformName", [Na], function () {
            return "";
          })),
          (EV = s(yV.prototype, "channelIndex", [so], {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: function () {},
          })),
          (gV = yV))
        ) || gV;
      var bV, AV, CV, OV, IV, wV, RV, DV;
      let xV =
          Ca("cc.animation.MorphWeightValueProxy")(
            ((AV = class {
              constructor() {
                (this.subMeshIndex = CV && CV()),
                  (this.shapeIndex = OV && OV());
              }
              forTarget(t) {
                return {
                  set: (e) => {
                    t.setWeight(e, this.subMeshIndex, this.shapeIndex);
                  },
                };
              }
            }),
            (CV = fa(AV.prototype, "subMeshIndex", [Na], function () {
              return 0;
            })),
            (OV = fa(AV.prototype, "shapeIndex", [Na], function () {
              return 0;
            })),
            (bV = AV))
          ) || bV,
        MV =
          Ca("cc.animation.MorphWeightsValueProxy")(
            ((wV = class {
              constructor() {
                this.subMeshIndex = RV && RV();
              }
              forTarget(t) {
                return {
                  set: (e) => {
                    t.setWeights(e, this.subMeshIndex);
                  },
                };
              }
            }),
            (RV = fa(wV.prototype, "subMeshIndex", [Na], function () {
              return 0;
            })),
            (IV = wV))
          ) || IV,
        PV =
          Ca("cc.animation.MorphWeightsAllValueProxy")(
            (DV = class {
              forTarget(t) {
                return {
                  set: (e) => {
                    var i, s;
                    const n =
                      null !==
                        (i =
                          null === (s = t.mesh) || void 0 === s
                            ? void 0
                            : s.struct.primitives.length) && void 0 !== i
                        ? i
                        : 0;
                    for (let i = 0; i < n; ++i) t.setWeights(e, i);
                  },
                };
              }
            })
          ) || DV;
      var NV, LV, BV, FV, UV;
      function kV(t, e, i, s) {
        var n, r, a, o, h;
        let l = new e(),
          c = new e(),
          u = new e(),
          _ =
            Ca(t)(
              ((r = class {
                constructor(t, i, s) {
                  (this.dataPoint = a && a()),
                    (this.inTangent = o && o()),
                    (this.outTangent = h && h()),
                    (this.dataPoint = t || new e()),
                    (this.inTangent = i || new e()),
                    (this.outTangent = s || new e());
                }
                lerp(t, e, n) {
                  const r = this.dataPoint,
                    a = t.dataPoint;
                  (c = i(c, this.inTangent, n)), (u = i(u, t.outTangent, n));
                  const o = e * e * e,
                    h = e * e,
                    _ = o - 2 * h + e,
                    d = -2 * o + 3 * h,
                    p = o - h;
                  return (
                    (l = i(l, r, 2 * o - 3 * h + 1)),
                    (l = s(l, l, c, _)),
                    (l = s(l, l, a, d)),
                    (l = s(l, l, u, p)),
                    l
                  );
                }
                getNoLerp() {
                  return this.dataPoint;
                }
              }),
              (a = fa(r.prototype, "dataPoint", [Na], function () {
                return new e();
              })),
              (o = fa(r.prototype, "inTangent", [Na], function () {
                return new e();
              })),
              (h = fa(r.prototype, "outTangent", [Na], function () {
                return new e();
              })),
              (n = r))
            ) || n;
        if (e === as) {
          const t = _.prototype.lerp;
          _.prototype.lerp = function (e, i, s) {
            const n = t.call(this, e, i, s);
            return as.normalize(n, n), n;
          };
        }
        return _;
      }
      const zV = kV(
          "cc.CubicSplineVec2Value",
          Ss,
          Ss.multiplyScalar,
          Ss.scaleAndAdd
        ),
        HV = kV(
          "cc.CubicSplineVec3Value",
          Yi,
          Yi.multiplyScalar,
          Yi.scaleAndAdd
        ),
        GV = kV(
          "cc.CubicSplineVec4Value",
          Wi,
          Wi.multiplyScalar,
          Wi.scaleAndAdd
        ),
        VV = kV(
          "cc.CubicSplineQuatValue",
          as,
          as.multiplyScalar,
          as.scaleAndAdd
        );
      let jV =
        Ca("cc.CubicSplineNumberValue")(
          ((LV = class {
            constructor(t, e, i) {
              (this.dataPoint = BV && BV()),
                (this.inTangent = FV && FV()),
                (this.outTangent = UV && UV()),
                (this.dataPoint = t),
                (this.inTangent = e),
                (this.outTangent = i);
            }
            lerp(t, e, i) {
              const s = this.dataPoint,
                n = t.dataPoint,
                r = e * e * e,
                a = e * e;
              return (
                s * (2 * r - 3 * a + 1) +
                this.outTangent * i * (r - 2 * a + e) +
                n * (-2 * r + 3 * a) +
                t.inTangent * i * (r - a)
              );
            }
            getNoLerp() {
              return this.dataPoint;
            }
          }),
          (BV = fa(LV.prototype, "dataPoint", [Na], function () {
            return 0;
          })),
          (FV = fa(LV.prototype, "inTangent", [Na], function () {
            return 0;
          })),
          (UV = fa(LV.prototype, "outTangent", [Na], function () {
            return 0;
          })),
          (NV = LV))
        ) || NV;
      var WV;
      let XV =
        Ca("cc.animation.RealTrack")(
          (WV = class extends cV {
            createCurve() {
              return new wh();
            }
          })
        ) || WV;
      function YV(t) {
        return 0 === t.keyFramesCount ? void 0 : t;
      }
      var KV, qV, $V, ZV;
      const QV = ["X", "Y", "Z", "W"];
      let JV =
        Ca("cc.animation.VectorTrack")(
          ((qV = class extends hV {
            constructor() {
              super(),
                (this._channels = $V && $V()),
                (this._nComponents = ZV && ZV()),
                (this._channels = new Array(4));
              for (let t = 0; t < this._channels.length; ++t) {
                const e = new lV(new wh());
                (e.name = QV[t]), (this._channels[t] = e);
              }
            }
            get componentsCount() {
              return this._nComponents;
            }
            set componentsCount(t) {
              this._nComponents = t;
            }
            channels() {
              return this._channels;
            }
            [hG]() {
              switch (this._nComponents) {
                default:
                case 2:
                  return new tj(
                    YV(this._channels[0].curve),
                    YV(this._channels[1].curve)
                  );
                case 3:
                  return new ej(
                    YV(this._channels[0].curve),
                    YV(this._channels[1].curve),
                    YV(this._channels[2].curve)
                  );
                case 4:
                  return new ij(
                    YV(this._channels[0].curve),
                    YV(this._channels[1].curve),
                    YV(this._channels[2].curve),
                    YV(this._channels[3].curve)
                  );
              }
            }
          }),
          ($V = fa(qV.prototype, "_channels", [Na], null)),
          (ZV = fa(qV.prototype, "_nComponents", [Na], function () {
            return 4;
          })),
          (KV = qV))
        ) || KV;
      class tj {
        constructor(t, e) {
          (this._result = new Ss()), (this._x = t), (this._y = e);
        }
        get requiresDefault() {
          return !this._x || !this._y;
        }
        evaluate(t, e) {
          return (
            e && Ss.copy(this._result, e),
            this._x && (this._result.x = this._x.evaluate(t)),
            this._y && (this._result.y = this._y.evaluate(t)),
            this._result
          );
        }
      }
      class ej {
        constructor(t, e, i) {
          (this._result = new Yi()),
            (this._x = t),
            (this._y = e),
            (this._z = i);
        }
        get requiresDefault() {
          return !this._x || !this._y || !this._z;
        }
        evaluate(t, e) {
          const { _x: i, _y: s, _z: n, _result: r } = this;
          return (
            e && Yi.copy(r, e),
            i && (r.x = i.evaluate(t)),
            s && (r.y = s.evaluate(t)),
            n && (r.z = n.evaluate(t)),
            r
          );
        }
      }
      class ij {
        constructor(t, e, i, s) {
          (this._result = new Wi()),
            (this._x = t),
            (this._y = e),
            (this._z = i),
            (this._w = s);
        }
        get requiresDefault() {
          return !(this._x && this._y && this._z && this._w);
        }
        evaluate(t, e) {
          return (
            e && Wi.copy(this._result, e),
            this._x && (this._result.x = this._x.evaluate(t)),
            this._y && (this._result.y = this._y.evaluate(t)),
            this._z && (this._result.z = this._z.evaluate(t)),
            this._w && (this._result.w = this._w.evaluate(t)),
            this._result
          );
        }
      }
      var sj;
      let nj =
        Ca("cc.animation.QuatTrack")(
          (sj = class extends cV {
            createCurve() {
              return new ul();
            }
            [hG]() {
              return new rj(this.channels()[0].curve);
            }
          })
        ) || sj;
      class rj {
        constructor(t) {
          (this._result = new as()), (this._curve = t);
        }
        get requiresDefault() {
          return !1;
        }
        evaluate(t) {
          return this._curve.evaluate(t, this._result), this._result;
        }
      }
      var aj, oj, hj;
      const lj = ["Red", "Green", "Blue", "Alpha"];
      let cj =
        Ca("cc.animation.ColorTrack")(
          ((oj = class extends hV {
            constructor() {
              super(),
                (this._channels = hj && hj()),
                (this._channels = new Array(4));
              for (let t = 0; t < this._channels.length; ++t) {
                const e = new lV(new wh());
                (e.name = lj[t]), (this._channels[t] = e);
              }
            }
            channels() {
              return this._channels;
            }
            [hG]() {
              return new uj(
                YV(this._channels[0].curve),
                YV(this._channels[1].curve),
                YV(this._channels[2].curve),
                YV(this._channels[3].curve)
              );
            }
          }),
          (hj = fa(oj.prototype, "_channels", [Na], null)),
          (aj = oj))
        ) || aj;
      class uj {
        constructor(t, e, i, s) {
          (this._result = new Qi()),
            (this._x = t),
            (this._y = e),
            (this._z = i),
            (this._w = s);
        }
        get requiresDefault() {
          return !(this._x && this._y && this._z && this._w);
        }
        evaluate(t, e) {
          return (
            e && Qi.copy(this._result, e),
            this._x && (this._result.r = this._x.evaluate(t)),
            this._y && (this._result.g = this._y.evaluate(t)),
            this._z && (this._result.b = this._z.evaluate(t)),
            this._w && (this._result.a = this._w.evaluate(t)),
            this._result
          );
        }
      }
      var _j, dj, pj;
      const mj = ["Width", "Height"];
      let fj =
        Ca("cc.animation.SizeTrack")(
          ((dj = class extends hV {
            constructor() {
              super(),
                (this._channels = pj && pj()),
                (this._channels = new Array(2));
              for (let t = 0; t < this._channels.length; ++t) {
                const e = new lV(new wh());
                (e.name = mj[t]), (this._channels[t] = e);
              }
            }
            channels() {
              return this._channels;
            }
            [hG]() {
              return new gj(
                YV(this._channels[0].curve),
                YV(this._channels[1].curve)
              );
            }
          }),
          (pj = fa(dj.prototype, "_channels", [Na], null)),
          (_j = dj))
        ) || _j;
      class gj {
        constructor(t, e) {
          (this._result = new ws()), (this._width = t), (this._height = e);
        }
        get requiresDefault() {
          return !this._width || !this._height;
        }
        evaluate(t, e) {
          return (
            e && ((this._result.x = e.x), (this._result.y = e.y)),
            this._width && (this._result.width = this._width.evaluate(t)),
            this._height && (this._result.height = this._height.evaluate(t)),
            this._result
          );
        }
      }
      var yj;
      let Tj =
        Ca("cc.animation.ObjectTrack")(
          (yj = class extends cV {
            createCurve() {
              return new vl();
            }
          })
        ) || yj;
      const Sj = Symbol("[[Owner]]");
      function Ej(t) {
        t[Sj];
      }
      let vj;
      !(function (t) {
        (t[(t.FLOAT = 0)] = "FLOAT"),
          (t[(t.BOOLEAN = 1)] = "BOOLEAN"),
          (t[(t.TRIGGER = 2)] = "TRIGGER"),
          (t[(t.INTEGER = 3)] = "INTEGER"),
          (t[(t.VEC3_experimental = 4)] = "VEC3_experimental"),
          (t[(t.QUAT_experimental = 5)] = "QUAT_experimental");
      })(vj || (vj = {}));
      const bj = Symbol("CreateInstance");
      class Aj {
        constructor(t) {
          (this._refs = []), (this.type = t);
        }
        bind(t, e, ...i) {
          return (
            this._refs.push({ fn: t, thisArg: e, args: i }), this.getValue()
          );
        }
        get value() {
          return this.getValue();
        }
        set value(t) {
          this.setValue(t);
          for (const { fn: e, thisArg: i, args: s } of this._refs)
            e.call(i, t, ...s);
        }
      }
      var Cj, Oj, Ij, wj;
      let Rj =
        Ca("cc.animation.PlainVariable")(
          ((Oj = class {
            constructor(t) {
              if (
                ((this._type = Ij && Ij()),
                (this._value = wj && wj()),
                void 0 !== t)
              )
                switch (((this._type = t), t)) {
                  default:
                    break;
                  case vj.FLOAT:
                  case vj.INTEGER:
                    this._value = 0;
                    break;
                  case vj.BOOLEAN:
                    this._value = !1;
                }
            }
            get type() {
              return this._type;
            }
            get value() {
              return this._value;
            }
            set value(t) {
              this._value = t;
            }
            [bj]() {
              return new Dj(this._type, this._value);
            }
          }),
          (Ij = fa(Oj.prototype, "_type", [Na], function () {
            return vj.FLOAT;
          })),
          (wj = fa(Oj.prototype, "_value", [Na], function () {
            return 0;
          })),
          (Cj = Oj))
        ) || Cj;
      class Dj extends Aj {
        constructor(t, e) {
          super(t), (this._value = void 0), (this._value = e);
        }
        getValue() {
          return this._value;
        }
        setValue(t) {
          this._value = t;
        }
      }
      var xj, Mj, Pj;
      let Nj;
      !(function (t) {
        (t[(t.AFTER_CONSUMED = 0)] = "AFTER_CONSUMED"),
          (t[(t.NEXT_FRAME_OR_AFTER_CONSUMED = 1)] =
            "NEXT_FRAME_OR_AFTER_CONSUMED");
      })(Nj || (Nj = {})),
        Nj.AFTER_CONSUMED;
      let Lj =
        Ca("cc.animation.TriggerVariable")(
          ((Mj = class {
            constructor() {
              this._flags = Pj && Pj();
            }
            get type() {
              return vj.TRIGGER;
            }
            get value() {
              return !!((1 & this._flags) >> 0);
            }
            set value(t) {
              t ? (this._flags |= 1) : (this._flags &= -2);
            }
            get resetMode() {
              return (6 & this._flags) >> 1;
            }
            set resetMode(t) {
              (this._flags &= -7), (this._flags |= t << 1);
            }
            [bj]() {
              return new Bj(this.value, this.resetMode);
            }
          }),
          (Pj = fa(Mj.prototype, "_flags", [Na], function () {
            return 0;
          })),
          (xj = Mj))
        ) || xj;
      class Bj extends Aj {
        constructor(t, e) {
          super(vj.TRIGGER),
            (this.resetMode = Nj.AFTER_CONSUMED),
            (this._value = void 0),
            (this.resetMode = e),
            (this._value = t);
        }
        getValue() {
          return this._value;
        }
        setValue(t) {
          this._value = t;
        }
      }
      var Fj, Uj, kj;
      let zj =
        Ca("cc.animation.Vec3Variable")(
          ((Uj = class {
            constructor() {
              this._value = kj && kj();
            }
            get type() {
              return vj.VEC3_experimental;
            }
            get value() {
              return this._value;
            }
            set value(t) {
              Yi.copy(this._value, t);
            }
            [bj]() {
              return new Hj(this.value);
            }
          }),
          (kj = fa(Uj.prototype, "_value", [Na], function () {
            return new Yi();
          })),
          (Fj = Uj))
        ) || Fj;
      class Hj extends Aj {
        constructor(t) {
          super(vj.VEC3_experimental),
            (this._value = new Yi()),
            Yi.copy(this._value, t);
        }
        getValue() {
          return this._value;
        }
        setValue(t) {
          Yi.copy(this._value, t);
        }
      }
      var Gj, Vj, jj;
      let Wj =
        Ca("cc.animation.QuatVariable")(
          ((Vj = class {
            constructor() {
              this._value = jj && jj();
            }
            get type() {
              return vj.QUAT_experimental;
            }
            get value() {
              return this._value;
            }
            set value(t) {
              as.copy(this._value, t);
            }
            [bj]() {
              return new Xj(this._value);
            }
          }),
          (jj = fa(Vj.prototype, "_value", [Na], function () {
            return new as();
          })),
          (Gj = Vj))
        ) || Gj;
      class Xj extends Aj {
        constructor(t) {
          super(vj.QUAT_experimental),
            (this._value = new as()),
            as.copy(this._value, t);
        }
        getValue() {
          return this._value;
        }
        setValue(t) {
          as.copy(this._value, t);
        }
      }
      class Yj extends Error {
        constructor(t) {
          super(`${t} transition is invalid`),
            (this.name = "TransitionRejectError");
        }
      }
      class Kj extends Error {
        constructor(t) {
          super(`Graph variable ${t} is not defined`);
        }
      }
      class qj extends Error {
        constructor(t, e, i) {
          super(
            `Expect graph variable ${t} to have type '${e}' instead of received '${
              null != i ? i : typeof i
            }'`
          );
        }
      }
      const $j = $n.Flags.Destroyed,
        Zj = $n.Flags.PersistentMask,
        Qj = [];
      function Jj(t) {
        let e;
        if (Zn(t)) {
          if (
            (function (t) {
              return "function" == typeof t._instantiate;
            })(t)
          )
            return (
              (a.game._isCloning = !0),
              (e = t._instantiate(null, !0)),
              (a.game._isCloning = !1),
              ic(e),
              e
            );
          if (t instanceof a.Asset) throw new TypeError(X(6903));
        }
        return (
          (a.game._isCloning = !0),
          (e = tW(t)),
          (a.game._isCloning = !1),
          ic(e),
          e
        );
      }
      function tW(t, e) {
        let i;
        (i = t._iN$t
          ? t._iN$t
          : t.constructor
          ? new (0, t.constructor)()
          : Object.create(null)),
          eW(t, i, e);
        for (let t = 0, e = Qj.length; t < e; ++t) Qj[t]._iN$t = null;
        return (Qj.length = 0), i;
      }
      function eW(t, e, i) {
        ft(t, "_iN$t", e, !0), Qj.push(t);
        const s = t.constructor;
        if (li(s))
          !(function (t, e, i, s) {
            const n = t.__values__;
            for (let t = 0; t < n.length; t++) {
              const r = n[t],
                a = e[r];
              if ("object" == typeof a && a) {
                const t = i[r];
                t instanceof pe && t.constructor === a.constructor
                  ? t.set(a)
                  : (i[r] = a._iN$t || iW(a, s));
              } else i[r] = a;
            }
          })(s, t, e, i);
        else
          for (const s in t) {
            if (
              !t.hasOwnProperty(s) ||
              (95 === s.charCodeAt(0) &&
                95 === s.charCodeAt(1) &&
                "__type__" !== s &&
                "__prefab" !== s)
            )
              continue;
            const n = t[s];
            if ("object" == typeof n && n) {
              if (n === e) continue;
              e[s] = n._iN$t || iW(n, i);
            } else e[s] = n;
          }
        Zn(t) && (e._objFlags &= Zj);
      }
      function iW(t, e) {
        if (t instanceof pe) return t.clone();
        if (t instanceof a.Asset) return t;
        let i;
        if (ArrayBuffer.isView(t)) {
          const e = t.length;
          (i = new t.constructor(e)), (t._iN$t = i), Qj.push(t);
          for (let s = 0; s < e; ++s) i[s] = t[s];
          return i;
        }
        if (Array.isArray(t)) {
          const s = t.length;
          (i = new Array(s)), (t._iN$t = i), Qj.push(t);
          for (let n = 0; n < s; ++n) {
            const s = t[n];
            i[n] = "object" == typeof s && s ? s._iN$t || iW(s, e) : s;
          }
          return i;
        }
        if (t._objFlags & $j) return null;
        const s = t.constructor;
        if (li(s)) {
          if (e)
            if (e instanceof np) {
              if (t instanceof Pf || t instanceof np) return t;
            } else if (e instanceof Pf)
              if (t instanceof Pf) {
                if (!t.isChildOf(e)) return t;
              } else if (t instanceof np && t.node && !t.node.isChildOf(e))
                return t;
          i = new s();
        } else if (s === Object) i = {};
        else {
          if (s) return t;
          i = Object.create(null);
        }
        return eW(t, i, e), i;
      }
      function sW(t) {
        const e = t[Kn];
        if ("object" == typeof e && e) {
          var i;
          const s = e;
          return null === (i = s.clone) || void 0 === i ? void 0 : i.call(s, t);
        }
      }
      var nW, rW, aW, oW, hW, lW;
      (Jj._clone = tW), (a.instantiate = Jj);
      const cW = Symbol("[[Outgoing transitions]]"),
        uW = Symbol("[[Incoming transitions]]"),
        { ccclass: _W, serializable: dW } = go;
      let pW =
          _W("cc.animation.State")(
            ((rW = class extends ho {
              constructor() {
                super(),
                  (this.name = aW && aW()),
                  (this[cW] = []),
                  (this[uW] = []);
              }
              copyTo(t) {
                (t.name = this.name), (t[Kn] = sW(this));
              }
            }),
            (aW = fa(rW.prototype, "name", [dW], function () {
              return "";
            })),
            (nW = rW))
          ) || nW,
        mW =
          _W("cc.animation.InteractiveState")(
            ((hW = class extends pW {
              constructor(...t) {
                super(...t), (this._components = lW && lW());
              }
              get components() {
                return this._components;
              }
              addComponent(t) {
                const e = new t();
                return this._components.push(e), e;
              }
              removeComponent(t) {
                te(this._components, t);
              }
              instantiateComponents() {
                return this._components.map((t) => Jj(t));
              }
              copyTo(t) {
                super.copyTo(t), (t._components = this.instantiateComponents());
              }
            }),
            (lW = fa(hW.prototype, "_components", [dW], function () {
              return [];
            })),
            (oW = hW))
          ) || oW;
      function fW(t, e, i) {
        const s = t.components,
          n = s.length;
        for (let t = 0; t < n; ++t) {
          const n = s[t],
            r = n[e];
          "function" == typeof r && r.apply(n, i);
        }
      }
      var gW, yW, TW;
      let SW =
        Ca("cc.animation.AnimationGraphEventBinding")(
          ((yW = class {
            constructor() {
              this.methodName = TW && TW();
            }
            get isBound() {
              return !!this.methodName;
            }
            emit(t) {
              this.methodName && fW(t, this.methodName, []);
            }
            copyTo(t) {
              return (t.methodName = this.methodName), this;
            }
          }),
          (TW = fa(yW.prototype, "methodName", [Na], function () {
            return "";
          })),
          (gW = yW))
        ) || gW;
      var EW, vW, bW, AW, CW, OW, IW, wW;
      let RW =
        Ca("cc.animation.Motion")(
          ((vW = class extends mW {
            constructor(...t) {
              super(...t),
                (this.motion = bW && bW()),
                (this.speed = AW && AW()),
                (this.speedMultiplier = CW && CW()),
                (this.speedMultiplierEnabled = OW && OW()),
                (this.transitionInEventBinding = IW && IW()),
                (this.transitionOutEventBinding = wW && wW());
            }
            __callOnAfterDeserializeRecursive() {
              var t;
              null === (t = this.motion) ||
                void 0 === t ||
                t.__callOnAfterDeserializeRecursive();
            }
            copyTo(t) {
              var e, i;
              return (
                super.copyTo(t),
                (t.motion =
                  null !==
                    (e =
                      null === (i = this.motion) || void 0 === i
                        ? void 0
                        : i.clone()) && void 0 !== e
                    ? e
                    : null),
                (t.speed = this.speed),
                (t.speedMultiplier = this.speedMultiplier),
                (t.speedMultiplierEnabled = this.speedMultiplierEnabled),
                this.transitionInEventBinding.copyTo(
                  t.transitionInEventBinding
                ),
                this.transitionOutEventBinding.copyTo(
                  t.transitionOutEventBinding
                ),
                this
              );
            }
          }),
          (bW = fa(vW.prototype, "motion", [Na], function () {
            return null;
          })),
          (AW = fa(vW.prototype, "speed", [Na], function () {
            return 1;
          })),
          (CW = fa(vW.prototype, "speedMultiplier", [Na], function () {
            return "";
          })),
          (OW = fa(vW.prototype, "speedMultiplierEnabled", [Na], function () {
            return !1;
          })),
          (IW = fa(vW.prototype, "transitionInEventBinding", [Na], function () {
            return new SW();
          })),
          (wW = fa(
            vW.prototype,
            "transitionOutEventBinding",
            [Na],
            function () {
              return new SW();
            }
          )),
          (EW = vW))
        ) || EW;
      const DW = Symbol("[[OnAfterDeserialized]]");
      var xW;
      let MW =
        Ca("cc.animation.AnimationGraphLike")((xW = class extends Ad {})) || xW;
      function PW(t, e, i) {
        const { propertyIsEnumerable: s } = Object.prototype;
        if (!s.call(t, e)) return t;
        if (i in t) return t;
        const n = {};
        return (
          "symbol" == typeof e
            ? (Object.entries(t).forEach(([t, e]) => {
                n[t] = e;
              }),
              Object.getOwnPropertySymbols(t).forEach((r) => {
                s.call(t, r) && (n[r === e ? i : r] = t[r]);
              }))
            : (Object.entries(t).forEach(([t, s]) => {
                n[t === e ? i : t] = s;
              }),
              Object.getOwnPropertySymbols(t).forEach((e) => {
                s.call(t, e) && (n[e] = t[e]);
              })),
          n
        );
      }
      const NW = (() => {
        let t = !1;
        try {
          class e {
            static [Symbol.hasInstance](t) {
              return Array.isArray(t);
            }
          }
          t = [] instanceof e;
        } catch {
          t = !1;
        }
        return t
          ? (t) => {
              function e() {
                throw new Error(
                  "This function can not be called as a constructor."
                );
              }
              return (
                Object.defineProperty(e, Symbol.hasInstance, {
                  value: (e) => e instanceof t,
                }),
                e
              );
            }
          : (t) => t;
      })();
      var LW, BW, FW, UW, kW, zW, HW, GW;
      let VW =
        Ca("cc.animation.PoseGraphNodeShell")(
          ((BW = class extends ho {
            constructor(...t) {
              super(...t), (this._bindings = FW && FW());
            }
            getBindings() {
              return this._bindings;
            }
            addBinding(t, e, i) {
              this._emplaceBinding(new XW(t, e, i));
            }
            deleteBinding(t) {
              const e = this._findBindingIndex(t);
              e >= 0 && this._bindings.splice(e, 1);
            }
            moveArrayElementBindingForward(t, e, i) {
              const { _bindings: s } = this,
                n = [];
              for (let i = 0; i < s.length; ++i) {
                const r = s[i],
                  [a, o = -1] = r.inputPath;
                a === t && o >= e && (n.push(r), s.splice(i, 1));
              }
              for (const t of n) {
                const [e, s = -1] = t.inputPath;
                this.addBinding(
                  [e, s + (i ? -1 : 1)],
                  t.producer,
                  t.outputIndex
                );
              }
            }
            deleteBindingTo(t) {
              const { _bindings: e } = this;
              for (let i = 0; i < e.length; ++i)
                e[i].producer === t && e.splice(i, 1);
            }
            findBinding(t) {
              const e = this._findBindingIndex(t);
              return e >= 0 ? this._bindings[e] : void 0;
            }
            _findBindingIndex(t) {
              return this._bindings.findIndex((e) => jW(e.inputPath, t));
            }
            _emplaceBinding(t) {
              const e = this._bindings.findIndex((e) =>
                jW(e.inputPath, t.inputPath)
              );
              e >= 0 ? (this._bindings[e] = t) : this._bindings.push(t);
            }
          }),
          (FW = fa(BW.prototype, "_bindings", [Na], function () {
            return [];
          })),
          (LW = BW))
        ) || LW;
      function jW(t, e) {
        const [i, s] = t,
          [n, r] = e;
        return i === n && s === r;
      }
      let WW,
        XW =
          Ca("cc.animation.PoseGraphNodeInputBinding")(
            ((kW = class {
              constructor(t, e, i) {
                (this._inputPath = zW && zW()),
                  (this._producer = HW && HW()),
                  (this._outputIndex = GW && GW()),
                  (this._inputPath = t),
                  (this._producer = e),
                  void 0 !== i && (this._outputIndex = i);
              }
              get inputPath() {
                return this._inputPath;
              }
              get producer() {
                return this._producer;
              }
              get outputIndex() {
                return this._outputIndex;
              }
            }),
            (zW = fa(kW.prototype, "_inputPath", [Na], null)),
            (HW = fa(kW.prototype, "_producer", [Na], null)),
            (GW = fa(kW.prototype, "_outputIndex", [Na], function () {
              return 0;
            })),
            (UW = kW))
          ) || UW;
      class YW extends Error {
        constructor(t) {
          super(
            `Can not add the specified ${t.toString()} since it has already been added into another graph.`
          );
        }
      }
      class KW extends Error {
        constructor(t) {
          super(
            `Can not perform specified operation on ${t.toString()} since it has not been added in to graph.`
          );
        }
      }
      !(function (t) {
        (t[(t.FLOAT = 0)] = "FLOAT"),
          (t[(t.INTEGER = 1)] = "INTEGER"),
          (t[(t.BOOLEAN = 2)] = "BOOLEAN"),
          (t[(t.VEC3 = 3)] = "VEC3"),
          (t[(t.QUAT = 4)] = "QUAT"),
          (t[(t.POSE = 5)] = "POSE");
      })(WW || (WW = {}));
      class qW extends ho {}
      const $W = new WeakMap();
      function ZW(t) {
        return (e) => {
          if (
            !Lt(e, qW) &&
            (R(
              "This kind of decorator should only be applied to pose graph node classes."
            ),
            1)
          )
            return;
          const i = (function (t) {
            const e = $W.get(t);
            if (e) return e;
            {
              const e = {};
              return $W.set(t, e), e;
            }
          })(e);
          t(i);
        };
      }
      const QW = (t) =>
        ZW((e) => {
          var i;
          Object.assign(
            null !== (i = e.appearance) && void 0 !== i
              ? i
              : (e.appearance = {}),
            t
          );
        });
      function JW(t, e, i, s) {
        const n = t.getShell(e);
        if (!n) throw new KW(e);
        const [r, a = -1] = i,
          o = e[r];
        Array.isArray(o) &&
          (o.splice(a, 0, s), n.moveArrayElementBindingForward(r, a + 1, !1));
      }
      function tX(t, e, i) {
        const s = t.getShell(e);
        if (!s) throw new KW(e);
        const [n, r = -1] = i,
          a = e[n];
        Array.isArray(a) &&
          (r < 0 ||
            r >= a.length ||
            (s.deleteBinding(i),
            a.splice(r, 1),
            s.moveArrayElementBindingForward(n, r + 1, !0)));
      }
      function eX(t) {
        switch (t) {
          default:
          case WW.FLOAT:
          case WW.INTEGER:
            return 0;
          case WW.BOOLEAN:
            return !1;
          case WW.POSE:
            return null;
          case WW.VEC3:
            return new Yi();
          case WW.QUAT:
            return new as();
        }
      }
      const iX = new (class {
        constructor() {
          this._classInputMap = new WeakMap();
        }
        setPropertyNodeInputRecord(t, e, i) {
          let s = this._classInputMap.get(t);
          s || ((s = { properties: {} }), this._classInputMap.set(t, s));
          const { arraySyncGroup: n, ...r } = i,
            a = r,
            o = i.arraySyncGroup;
          if (o) {
            var h, l;
            s.arraySyncGroups || (s.arraySyncGroups = {});
            const t =
              null !== (l = (h = s.arraySyncGroups)[o]) && void 0 !== l
                ? l
                : (h[o] = { members: [] });
            t.members.includes(e) || t.members.push(e), (a.arraySyncGroup = t);
          }
          s.properties[e] = Object.freeze(a);
        }
        getInputKeys(t) {
          const e = [],
            i = (s) => {
              if (!s) return;
              i(Nt(s));
              const n = this._classInputMap.get(s);
              if (n)
                for (const [i] of Object.entries(n.properties)) {
                  if (e.findIndex(([t]) => i === t) >= 0) continue;
                  const s = t[i];
                  if (Array.isArray(s))
                    for (let t = 0; t < s.length; ++t) e.push([i, t]);
                  else e.push([i]);
                }
            };
          return i(t.constructor), e;
        }
        isPoseInput(t, e) {
          const [i] = e,
            s = this._getPropertyNodeInputRecord(t.constructor, i);
          return !!s && s.type === WW.POSE;
        }
        getInputMetadata(t, e) {
          const [i, s = -1] = e,
            n = this._getPropertyNodeInputRecord(t.constructor, i);
          if (!n) return;
          const r = t[i];
          if (Array.isArray(r)) {
            if (s < 0 || s >= r.length) return;
            {
              var a, o;
              const e =
                null !==
                  (a =
                    null === (o = n.getArrayElementDisplayName) || void 0 === o
                      ? void 0
                      : o.call(t, s)) && void 0 !== a
                  ? a
                  : n.displayName;
              return {
                type: n.type,
                displayName: e,
                deletable: !(n.arraySyncGroup && n.arraySyncGroupFollower),
                insertPoint: !0,
              };
            }
          }
          return { type: n.type, displayName: n.displayName };
        }
        hasInput(t, e) {
          const [i, s = -1] = e;
          if (!this._getPropertyNodeInputRecord(t.constructor, i)) return !1;
          const n = t[i];
          return !Array.isArray(n) || !(s < 0 || s >= n.length);
        }
        getInputInsertInfos(t) {
          const e = {};
          for (let i = t.constructor; i; i = Nt(i)) {
            const s = this._classInputMap.get(i);
            if (s)
              for (const i in s.properties) {
                const n = s.properties[i],
                  r = t[i];
                if (Array.isArray(r)) {
                  if (n.arraySyncGroup && n.arraySyncGroupFollower) continue;
                  e[i] = { displayName: i };
                }
              }
          }
          return e;
        }
        deleteInput(t, e, i) {
          const [s, n = -1] = i,
            r = this._getPropertyNodeInputRecord(e.constructor, s);
          if (!r) return;
          const a = e[s];
          if (Array.isArray(a) && !(n < 0 || n >= a.length)) {
            {
              const { arraySyncGroup: i } = r;
              if (i)
                return void this._deleteInputInArraySyncGroup(
                  t,
                  e,
                  i,
                  a.length,
                  n
                );
            }
            tX(t, e, i);
          }
        }
        insertInput(t, e, i) {
          const s = i,
            n = this._getPropertyNodeInputRecord(e.constructor, s);
          if (!n) return;
          const r = e[s];
          if (!Array.isArray(r)) return;
          const a = r.length;
          {
            const { arraySyncGroup: i } = n;
            if (i)
              return void this._insertInputInArraySyncGroup(
                t,
                e,
                i,
                r.length,
                a
              );
          }
          JW(t, e, [s, a], eX(n.type));
        }
        _getPropertyNodeInputRecord(t, e) {
          if (!t) return;
          const i = this._classInputMap.get(t);
          if (i) {
            const t = i.properties[e];
            if (t) return t;
          }
          return this._getPropertyNodeInputRecord(Nt(t), e);
        }
        _insertInputInArraySyncGroup(t, e, i, s, n) {
          for (let r = 0; r < i.members.length; ++r) {
            const a = i.members[r],
              o = this._getPropertyNodeInputRecord(e.constructor, a),
              h = e[a];
            Array.isArray(h) && h.length === s && JW(t, e, [a, n], eX(o.type));
          }
        }
        _deleteInputInArraySyncGroup(t, e, i, s, n) {
          for (let r = 0; r < i.members.length; ++r) {
            const a = i.members[r];
            this._getPropertyNodeInputRecord(e.constructor, a);
            const o = e[a];
            Array.isArray(o) && o.length === s && tX(t, e, [a, n]);
          }
        }
      })();
      var sX;
      const nX = new Yi(),
        rX = new Yi(),
        aX = new as();
      new as();
      class oX {
        constructor() {
          (this._position = new Yi()),
            (this._rotation = new as()),
            (this._scale = Yi.clone(Yi.ONE));
        }
        get position() {
          return this._position;
        }
        set position(t) {
          Yi.copy(this._position, t);
        }
        get rotation() {
          return this._rotation;
        }
        set rotation(t) {
          as.copy(this._rotation, t);
        }
        get scale() {
          return this._scale;
        }
        set scale(t) {
          Yi.copy(this._scale, t);
        }
        static clone(t) {
          const e = new oX();
          return oX.copy(e, t), e;
        }
        static setIdentity(t) {
          return (
            Yi.copy(t._position, Yi.ZERO),
            as.copy(t._rotation, as.IDENTITY),
            Yi.copy(t._scale, Yi.ONE),
            t
          );
        }
        static copy(t, e) {
          return (
            Yi.copy(t._position, e._position),
            as.copy(t._rotation, e._rotation),
            Yi.copy(t._scale, e._scale),
            t
          );
        }
        static equals(t, e, i) {
          return (
            Yi.equals(t._position, e._position, i) &&
            as.equals(t._rotation, e._rotation, i) &&
            Yi.equals(t._scale, e._scale, i)
          );
        }
        static strictEquals(t, e) {
          return (
            Yi.strictEquals(t._position, e._position) &&
            as.strictEquals(t._rotation, e._rotation) &&
            Yi.strictEquals(t._scale, e._scale)
          );
        }
        static lerp(t, e, i, s) {
          return 0 === s
            ? oX.copy(t, e)
            : 1 === s
            ? oX.copy(t, i)
            : (Yi.lerp(t._position, e._position, i._position, s),
              as.slerp(t._rotation, e._rotation, i._rotation, s),
              Yi.lerp(t._scale, e._scale, i._scale, s),
              t);
        }
        static multiply(t, e, i) {
          const s = as.multiply(aX, e._rotation, i._rotation),
            n = Yi.multiply(nX, i._scale, e._scale),
            r = Yi.multiply(rX, i._position, e._scale);
          return (
            Yi.transformQuat(r, r, e._rotation),
            Yi.add(r, r, e._position),
            Yi.copy(t._position, r),
            as.copy(t._rotation, s),
            Yi.copy(t._scale, n),
            t
          );
        }
        static invert(t, e) {
          const { _rotation: i, _scale: s, _position: n } = t;
          return (
            as.invert(i, e._rotation),
            hX(s, e._scale, gi),
            Yi.negate(n, e._position),
            Yi.multiply(n, n, s),
            Yi.transformQuat(n, n, i),
            t
          );
        }
        static fromMatrix(t, e) {
          return ms.toSRT(e, t._rotation, t._position, t._scale), t;
        }
        static toMatrix(t, e) {
          return ms.fromSRT(t, e._rotation, e._position, e._scale);
        }
      }
      function hX(t, e, i) {
        const { x: s, y: n, z: r } = e;
        return Yi.set(
          t,
          Math.abs(s) <= i ? 0 : 1 / s,
          Math.abs(n) <= i ? 0 : 1 / n,
          Math.abs(r) <= i ? 0 : 1 / r
        );
      }
      (sX = oX),
        (oX.IDENTITY = Object.freeze(new sX())),
        (oX.ZERO = Object.freeze(
          (() => {
            const t = new sX();
            return (
              Yi.copy(t._position, Yi.ZERO),
              as.set(t._rotation, 0, 0, 0, 0),
              Yi.copy(t._scale, Yi.ZERO),
              t
            );
          })()
        )),
        (oX.calculateRelative = (() => {
          const t = new as(),
            e = new Yi();
          return (i, s, n) => {
            const r = as.invert(t, n._rotation),
              a = hX(e, n._scale, gi),
              o = Yi.subtract(rX, s._position, n._position);
            return (
              Yi.transformQuat(o, o, r),
              Yi.multiply(o, o, a),
              Yi.copy(i._position, o),
              as.multiply(i._rotation, r, s._rotation),
              Yi.multiply(i._scale, s._scale, a),
              i
            );
          };
        })());
      const lX = (() => {
          const t = new as();
          return (e, i, s, n) => {
            Yi.scaleAndAdd(e.position, i.position, s.position, n);
            const r = as.slerp(t, as.IDENTITY, s.rotation, n);
            return (
              as.multiply(e.rotation, r, i.rotation),
              Yi.scaleAndAdd(e.scale, i.scale, s.scale, n),
              e
            );
          };
        })(),
        cX = (() => {
          const t = new as();
          return (e, i, s) => {
            const n = as.invert(t, i);
            return as.multiply(e, s, n);
          };
        })(),
        uX = Object.freeze(
          (() => {
            const t = new oX();
            return (
              (t.position = Yi.ZERO),
              (t.rotation = as.IDENTITY),
              (t.scale = Yi.ZERO),
              t
            );
          })()
        );
      class _X {
        constructor(t, e) {
          (this.transforms = void 0),
            (this.auxiliaryCurves = void 0),
            (this._poseTransformSpace = dX.LOCAL),
            (this.transforms = t),
            (this.auxiliaryCurves = e);
        }
        static _create(t, e) {
          return new _X(t, e);
        }
      }
      let dX;
      !(function (t) {
        (t[(t.LOCAL = 0)] = "LOCAL"), (t[(t.COMPONENT = 1)] = "COMPONENT");
      })(dX || (dX = {}));
      class pX {
        constructor(t) {
          this._involvedTransforms = new Uint16Array(t);
        }
        get involvedTransforms() {
          return this._involvedTransforms;
        }
      }
      function mX(t, e, i, s) {
        !(function (t, e, i, s) {
          const n = t.length;
          if ((t.length, 0 !== i))
            if (1 !== i)
              if (s)
                for (let n = 0; n < s.involvedTransforms.length; ++n) {
                  const r = s.involvedTransforms[n];
                  fX(t, e, i, r);
                }
              else for (let s = 0; s < n; ++s) fX(t, e, i, s);
            else
              s
                ? (function (t, e, i) {
                    t.length, t.length;
                    for (let s = 0; s < i.involvedTransforms.length; ++s) {
                      const n = i.involvedTransforms[s];
                      t.copyRange(n, e, n, 1);
                    }
                  })(t, e, s)
                : t.set(e);
        })(t.transforms, e.transforms, i, s),
          (function (t, e, i) {
            const s = e.length;
            t.length;
            for (let n = 0; n < s; ++n) t[n] = vi(t[n], e[n], i);
          })(t.auxiliaryCurves, e.auxiliaryCurves, i);
      }
      const fX = (() => {
        const t = new oX(),
          e = new oX();
        return (i, s, n, r) => {
          const a = i.getTransform(r, e),
            o = s.getTransform(r, t);
          oX.lerp(a, a, o, n), i.setTransform(r, a);
        };
      })();
      const gX = (() => {
        const t = new oX(),
          e = new oX();
        return (i, s, n) => {
          const r = s.getTransform(n, t),
            a = i.getTransform(n, e);
          !(function (t, e, i) {
            Yi.subtract(t.position, e.position, i.position),
              cX(t.rotation, i.rotation, e.rotation),
              Yi.subtract(t.scale, e.scale, i.scale);
          })(a, a, r),
            i.setTransform(n, a);
        };
      })();
      function yX(t, e, i, s) {
        !(function (t, e, i, s) {
          const n = t.length;
          if ((e.length, s))
            for (let n = 0; n < s.involvedTransforms.length; ++n) {
              const r = s.involvedTransforms[n];
              TX(t, e, i, r);
            }
          else for (let s = 0; s < n; ++s) TX(t, e, i, s);
        })(t.transforms, e.transforms, i, s),
          (function (t, e, i) {
            t.length, e.length;
            for (let s = 0; s < t.length; ++s) t[s] += e[s] * i;
          })(t.auxiliaryCurves, e.auxiliaryCurves, i);
      }
      const TX = (() => {
        const t = new oX(),
          e = new oX();
        return (i, s, n, r) => {
          const a = s.getTransform(r, t),
            o = i.getTransform(r, e);
          lX(o, o, a, n), i.setTransform(r, o);
        };
      })();
      var SX;
      let EX;
      !(function (t) {
        (t[(t.NO = 0)] = "NO"),
          (t[(t.LOCAL = 1)] = "LOCAL"),
          (t[(t.COMPONENT = 2)] = "COMPONENT");
      })(EX || (EX = {})),
        de(EX);
      let vX =
        Ca("cc.animation.PoseNode")(
          (SX = class extends qW {
            constructor(...t) {
              super(...t), (this._dependencyEvaluation = void 0);
            }
            update(t) {
              var e;
              null === (e = this._dependencyEvaluation) ||
                void 0 === e ||
                e.evaluate(),
                this.doUpdate(t);
            }
            evaluate(t, e) {
              const i = this.doEvaluate(t),
                s = i._poseTransformSpace;
              switch (e) {
                default:
                case EX.NO:
                  break;
                case EX.LOCAL:
                  s === dX.COMPONENT &&
                    t._poseTransformsSpaceComponentToLocal(i),
                    i._poseTransformSpace,
                    dX.LOCAL;
                  break;
                case EX.COMPONENT:
                  s === dX.LOCAL && t._poseTransformsSpaceLocalToComponent(i),
                    i._poseTransformSpace,
                    dX.COMPONENT;
              }
              return i;
            }
            static evaluateDefaultPose(t, e) {
              switch (e) {
                default:
                case EX.NO:
                case EX.LOCAL:
                  return t.pushDefaultedPose();
                case EX.COMPONENT:
                  return t.pushDefaultedPoseInComponentSpace();
              }
            }
            _setDependencyEvaluation(t) {
              this._dependencyEvaluation = t;
            }
            _forceEvaluateEvaluation() {
              var t;
              null === (t = this._dependencyEvaluation) ||
                void 0 === t ||
                t.evaluate();
            }
          })
        ) || SX;
      class bX extends qW {
        constructor(t) {
          super(), (this._outputTypes = []), (this._outputTypes = t);
        }
        get outputCount() {
          return this._outputTypes.length;
        }
        getOutputType(t) {
          return this._outputTypes[t];
        }
        link(t) {}
      }
      function AX(t) {
        return (e, i) => {
          const s = e.constructor;
          t.type !== WW.POSE || Lt(s, vX)
            ? Lt(s, vX) || Lt(s, bX)
              ? CX(t)(e, i)
              : R(
                  "@input can be only applied to fields of subclasses of PoseNode or PureValueNode."
                )
            : R(
                "@input specifying pose input can be only applied to fields of subclasses of PoseNode."
              );
        };
      }
      function CX(t) {
        return (e, i) => {
          if ("string" != typeof i)
            return void R("@input can be only applied to string-named fields.");
          const s = e.constructor;
          iX.setPropertyNodeInputRecord(s, i, t),
            (xa(e, i).__internalFlags |= $e.STANDALONE | $e.IMPLICIT_VISIBLE);
        };
      }
      var OX, IX, wX, RX, DX, xX;
      let MX =
        ((OX = Ca("cc.animation.PoseGraphOutputNode")),
        (IX = QW({ themeColor: "#CD3A58", inline: !0 })),
        (wX = CX({ type: WW.POSE })),
        OX(
          (RX =
            IX(
              ((xX = s(
                (DX = class extends qW {
                  constructor(...t) {
                    super(...t), i(this, "pose", xX, this);
                  }
                }).prototype,
                "pose",
                [Na, wX],
                {
                  configurable: !0,
                  enumerable: !0,
                  writable: !0,
                  initializer: function () {
                    return null;
                  },
                }
              )),
              (RX = DX))
            ) || RX)
        ) || RX);
      var PX, NX, LX, BX, FX, UX;
      let kX =
        Ca("cc.animation.PoseGraph")(
          ((NX = class extends ho {
            constructor() {
              super(),
                (this._outputNode = LX && LX()),
                (this._nodes = BX && BX()),
                (this._shells = FX && FX()),
                (this._shellMap = UX && UX()),
                this.addNode(this._outputNode);
            }
            get outputNode() {
              return this._outputNode;
            }
            __callOnAfterDeserializeRecursive() {
              this._nodes.length, this._shells.length;
              for (let e = 0; e < this._nodes.length; ++e) {
                var t;
                const i = this._nodes[e],
                  s = this._shells[e];
                this._shellMap.set(i, s),
                  null === (t = i.__callOnAfterDeserializeRecursive) ||
                    void 0 === t ||
                    t.call(i);
              }
            }
            nodes() {
              return this._nodes.values();
            }
            addNode(t) {
              if (this._shellMap.has(t)) throw new YW(t);
              const e = new VW();
              return (
                this._shells.push(e),
                this._nodes.push(t),
                this._shellMap.set(t, e),
                t
              );
            }
            removeNode(t) {
              if (t === this._outputNode)
                return void R("Can not remove the output node.");
              const e = this._nodes.indexOf(t);
              if (!(e < 0)) {
                this._shellMap.has(t);
                for (const e of this._shells) e.deleteBindingTo(t);
                Qt(this._shells, e),
                  Qt(this._nodes, e),
                  this._shellMap.delete(t);
              }
            }
            getShell(t) {
              return this._shellMap.get(t);
            }
          }),
          (LX = fa(NX.prototype, "_outputNode", [Na], function () {
            return new MX();
          })),
          (BX = fa(NX.prototype, "_nodes", [Na], function () {
            return [];
          })),
          (FX = fa(NX.prototype, "_shells", [Na], function () {
            return [];
          })),
          (UX = fa(NX.prototype, "_shellMap", [Na], function () {
            return new Map();
          })),
          (PX = NX))
        ) || PX;
      var zX,
        HX,
        GX,
        VX,
        jX,
        WX,
        XX,
        YX,
        KX,
        qX,
        $X,
        ZX,
        QX,
        JX,
        tY,
        eY,
        iY,
        sY,
        nY,
        rY,
        aY,
        oY,
        hY,
        lY,
        cY,
        uY,
        _Y,
        dY,
        pY,
        mY,
        fY,
        gY,
        yY,
        TY,
        SY,
        EY,
        vY,
        bY,
        AY,
        CY,
        OY,
        IY,
        wY,
        RY,
        DY,
        xY,
        MY,
        PY,
        NY,
        LY,
        BY,
        FY,
        UY,
        kY;
      let zY =
          Ca("cc.animation.Transition")(
            ((HX = class extends ho {
              constructor(t, e, i) {
                super(),
                  (this.from = GX && GX()),
                  (this.to = VX && VX()),
                  (this.conditions = jX && jX()),
                  (this[Sj] = void 0),
                  (this.from = t),
                  (this.to = e),
                  i && (this.conditions = i);
              }
              copyTo(t) {
                t.conditions = this.conditions.map((t) => t.clone());
              }
            }),
            (GX = fa(HX.prototype, "from", [Na], null)),
            (VX = fa(HX.prototype, "to", [Na], null)),
            (jX = fa(HX.prototype, "conditions", [Na], function () {
              return [];
            })),
            (zX = HX))
          ) || zX,
        HY =
          Ca("cc.animation.DurationalTransition")(
            ((XX = class extends zY {
              constructor(...t) {
                super(...t),
                  (this.destinationStart = YX && YX()),
                  (this.relativeDestinationStart = KX && KX()),
                  (this.startEventBinding = qX && qX()),
                  (this.endEventBinding = $X && $X()),
                  (this[Sj] = void 0);
              }
              copyTo(t) {
                super.copyTo(t),
                  (t.destinationStart = this.destinationStart),
                  (t.relativeDestinationStart = this.relativeDestinationStart),
                  this.startEventBinding.copyTo(t.startEventBinding),
                  this.endEventBinding.copyTo(t.endEventBinding);
              }
            }),
            (YX = fa(XX.prototype, "destinationStart", [Na], function () {
              return 0;
            })),
            (KX = fa(
              XX.prototype,
              "relativeDestinationStart",
              [Na],
              function () {
                return !1;
              }
            )),
            (qX = fa(XX.prototype, "startEventBinding", [Na], function () {
              return new SW();
            })),
            ($X = fa(XX.prototype, "endEventBinding", [Na], function () {
              return new SW();
            })),
            (WX = XX))
          ) || WX,
        GY =
          Ca("cc.animation.AnimationTransition")(
            ((QX = class extends HY {
              constructor(...t) {
                super(...t),
                  (this.duration = JX && JX()),
                  (this.relativeDuration = tY && tY()),
                  (this.exitConditionEnabled = eY && eY()),
                  (this._exitCondition = iY && iY());
              }
              get exitCondition() {
                return this._exitCondition;
              }
              set exitCondition(t) {
                this._exitCondition = t;
              }
              copyTo(t) {
                super.copyTo(t),
                  (t.duration = this.duration),
                  (t.relativeDuration = this.relativeDuration),
                  (t.exitConditionEnabled = this.exitConditionEnabled),
                  (t.exitCondition = this.exitCondition);
              }
            }),
            (JX = fa(QX.prototype, "duration", [Na], function () {
              return 0.3;
            })),
            (tY = fa(QX.prototype, "relativeDuration", [Na], function () {
              return !1;
            })),
            (eY = fa(QX.prototype, "exitConditionEnabled", [Na], function () {
              return !0;
            })),
            (iY = fa(QX.prototype, "_exitCondition", [Na], function () {
              return 1;
            })),
            (ZX = QX))
          ) || ZX;
      function VY(t) {
        return t instanceof GY;
      }
      let jY = Ca("cc.animation.EmptyState")((sY = class extends pW {})) || sY,
        WY =
          Ca("cc.animation.EmptyStateTransition")(
            ((rY = class extends HY {
              constructor(...t) {
                super(...t), (this.duration = aY && aY());
              }
              copyTo(t) {
                super.copyTo(t), (t.duration = this.duration);
              }
            }),
            (aY = fa(rY.prototype, "duration", [Na], function () {
              return 0.3;
            })),
            (nY = rY))
          ) || nY,
        XY =
          Ca("cc.animation.ProceduralPoseState")(
            ((hY = class extends pW {
              constructor(...t) {
                super(...t),
                  (this.graph = lY && lY()),
                  (this.transitionInEventBinding = cY && cY()),
                  (this.transitionOutEventBinding = uY && uY());
              }
              __callOnAfterDeserializeRecursive() {
                this.graph.__callOnAfterDeserializeRecursive();
              }
              copyTo(t) {
                return (
                  super.copyTo(t),
                  this.transitionInEventBinding.copyTo(
                    t.transitionInEventBinding
                  ),
                  this.transitionOutEventBinding.copyTo(
                    t.transitionOutEventBinding
                  ),
                  this
                );
              }
            }),
            (lY = fa(hY.prototype, "graph", [Na], function () {
              return new kX();
            })),
            (cY = fa(
              hY.prototype,
              "transitionInEventBinding",
              [Na],
              function () {
                return new SW();
              }
            )),
            (uY = fa(
              hY.prototype,
              "transitionOutEventBinding",
              [Na],
              function () {
                return new SW();
              }
            )),
            (oY = hY))
          ) || oY;
      const YY = NW(XY);
      let KY =
        Ca("cc.animation.ProceduralPoseTransition")(
          ((dY = class extends HY {
            constructor(...t) {
              super(...t), (this.duration = pY && pY());
            }
            copyTo(t) {
              super.copyTo(t), (t.duration = this.duration);
            }
          }),
          (pY = fa(dY.prototype, "duration", [Na], function () {
            return 0.3;
          })),
          (_Y = dY))
        ) || _Y;
      const qY = NW(KY);
      let $Y,
        ZY =
          Ca("cc.animation.StateMachine")(
            ((fY = class t extends ho {
              __callOnAfterDeserializeRecursive() {
                this[DW]();
                const t = this._states.length;
                for (let e = 0; e < t; ++e) {
                  const t = this._states[e];
                  t instanceof QY
                    ? t.stateMachine.__callOnAfterDeserializeRecursive()
                    : (t instanceof XY || t instanceof RW) &&
                      t.__callOnAfterDeserializeRecursive();
                }
              }
              constructor(t) {
                super(),
                  (this._states = gY && gY()),
                  (this._transitions = yY && yY()),
                  (this._entryState = TY && TY()),
                  (this._exitState = SY && SY()),
                  (this._anyState = EY && EY()),
                  (this._allowEmptyStates = !0),
                  (this._allowEmptyStates = null != t && t),
                  (this._entryState = this._addState(new pW())),
                  (this._entryState.name = "Entry"),
                  (this._exitState = this._addState(new pW())),
                  (this._exitState.name = "Exit"),
                  (this._anyState = this._addState(new pW())),
                  (this._anyState.name = "Any");
              }
              [DW]() {
                this._states.forEach(() => {}),
                  this._transitions.forEach((t) => {
                    t.from[cW].push(t), t.to[uW].push(t);
                  });
              }
              get allowEmptyStates() {
                return this._allowEmptyStates;
              }
              get entryState() {
                return this._entryState;
              }
              get exitState() {
                return this._exitState;
              }
              get anyState() {
                return this._anyState;
              }
              states() {
                return this._states;
              }
              transitions() {
                return this._transitions;
              }
              getTransitionsBetween(t, e) {
                return Ej(t), Ej(e), t[cW].filter((t) => t.to === e);
              }
              getOutgoings(t) {
                return Ej(t), t[cW];
              }
              getIncomings(t) {
                return Ej(t), t[uW];
              }
              addMotion() {
                return this._addState(new RW());
              }
              addSubStateMachine() {
                return this._addState(new QY(this._allowEmptyStates));
              }
              addEmpty() {
                if (!this._allowEmptyStates)
                  throw new Error(
                    "Empty states are now allowed in this state machine."
                  );
                return this._addState(new jY());
              }
              addProceduralPoseState() {
                return this._addState(new XY());
              }
              remove(t) {
                Ej(t),
                  t !== this.entryState &&
                    t !== this.exitState &&
                    t !== this.anyState &&
                    (this.eraseTransitionsIncludes(t), te(this._states, t));
              }
              connect(t, e, i) {
                if ((Ej(t), Ej(e), e === this.entryState))
                  throw new Yj("to-entry");
                if (e === this.anyState) throw new Yj("to-any");
                if (t === this.exitState) throw new Yj("from-exit");
                const s =
                  t instanceof RW || t === this._anyState
                    ? new GY(t, e, i)
                    : t instanceof jY
                    ? new WY(t, e, i)
                    : t instanceof XY
                    ? new KY(t, e, i)
                    : new zY(t, e, i);
                return (
                  this._transitions.push(s), t[cW].push(s), e[uW].push(s), s
                );
              }
              disconnect(t, e) {
                Ej(t), Ej(e);
                const i = t[cW],
                  s = e[uW],
                  n = this._transitions,
                  r = i.filter((t) => t.to === e),
                  a = r.length;
                for (let t = 0; t < a; ++t) {
                  const e = r[t];
                  te(i, e), te(n, e), ie(s, (t) => t === e);
                }
              }
              removeTransition(t) {
                te(this._transitions, t),
                  ie(t.from[cW], (e) => e === t),
                  ie(t.to[uW], (e) => e === t);
              }
              eraseOutgoings(t) {
                Ej(t);
                const e = t[cW];
                for (let t = 0; t < e.length; ++t) {
                  const i = e[t],
                    s = i.to;
                  te(this._transitions, i), ie(s[uW], (t) => t === i);
                }
                e.length = 0;
              }
              eraseIncomings(t) {
                Ej(t);
                const e = t[uW];
                for (let t = 0; t < e.length; ++t) {
                  const i = e[t],
                    s = i.from;
                  te(this._transitions, i), ie(s[cW], (t) => t === i);
                }
                e.length = 0;
              }
              eraseTransitionsIncludes(t) {
                this.eraseIncomings(t), this.eraseOutgoings(t);
              }
              adjustTransitionPriority(t, e) {
                const { from: i } = t;
                if (0 === e) return;
                const s = i[cW],
                  n = s.indexOf(t),
                  r = Si(n + e, 0, s.length - 1);
                {
                  const { _transitions: e } = this;
                  let i = e.indexOf(t);
                  if (r > n)
                    for (let t = n + 1; t <= r; ++t) {
                      const n = s[t],
                        r = e.indexOf(n);
                      (e[i] = n), (i = r);
                    }
                  else if (n > r)
                    for (let t = n - 1; t >= r; --t) {
                      const n = s[t],
                        r = e.indexOf(n);
                      (e[i] = n), (i = r);
                    }
                  e[i] = t;
                }
                nc(s, n, r);
              }
              copyTo(t) {
                const e = t._states.filter((e) => {
                  switch (e) {
                    case t._entryState:
                    case t._exitState:
                    case t._anyState:
                      return !0;
                    default:
                      return !1;
                  }
                });
                for (const i of e) t.remove(i);
                const i = new Map();
                for (const e of this._states)
                  switch (e) {
                    case this._entryState:
                      i.set(e, t._entryState);
                      break;
                    case this._exitState:
                      i.set(e, t._exitState);
                      break;
                    case this._anyState:
                      i.set(e, t._anyState);
                      break;
                    default:
                      if (
                        e instanceof RW ||
                        e instanceof QY ||
                        e instanceof jY ||
                        e instanceof XY
                      ) {
                        if (e instanceof jY && !t._allowEmptyStates) continue;
                        const s = Jj(e);
                        t._addState(s), i.set(e, s);
                      }
                  }
                for (const e of this._transitions) {
                  if (
                    !t._allowEmptyStates &&
                    (e.from instanceof jY || e.to instanceof jY)
                  )
                    continue;
                  const s = i.get(e.from),
                    n = i.get(e.to),
                    r = t.connect(s, n);
                  (r.conditions = e.conditions.map((t) => t.clone())),
                    e.copyTo(r);
                }
              }
              clone() {
                const e = new t(this._allowEmptyStates);
                return this.copyTo(e), e;
              }
              _addState(t) {
                return this._states.push(t), t;
              }
            }),
            (gY = fa(fY.prototype, "_states", [Na], function () {
              return [];
            })),
            (yY = fa(fY.prototype, "_transitions", [Na], function () {
              return [];
            })),
            (TY = fa(fY.prototype, "_entryState", [Na], null)),
            (SY = fa(fY.prototype, "_exitState", [Na], null)),
            (EY = fa(fY.prototype, "_anyState", [Na], null)),
            (mY = fY))
          ) || mY,
        QY =
          Ca("cc.animation.SubStateMachine")(
            ((bY = class extends mW {
              constructor(t) {
                super(),
                  (this._stateMachine = AY && AY()),
                  (this._stateMachine = new ZY(t));
              }
              get stateMachine() {
                return this._stateMachine;
              }
              copyTo(t) {
                super.copyTo(t), this._stateMachine.copyTo(t._stateMachine);
              }
            }),
            (AY = fa(bY.prototype, "_stateMachine", [Na], null)),
            (vY = bY))
          ) || vY,
        JY =
          Ca("cc.animation.PoseGraphStash")(
            ((OY = class extends ho {
              constructor(...t) {
                super(...t), (this.graph = IY && IY());
              }
            }),
            (IY = fa(OY.prototype, "graph", [Na], function () {
              return new kX();
            })),
            (CY = OY))
          ) || CY,
        tK =
          Ca("cc.animation.Layer")(
            ((RY = class {
              __callOnAfterDeserializeRecursive() {
                (this.stateMachine._allowEmptyStates = !0),
                  this.stateMachine.__callOnAfterDeserializeRecursive();
                for (const t in this._stashes)
                  this._stashes[t].graph.__callOnAfterDeserializeRecursive();
              }
              stashes() {
                return Object.entries(this._stashes);
              }
              getStash(t) {
                return this._stashes[t];
              }
              addStash(t) {
                return (this._stashes[t] = new JY());
              }
              removeStash(t) {
                delete this._stashes[t];
              }
              renameStash(t, e) {
                this._stashes = PW(this._stashes, t, e);
              }
              constructor() {
                (this[Sj] = void 0),
                  (this._stateMachine = DY && DY()),
                  (this.name = xY && xY()),
                  (this.weight = MY && MY()),
                  (this.mask = PY && PY()),
                  (this.additive = NY && NY()),
                  (this._stashes = LY && LY()),
                  (this._stateMachine = new ZY(!0));
              }
              get stateMachine() {
                return this._stateMachine;
              }
            }),
            (DY = fa(RY.prototype, "_stateMachine", [Na], null)),
            (xY = fa(RY.prototype, "name", [Na], function () {
              return "";
            })),
            (MY = fa(RY.prototype, "weight", [Na], function () {
              return 1;
            })),
            (PY = fa(RY.prototype, "mask", [Na], function () {
              return null;
            })),
            (NY = fa(RY.prototype, "additive", [Na], function () {
              return !1;
            })),
            (LY = fa(RY.prototype, "_stashes", [Na], function () {
              return {};
            })),
            (wY = RY))
          ) || wY;
      !(function (t) {
        (t[(t.override = 0)] = "override"), (t[(t.additive = 1)] = "additive");
      })($Y || ($Y = {}));
      let eK =
        Ca("cc.animation.AnimationGraph")(
          ((FY = class extends MW {
            constructor() {
              super(),
                (this._layers = UY && UY()),
                (this._variables = kY && kY());
            }
            onLoaded() {
              const { _layers: t } = this,
                e = t.length;
              for (let i = 0; i < e; ++i)
                t[i].__callOnAfterDeserializeRecursive();
            }
            get layers() {
              return this._layers;
            }
            get variables() {
              return Object.entries(this._variables);
            }
            addLayer() {
              const t = new tK();
              return this._layers.push(t), t;
            }
            removeLayer(t) {
              Qt(this._layers, t);
            }
            moveLayer(t, e) {
              nc(this._layers, t, e);
            }
            addVariable(t, e, i) {
              const s = (function (t, e) {
                let i;
                switch (t) {
                  case vj.FLOAT:
                  case vj.INTEGER:
                  case vj.BOOLEAN:
                    i = new Rj(t);
                    break;
                  case vj.TRIGGER:
                    i = new Lj();
                    break;
                  case vj.VEC3_experimental:
                    i = new zj();
                    break;
                  case vj.QUAT_experimental:
                    i = new Wj();
                    break;
                  default:
                    throw new Error(`Unknown variable type ${t}`);
                }
                return void 0 !== e && (i.value = e), i;
              })(e, i);
              return (this._variables[t] = s), s;
            }
            removeVariable(t) {
              delete this._variables[t];
            }
            getVariable(t) {
              return this._variables[t];
            }
            renameVariable(t, e) {
              this._variables = PW(this._variables, t, e);
            }
          }),
          (UY = fa(FY.prototype, "_layers", [Na], function () {
            return [];
          })),
          (kY = fa(FY.prototype, "_variables", [Na], function () {
            return {};
          })),
          (BY = FY))
        ) || BY;
      const iK = Symbol("[[createEval]]");
      var sK;
      let nK =
        Ca("cc.animation.MotionBase")(
          (sK = class extends ho {
            __callOnAfterDeserializeRecursive() {}
          })
        ) || sK;
      const rK = Symbol("BakeNodeCurves");
      class aK {
        static getOrExtract(t) {
          let e = aK.pool.get(t);
          if (!e || e.samples !== t.sample) {
            e && a.director.root.dataPoolManager.releaseAnimationClip(t);
            const i = Math.ceil(t.sample * t.duration) + 1,
              s = t.sample;
            (e = t[rK](0, s, i)), aK.pool.set(t, e);
          }
          return e;
        }
        static destroy(t) {
          aK.pool.delete(t);
        }
      }
      t("SkelAnimDataHub", aK), (aK.pool = new Map());
      class oK {
        constructor(t) {
          let e, i;
          (this.ratios = void 0), (this._findRatio = void 0), (this.ratios = t);
          let s = !0;
          for (let n = 1, r = t.length; n < r; n++)
            if (((e = t[n] - t[n - 1]), 1 === n)) i = e;
            else if (Math.abs(e - i) > 1e-6) {
              s = !1;
              break;
            }
          this._findRatio = s ? uK : la;
        }
        sample(t) {
          return this._findRatio(this.ratios, t);
        }
      }
      t("RatioSampler", oK), (a.RatioSampler = oK);
      class hK {
        static Bezier(t) {
          return t;
        }
        constructor(t, e) {
          (this.types = void 0),
            (this.type = null),
            (this._values = []),
            (this._lerp = void 0),
            (this._duration = void 0),
            (this._array = void 0),
            (this._duration = e),
            (this._values = t.values);
          const i = (t) =>
            "string" == typeof t
              ? t
              : Array.isArray(t)
              ? t[0] === t[1] && t[2] === t[3]
                ? hK.Linear
                : hK.Bezier(t)
              : hK.Linear;
          if (void 0 !== t.easingMethod) this.type = i(t.easingMethod);
          else if (Array.isArray(t.easingMethods))
            this.types = t.easingMethods.map(i);
          else if (void 0 !== t.easingMethods) {
            this.types = new Array(this._values.length).fill(null);
            for (const e of Object.keys(t.easingMethods))
              this.types[e] = i(t.easingMethods[e]);
          } else this.type = null;
          const s = t.values[0];
          (void 0 === t.interpolate || t.interpolate) && (this._lerp = _K(s)),
            void 0 !== t._arrayLength &&
              (this._array = new Array(t._arrayLength));
        }
        hasLerp() {
          return !!this._lerp;
        }
        valueAt(t) {
          if (void 0 === this._array) {
            const e = this._values[t];
            return e && e.getNoLerp ? e.getNoLerp() : e;
          }
          for (let e = 0; e < this._array.length; ++e)
            this._array[e] = this._values[this._array.length * t + e];
          return this._array;
        }
        valueBetween(t, e, i, s, n) {
          if (this._lerp) {
            const r = this.types ? this.types[e] : this.type,
              a = n - i;
            let o = (t - i) / a;
            if ((r && (o = cK(o, r)), void 0 === this._array)) {
              const t = this._values[e],
                i = this._values[s];
              return this._lerp(t, i, o, a * this._duration);
            }
            for (let t = 0; t < this._array.length; ++t) {
              const i = this._values[this._array.length * e + t],
                n = this._values[this._array.length * s + t];
              this._array[t] = this._lerp(i, n, o, a * this._duration);
            }
            return this._array;
          }
          if (void 0 === this._array) return this.valueAt(e);
          for (let t = 0; t < this._array.length; ++t)
            this._array[t] = this._values[this._array.length * e + t];
          return this._array;
        }
        empty() {
          return 0 === this._values.length;
        }
        constant() {
          return 1 === this._values.length;
        }
      }
      function lK(t, e, i) {
        let s = e.sample(i);
        if (s < 0)
          if (((s = ~s), s <= 0)) s = 0;
          else {
            if (!(s >= e.ratios.length))
              return t.valueBetween(i, s - 1, e.ratios[s - 1], s, e.ratios[s]);
            s = e.ratios.length - 1;
          }
        return t.valueAt(s);
      }
      function cK(t, e) {
        if ("string" == typeof e) {
          const i = gh[e];
          i ? (t = i(t)) : G(3906, e);
        } else Array.isArray(e) && (t = Qh(e, t));
        return t;
      }
      function uK(t, e) {
        const i = t.length - 1;
        if (0 === i) return 0;
        const s = t[0];
        if (e < s) return 0;
        const n = t[i];
        if (e > n) return i;
        const r = (e = (e - s) / (n - s)) / (1 / i),
          a = 0 | r,
          o = 1e-6;
        return r - a < o ? a : a + 1 - r < o ? a + 1 : ~(a + 1);
      }
      t("AnimCurve", hK),
        (hK.Linear = null),
        (a.AnimCurve = hK),
        t(
          "EventInfo",
          class {
            constructor() {
              this.events = [];
            }
            add(t, e) {
              this.events.push({ func: t || "", params: e || [] });
            }
          }
        ),
        (a.sampleAnimationCurve = lK);
      const _K = (() => {
        function t(t, e, i, s) {
          return t.lerp(e, i, s);
        }
        return (e) => {
          if (null !== e) {
            if ("number" == typeof e) return vi;
            if ("object" == typeof e && e.constructor) {
              if (e instanceof as)
                return (function () {
                  const t = new as();
                  return (e, i, s) => as.slerp(t, e, i, s);
                })();
              if (e instanceof pe)
                return (function (t) {
                  const e = new t();
                  return (i, s, n) => (t.lerp(e, i, s, n), e);
                })(e.constructor);
              if (e.constructor === Number) return vi;
              if ("function" == typeof e.lerp) return t;
            }
          }
        };
      })();
      var dK, pK, mK, fK, gK, yK;
      let TK =
          Ca("cc.animation.UntypedTrackChannel")(
            ((pK = class extends lV {
              constructor() {
                super(new wh()), (this.property = mK && mK());
              }
            }),
            (mK = fa(pK.prototype, "property", [Na], function () {
              return "";
            })),
            (dK = pK))
          ) || dK,
        SK =
          Ca("cc.animation.UntypedTrack")(
            ((gK = class extends hV {
              constructor(...t) {
                super(...t), (this._channels = yK && yK());
              }
              channels() {
                return this._channels;
              }
              [hG]() {
                throw new Error(
                  "UntypedTrack should be handled specially. Please file an issue."
                );
              }
              createLegacyEval(t) {
                const e = (t) => {
                  var e;
                  return null ===
                    (e = this._channels.find((e) => e.property === t)) ||
                    void 0 === e
                    ? void 0
                    : e.curve;
                };
                switch (!0) {
                  default:
                    throw new Error(X(3931));
                  case t instanceof Ss:
                    return new tj(e("x"), e("y"));
                  case t instanceof Yi:
                    return new ej(e("x"), e("y"), e("z"));
                  case t instanceof Wi:
                    return new ij(e("x"), e("y"), e("z"), e("w"));
                  case t instanceof Qi:
                    return new uj(e("r"), e("g"), e("b"), e("a"));
                  case t instanceof ws:
                    return new gj(e("width"), e("height"));
                }
              }
              addChannel(t) {
                const e = new TK();
                return (e.property = t), this._channels.push(e), e;
              }
              upgrade(t) {
                const e = (t, e) => {
                    const i = this.channels().find((e) => e.property === t);
                    i &&
                      ((e.name = i.name),
                      e.curve.assignSorted(
                        Array.from(i.curve.times()),
                        Array.from(i.curve.values())
                      ));
                  },
                  i = t(this.path, this.proxy);
                switch (i) {
                  default:
                    break;
                  case "vec2":
                  case "vec3":
                  case "vec4": {
                    const t = new JV();
                    (t.path = this.path),
                      (t.proxy = this.proxy),
                      (t.componentsCount =
                        "vec2" === i ? 2 : "vec3" === i ? 3 : 4);
                    const [s, n, r, a] = t.channels();
                    switch (i) {
                      case "vec4":
                        e("w", a);
                      case "vec3":
                        e("z", r);
                      default:
                      case "vec2":
                        e("x", s), e("y", n);
                    }
                    return t;
                  }
                  case "color": {
                    const t = new cj(),
                      [i, s, n, r] = t.channels();
                    return (
                      e("r", i),
                      e("g", s),
                      e("b", n),
                      e("a", r),
                      e("x", i),
                      e("y", s),
                      e("z", n),
                      e("w", r),
                      t
                    );
                  }
                  case "size":
                }
                return null;
              }
            }),
            (yK = fa(gK.prototype, "_channels", [Na], function () {
              return [];
            })),
            (fK = gK))
          ) || fK;
      class EK {
        constructor(t) {
          (this._keys = []),
            (this._curves = []),
            (this._commonTargets = []),
            (this._ratioSamplers = []),
            (this._runtimeCurves = void 0),
            (this._data = null),
            (this._duration = void 0),
            (this._duration = t);
        }
        get keys() {
          return this._keys;
        }
        set keys(t) {
          this._keys = t;
        }
        get curves() {
          return this._curves;
        }
        set curves(t) {
          (this._curves = t), delete this._runtimeCurves;
        }
        get commonTargets() {
          return this._commonTargets;
        }
        set commonTargets(t) {
          this._commonTargets = t;
        }
        get data() {
          return this._data;
        }
        getPropertyCurves() {
          return (
            this._runtimeCurves || this._createPropertyCurves(),
            this._runtimeCurves
          );
        }
        toTracks() {
          const t = [],
            { keys: e, curves: i, commonTargets: s } = this,
            n = (t, e, i) => {
              const s = new rV();
              for (const t of e)
                "string" == typeof t
                  ? s.toProperty(t)
                  : "number" == typeof t
                  ? s.toElement(t)
                  : t instanceof FG
                  ? s.toHierarchy(t.path)
                  : t instanceof UG
                  ? s.toComponent(t.component)
                  : s.toCustomized(t);
              (t.path = s), (t.proxy = i);
            },
            r = s.map((e) => {
              const i = new SK();
              return n(i, e.modifiers, e.valueAdapter), t.push(i), i;
            });
          for (const s of i) {
            var a;
            const i = s.data,
              o = i.values;
            if (0 === o.length) continue;
            const h = i.keys < 0 ? [0] : e[i.keys],
              l = o[0],
              c = null === (a = i.interpolate) || void 0 === a || a;
            i._arrayLength;
            const u = new bK(i, h.length),
              _ = (t) => {
                n(t, s.modifiers, s.valueAdapter);
              };
            let d;
            if ("number" == typeof s.commonTarget) {
              if (!o.every((t) => "number" == typeof t)) {
                z(3932);
                continue;
              }
              if (
                s.valueAdapter ||
                1 !== s.modifiers.length ||
                "string" != typeof s.modifiers[0]
              ) {
                z(3933);
                continue;
              }
              const t = s.modifiers[0],
                e = r[s.commonTarget],
                { curve: i } = e.addChannel(t);
              d = i;
            }
            (() => {
              if ("number" == typeof l) {
                if (!o.every((t) => "number" == typeof t)) return void z(3934);
                let e;
                if (d) e = d;
                else {
                  const i = new XV();
                  _(i), t.push(i), (e = i.channel.curve);
                }
                const i = c ? ua.LINEAR : ua.CONSTANT;
                return (
                  e.assignSorted(
                    h,
                    o.map((t) => ({ value: t, interpolationMode: i }))
                  ),
                  void u.convert(e)
                );
              }
              if ("object" == typeof l)
                switch (!0) {
                  default:
                    break;
                  case vK(o, Ss):
                  case vK(o, Yi):
                  case vK(o, Wi): {
                    const e = l instanceof Ss ? 2 : l instanceof Yi ? 3 : 4,
                      i = new JV();
                    _(i), (i.componentsCount = e);
                    const [
                        { curve: s },
                        { curve: n },
                        { curve: r },
                        { curve: a },
                      ] = i.channels(),
                      d = c ? ua.LINEAR : ua.CONSTANT,
                      p = (t) => ({ value: t, interpolationMode: d });
                    switch (e) {
                      case 4:
                        a.assignSorted(
                          h,
                          o.map((t) => p(t.w))
                        ),
                          u.convert(a);
                      case 3:
                        r.assignSorted(
                          h,
                          o.map((t) => p(t.z))
                        ),
                          u.convert(r);
                      default:
                        s.assignSorted(
                          h,
                          o.map((t) => p(t.x))
                        ),
                          u.convert(s),
                          n.assignSorted(
                            h,
                            o.map((t) => p(t.y))
                          ),
                          u.convert(n);
                    }
                    return void t.push(i);
                  }
                  case vK(o, as): {
                    const e = new nj();
                    _(e);
                    const i = c ? hl.SLERP : hl.CONSTANT;
                    return (
                      e.channel.curve.assignSorted(
                        h,
                        o.map((t) => ({
                          value: as.clone(t),
                          interpolationMode: i,
                        }))
                      ),
                      u.convertQuatCurve(e.channel.curve),
                      void t.push(e)
                    );
                  }
                  case vK(o, Qi): {
                    const e = new cj();
                    _(e);
                    const [
                        { curve: i },
                        { curve: s },
                        { curve: n },
                        { curve: r },
                      ] = e.channels(),
                      a = c ? ua.LINEAR : ua.CONSTANT,
                      l = (t) => ({ value: t, interpolationMode: a });
                    return (
                      i.assignSorted(
                        h,
                        o.map((t) => l(t.r))
                      ),
                      u.convert(i),
                      s.assignSorted(
                        h,
                        o.map((t) => l(t.g))
                      ),
                      u.convert(s),
                      n.assignSorted(
                        h,
                        o.map((t) => l(t.b))
                      ),
                      u.convert(n),
                      r.assignSorted(
                        h,
                        o.map((t) => l(t.a))
                      ),
                      u.convert(r),
                      void t.push(e)
                    );
                  }
                  case vK(o, ws): {
                    const e = new fj();
                    _(e);
                    const [{ curve: i }, { curve: s }] = e.channels(),
                      n = c ? ua.LINEAR : ua.CONSTANT,
                      r = (t) => ({ value: t, interpolationMode: n });
                    return (
                      i.assignSorted(
                        h,
                        o.map((t) => r(t.width))
                      ),
                      u.convert(i),
                      s.assignSorted(
                        h,
                        o.map((t) => r(t.height))
                      ),
                      u.convert(s),
                      void t.push(e)
                    );
                  }
                  case vK(o, jV): {
                    u.nil;
                    const e = new XV();
                    _(e);
                    const i = c ? ua.CUBIC : ua.CONSTANT;
                    return (
                      e.channel.curve.assignSorted(
                        h,
                        o.map((t) => ({
                          value: t.dataPoint,
                          leftTangent: t.inTangent,
                          rightTangent: t.outTangent,
                          interpolationMode: i,
                        }))
                      ),
                      void t.push(e)
                    );
                  }
                  case vK(o, zV):
                  case vK(o, HV):
                  case vK(o, GV): {
                    u.nil;
                    const e = l instanceof zV ? 2 : l instanceof HV ? 3 : 4,
                      i = new JV();
                    _(i), (i.componentsCount = e);
                    const [s, n, r, a] = i.channels(),
                      d = c ? ua.LINEAR : ua.CONSTANT,
                      p = (t, e, i) => ({
                        value: t,
                        leftTangent: e,
                        rightTangent: i,
                        interpolationMode: d,
                      });
                    switch (e) {
                      case 4:
                        a.curve.assignSorted(
                          h,
                          o.map((t) =>
                            p(t.dataPoint.w, t.inTangent.w, t.outTangent.w)
                          )
                        );
                      case 3:
                        r.curve.assignSorted(
                          h,
                          o.map((t) =>
                            p(t.dataPoint.z, t.inTangent.z, t.outTangent.z)
                          )
                        );
                      default:
                        s.curve.assignSorted(
                          h,
                          o.map((t) =>
                            p(t.dataPoint.y, t.inTangent.y, t.outTangent.y)
                          )
                        ),
                          n.curve.assignSorted(
                            h,
                            o.map((t) =>
                              p(t.dataPoint.x, t.inTangent.x, t.outTangent.x)
                            )
                          );
                    }
                    return void t.push(i);
                  }
                  case o.every((t) => t instanceof VV):
                    z(3935);
                }
              const e = new Tj();
              _(e), e.channel.curve.assignSorted(h, o), t.push(e);
            })();
          }
          return t;
        }
        _createPropertyCurves() {
          (this._ratioSamplers = this._keys.map(
            (t) => new oK(t.map((t) => t / this._duration))
          )),
            (this._runtimeCurves = this._curves.map((t) => ({
              curve: new hK(t.data, this._duration),
              modifiers: t.modifiers,
              valueAdapter: t.valueAdapter,
              sampler: this._ratioSamplers[t.data.keys],
              commonTarget: t.commonTarget,
            })));
        }
      }
      function vK(t, e) {
        return t.every((t) => t instanceof e);
      }
      class bK {
        constructor(t, e) {
          this._easingMethods = void 0;
          const { easingMethods: i } = t;
          Array.isArray(i)
            ? 0 === i.length && 0 !== e
              ? (this._easingMethods = new Array(e).fill(null))
              : (this._easingMethods = i)
            : (this._easingMethods =
                void 0 === i
                  ? new Array(e).fill(t.easingMethod)
                  : Array.from({ length: e }, (t, e) => {
                      var s;
                      return null !== (s = i[e]) && void 0 !== s ? s : null;
                    }));
        }
        get nil() {
          return (
            !this._easingMethods || this._easingMethods.every((t) => null == t)
          );
        }
        convert(t) {
          const { _easingMethods: e } = this;
          if (!e) return;
          const i = t.keyFramesCount;
          if (t.keyFramesCount < 2) return;
          Array.isArray(e) && e.length;
          const s = i - 1;
          for (let i = 0; i < s; ++i) {
            const s = e[i];
            s &&
              (Array.isArray(s)
                ? IK(
                    s,
                    t.getKeyframeTime(i),
                    t.getKeyframeValue(i),
                    t.getKeyframeTime(i + 1),
                    t.getKeyframeValue(i + 1)
                  )
                : AK(s, t, i));
          }
        }
        convertQuatCurve(t) {
          const { _easingMethods: e } = this;
          if (!e) return;
          const i = t.keyFramesCount;
          if (t.keyFramesCount < 2) return;
          Array.isArray(e) && e.length;
          const s = i - 1;
          for (let i = 0; i < s; ++i) {
            const s = e[i];
            s &&
              (Array.isArray(s)
                ? (t.getKeyframeValue(i).easingMethod = s.slice())
                : CK(s, t, i));
          }
        }
      }
      function AK(t, e, i) {
        e.keyFramesCount;
        const s = e.getKeyframeValue(i),
          n = OK[t];
        n === yh.CONSTANT
          ? (s.interpolationMode = ua.CONSTANT)
          : ((s.interpolationMode = ua.LINEAR), (s.easingMethod = n));
      }
      function CK(t, e, i) {
        e.keyFramesCount;
        const s = e.getKeyframeValue(i),
          n = OK[t];
        s.easingMethod = n;
      }
      const OK = {
        constant: yh.CONSTANT,
        linear: yh.LINEAR,
        quadIn: yh.QUAD_IN,
        quadOut: yh.QUAD_OUT,
        quadInOut: yh.QUAD_IN_OUT,
        quadOutIn: yh.QUAD_OUT_IN,
        cubicIn: yh.CUBIC_IN,
        cubicOut: yh.CUBIC_OUT,
        cubicInOut: yh.CUBIC_IN_OUT,
        cubicOutIn: yh.CUBIC_OUT_IN,
        quartIn: yh.QUART_IN,
        quartOut: yh.QUART_OUT,
        quartInOut: yh.QUART_IN_OUT,
        quartOutIn: yh.QUART_OUT_IN,
        quintIn: yh.QUINT_IN,
        quintOut: yh.QUINT_OUT,
        quintInOut: yh.QUINT_IN_OUT,
        quintOutIn: yh.QUINT_OUT_IN,
        sineIn: yh.SINE_IN,
        sineOut: yh.SINE_OUT,
        sineInOut: yh.SINE_IN_OUT,
        sineOutIn: yh.SINE_OUT_IN,
        expoIn: yh.EXPO_IN,
        expoOut: yh.EXPO_OUT,
        expoInOut: yh.EXPO_IN_OUT,
        expoOutIn: yh.EXPO_OUT_IN,
        circIn: yh.CIRC_IN,
        circOut: yh.CIRC_OUT,
        circInOut: yh.CIRC_IN_OUT,
        circOutIn: yh.CIRC_OUT_IN,
        elasticIn: yh.ELASTIC_IN,
        elasticOut: yh.ELASTIC_OUT,
        elasticInOut: yh.ELASTIC_IN_OUT,
        elasticOutIn: yh.ELASTIC_OUT_IN,
        backIn: yh.BACK_IN,
        backOut: yh.BACK_OUT,
        backInOut: yh.BACK_IN_OUT,
        backOutIn: yh.BACK_OUT_IN,
        bounceIn: yh.BOUNCE_IN,
        bounceOut: yh.BOUNCE_OUT,
        bounceInOut: yh.BOUNCE_IN_OUT,
        bounceOutIn: yh.BOUNCE_OUT_IN,
        smooth: yh.SMOOTH,
        fade: yh.FADE,
      };
      function IK(t, e, i, s, n) {
        const [r, a, o, h] = t,
          { value: l } = i,
          { value: c } = n,
          u = 3 * (s - e),
          _ = 3 * (c - l),
          d = r * u,
          p = a * _,
          m = (1 - o) * u,
          f = (1 - h) * _,
          g = 1 / 3,
          y = p / d,
          T = Math.sqrt(d * d + p * p) * g,
          S = f / m,
          E = Math.sqrt(m * m + f * f) * g;
        var v;
        (i.interpolationMode = ua.CUBIC),
          (i.tangentWeightMode =
            (v = i.tangentWeightMode) === da.NONE
              ? da.RIGHT
              : v === da.LEFT
              ? da.BOTH
              : v),
          (i.rightTangent = y),
          (i.rightTangentWeight = T),
          (n.tangentWeightMode = (function (t) {
            return t === da.NONE ? da.LEFT : t === da.RIGHT ? da.BOTH : t;
          })(n.tangentWeightMode)),
          (n.leftTangent = S),
          (n.leftTangentWeight = E);
      }
      var wK,
        RK,
        DK,
        xK,
        MK,
        PK,
        NK,
        LK,
        BK,
        FK,
        UK,
        kK,
        zK,
        HK,
        GK,
        VK,
        jK,
        WK,
        XK,
        YK,
        KK,
        qK,
        $K,
        ZK;
      const { ccclass: QK, serializable: JK } = go;
      function tq() {
        throw new Error("split() only valid in Editor.");
      }
      QK("cc.animation.ExoticAnimation")(
        ((wK = class {
          constructor() {
            this._nodeAnimations = RK && RK();
          }
          createEvaluator(t) {
            return new hq(this._nodeAnimations, t);
          }
          createEvaluatorForAnimationGraph(t) {
            return new uq(this._nodeAnimations, t);
          }
          addNodeAnimation(t) {
            const e = new eq(t);
            return this._nodeAnimations.push(e), e;
          }
          collectAnimatedJoints() {
            return Array.from(
              new Set(this._nodeAnimations.map(({ path: t }) => t))
            );
          }
          split(t, e) {
            return tq();
          }
          toHashString() {
            return this._nodeAnimations.map((t) => t.toHashString()).join("\n");
          }
        }),
        (RK = fa(wK.prototype, "_nodeAnimations", [JK], function () {
          return [];
        })),
        wK)
      );
      let eq =
        QK("cc.animation.ExoticNodeAnimation")(
          ((xK = class {
            constructor(t) {
              (this._path = MK && MK()),
                (this._position = PK && PK()),
                (this._rotation = NK && NK()),
                (this._scale = LK && LK()),
                (this._path = t);
            }
            createPosition(t, e) {
              this._position = new oq(t, new rq(e));
            }
            createRotation(t, e) {
              this._rotation = new oq(t, new aq(e));
            }
            createScale(t, e) {
              this._scale = new oq(t, new rq(e));
            }
            createEvaluator(t) {
              return new lq(
                this._path,
                this._position,
                this._rotation,
                this._scale,
                t
              );
            }
            createEvaluatorForAnimationGraph(t) {
              const e = t.bindTransform(this._path);
              return e
                ? new _q(e, this._position, this._rotation, this._scale)
                : null;
            }
            split(t, e, i) {
              return tq();
            }
            get path() {
              return this._path;
            }
            toHashString() {
              var t, e, i, s, n, r;
              return `${this._path}\n${
                null !==
                  (t =
                    null === (e = this._position) || void 0 === e
                      ? void 0
                      : e.toHashString()) && void 0 !== t
                  ? t
                  : ""
              }${
                null !==
                  (i =
                    null === (s = this._scale) || void 0 === s
                      ? void 0
                      : s.toHashString()) && void 0 !== i
                  ? i
                  : ""
              }${
                null !==
                  (n =
                    null === (r = this._rotation) || void 0 === r
                      ? void 0
                      : r.toHashString()) && void 0 !== n
                  ? n
                  : ""
              }`;
            }
          }),
          (MK = fa(xK.prototype, "_path", [JK], function () {
            return "";
          })),
          (PK = fa(xK.prototype, "_position", [JK], function () {
            return null;
          })),
          (NK = fa(xK.prototype, "_rotation", [JK], function () {
            return null;
          })),
          (LK = fa(xK.prototype, "_scale", [JK], function () {
            return null;
          })),
          (DK = xK))
        ) || DK;
      function iq(t) {
        return t.toPrecision(2);
      }
      function sq(t) {
        return t.map((t) => Number.parseFloat(iq(t))).join(" ");
      }
      let nq =
          QK("cc.animation.ExoticVectorLikeTrackValues")(
            ((FK = class {
              constructor(t) {
                (this._values = UK && UK()),
                  (this._isQuantized = kK && kK()),
                  (this._values = t);
              }
              get precision() {
                return this._isQuantized
                  ? this._values.originalPrecision
                  : mq(this._values);
              }
              quantize(t) {
                this._isQuantized,
                  (this._values = (function (t, e) {
                    const i = dq[e],
                      s = 1 << i.BYTES_PER_ELEMENT;
                    let n = Number.POSITIVE_INFINITY,
                      r = Number.NEGATIVE_INFINITY;
                    t.forEach((t) => {
                      (n = Math.min(t, n)), (r = Math.max(t, r));
                    });
                    const a = r - n,
                      o = i.from(t, (t) => ((t - n) / a) * s);
                    return new fq(mq(t), o, a, n);
                  })(this._values, t)),
                  (this._isQuantized = !0);
              }
              toHashString() {
                const { _isQuantized: t, _values: e } = this;
                return `${t} ${t ? e.toHashString() : sq(e)}`;
              }
            }),
            (UK = fa(FK.prototype, "_values", [JK], null)),
            (kK = fa(FK.prototype, "_isQuantized", [JK], function () {
              return !1;
            })),
            (BK = FK))
          ) || BK,
        rq =
          QK("cc.animation.ExoticVec3TrackValues")(
            (zK = class t extends nq {
              static imitate(e, i) {
                const s = new t(e);
                return (
                  i._isQuantized && s.quantize(i._values.quantizationType), s
                );
              }
              get(t, e) {
                const { _values: i, _isQuantized: s } = this;
                s ? Tq(i, t, e) : Yi.fromArray(e, i, 3 * t);
              }
              lerp(t, e, i, s, n, r) {
                const { _values: a, _isQuantized: o } = this;
                o
                  ? (Tq(a, t, s), Tq(a, e, n))
                  : (Yi.fromArray(s, a, 3 * t), Yi.fromArray(n, a, 3 * e)),
                  Yi.lerp(r, s, n, i);
              }
            })
          ) || zK,
        aq =
          QK("cc.animation.ExoticQuatTrackValues")(
            (HK = class t extends nq {
              static imitate(e, i) {
                const s = new t(e);
                return (
                  i._isQuantized && s.quantize(i._values.quantizationType), s
                );
              }
              get(t, e) {
                const { _values: i, _isQuantized: s } = this;
                s ? Sq(i, t, e) : as.fromArray(e, i, 4 * t);
              }
              lerp(t, e, i, s, n, r) {
                const { _values: a, _isQuantized: o } = this;
                o
                  ? (Sq(a, t, s), Sq(a, e, n))
                  : (as.fromArray(s, a, 4 * t), as.fromArray(n, a, 4 * e)),
                  as.slerp(r, s, n, i);
              }
            })
          ) || HK,
        oq =
          QK("cc.animation.ExoticTrack")(
            ((VK = class {
              constructor(t, e) {
                (this.times = jK && jK()),
                  (this.values = WK && WK()),
                  (this.times = t),
                  (this.values = e);
              }
              toHashString() {
                const { times: t, values: e } = this;
                return `times: ${sq(t)}; values: ${e.toHashString()}`;
              }
            }),
            (jK = fa(VK.prototype, "times", [JK], null)),
            (WK = fa(VK.prototype, "values", [JK], null)),
            (GK = VK))
          ) || GK;
      class hq {
        constructor(t, e) {
          (this._nodeEvaluations = void 0),
            (this._nodeEvaluations = t.map((t) => t.createEvaluator(e)));
        }
        evaluate(t) {
          this._nodeEvaluations.forEach((e) => {
            e.evaluate(t);
          });
        }
      }
      class lq {
        constructor(t, e, i, s, n) {
          (this._position = null),
            (this._rotation = null),
            (this._scale = null),
            e && (this._position = yq(e.times, e.values, Yi, t, "position", n)),
            i && (this._rotation = yq(i.times, i.values, as, t, "rotation", n)),
            s && (this._scale = yq(s.times, s.values, Yi, t, "scale", n));
        }
        evaluate(t) {
          if (this._position) {
            const e = this._position.evaluator.evaluate(t);
            this._position.runtimeBinding.setValue(e);
          }
          if (this._rotation) {
            const e = this._rotation.evaluator.evaluate(t);
            this._rotation.runtimeBinding.setValue(e);
          }
          if (this._scale) {
            const e = this._scale.evaluator.evaluate(t);
            this._scale.runtimeBinding.setValue(e);
          }
        }
      }
      class cq {
        constructor(t, e, i) {
          (this._times = void 0),
            (this._inputSampleResultCache = {
              just: !1,
              index: -1,
              nextIndex: -1,
              ratio: 0,
            }),
            (this._values = void 0),
            (this._prevValue = void 0),
            (this._nextValue = void 0),
            (this._resultValue = void 0),
            (this._times = t),
            (this._values = e),
            (this._prevValue = new i()),
            (this._nextValue = new i()),
            (this._resultValue = new i());
        }
        evaluate(t) {
          const { _times: e, _values: i, _resultValue: s } = this;
          if (0 === e.length) return s;
          const n = (function (t, e, i) {
            const s = t.length,
              n = t[0],
              r = t[s - 1];
            if (e < n) (i.just = !0), (i.index = 0);
            else if (e > r) (i.just = !0), (i.index = s - 1);
            else {
              const s = la(t, e);
              if (s >= 0) (i.just = !0), (i.index = s);
              else {
                const n = ~s,
                  r = n - 1,
                  a = t[r],
                  o = t[n],
                  h = (e - t[r]) / (o - a);
                (i.just = !1), (i.index = r), (i.nextIndex = n), (i.ratio = h);
              }
            }
            return i;
          })(e, t, this._inputSampleResultCache);
          return (
            n.just
              ? i.get(n.index, s)
              : i.lerp(
                  n.index,
                  n.nextIndex,
                  n.ratio,
                  this._prevValue,
                  this._nextValue,
                  s
                ),
            s
          );
        }
      }
      class uq {
        constructor(t, e) {
          (this._nodeEvaluations = void 0),
            (this._nodeEvaluations = t
              .map((t) => t.createEvaluatorForAnimationGraph(e))
              .filter((t) => !!t));
        }
        destroy() {
          const { _nodeEvaluations: t } = this,
            e = t.length;
          for (let i = 0; i < e; ++i) t[i].destroy();
        }
        evaluate(t, e) {
          const { _nodeEvaluations: i } = this,
            s = i.length;
          for (let n = 0; n < s; ++n) i[n].evaluate(t, e);
        }
      }
      class _q {
        constructor(t, e, i, s) {
          (this._position = null),
            (this._rotation = null),
            (this._scale = null),
            (this._transformHandle = void 0),
            (this._transformHandle = t),
            e && (this._position = new cq(e.times, e.values, Yi)),
            i && (this._rotation = new cq(i.times, i.values, as)),
            s && (this._scale = new cq(s.times, s.values, Yi));
        }
        destroy() {
          this._transformHandle.destroy();
        }
        evaluate(t, e) {
          const {
              _transformHandle: { index: i },
              _position: s,
              _rotation: n,
              _scale: r,
            } = this,
            { transforms: a } = e;
          if (s) {
            const e = s.evaluate(t);
            a.setPosition(i, e);
          }
          if (n) {
            const e = n.evaluate(t);
            a.setRotation(i, e);
          }
          if (r) {
            const e = r.evaluate(t);
            a.setScale(i, e);
          }
        }
      }
      const dq = { uint8: Uint8Array, uint16: Uint16Array };
      var pq;
      function mq(t) {
        switch (t.BYTES_PER_ELEMENT) {
          default:
          case 4:
            return pq.FLOAT_32;
          case 8:
            return pq.FLOAT_64;
        }
      }
      !(function (t) {
        (t[(t.FLOAT_32 = 0)] = "FLOAT_32"), (t[(t.FLOAT_64 = 1)] = "FLOAT_64");
      })(pq || (pq = {}));
      let fq =
        QK("cc.animation.QuantizedFloatArray")(
          ((YK = class {
            get quantizationType() {
              switch (this.values.BYTES_PER_ELEMENT) {
                default:
                case 1:
                  return "uint8";
                case 2:
                  return "uint16";
              }
            }
            constructor(t, e, i, s = 0) {
              (this.originalPrecision = KK && KK()),
                (this.min = qK && qK()),
                (this.extent = $K && $K()),
                (this.values = ZK && ZK()),
                (this.originalPrecision = t),
                (this.values = e),
                (this.extent = i),
                (this.min = s);
            }
            toHashString() {
              const {
                originalPrecision: t,
                min: e,
                extent: i,
                values: s,
              } = this;
              return `${t} ${iq(e)} ${iq(i)} ${s.join(" ")}`;
            }
          }),
          (KK = fa(YK.prototype, "originalPrecision", [JK], null)),
          (qK = fa(YK.prototype, "min", [JK], null)),
          ($K = fa(YK.prototype, "extent", [JK], null)),
          (ZK = fa(YK.prototype, "values", [JK], null)),
          (XK = YK))
        ) || XK;
      function gq(t, e) {
        return (
          (t.values[e] / (1 << t.values.BYTES_PER_ELEMENT)) * t.extent + t.min
        );
      }
      function yq(t, e, i, s, n, r) {
        const a = new aV();
        a.path = new rV().toHierarchy(s).toProperty(n);
        const o = r(a);
        return o ? { runtimeBinding: o, evaluator: new cq(t, e, i) } : null;
      }
      function Tq(t, e, i) {
        Yi.set(i, gq(t, 3 * e + 0), gq(t, 3 * e + 1), gq(t, 3 * e + 2));
      }
      function Sq(t, e, i) {
        as.set(
          i,
          gq(t, 4 * e + 0),
          gq(t, 4 * e + 1),
          gq(t, 4 * e + 2),
          gq(t, 4 * e + 3)
        );
      }
      var Eq, vq, bq, Aq;
      let Cq =
        Ca("cc.animation.AuxiliaryCurveEntry")(
          ((vq = class {
            constructor() {
              (this.name = bq && bq()), (this.curve = Aq && Aq());
            }
          }),
          (bq = fa(vq.prototype, "name", [Na], function () {
            return "";
          })),
          (Aq = fa(vq.prototype, "curve", [Na], function () {
            return new wh();
          })),
          (Eq = vq))
        ) || Eq;
      var Oq,
        Iq,
        wq,
        Rq,
        Dq,
        xq,
        Mq,
        Pq,
        Nq,
        Lq,
        Bq,
        Fq,
        Uq,
        kq,
        zq,
        Hq,
        Gq,
        Vq,
        jq;
      const Wq = Symbol("SearchForRootBonePath"),
        Xq = Symbol("ExoticAnimation"),
        Yq = Symbol("[[EmbeddedPlayerCount]]"),
        Kq = Symbol("[[GetEmbeddedPlayers]]"),
        qq = Symbol("[[AddEmbeddedPlayer]]"),
        $q = Symbol("[[RemoveEmbeddedPlayer]]"),
        Zq = Symbol("[[ClearEmbeddedPlayers]]"),
        Qq = Symbol("[[Additive Settings]]");
      let Jq = t(
          "AnimationClip",
          Ca("cc.AnimationClip")(
            (((zq = class t extends Ad {
              constructor(...t) {
                super(...t),
                  (this.sample = wq && wq()),
                  (this.speed = Rq && Rq()),
                  (this.wrapMode = Dq && Dq()),
                  (this.enableTrsBlending = xq && xq()),
                  (this._duration = Mq && Mq()),
                  (this._hash = Pq && Pq()),
                  (this.frameRate = 0),
                  (this._tracks = Nq && Nq()),
                  (this._exoticAnimation = Lq && Lq()),
                  (this._legacyData = void 0),
                  (this._legacyDataDirty = !1),
                  (this._events = Bq && Bq()),
                  (this._embeddedPlayers = Fq && Fq()),
                  (this._additiveSettings = Uq && Uq()),
                  (this._auxiliaryCurveEntries = kq && kq()),
                  (this._runtimeEvents = { ratios: [], eventGroups: [] });
              }
              static createWithSpriteFrames(e, i) {
                const s = new t();
                (s.sample = i || s.sample), (s.duration = e.length / s.sample);
                const n = 1 / s.sample,
                  r = new Tj();
                return (
                  (r.path = new rV()
                    .toComponent("cc.Sprite")
                    .toProperty("spriteFrame")),
                  r
                    .channels()[0]
                    .curve.assignSorted(e.map((t, e) => [n * e, t])),
                  s.addTrack(r),
                  s
                );
              }
              get duration() {
                return this._duration;
              }
              set duration(t) {
                this._duration = t;
              }
              get tracksCount() {
                return this._tracks.length;
              }
              get tracks() {
                return this._tracks;
              }
              get hash() {
                var t, e;
                if (this._hash) return this._hash;
                const i = `Exotic:${
                  null !==
                    (t =
                      null === (e = this._exoticAnimation) || void 0 === e
                        ? void 0
                        : e.toHashString()) && void 0 !== t
                    ? t
                    : ""
                }`;
                return (this._hash = tc(i, 666));
              }
              get events() {
                return this._events;
              }
              set events(t) {
                this._events = t;
                const e = [],
                  i = [],
                  s = this.events.sort((t, e) => t.frame - e.frame),
                  n = s.length;
                for (let t = 0; t < n; ++t) {
                  const n = s[t],
                    r = n.frame / this._duration;
                  let a = e.findIndex((t) => t === r);
                  a < 0 && ((a = e.length), e.push(r), i.push({ events: [] })),
                    i[a].events.push({
                      functionName: n.func,
                      parameters: n.params,
                    });
                }
                this._runtimeEvents = { ratios: e, eventGroups: i };
              }
              get [Xq]() {
                return this._exoticAnimation;
              }
              set [Xq](t) {
                this._exoticAnimation = t;
              }
              get isAdditive_experimental() {
                return this._additiveSettings.enabled;
              }
              get [Qq]() {
                return this._additiveSettings;
              }
              onLoaded() {
                (this.frameRate = this.sample), (this.events = this._events);
              }
              range() {
                const t = { min: 1 / 0, max: -1 / 0 },
                  { _tracks: e } = this,
                  i = e.length;
                for (let s = 0; s < i; ++s) {
                  const i = e[s].range();
                  (t.min = Math.min(t.min, i.min)),
                    (t.max = Math.max(t.max, i.max));
                }
                return t;
              }
              getTrack(t) {
                return this._tracks[t];
              }
              addTrack(t) {
                const e = this._tracks.length;
                return this._tracks.push(t), e;
              }
              removeTrack(t) {
                this._tracks.splice(t, 1);
              }
              clearTracks() {
                this._tracks.length = 0;
              }
              containsAnyEvent() {
                return 0 !== this._events.length;
              }
              createEventEvaluator(t) {
                return new c$(
                  t,
                  this._runtimeEvents.ratios,
                  this._runtimeEvents.eventGroups,
                  this.wrapMode
                );
              }
              containsAnyEmbeddedPlayer() {
                return 0 !== this._embeddedPlayers.length;
              }
              createEmbeddedPlayerEvaluator(t) {
                return new i$(this._embeddedPlayers, t);
              }
              createEvaluator(t) {
                const { target: e } = t;
                return this._createEvalWithBinder(
                  e,
                  (i) => {
                    if (t.mask && i.isMaskedOff(t.mask)) return;
                    const s = i.createRuntimeBinding(
                      e,
                      this.enableTrsBlending ? t.pose : void 0,
                      !1
                    );
                    return null != s ? s : void 0;
                  },
                  t.rootMotion
                );
              }
              destroy() {
                var t;
                return (
                  null !== (t = a.director.root) &&
                    void 0 !== t &&
                    t.dataPoolManager &&
                    a.director.root.dataPoolManager.releaseAnimationClip(this),
                  aK.destroy(this),
                  super.destroy()
                );
              }
              [rK](t, e, i) {
                const s = 1 / e,
                  n = this._collectAnimatedJoints(),
                  r = n.length,
                  a = {};
                for (let t = 0; t < r; ++t)
                  a[n[t]] = {
                    transforms: Array.from({ length: i }, () => new ms()),
                  };
                const o = n.reduce((t, e) => ((t[e] = new r$()), t), {});
                for (const t in o) {
                  const e = o[t],
                    i = t.lastIndexOf("/");
                  if (i >= 0) {
                    const s = t.substring(0, i),
                      n = o[s];
                    n && (e.parent = n);
                  }
                }
                const h = this._createEvalWithBinder(
                  void 0,
                  (t) => {
                    const e = t.parseTrsPath();
                    if (!e) return;
                    const i = o[e.node];
                    return i ? l$(i, e.property) : void 0;
                  },
                  void 0
                );
                for (let e = 0; e < i; ++e) {
                  const i = t + s * e;
                  h.evaluate(i);
                  for (let t = 0; t < r; ++t) {
                    const i = n[t];
                    ms.copy(a[i].transforms[e], o[i].globalTransform);
                  }
                  for (let t = 0; t < r; ++t) {
                    const e = n[t];
                    o[e].invalidate();
                  }
                }
                return { samples: e, frames: i, joints: a };
              }
              upgradeUntypedTracks(t) {
                const e = [],
                  i = [],
                  { _tracks: s } = this,
                  n = s.length;
                for (let r = 0; r < n; ++r) {
                  const n = s[r];
                  if (!(n instanceof SK)) continue;
                  const a = n.upgrade(t);
                  a && (e.push(a), i.push(n));
                }
                const r = i.length;
                for (let t = 0; t < r; ++t) te(s, i[t]);
                s.push(...e);
              }
              [Wq]() {
                return this._searchForRootBonePath();
              }
              get keys() {
                return this._getLegacyData().keys;
              }
              set keys(t) {
                (this._legacyDataDirty = !0), (this._getLegacyData().keys = t);
              }
              get curves() {
                return (
                  (this._legacyDataDirty = !0), this._getLegacyData().curves
                );
              }
              set curves(t) {
                this._getLegacyData().curves = t;
              }
              get commonTargets() {
                return this._getLegacyData().commonTargets;
              }
              set commonTargets(t) {
                (this._legacyDataDirty = !0),
                  (this._getLegacyData().commonTargets = t);
              }
              get data() {
                return this._getLegacyData().data;
              }
              getPropertyCurves() {
                return this._getLegacyData().getPropertyCurves();
              }
              get eventGroups() {
                return this._runtimeEvents.eventGroups;
              }
              updateEventDatas() {
                this.events = this._events;
              }
              hasEvents() {
                return 0 !== this.events.length;
              }
              syncLegacyData() {
                this._legacyData &&
                  (this._fromLegacy(this._legacyData),
                  (this._legacyData = void 0));
              }
              get [Yq]() {
                return this._embeddedPlayers.length;
              }
              [Kq]() {
                return this._embeddedPlayers;
              }
              [qq](t) {
                this._embeddedPlayers.push(t);
              }
              [$q](t) {
                const e = this._embeddedPlayers.indexOf(t);
                e >= 0 && this._embeddedPlayers.splice(e, 1);
              }
              [Zq]() {
                this._embeddedPlayers.length = 0;
              }
              get auxiliaryCurveCount_experimental() {
                return this._auxiliaryCurveEntries.length;
              }
              getAuxiliaryCurveNames_experimental() {
                return this._auxiliaryCurveEntries.map((t) => t.name);
              }
              hasAuxiliaryCurve_experimental(t) {
                return !!this._findAuxiliaryCurveEntry(t);
              }
              addAuxiliaryCurve_experimental(t) {
                let e = this._findAuxiliaryCurveEntry(t);
                return (
                  e ||
                    ((e = new Cq()),
                    (e.name = t),
                    this._auxiliaryCurveEntries.push(e)),
                  e.curve
                );
              }
              getAuxiliaryCurve_experimental(t) {
                return this._findAuxiliaryCurveEntry(t).curve;
              }
              renameAuxiliaryCurve_experimental(t, e) {
                const i = this._findAuxiliaryCurveEntry(t);
                i && (i.name = e);
              }
              removeAuxiliaryCurve_experimental(t) {
                ie(this._auxiliaryCurveEntries, (e) => e.name === t);
              }
              _trySyncLegacyData() {
                this._legacyDataDirty &&
                  ((this._legacyDataDirty = !1), this.syncLegacyData());
              }
              _createEvalWithBinder(t, e, i) {
                this._legacyDataDirty &&
                  ((this._legacyDataDirty = !1), this.syncLegacyData());
                const s = [];
                let n;
                i && (n = this._createRootMotionEvaluation(t, i, s));
                const r = [];
                let a;
                const { _tracks: o } = this,
                  h = o.length;
                for (let t = 0; t < h; ++t) {
                  const i = o[t];
                  if (s.includes(i)) continue;
                  if (
                    Array.from(i.channels()).every(
                      ({ curve: t }) => 0 === t.keyFramesCount
                    )
                  )
                    continue;
                  const n = e(i[nV]);
                  if (!n) continue;
                  let a;
                  if (i instanceof SK) {
                    if (!n.getValue) {
                      G(3930);
                      continue;
                    }
                    const t = n.getValue();
                    a = i.createLegacyEval(t);
                  } else a = i[hG]();
                  r.push(new e$(n, a));
                }
                return (
                  this._exoticAnimation &&
                    (a = this._exoticAnimation.createEvaluator(e)),
                  new s$(r, a, n)
                );
              }
              _createRootMotionEvaluation(t, e, i) {
                if (!(t instanceof Pf)) return void G(3920);
                const s = this._searchForRootBonePath();
                if (!s) return void z(3923);
                const n = t.getChildByPath(s);
                if (!n) return void z(3924);
                const r = new n$(),
                  a = [],
                  { _tracks: o } = this,
                  h = o.length;
                for (let t = 0; t < h; ++t) {
                  const e = o[t],
                    { [nV]: n } = e,
                    h = n.parseTrsPath();
                  if (!h) continue;
                  if (h.node !== s) continue;
                  i.push(e);
                  const l = l$(r, h.property);
                  if (!l) continue;
                  const c = e[hG]();
                  a.push(new e$(l, c));
                }
                return new o$(n, this._duration, r, a);
              }
              _searchForRootBonePath() {
                const t = this._tracks.map((t) => {
                  const e = t[nV].parseTrsPath();
                  if (e) {
                    const t = e.node;
                    return { path: t, rank: t.split("/").length };
                  }
                  return { path: "", rank: 0 };
                });
                t.sort((t, e) => t.rank - e.rank);
                const e = t.findIndex((t) => 0 !== t.rank);
                if (e < 0) return "";
                const i = t.length,
                  s = t[e];
                let n = !0;
                for (let r = e + 1; r < i; ++r) {
                  const e = t[r];
                  if (e.rank !== s.rank) break;
                  if (e.path !== s.path) {
                    n = !1;
                    break;
                  }
                }
                return n ? s.path : "";
              }
              _getLegacyData() {
                return (
                  this._legacyData || (this._legacyData = this._toLegacy()),
                  this._legacyData
                );
              }
              _toLegacy() {
                const t = new EK(this._duration);
                return (
                  (t.keys = []), (t.curves = []), (t.commonTargets = []), t
                );
              }
              _fromLegacy(t) {
                const e = t.toTracks(),
                  i = e.length;
                for (let t = 0; t < i; ++t) this.addTrack(e[t]);
              }
              _collectAnimatedJoints() {
                const t = new Set(),
                  { _tracks: e } = this,
                  i = e.length;
                for (let s = 0; s < i; ++s) {
                  const i = e[s][nV].parseTrsPath();
                  i && t.add(i.node);
                }
                if (this._exoticAnimation) {
                  const e = this._exoticAnimation.collectAnimatedJoints(),
                    i = e.length;
                  for (let s = 0; s < i; ++s) t.add(e[s]);
                }
                return Array.from(t);
              }
              _findAuxiliaryCurveEntry(t) {
                return this._auxiliaryCurveEntries.find((e) => e.name === t);
              }
            }).WrapMode = gG),
            (wq = fa((Iq = zq).prototype, "sample", [Na], function () {
              return 60;
            })),
            (Rq = fa(Iq.prototype, "speed", [Na], function () {
              return 1;
            })),
            (Dq = fa(Iq.prototype, "wrapMode", [Na], function () {
              return gG.Normal;
            })),
            (xq = fa(Iq.prototype, "enableTrsBlending", [Na], function () {
              return !1;
            })),
            (Mq = fa(Iq.prototype, "_duration", [Na], function () {
              return 0;
            })),
            (Pq = fa(Iq.prototype, "_hash", [Na], function () {
              return 0;
            })),
            (Nq = fa(Iq.prototype, "_tracks", [Na], function () {
              return [];
            })),
            (Lq = fa(Iq.prototype, "_exoticAnimation", [Na], function () {
              return null;
            })),
            (Bq = fa(Iq.prototype, "_events", [Na], function () {
              return [];
            })),
            (Fq = fa(Iq.prototype, "_embeddedPlayers", [Na], function () {
              return [];
            })),
            (Uq = fa(Iq.prototype, "_additiveSettings", [Na], function () {
              return new t$();
            })),
            (kq = fa(Iq.prototype, "_auxiliaryCurveEntries", [Na], function () {
              return [];
            })),
            (Oq = Iq))
          ) || Oq
        ),
        t$ =
          Ca("cc.AnimationClipAdditiveSettings")(
            ((Gq = class {
              constructor() {
                (this.enabled = Vq && Vq()), (this.refClip = jq && jq());
              }
            }),
            (Vq = fa(Gq.prototype, "enabled", [Na], function () {
              return !1;
            })),
            (jq = fa(Gq.prototype, "refClip", [Na], function () {
              return null;
            })),
            (Hq = Gq))
          ) || Hq;
      a.AnimationClip = Jq;
      class e$ {
        constructor(t, e) {
          (this._binding = void 0),
            (this._trackEval = void 0),
            (this._shouldEvaluateDefault = !0),
            (this._binding = t),
            (this._trackEval = e),
            (this._shouldEvaluateDefault = !!t.getValue && e.requiresDefault);
        }
        evaluate(t) {
          const { _binding: e, _trackEval: i } = this,
            s = this._shouldEvaluateDefault ? e.getValue() : void 0,
            n = i.evaluate(t, s);
          e.setValue(n);
        }
      }
      class i$ {
        constructor(t, e) {
          (this._embeddedPlayers = t),
            (this._embeddedPlayerEvaluationInfos = t.map((t) => {
              const { playable: i } = t;
              if (!i) return null;
              const s = i.instantiate(e);
              return s
                ? {
                    instantiatedPlayer: s,
                    entered: !1,
                    hostPauseTime: 0,
                    lastIterations: 0,
                  }
                : null;
            }));
        }
        destroy() {
          const { _embeddedPlayerEvaluationInfos: t } = this,
            e = t.length;
          for (let s = 0; s < e; ++s) {
            var i;
            null === (i = t[s]) ||
              void 0 === i ||
              i.instantiatedPlayer.destroy();
          }
          this._embeddedPlayerEvaluationInfos.length = 0;
        }
        evaluate(t, e) {
          const { _embeddedPlayers: i, _embeddedPlayerEvaluationInfos: s } =
              this,
            n = i.length;
          for (let r = 0; r < n; ++r) {
            const n = s[r];
            if (!n) continue;
            const { entered: a, instantiatedPlayer: o, lastIterations: h } = n,
              { begin: l, end: c } = i[r];
            if (
              (t >= l && t <= c
                ? a
                  ? e !== h && (o.stop(), o.play(), (n.entered = !0))
                  : (o.play(), (n.entered = !0))
                : a && (o.stop(), (n.entered = !1)),
              (n.lastIterations = e),
              n.entered)
            ) {
              const e = t - l;
              n.instantiatedPlayer.setTime(e);
            }
          }
        }
        notifyHostSpeedChanged(t) {
          const { _embeddedPlayers: e, _embeddedPlayerEvaluationInfos: i } =
              this,
            s = e.length;
          for (let n = 0; n < s; ++n) {
            const s = i[n];
            if (!s) continue;
            const { instantiatedPlayer: r } = s,
              { reconciledSpeed: a } = e[n];
            a && r.setSpeed(t);
          }
        }
        notifyHostPlay(t) {
          const { _embeddedPlayers: e, _embeddedPlayerEvaluationInfos: i } =
              this,
            s = e.length;
          for (let n = 0; n < s; ++n) {
            const s = i[n];
            if (!s) continue;
            const { begin: r, end: a } = e[n],
              { instantiatedPlayer: o, entered: h } = s;
            if (h) {
              const { hostPauseTime: e } = s;
              if (o.randomAccess || Ti(e, t, 1e-5)) {
                const e = Si(t, r, a);
                o.play(), o.setTime(e - r);
              } else o.stop();
            }
          }
        }
        notifyHostPause(t) {
          const { _embeddedPlayers: e, _embeddedPlayerEvaluationInfos: i } =
              this,
            s = e.length;
          for (let e = 0; e < s; ++e) {
            const s = i[e];
            if (!s) continue;
            const { instantiatedPlayer: n, entered: r } = s;
            r && (n.pause(), (s.hostPauseTime = t));
          }
        }
        notifyHostStop() {
          const { _embeddedPlayers: t, _embeddedPlayerEvaluationInfos: e } =
              this,
            i = t.length;
          for (let t = 0; t < i; ++t) {
            const i = e[t];
            if (!i) continue;
            const { instantiatedPlayer: s, entered: n } = i;
            n && ((i.entered = !1), s.stop());
          }
        }
      }
      class s$ {
        constructor(t, e, i) {
          (this._exoticAnimationEvaluator = void 0),
            (this._trackEvalStatues = []),
            (this._rootMotionEvaluation = void 0),
            (this._trackEvalStatues = t),
            (this._exoticAnimationEvaluator = e),
            (this._rootMotionEvaluation = i);
        }
        evaluate(t) {
          const { _trackEvalStatues: e, _exoticAnimationEvaluator: i } = this,
            s = e.length;
          for (let i = 0; i < s; ++i) e[i].evaluate(t);
          i && i.evaluate(t);
        }
        evaluateRootMotion(t, e) {
          const { _rootMotionEvaluation: i } = this;
          i && i.evaluate(t, e);
        }
      }
      class n$ {
        constructor() {
          (this.position = new Yi()),
            (this.scale = new Yi(1, 1, 1)),
            (this.rotation = new as()),
            (this.eulerAngles = new Yi());
        }
        getTransform(t) {
          ms.fromRTS(t, this.rotation, this.position, this.scale);
        }
      }
      class r$ extends n$ {
        constructor(...t) {
          super(...t),
            (this.parent = null),
            (this._dirty = !0),
            (this._transform = new ms());
        }
        get globalTransform() {
          const t = this._transform;
          return (
            this._dirty &&
              ((this._dirty = !1),
              ms.fromRTS(t, this.rotation, this.position, this.scale),
              this.parent && ms.multiply(t, this.parent.globalTransform, t)),
            this._transform
          );
        }
        invalidate() {
          this._dirty = !0;
        }
      }
      const a$ = new ms();
      class o$ {
        constructor(t, e, i, s) {
          (this._initialTransformCache = new ms()),
            (this._clipEndTransformCache = new ms()),
            (this._startTransformCache = new ms()),
            (this._endTransformCache = new ms()),
            (this._motionTransformCache = new ms()),
            (this._translationMotionCache = new Yi()),
            (this._rotationMotionCache = new as()),
            (this._scaleMotionCache = new Yi()),
            (this._rootBone = t),
            (this._duration = e),
            (this._boneTransform = i),
            (this._trackEvalStatuses = s);
        }
        evaluate(t, e) {
          const i = this._calcMotionTransform(t, e, this._motionTransformCache),
            {
              _translationMotionCache: s,
              _rotationMotionCache: n,
              _scaleMotionCache: r,
              _rootBone: a,
            } = this;
          ms.toRTS(i, n, s, r),
            Yi.add(s, s, a.position),
            a.setPosition(s),
            as.multiply(n, n, a.rotation),
            a.setRotation(n),
            Yi.multiply(r, r, a.scale),
            a.setScale(r);
        }
        _calcMotionTransform(t, e, i) {
          const { _duration: s } = this,
            n = s - t,
            r = this._evaluateAt(t, this._startTransformCache);
          if (e < n) {
            const s = this._evaluateAt(t + e, this._endTransformCache);
            h$(i, r, s);
          } else {
            ms.identity(i);
            const t = (t, e) => {
                h$(a$, t, e), ms.multiply(i, i, a$);
              },
              a = e - n,
              o = Math.floor(a / s),
              h = a - o * s,
              l = this._evaluateAt(0, this._initialTransformCache),
              c = this._evaluateAt(s, this._clipEndTransformCache),
              u = this._evaluateAt(h, this._endTransformCache);
            t(r, c), h$(a$, l, c);
            for (let t = 0; t < o; ++t) ms.multiply(i, i, a$);
            t(l, u);
          }
          return i;
        }
        _evaluateAt(t, e) {
          const { _trackEvalStatuses: i } = this,
            s = i.length;
          for (let e = 0; e < s; ++e) i[e].evaluate(t);
          return this._boneTransform.getTransform(e), e;
        }
      }
      function h$(t, e, i) {
        ms.invert(t, e), ms.multiply(t, i, t);
      }
      function l$(t, e) {
        switch (e) {
          default:
            return;
          case "position":
            return {
              setValue(e) {
                Yi.copy(t.position, e);
              },
            };
          case "rotation":
            return {
              setValue(e) {
                as.copy(t.rotation, e);
              },
            };
          case "scale":
            return {
              setValue(e) {
                Yi.copy(t.scale, e);
              },
            };
          case "eulerAngles":
            return {
              setValue(e) {
                Yi.copy(t.eulerAngles, e);
              },
            };
        }
      }
      class c$ {
        constructor(t, e, i, s) {
          (this._lastFrameIndex = -1),
            (this._lastIterations = 0),
            (this._lastDirection = 0),
            (this._ignoreIndex = -1),
            (this._sampled = !1),
            (this._targetNode = t),
            (this._ratios = e),
            (this._eventGroups = i),
            (this._wrapMode = s);
        }
        setWrapMode(t) {
          this._wrapMode = t;
        }
        ignore(t, e) {
          (this._ignoreIndex = -1), (this._sampled = !1);
          let i = _$(t, this._ratios);
          i < 0 && ((i = ~i - 1), e < 0 && (i += 1), (this._ignoreIndex = i));
        }
        reset() {
          (this._lastFrameIndex = -1),
            (this._lastIterations = 0),
            (this._lastDirection = 0),
            (this._ignoreIndex = -1),
            (this._sampled = !1);
        }
        sample(t, e, i) {
          if (0 === this._eventGroups.length) return;
          const s = this._eventGroups.length;
          let n = _$(t, this._ratios);
          if (
            (n < 0 && ((n = ~n - 1), e < 0 && (n += 1)),
            this._ignoreIndex !== n && (this._ignoreIndex = -1),
            !this._sampled)
          )
            return (
              (this._sampled = !0),
              this._doFire(n, !1),
              (this._lastFrameIndex = n),
              (this._lastIterations = i),
              void (this._lastDirection = e)
            );
          const r = this._wrapMode,
            a = u$(i);
          let o = u$(this._lastIterations),
            h = this._lastFrameIndex;
          const l = this._lastDirection,
            c = -1 !== o && a !== o;
          if (h === n && c && 1 === s) this._doFire(0, !1);
          else if (h !== n || c) {
            e = l;
            do {
              if (h !== n) {
                if (
                  (-1 === e && 0 === h && n > 0
                    ? ((r & xl.PingPong) === xl.PingPong ? (e *= -1) : (h = s),
                      o++)
                    : 1 === e &&
                      h === s - 1 &&
                      n < s - 1 &&
                      ((r & xl.PingPong) === xl.PingPong ? (e *= -1) : (h = -1),
                      o++),
                  h === n)
                )
                  break;
                if (o > a) break;
              }
              (h += e), this._doFire(h, !0);
            } while (h !== n && h > -1 && h < s);
          }
          (this._lastFrameIndex = n),
            (this._lastIterations = i),
            (this._lastDirection = e);
        }
        _doFire(t, e) {
          e
            ? EG().pushDelayEvent(this._checkAndFire, this, [t])
            : this._checkAndFire(t);
        }
        _checkAndFire(t) {
          if (!this._targetNode || !this._targetNode.isValid) return;
          const { _eventGroups: e } = this;
          if (t < 0 || t >= e.length || this._ignoreIndex === t) return;
          const i = e[t],
            s = i.events.length;
          for (let t = 0; t < s; ++t) {
            const e = i.events[t];
            fW(this._targetNode, e.functionName, e.parameters);
          }
        }
      }
      function u$(t) {
        return t - (0 | t) == 0 && (t -= 1), 0 | t;
      }
      function _$(t, e) {
        return la(e, t);
      }
      const d$ = new Yi(),
        p$ = new as();
      class m$ {
        constructor(t) {
          this._transformHandle = t;
        }
        destroy() {
          this._transformHandle.destroy();
        }
      }
      class f$ extends m$ {
        setValue(t, e) {
          e.transforms.setPosition(this._transformHandle.index, t);
        }
        getValue(t) {
          return t.transforms.getPosition(this._transformHandle.index, d$);
        }
      }
      class g$ extends m$ {
        setValue(t, e) {
          e.transforms.setRotation(this._transformHandle.index, t);
        }
        getValue(t) {
          return t.transforms.getRotation(this._transformHandle.index, p$);
        }
      }
      class y$ extends m$ {
        setValue(t, e) {
          const i = as.fromEuler(y$._EULER_TO_QUAT_CACHE, t.x, t.y, t.z);
          e.transforms.setRotation(this._transformHandle.index, i);
        }
        getValue(t) {
          const e = t.transforms.getRotation(this._transformHandle.index, p$);
          return as.toEuler(d$, e);
        }
      }
      y$._EULER_TO_QUAT_CACHE = new as();
      class T$ extends m$ {
        setValue(t, e) {
          e.transforms.setScale(this._transformHandle.index, t);
        }
        getValue(t) {
          return t.transforms.getScale(this._transformHandle.index, d$);
        }
      }
      class S$ {
        constructor(t) {
          this._handle = t;
        }
        destroy() {
          this._handle.destroy();
        }
        setValue(t, e) {
          e.auxiliaryCurves[this._handle.index] = t;
        }
        getValue(t) {
          return t.auxiliaryCurves[this._handle.index];
        }
      }
      class E$ {
        constructor(t) {
          this.binding = t;
        }
        destroy() {}
        setValue(t, e) {
          this.binding.setValue(t);
        }
        getValue(t) {
          var e, i, s;
          return null !==
            (e =
              null === (i = (s = this.binding).getValue) || void 0 === i
                ? void 0
                : i.call(s)) && void 0 !== e
            ? e
            : void 0;
        }
      }
      class v$ {
        constructor(t, e) {
          (this._binding = void 0),
            (this._trackSampler = void 0),
            (this._binding = t),
            (this._trackSampler = e);
        }
        destroy() {
          this._binding.destroy();
        }
        evaluate(t, e) {
          const { _trackSampler: i, _binding: s } = this,
            n = i.requiresDefault ? s.getValue(e) : void 0,
            r = i.evaluate(t, n);
          s.setValue(r, e);
        }
      }
      function b$(t, e, i) {
        const s = (function (t, e) {
          const { origin: i } = e,
            { path: s, proxy: n } = t,
            r = s.length,
            a = r - 1;
          if (0 !== r && (s.isPropertyAt(a) || s.isElementAt(a)) && !n) {
            const t = s.isPropertyAt(a)
                ? s.parsePropertyAt(a)
                : s.parseElementAt(a),
              n = s[iV](i, 0, r - 1);
            if (null === n) return null;
            if (n instanceof Pf && oV(t)) {
              const s = (() => {
                const t = [];
                let e = n;
                for (; e && e !== i; e = e.parent) t.unshift(e.name);
                return e === i ? t.join("/") : void 0;
              })();
              if ("string" == typeof s) {
                const i = e.bindTransform(s);
                if (!i) return;
                return (function (t, e) {
                  switch (e) {
                    case "position":
                      return new f$(t);
                    case "rotation":
                      return new g$(t);
                    case "eulerAngles":
                      return new y$(t);
                    case "scale":
                      return new T$(t);
                  }
                })(i, t);
              }
            }
          }
          {
            const i = t.createRuntimeBinding(e.origin, void 0, !1);
            return i ? new E$(i) : null;
          }
        })(e[nV], i);
        return null != s ? s : void 0;
      }
      class A$ {
        constructor(t, e) {
          (this._binding = t), (this._curve = e);
        }
        evaluate(t, e) {
          const { _curve: i, _binding: s } = this,
            n = e,
            r = i.evaluate(t);
          s.setValue(r, n);
        }
      }
      class C$ {
        constructor(t, e) {
          (this._trackEvaluations = []),
            (this._exoticAnimationEvaluation = void 0),
            (this._auxiliaryCurveEvaluations = []),
            t._trySyncLegacyData();
          const i = [];
          let s;
          const n = [],
            { tracks: r } = t,
            a = t[Xq];
          for (const t of r) {
            if (t instanceof SK) continue;
            if (
              Array.from(t.channels()).every(
                ({ curve: t }) => 0 === t.keyFramesCount
              )
            )
              continue;
            const s = b$(0, t, e);
            if (!s) continue;
            const n = t[hG](),
              r = new v$(s, n);
            i.push(r);
          }
          a && (s = a.createEvaluatorForAnimationGraph(e));
          const o = t.getAuxiliaryCurveNames_experimental(),
            h = o.length;
          for (let i = 0; i < h; ++i) {
            const s = o[i],
              r = t.getAuxiliaryCurve_experimental(s),
              a = e.bindAuxiliaryCurve(s),
              h = new S$(a);
            n.push(new A$(h, r));
          }
          (this._trackEvaluations = i),
            (this._exoticAnimationEvaluation = s),
            (this._auxiliaryCurveEvaluations = n);
        }
        destroy() {
          var t;
          null === (t = this._exoticAnimationEvaluation) ||
            void 0 === t ||
            t.destroy();
          const { _trackEvaluations: e } = this,
            i = e.length;
          for (let t = 0; t < i; ++t) e[t].destroy();
        }
        evaluate(t, e) {
          const {
              _trackEvaluations: i,
              _exoticAnimationEvaluation: s,
              _auxiliaryCurveEvaluations: n,
            } = this,
            r = e.pushDefaultedPose(),
            a = i.length;
          for (let e = 0; e < a; ++e) i[e].evaluate(t, r);
          s && s.evaluate(t, r);
          const o = n.length;
          for (let e = 0; e < o; ++e) n[e].evaluate(t, r);
          return r;
        }
      }
      class O$ {
        constructor(t, e) {
          (this._clipEval = void 0),
            (this._refClipEval = void 0),
            (this._clipEval = new C$(t, e));
          const i = t[Qq].refClip;
          i && i !== t && (this._refClipEval = new C$(i, e));
        }
        destroy() {
          var t;
          this._clipEval.destroy(),
            null === (t = this._refClipEval) || void 0 === t || t.destroy();
        }
        evaluate(t, e) {
          const i = this._clipEval.evaluate(t, e);
          let s;
          if (this._refClipEval) {
            const t = 0;
            s = this._refClipEval.evaluate(t, e);
          } else s = this._clipEval.evaluate(0, e);
          return (
            (r = s),
            (function (t, e) {
              const i = t.length;
              e.length;
              for (let s = 0; s < i; ++s) gX(t, e, s);
            })((n = i).transforms, r.transforms),
            (function (t, e) {
              t.length, e.length;
              for (let i = 0; i < t.length; ++i) t[i] -= e[i];
            })(n.auxiliaryCurves, r.auxiliaryCurves),
            e.popPose(),
            i
          );
          var n, r;
        }
      }
      var I$, w$, R$, D$, x$;
      const { ccclass: M$, type: P$ } = go;
      let N$ =
        ((I$ = M$("cc.animation.ClipMotion")),
        (w$ = P$(Jq)),
        I$(
          ((D$ = class t extends nK {
            constructor(...t) {
              super(...t), (this.clip = x$ && x$());
            }
            [iK](t, e) {
              return this.clip ? new B$(t, this.clip, e) : null;
            }
            clone() {
              const e = new t();
              return (e.clip = this.clip), (e[Kn] = sW(this)), e;
            }
          }),
          (x$ = fa(D$.prototype, "clip", [w$, Na], function () {
            return null;
          })),
          (R$ = D$))
        ) || R$);
      const L$ = Symbol("EvaluatePort");
      class B$ {
        constructor(t, e, i) {
          var s, n;
          (this._clipEmbeddedPlayerEval = null),
            (this._frameEventEval = null),
            (this._wrapInfo = new TG()),
            (this._duration = 0),
            (this._ignoreEmbeddedPlayers = void 0),
            (this._originalClip = e),
            (this._ignoreEmbeddedPlayers = i);
          const r =
            null !==
              (s =
                null === (n = t.clipOverrides) || void 0 === n
                  ? void 0
                  : n.get(e)) && void 0 !== s
              ? s
              : e;
          this._setClip(r, t);
        }
        get duration() {
          return this._duration;
        }
        createPort() {
          return new F$(this);
        }
        getClipStatuses(t) {
          let e = !1;
          return {
            next: () =>
              e
                ? { done: !0, value: void 0 }
                : ((e = !0),
                  {
                    done: !1,
                    value: {
                      __DEBUG_ID__: this.__DEBUG__ID__,
                      clip: this._clip,
                      weight: t,
                    },
                  }),
          };
        }
        [L$](t, e) {
          var i, s;
          const {
              _duration: n,
              _clip: { duration: r },
              _clipEval: a,
            } = this,
            o = n * t,
            { wrapMode: h } = this._clip,
            l = (function (t, e, i, s, n, r) {
              if (0 === e)
                return (
                  (r.time = 0),
                  (r.ratio = 0),
                  (r.direction = 1),
                  (r.stopped = !!Number.isFinite(s)),
                  (r.iterations = 0),
                  r
                );
              let a = !1,
                o = t > 0 ? t / e : -t / e;
              if (o >= s) {
                (o = s), (a = !0);
                let i = s - (0 | s);
                0 === i && (i = 1), (t = i * e * (t > 0 ? 1 : -1));
              }
              if (t > e) {
                const i = t % e;
                t = 0 === i ? e : i;
              } else t < 0 && 0 != (t %= e) && (t += e);
              let h = !1;
              const l = i & xl.ShouldWrap;
              l &&
                (h = (function (t, e) {
                  let i = !1;
                  return (
                    (t & xl.PingPong) === xl.PingPong &&
                      (e - (0 | e) == 0 && e > 0 && (e -= 1),
                      1 & e && (i = !i)),
                    (t & xl.Reverse) === xl.Reverse && (i = !i),
                    i
                  );
                })(i, o));
              let c = h ? -1 : 1;
              return (
                n && (c *= -1),
                l && h && (t = e - t),
                (r.time = t),
                (r.ratio = r.time / e),
                (r.direction = c),
                (r.stopped = a),
                (r.iterations = o),
                r
              );
            })(
              o,
              n,
              h,
              (h & xl.Loop) === xl.Loop ? 1 / 0 : 1,
              !1,
              this._wrapInfo
            ),
            c = l.ratio * r,
            u = a.evaluate(c, e);
          return (
            null === (i = this._frameEventEval) ||
              void 0 === i ||
              i.sample(l.ratio, l.direction, l.iterations),
            null === (s = this._clipEmbeddedPlayerEval) ||
              void 0 === s ||
              s.evaluate(c, Math.trunc(l.iterations)),
            u
          );
        }
        overrideClips(t) {
          var e;
          const { _originalClip: i } = this,
            s =
              null === (e = t.clipOverrides) || void 0 === e
                ? void 0
                : e.get(i);
          s && this._setClip(s, t);
        }
        reenter() {
          var t;
          null === (t = this._frameEventEval) || void 0 === t || t.reset();
        }
        _setClip(t, e) {
          var i;
          null === (i = this._clipEval) || void 0 === i || i.destroy(),
            (this._frameEventEval = null),
            this._clipEmbeddedPlayerEval &&
              (this._clipEmbeddedPlayerEval.destroy(),
              (this._clipEmbeddedPlayerEval = null)),
            (this._clip = t),
            (this._duration = 0 === t.speed ? 0 : t.duration / t.speed),
            (this._clipEval = (function (t, e) {
              return t.isAdditive_experimental ? new O$(t, e) : new C$(t, e);
            })(t, e)),
            (this._frameEventEval = t.createEventEvaluator(e.origin)),
            !this._ignoreEmbeddedPlayers &&
              t.containsAnyEmbeddedPlayer() &&
              (this._clipEmbeddedPlayerEval = t.createEmbeddedPlayerEvaluator(
                e.origin
              ));
        }
      }
      class F$ {
        constructor(t) {
          (this._eval = void 0), (this._eval = t);
        }
        evaluate(t, e) {
          return this._eval[L$](t, e);
        }
        reenter() {
          this._eval.reenter();
        }
      }
      var U$, k$, z$, H$, G$, V$;
      const { ccclass: j$, serializable: W$ } = go;
      let X$ =
          j$("cc.animation.AnimationBlendItem")(
            ((k$ = class t {
              constructor() {
                this.motion = z$ && z$();
              }
              clone() {
                const e = new t();
                return this._copyTo(e), e;
              }
              _copyTo(t) {
                var e, i;
                return (
                  (t.motion =
                    null !==
                      (e =
                        null === (i = this.motion) || void 0 === i
                          ? void 0
                          : i.clone()) && void 0 !== e
                      ? e
                      : null),
                  t
                );
              }
            }),
            (z$ = fa(k$.prototype, "motion", [W$], function () {
              return null;
            })),
            (U$ = k$))
          ) || U$,
        Y$ =
          j$("cc.animation.AnimationBlend")(
            ((G$ = class extends nK {
              constructor(...t) {
                super(...t), (this.name = V$ && V$());
              }
              copyTo(t) {
                (t.name = this.name), (t[Kn] = sW(this));
              }
            }),
            (V$ = fa(G$.prototype, "name", [W$], function () {
              return "";
            })),
            (H$ = G$))
          ) || H$;
      class K$ {
        constructor(t, e, i, s, n) {
          (this._childEvaluators = s.map((i) => {
            var s, n;
            return null !==
              (s =
                null === (n = i.motion) || void 0 === n
                  ? void 0
                  : n[iK](t, e)) && void 0 !== s
              ? s
              : null;
          })),
            (this._weights = new Array(this._childEvaluators.length).fill(0)),
            (this._inputs = [...n]);
        }
        createPort() {
          return new q$(
            this,
            this._childEvaluators.map((t) => {
              var e;
              return null !== (e = null == t ? void 0 : t.createPort()) &&
                void 0 !== e
                ? e
                : null;
            })
          );
        }
        get childCount() {
          return this._weights.length;
        }
        getChildWeight(t) {
          return this._weights[t];
        }
        getChildMotionEval(t) {
          return this._childEvaluators[t];
        }
        get duration() {
          let t = 0;
          for (let s = 0; s < this._childEvaluators.length; ++s) {
            var e, i;
            t +=
              (null !==
                (e =
                  null === (i = this._childEvaluators[s]) || void 0 === i
                    ? void 0
                    : i.duration) && void 0 !== e
                ? e
                : 0) * this._weights[s];
          }
          return t;
        }
        getClipStatuses(t) {
          const { _childEvaluators: e, _weights: i } = this,
            s = e.length;
          let n,
            r = 0;
          return {
            next() {
              for (;;) {
                if (n) {
                  const t = n.next();
                  if (!t.done) return t;
                }
                if (r >= s) return { done: !0, value: void 0 };
                {
                  const s = e[r];
                  (n = null == s ? void 0 : s.getClipStatuses(t * i[r])), ++r;
                }
              }
            },
          };
        }
        __evaluatePort(t, e, i) {
          const s = this._childEvaluators.length;
          let n = 0,
            r = null;
          for (let o = 0; o < s; ++o) {
            var a;
            const s = this._weights[o];
            if (!s) continue;
            const h =
              null === (a = t.childPorts[o]) || void 0 === a
                ? void 0
                : a.evaluate(e, i);
            h && ((n += s), r ? (n && mX(r, h, s / n), i.popPose()) : (r = h));
          }
          return r || i.pushDefaultedPose();
        }
        overrideClips(t) {
          for (let i = 0; i < this._childEvaluators.length; ++i) {
            var e;
            null === (e = this._childEvaluators[i]) ||
              void 0 === e ||
              e.overrideClips(t);
          }
        }
        setInput(t, e) {
          (this._inputs[e] = t), this.doEval();
        }
        doEval() {
          this.eval(this._weights, this._inputs);
        }
      }
      class q$ {
        constructor(t, e) {
          (this.childPorts = []),
            (this._host = void 0),
            (this._host = t),
            (this.childPorts = e);
        }
        evaluate(t, e) {
          return this._host.__evaluatePort(this, t, e);
        }
        reenter() {
          const { childPorts: t } = this,
            e = t.length;
          for (let s = 0; s < e; ++s) {
            var i;
            null === (i = t[s]) || void 0 === i || i.reenter();
          }
        }
      }
      var $$, Z$, Q$, J$, tZ, eZ, iZ, sZ;
      const { ccclass: nZ, serializable: rZ } = go;
      let aZ =
          nZ("cc.animation.BindableNumber")(
            ((Z$ = class t {
              constructor(t = 0) {
                (this.variable = Q$ && Q$()),
                  (this.value = J$ && J$()),
                  (this.value = t);
              }
              clone() {
                const e = new t();
                return (e.value = this.value), (e.variable = this.variable), e;
              }
            }),
            (Q$ = fa(Z$.prototype, "variable", [rZ], function () {
              return "";
            })),
            (J$ = fa(Z$.prototype, "value", [rZ], function () {
              return 0;
            })),
            ($$ = Z$))
          ) || $$,
        oZ =
          nZ("cc.animation.BindableBoolean")(
            ((eZ = class t {
              constructor(t = !1) {
                (this.variable = iZ && iZ()),
                  (this.value = sZ && sZ()),
                  (this.value = t);
              }
              clone() {
                const e = new t();
                return (e.value = this.value), (e.variable = this.variable), e;
              }
            }),
            (iZ = fa(eZ.prototype, "variable", [rZ], function () {
              return "";
            })),
            (sZ = fa(eZ.prototype, "value", [rZ], function () {
              return !1;
            })),
            (tZ = eZ))
          ) || tZ;
      function hZ(t, e, i, s, n, ...r) {
        const { variable: a, value: o } = e;
        if (!a) return o;
        const h = t.getVar(a);
        if (!lZ(h, a)) return o;
        if (h.type !== i) throw new qj(a, "number");
        return h.bind(s, n, ...r);
      }
      function lZ(t, e) {
        if (t) return !0;
        throw new Kj(e);
      }
      var cZ, uZ, _Z, dZ, pZ, mZ, fZ, gZ;
      const { ccclass: yZ, serializable: TZ } = go;
      let SZ =
          yZ("cc.animation.AnimationBlend1DItem")(
            ((uZ = class t extends X$ {
              constructor(...t) {
                super(...t), (this.threshold = _Z && _Z());
              }
              clone() {
                const e = new t();
                return this._copyTo(e), e;
              }
              _copyTo(t) {
                return super._copyTo(t), (t.threshold = this.threshold), t;
              }
            }),
            (_Z = fa(uZ.prototype, "threshold", [TZ], function () {
              return 0;
            })),
            (cZ = uZ))
          ) || cZ,
        EZ =
          yZ("cc.animation.AnimationBlend1D")(
            (((gZ = class t extends Y$ {
              constructor(...t) {
                super(...t),
                  (this._items = mZ && mZ()),
                  (this.param = fZ && fZ());
              }
              get items() {
                return this._items;
              }
              set items(t) {
                this._items = Array.from(t).sort(
                  ({ threshold: t }, { threshold: e }) => t - e
                );
              }
              clone() {
                const e = new t();
                return (
                  this.copyTo(e),
                  (e._items = this._items.map((t) => t.clone())),
                  (e.param = this.param.clone()),
                  e
                );
              }
              [iK](t, e) {
                const i = new vZ(
                    t,
                    e,
                    this,
                    this._items,
                    this._items.map(({ threshold: t }) => t),
                    0
                  ),
                  s = hZ(t, this.param, vj.FLOAT, i.setInput, i, 0);
                return i.setInput(s, 0), i;
              }
            }).Item = SZ),
            (mZ = fa((pZ = gZ).prototype, "_items", [TZ], function () {
              return [];
            })),
            (fZ = fa(pZ.prototype, "param", [TZ], function () {
              return new aZ();
            })),
            (dZ = pZ))
          ) || dZ;
      class vZ extends K$ {
        constructor(t, e, i, s, n, r) {
          super(t, e, i, s, [r]), (this._thresholds = n), this.doEval();
        }
        eval(t, [e]) {
          !(function (t, e, i) {
            if ((t.fill(0), 0 === e.length));
            else if (i <= e[0]) t[0] = 1;
            else if (i >= e[e.length - 1]) t[t.length - 1] = 1;
            else {
              let s = 0;
              for (let t = 1; t < e.length; ++t)
                if (e[t] > i) {
                  s = t;
                  break;
                }
              const n = e[s - 1],
                r = e[s],
                a = r - n;
              (t[s - 1] = (r - i) / a), (t[s] = (i - n) / a);
            }
          })(t, this._thresholds, e);
        }
      }
      const bZ = (() => {
        const t = new Ss(),
          e = { wA: 0, wB: 0 };
        return function (i, s, n) {
          if ((i.length, s.length, 0 === s.length)) return;
          if (1 === s.length) return void (i[0] = 1);
          if (Ss.strictEquals(n, Ss.ZERO)) {
            const t = s.findIndex((t) => Ss.strictEquals(t, Ss.ZERO));
            return void (t >= 0 ? (i[t] = 1) : i.fill(1 / s.length));
          }
          let r = -1,
            a = -1,
            o = -1,
            h = Number.NEGATIVE_INFINITY,
            l = Number.NEGATIVE_INFINITY;
          const { x: c, y: u } = n;
          for (let e = 0; e < s.length; ++e) {
            const i = s[e];
            if (Ss.equals(i, Ss.ZERO)) {
              o = e;
              continue;
            }
            const _ = Ss.normalize(t, i),
              d = Ss.dot(_, n);
            _.x * u - _.y * c > 0
              ? d >= l && ((l = d), (r = e))
              : d >= h && ((h = d), (a = e));
          }
          let _ = 0;
          if (r < 0 || a < 0) _ = 1;
          else {
            const { wA: t, wB: o } = (function (t, e, i, s) {
              const n = Ss.cross(t, e);
              return (
                n
                  ? ((s.wA = Ss.cross(i, e) / n), (s.wB = Ss.cross(i, t) / -n))
                  : ((s.wA = 0), (s.wB = 0)),
                s
              );
            })(s[r], s[a], n, e);
            let h = 0,
              l = 0;
            const c = t + o;
            c > 1
              ? ((h = t / c), (l = o / c))
              : c < 0
              ? ((h = 0), (l = 0), (_ = 1))
              : ((h = t), (l = o), (_ = 1 - c)),
              (i[r] = h),
              (i[a] = l);
          }
          if (_ > 0)
            if (o >= 0) i[o] = _;
            else {
              const t = _ / i.length;
              for (let e = 0; e < i.length; ++e) i[e] += t;
            }
        };
      })();
      const AZ = (t, e, i, s, n) => {
        Ss.subtract(s, i, t), Ss.subtract(n, e, t);
      };
      class CZ {
        constructor(t) {
          const { _ANGLE_MULTIPLIER: e } = CZ,
            i = t.length,
            s = (this._exampleMagnitudes = new Array(i).fill(0)),
            n = (this._exampleDirections = t.map((t, e) => {
              const i = Ss.copy(new Ss(), t),
                n = Ss.len(i);
              return (
                (s[e] = n), Ti(n, 0, 1e-5) || Ss.multiplyScalar(i, i, 1 / n), i
              );
            })),
            r = (this._precomputedVIJs = new Float32Array(3 * i * i));
          for (let t = 0; t < i; ++t) {
            const a = s[t],
              o = n[t];
            for (let h = 0; h < i; ++h) {
              if (t === h) continue;
              const l = s[h],
                c = n[h],
                u = (a + l) / 2,
                _ = 3 * (i * t + h);
              (r[_ + 0] = (l - a) / u),
                (r[_ + 1] = OZ(o, c) * e),
                (r[_ + 2] = u);
            }
          }
          this._cacheVIXAngles = new Float32Array(i);
        }
        interpolate(t, e) {
          const {
              _exampleDirections: i,
              _exampleMagnitudes: s,
              _precomputedVIJs: n,
              _cacheVIXAngles: r,
            } = this,
            {
              _CACHE_INPUT_DIRECTION: a,
              _CACHE_VIJ: o,
              _CACHE_VIX: h,
              _ANGLE_MULTIPLIER: l,
            } = CZ,
            c = i.length;
          if ((t.length, 0 === c)) return;
          if (1 === c) return void (t[0] = 1);
          const u = e,
            _ = Ss.len(u),
            d = r;
          if (Ss.equals(u, Ss.ZERO)) for (let t = 0; t < c; ++t) d[t] = 0;
          else {
            const t = Ss.multiplyScalar(a, u, 1 / _);
            for (let e = 0; e < c; ++e) {
              const s = i[e];
              Ss.equals(s, Ss.ZERO) ? (d[e] = 0) : (d[e] = OZ(s, t) * l);
            }
          }
          let p = 0;
          for (let e = 0; e < c; ++e) {
            const r = s[e],
              a = i[e];
            let l = Number.POSITIVE_INFINITY;
            for (let t = 0; t < c; ++t) {
              if (e === t) continue;
              const s = i[t],
                p = 3 * (c * e + t),
                { [p + 0]: m, [p + 1]: f, [p + 2]: g } = n;
              let y = f,
                T = d[e];
              Ss.equals(a, Ss.ZERO)
                ? (y = d[t])
                : Ss.equals(s, Ss.ZERO)
                ? (y = d[e])
                : Ss.equals(u, Ss.ZERO) && (T = y);
              const S = Ss.set(o, m, y),
                E = Ss.set(h, (_ - r) / g, T),
                v = 1 - Ss.dot(E, S) / Ss.lengthSqr(S);
              if (v <= 0) {
                l = 0;
                break;
              }
              l = Math.min(l, v);
            }
            (t[e] = l), (p += l);
          }
          if (p > 0) for (let e = 0; e < c; ++e) t[e] /= p;
          else {
            const e = 1 / c;
            for (let i = 0; i < c; ++i) t[i] = e;
          }
        }
      }
      function OZ(t, e) {
        const i = Ss.angle(t, e);
        return t.x * e.y - t.y * e.x < 0 ? -i : i;
      }
      var IZ, wZ, RZ, DZ, xZ, MZ, PZ, NZ, LZ, BZ;
      (CZ._CACHE_INPUT_DIRECTION = new Ss()),
        (CZ._CACHE_VIJ = new Ss()),
        (CZ._CACHE_VIX = new Ss()),
        (CZ._ANGLE_MULTIPLIER = 1);
      const { ccclass: FZ, serializable: UZ } = go;
      var kZ;
      !(function (t) {
        (t[(t.SIMPLE_DIRECTIONAL = 0)] = "SIMPLE_DIRECTIONAL"),
          (t[(t.FREEFORM_CARTESIAN = 1)] = "FREEFORM_CARTESIAN"),
          (t[(t.FREEFORM_DIRECTIONAL = 2)] = "FREEFORM_DIRECTIONAL");
      })(kZ || (kZ = {})),
        de(kZ);
      let zZ =
          FZ("cc.animation.AnimationBlend2DItem")(
            ((wZ = class t extends X$ {
              constructor(...t) {
                super(...t), (this.threshold = RZ && RZ());
              }
              clone() {
                const e = new t();
                return this._copyTo(e), e;
              }
              _copyTo(t) {
                return (
                  super._copyTo(t), Ss.copy(t.threshold, this.threshold), t
                );
              }
            }),
            (RZ = fa(wZ.prototype, "threshold", [UZ], function () {
              return new Ss();
            })),
            (IZ = wZ))
          ) || IZ,
        HZ =
          FZ("cc.animation.AnimationBlend2D")(
            (((BZ = class t extends Y$ {
              constructor(...t) {
                super(...t),
                  (this._items = MZ && MZ()),
                  (this.paramX = PZ && PZ()),
                  (this.paramY = NZ && NZ()),
                  (this._algorithm = LZ && LZ()),
                  (this._polarSpaceGBI = void 0);
              }
              get algorithm() {
                return this._algorithm;
              }
              set algorithm(t) {
                t !== this._algorithm &&
                  ((this._algorithm = t),
                  this._tryReconstructPolarSpaceInterpolator());
              }
              get items() {
                return this._items;
              }
              set items(t) {
                (this._items = Array.from(t)),
                  this._tryReconstructPolarSpaceInterpolator();
              }
              __callOnAfterDeserializeRecursive() {
                this._tryReconstructPolarSpaceInterpolator();
              }
              clone() {
                const e = new t();
                return (
                  this.copyTo(e),
                  (e._items = this._items.map((t) => {
                    var e;
                    return null !== (e = null == t ? void 0 : t.clone()) &&
                      void 0 !== e
                      ? e
                      : null;
                  })),
                  (e.paramX = this.paramX.clone()),
                  (e.paramY = this.paramY.clone()),
                  (e.algorithm = this._algorithm),
                  e
                );
              }
              [iK](t, e) {
                const { algorithm: i } = this;
                let s;
                switch (i) {
                  case kZ.FREEFORM_DIRECTIONAL:
                    this._polarSpaceGBI,
                      (s = new VZ(
                        t,
                        e,
                        this,
                        this._items,
                        this._polarSpaceGBI,
                        [0, 0]
                      ));
                    break;
                  default:
                  case kZ.SIMPLE_DIRECTIONAL:
                  case kZ.FREEFORM_CARTESIAN:
                    s = new GZ(
                      t,
                      e,
                      this,
                      this._items,
                      this._items.map(({ threshold: t }) => t),
                      i,
                      [0, 0]
                    );
                }
                const n = hZ(t, this.paramX, vj.FLOAT, s.setInput, s, 0),
                  r = hZ(t, this.paramY, vj.FLOAT, s.setInput, s, 1);
                return s.setInput(n, 0), s.setInput(r, 1), s;
              }
              _tryReconstructPolarSpaceInterpolator() {
                this._algorithm === kZ.FREEFORM_DIRECTIONAL
                  ? (this._polarSpaceGBI = new CZ(
                      this._items.map((t) => t.threshold)
                    ))
                  : (this._polarSpaceGBI = void 0);
              }
            }).Algorithm = kZ),
            (BZ.Item = zZ),
            (MZ = fa((xZ = BZ).prototype, "_items", [UZ], function () {
              return [];
            })),
            (PZ = fa(xZ.prototype, "paramX", [UZ], function () {
              return new aZ();
            })),
            (NZ = fa(xZ.prototype, "paramY", [UZ], function () {
              return new aZ();
            })),
            (LZ = fa(xZ.prototype, "_algorithm", [UZ], function () {
              return kZ.SIMPLE_DIRECTIONAL;
            })),
            (DZ = xZ))
          ) || DZ;
      class GZ extends K$ {
        constructor(t, e, i, s, n, r, a) {
          super(t, e, i, s, a),
            (this._thresholds = void 0),
            (this._algorithm = void 0),
            (this._value = new Ss()),
            (this._thresholds = n),
            (this._algorithm = r),
            this.doEval();
        }
        eval(t, [e, i]) {
          switch ((Ss.set(this._value, e, i), t.fill(0), this._algorithm)) {
            case kZ.SIMPLE_DIRECTIONAL:
              bZ(t, this._thresholds, this._value);
              break;
            case kZ.FREEFORM_CARTESIAN:
              !(function (t, e, i) {
                !(function (t, e, i, s) {
                  t.fill(0);
                  const n = new Ss(0, 0),
                    r = new Ss(0, 0);
                  let a = 0;
                  const o = e.length;
                  for (let h = 0; h < o; ++h) {
                    let l = Number.MAX_VALUE,
                      c = !1;
                    for (let t = 0; t < o; ++t) {
                      if (h === t) continue;
                      s(e[h], e[t], i, n, r);
                      const a = 1 - Ss.dot(n, r) / Ss.lengthSqr(r);
                      if (a < 0) {
                        c = !0;
                        break;
                      }
                      l = Math.min(l, a);
                    }
                    c || ((t[h] = l), (a += l));
                  }
                  a > 0 && t.forEach((e, i) => (t[i] = e / a));
                })(t, e, i, AZ);
              })(t, this._thresholds, this._value);
          }
        }
      }
      class VZ extends K$ {
        constructor(t, e, i, s, n, r) {
          super(t, e, i, s, r),
            (this._interpolator = void 0),
            (this._value = new Ss()),
            (this._interpolator = n),
            this.doEval();
        }
        eval(t, [e, i]) {
          Ss.set(this._value, e, i),
            t.fill(0),
            this._interpolator.interpolate(t, this._value);
        }
      }
      var jZ, WZ, XZ, YZ, KZ, qZ;
      const { ccclass: $Z, serializable: ZZ } = go;
      let QZ =
        $Z("cc.animation.AnimationBlendDirectItem")(
          ((WZ = class t extends X$ {
            constructor(...t) {
              super(...t), (this.weight = XZ && XZ());
            }
            clone() {
              const e = new t();
              return this._copyTo(e), e;
            }
            _copyTo(t) {
              return super._copyTo(t), (t.weight = this.weight), t;
            }
          }),
          (XZ = fa(WZ.prototype, "weight", [ZZ], function () {
            return new aZ(0);
          })),
          (jZ = WZ))
        ) || jZ;
      $Z("cc.animation.AnimationBlendDirect")(
        (((qZ = class t extends Y$ {
          constructor(...t) {
            super(...t), (this._items = KZ && KZ());
          }
          get items() {
            return this._items;
          }
          set items(t) {
            this._items = Array.from(t);
          }
          clone() {
            const e = new t();
            return (
              this.copyTo(e),
              (e._items = this._items.map((t) => {
                var e;
                return null !== (e = null == t ? void 0 : t.clone()) &&
                  void 0 !== e
                  ? e
                  : null;
              })),
              e
            );
          }
          [iK](t, e) {
            const i = new JZ(
              t,
              e,
              this,
              this._items,
              new Array(this._items.length).fill(0)
            );
            for (let e = 0; e < this._items.length; ++e) {
              const s = hZ(
                t,
                this._items[e].weight,
                vj.FLOAT,
                i.setInput,
                i,
                e
              );
              i.setInput(s, e);
            }
            return i;
          }
        }).Item = QZ),
        (KZ = fa((YZ = qZ).prototype, "_items", [ZZ], function () {
          return [];
        })),
        YZ)
      );
      class JZ extends K$ {
        constructor(...t) {
          super(...t), this.doEval();
        }
        eval(t, e) {
          const i = t.length;
          for (let s = 0; s < i; ++s) t[s] = e[s];
        }
      }
      var tQ, eQ, iQ, sQ, nQ, rQ, aQ, oQ;
      let hQ,
        lQ =
          Ca("cc.JointMask")(
            ((eQ = class {
              constructor() {
                (this.path = iQ && iQ()), (this.enabled = sQ && sQ());
              }
            }),
            (iQ = fa(eQ.prototype, "path", [Na], function () {
              return "";
            })),
            (sQ = fa(eQ.prototype, "enabled", [Na], function () {
              return !0;
            })),
            (tQ = eQ))
          ) || tQ;
      var cQ, uQ, _Q, dQ, pQ, mQ, fQ, gQ, yQ, TQ, SQ, EQ, vQ;
      (nQ = Ca("cc.animation.AnimationMask")),
        (rQ = ao(lQ)),
        nQ(
          ((aQ = class extends Ad {
            constructor(...t) {
              super(...t), (this._jointMasks = oQ && oQ());
            }
            get joints() {
              return this._jointMasks;
            }
            set joints(t) {
              this.clear();
              for (const e of t) this.addJoint(e.path, e.enabled);
            }
            addJoint(t, e) {
              this.removeJoint(t);
              const i = new lQ();
              (i.path = t), (i.enabled = e), this._jointMasks.push(i);
            }
            removeJoint(t) {
              ie(this._jointMasks, ({ path: e }) => e === t);
            }
            clear() {
              this._jointMasks.length = 0;
            }
            filterDisabledNodes(t) {
              const { _jointMasks: e } = this,
                i = e.length,
                s = new Set();
              for (let n = 0; n < i; ++n) {
                const { path: i, enabled: r } = e[n];
                if (r) continue;
                const a = t.getChildByPath(i);
                a && s.add(a);
              }
              return s;
            }
            isExcluded(t) {
              var e, i;
              return !(
                null ===
                  (e =
                    null ===
                      (i = this._jointMasks.find(({ path: e }) => e === t)) ||
                    void 0 === i
                      ? void 0
                      : i.enabled) ||
                void 0 === e ||
                e
              );
            }
          }),
          (oQ = fa(aQ.prototype, "_jointMasks", [Na], function () {
            return [];
          })),
          s(
            aQ.prototype,
            "joints",
            [rQ],
            Object.getOwnPropertyDescriptor(aQ.prototype, "joints"),
            aQ.prototype
          ),
          aQ)
        );
      let bQ =
          Ca("cc.animation.ClipOverrideEntry")(
            ((uQ = class {
              constructor() {
                (this.original = _Q && _Q()), (this.substitution = dQ && dQ());
              }
            }),
            (_Q = fa(uQ.prototype, "original", [Na], function () {
              return null;
            })),
            (dQ = fa(uQ.prototype, "substitution", [Na], function () {
              return null;
            })),
            (cQ = uQ))
          ) || cQ,
        AQ =
          ((pQ = Ca("cc.animation.AnimationGraphVariant")),
          (mQ = ao(eK)),
          pQ(
            (s(
              (gQ = class extends MW {
                constructor(...t) {
                  super(...t),
                    (this._graph = yQ && yQ()),
                    (this._clipOverrides = TQ && TQ());
                }
                get original() {
                  return this._graph;
                }
                set original(t) {
                  this._graph = t;
                }
                get clipOverrides() {
                  return this._clipOverrides;
                }
              }).prototype,
              "original",
              [mQ],
              Object.getOwnPropertyDescriptor(gQ.prototype, "original"),
              gQ.prototype
            ),
            (yQ = fa(gQ.prototype, "_graph", [Na], function () {
              return null;
            })),
            (TQ = fa(gQ.prototype, "_clipOverrides", [Na], function () {
              return new CQ();
            })),
            (fQ = gQ))
          ) || fQ),
        CQ =
          Ca("cc.animation.ClipOverrideMap")(
            ((hQ = Symbol.iterator),
            (EQ = class {
              constructor() {
                this._entries = vQ && vQ();
              }
              get size() {
                return this._entries.length;
              }
              [hQ]() {
                return this._entries[Symbol.iterator]();
              }
              has(t) {
                return !!this._entries.find(({ original: e }) => e === t);
              }
              get(t) {
                const e = this._entries.find(({ original: e }) => e === t);
                return null == e ? void 0 : e.substitution;
              }
              set(t, e) {
                const i = this._entries.find(({ original: e }) => e === t);
                if (i) i.substitution = e;
                else {
                  const i = new bQ();
                  (i.original = t), (i.substitution = e), this._entries.push(i);
                }
              }
              delete(t) {
                ie(this._entries, ({ original: e }) => e === t);
              }
              clear() {
                this._entries.length = 0;
              }
            }),
            (vQ = fa(EQ.prototype, "_entries", [Na], function () {
              return [];
            })),
            (SQ = EQ))
          ) || SQ;
      const OQ = 10,
        IQ = Float64Array.BYTES_PER_ELEMENT * OQ;
      class wQ {
        static get BYTES_PER_ELEMENT() {
          return IQ;
        }
        constructor(t, e, i) {
          (this._data = void 0),
            (this._data =
              void 0 === t
                ? new Float64Array()
                : "number" == typeof t
                ? new Float64Array(OQ * t)
                : new Float64Array(
                    t,
                    e,
                    "number" == typeof i ? OQ * i : void 0
                  ));
        }
        get buffer() {
          return this._data.buffer;
        }
        get byteLength() {
          return this._data.byteLength;
        }
        get byteOffset() {
          return this._data.byteOffset;
        }
        get length() {
          return this._data.length / OQ;
        }
        getTransform(t, e) {
          const { _data: i } = this,
            { position: s, rotation: n, scale: r } = e,
            a = OQ * t;
          return (
            Yi.fromArray(s, i, a),
            as.fromArray(n, i, a + 3),
            Yi.fromArray(r, i, a + 7),
            e
          );
        }
        getPosition(t, e) {
          const { _data: i } = this,
            s = OQ * t;
          return Yi.fromArray(e, i, s), e;
        }
        getRotation(t, e) {
          const { _data: i } = this,
            s = OQ * t;
          return as.fromArray(e, i, s + 3), e;
        }
        getScale(t, e) {
          const { _data: i } = this,
            s = OQ * t;
          return Yi.fromArray(e, i, s + 7), e;
        }
        setTransform(t, e) {
          const { _data: i } = this,
            { position: s, rotation: n, scale: r } = e,
            a = OQ * t;
          Yi.toArray(i, s, a), as.toArray(i, n, a + 3), Yi.toArray(i, r, a + 7);
        }
        setPosition(t, e) {
          const { _data: i } = this,
            s = OQ * t;
          Yi.toArray(i, e, s);
        }
        setRotation(t, e) {
          const { _data: i } = this,
            s = OQ * t;
          as.toArray(i, e, s + 3);
        }
        setScale(t, e) {
          const { _data: i } = this,
            s = OQ * t;
          Yi.toArray(i, e, s + 7);
        }
        copyWithin(t, e, i) {
          this._data.copyWithin(
            t * OQ,
            e * OQ,
            "number" == typeof i ? i * OQ : void 0
          );
        }
        fill(t, e, i) {
          var s, n;
          const { length: r } = this;
          if (
            ((null !== (s = e) && void 0 !== s) || (e = 0),
            (null !== (n = i) && void 0 !== n) || (i = r),
            !(e >= r))
          ) {
            this.setTransform(e, t);
            for (let t = e + 1; t < i; ++t) this.copyWithin(t, e, e + 1);
          }
        }
        fillZero(t, e) {
          this._data.fill(
            0,
            "number" == typeof t ? t * OQ : void 0,
            "number" == typeof e ? e * OQ : void 0
          );
        }
        set(t, e) {
          this._data.set(t._data, "number" == typeof e ? e * OQ : void 0);
        }
        slice(t, e) {
          const i = this._data.slice(
            "number" == typeof t ? t * OQ : void 0,
            "number" == typeof e ? e * OQ : void 0
          );
          return new wQ(i.buffer, i.byteOffset, i.length / OQ);
        }
        copyRange(t, e, i, s) {
          const n = OQ * s,
            r = this._data,
            a = OQ * t,
            o = e._data,
            h = OQ * i;
          for (let t = 0; t < n; ++t) r[a + t] = o[h + t];
        }
      }
      const RQ = Symbol(""),
        DQ = Symbol("");
      class xQ {
        constructor(t) {
          (this.buffer = void 0),
            (this.useCount = 0),
            (this.buffer = new ArrayBuffer(t));
        }
      }
      class MQ {
        constructor(t, e) {
          (this._locking = !1),
            (this._pages = []),
            (this._allocatorCount = 0),
            (this._manager = t),
            (this._pageSize = e);
        }
        get pageSize() {
          return this._pageSize;
        }
        get debugLocking() {
          return this._locking;
        }
        get allocatorCount() {
          return this._allocatorCount;
        }
        debugLock() {
          this._locking, (this._locking = !0);
        }
        debugUnlock() {
          this._locking, (this._locking = !1);
        }
        getPageMemory(t) {
          return t >= 0 && this._pages.length, this._pages[t].buffer;
        }
        pushPage(t) {
          const e = t[RQ];
          this._pages.length,
            e === this._pages.length && this._pushNewPage(),
            this._pages.length;
          const i = this._pages[e];
          return ++i.useCount, ++t[RQ], i;
        }
        popPage(t) {
          const e = t[RQ] - 1,
            i = this._pages[e];
          i.useCount,
            --i.useCount,
            --t[RQ],
            0 === i.useCount && (this._pages.length, this._pages.pop());
        }
        createAllocator(t) {
          const e = new NQ(this, t);
          return ++this._allocatorCount, e;
        }
        destroyAllocator(t) {
          const e = t[RQ];
          for (let t = 0; t < e; ++t) {
            const e = this._pages[t];
            e.useCount, --e.useCount;
          }
          this._allocatorCount,
            --this._allocatorCount,
            0 === this._allocatorCount && this._manager[DQ](this);
        }
        _pushNewPage() {
          const t = new xQ(this._pageSize);
          this._pages.push(t);
        }
      }
      class PQ {
        constructor(t, e) {
          (this.buffer = t), (this.byteOffset = e);
        }
      }
      class NQ {
        constructor(t, e) {
          (this[RQ] = 0),
            (this._slicesPerPage = 0),
            (this._slices = []),
            (this._resource = t),
            (this._sliceSize = e);
          const i = Math.floor(this._resource.pageSize / e);
          this._slicesPerPage = i;
        }
        get isEmpty() {
          return 0 === this._slices.length;
        }
        destroy() {
          this._slices.length,
            this._resource.debugLocking,
            this._resource.destroyAllocator(this);
        }
        debugLock() {
          this._resource.debugLock();
        }
        debugUnlock() {
          this._resource.debugUnlock();
        }
        push() {
          const { _sliceSize: t, _slices: e, _slicesPerPage: i } = this,
            s = e.length;
          let n = 0,
            r = 0;
          0 === t
            ? (0 === this[RQ] && this._resource.pushPage(this), this[RQ])
            : (s === i * this[RQ] && (this._resource.pushPage(this), this[RQ]),
              (n = s % i),
              (r = (s - n) / i),
              this[RQ]);
          const a = this._resource.getPageMemory(r),
            o = new PQ(a, t * n);
          return this._slices.push(o), o;
        }
        pop() {
          const { _slices: t, _slicesPerPage: e } = this,
            i = t.length - 1;
          0 === this._sliceSize
            ? (this[RQ], 0 === i && this._resource.popPage(this))
            : 0 == i % e && this._resource.popPage(this),
            this._slices.pop();
        }
      }
      class LQ {
        constructor(t, e) {
          (this._poses = []),
            (this._allocatedCount = 0),
            (this._memoryAllocator = void 0),
            (this._transformCount = t),
            (this._auxiliaryCurveCount = e);
          const i = BQ(t, e, 1);
          this._memoryAllocator = UQ.createAllocator(i);
        }
        destroy() {
          this._allocatedCount;
          for (let t = 0; t < this._poses.length; ++t)
            this._memoryAllocator.pop();
          return (this._poses.length = 0), this._memoryAllocator.destroy();
        }
        get allocatedCount() {
          return this._allocatedCount;
        }
        push() {
          0 === this._allocatedCount && this._memoryAllocator.debugLock(),
            this._allocatedCount === this._poses.length &&
              (this._allocateNewPose(),
              this._allocatedCount,
              this._poses.length);
          const t = this._poses[this._allocatedCount];
          return ++this._allocatedCount, t;
        }
        pop() {
          this._allocatedCount,
            --this._allocatedCount,
            0 === this._allocatedCount && this._memoryAllocator.debugUnlock();
        }
        get top() {
          return this._allocatedCount, this._poses[this._allocatedCount - 1];
        }
        _allocateNewPose() {
          const t = this._memoryAllocator.push(),
            e = wQ.BYTES_PER_ELEMENT * this._transformCount,
            i = t.byteOffset,
            s = new wQ(t.buffer, i, this._transformCount),
            n = new Float64Array(t.buffer, i + e, this._auxiliaryCurveCount),
            r = _X._create(s, n);
          this._poses.push(r);
        }
      }
      function BQ(t, e, i) {
        return (
          (wQ.BYTES_PER_ELEMENT * t + Float64Array.BYTES_PER_ELEMENT * e) * i
        );
      }
      const FQ = BQ(128, 10, 4),
        UQ = new (class {
          constructor(t) {
            (this._stacks = new Map()),
              (this._thresholds = t),
              t.every((t, e, i) => 0 === e || t > i[e - 1]);
          }
          get isEmpty() {
            return 0 === this._stacks.size;
          }
          createAllocator(t) {
            const e = t,
              i = this._selectStackPageSize(e);
            let s = this._stacks.get(i);
            return (
              s || ((s = new MQ(this, i)), this._stacks.set(i, s)),
              s.createAllocator(e)
            );
          }
          [DQ](t) {
            for (const [e, i] of this._stacks)
              if (i === t) {
                this._stacks.delete(e);
                break;
              }
          }
          _selectStackPageSize(t) {
            let e = la(this._thresholds, t),
              i = t;
            return (
              e >= 0
                ? (i = this._thresholds[e])
                : ((e = ~e),
                  e === this._thresholds.length ||
                    (e >= 0 && this._thresholds.length,
                    (i = this._thresholds[e]))),
              i
            );
          }
        })([FQ]);
      let kQ;
      !(function (t) {
        (t[(t.WORLD = 0)] = "WORLD"),
          (t[(t.COMPONENT = 1)] = "COMPONENT"),
          (t[(t.PARENT = 2)] = "PARENT"),
          (t[(t.LOCAL = 3)] = "LOCAL");
      })(kQ || (kQ = {})),
        de(kQ);
      const zQ = Symbol("PoseHeapAllocator");
      class HQ {
        constructor(t, e) {
          (this._transformCount = 0),
            (this._metaValueCount = 0),
            (this._pages = []),
            (this._allocatedCount = 0),
            (this._foremostPossibleFreePage = 0),
            (this._transformCount = t),
            (this._metaValueCount = e);
        }
        get allocatedCount() {
          return this._allocatedCount;
        }
        allocatePose() {
          ++this._allocatedCount;
          const { _pages: t } = this,
            e = t.length;
          for (let i = this._foremostPossibleFreePage; i < e; ++i) {
            const e = t[i],
              s = e.tryAllocate();
            if (s)
              return (
                (s[zQ].pageIndex = i),
                0 === e.freeCount && ++this._foremostPossibleFreePage,
                s
              );
          }
          const i = this._allocatePoseInNewPage();
          return (this._foremostPossibleFreePage = i[zQ].pageIndex), i;
        }
        destroyPose(t) {
          const { _pages: e } = this;
          e.length;
          const i = t[zQ].pageIndex,
            s = e[i];
          s.deallocate(t),
            --this._allocatedCount,
            i < this._foremostPossibleFreePage &&
              (s.freeCount, (this._foremostPossibleFreePage = i));
        }
        _allocatePoseInNewPage() {
          const t = new WQ(this._transformCount, this._metaValueCount, 4),
            e = this._pages.length;
          this._pages.push(t);
          const i = t.tryAllocate();
          return (i[zQ].pageIndex = e), i;
        }
      }
      class GQ {
        constructor() {
          this._id = -1;
        }
        get pageIndex() {
          return this._id >> jQ;
        }
        set pageIndex(t) {
          (this._id &= VQ), (this._id |= t << jQ);
        }
        get poseIndex() {
          return this._id & VQ;
        }
        set poseIndex(t) {
          (this._id &= ~VQ), (this._id |= t);
        }
      }
      const VQ = 7,
        jQ = 3;
      class WQ {
        constructor(t, e, i) {
          (this._buffer = void 0),
            (this._idleFlags = 15),
            (this._poses = void 0),
            (this._freeCount = 0),
            (this._transformCount = t),
            (this._metaValueCount = e),
            (this._capacity = i);
          const s =
            (wQ.BYTES_PER_ELEMENT * t + Float64Array.BYTES_PER_ELEMENT * e) * i;
          (this._buffer = new ArrayBuffer(s)),
            (this._poses = new Array(i).fill(null)),
            (this._freeCount = i);
        }
        get capacity() {
          return this._capacity;
        }
        get freeCount() {
          return this._freeCount;
        }
        tryAllocate() {
          var t;
          const { _poses: e, _idleFlags: i, _capacity: s } = this,
            n = (function (t) {
              return 0 === t ? 1 / 0 : Math.log2(t & -t);
            })(i);
          if (n >= s) return null;
          n >= 0 && e.length;
          const r =
            null !== (t = e[n]) && void 0 !== t
              ? t
              : (e[n] = this._createPose(n));
          return (
            (r[zQ].poseIndex = n),
            (this._idleFlags &= ~(1 << n)),
            this._freeCount,
            --this._freeCount,
            r
          );
        }
        deallocate(t) {
          const { _poses: e } = this,
            i = t[zQ].poseIndex;
          i >= 0 && e.length,
            e[i],
            (this._idleFlags |= 1 << i),
            this._freeCount,
            this._capacity,
            ++this._freeCount;
        }
        _createPose(t) {
          const e = wQ.BYTES_PER_ELEMENT * this._transformCount,
            i = (e + Float64Array.BYTES_PER_ELEMENT * this._metaValueCount) * t,
            s = new wQ(this._buffer, i, this._transformCount),
            n = new Float64Array(this._buffer, i + e, this._metaValueCount),
            r = _X._create(s, n);
          return (r[zQ] = new GQ()), r;
        }
      }
      var XQ, YQ, KQ, qQ, $Q, ZQ, QQ, JQ;
      function tJ(t, e) {
        if (t.name === e) return t;
        const i = t.children.length;
        for (let s = 0; s < i; ++s) {
          const i = tJ(t.children[s], e);
          if (i) return i;
        }
        return null;
      }
      class eJ {
        constructor(t, e, i, s) {
          (this._origin = void 0),
            (this._layoutMaintainer = void 0),
            (this._varRegistry = void 0),
            (this._additiveFlagStack = []),
            (this._triggerResetter = (t) => this._resetTrigger(t)),
            (this._isLayerWideContextPropertiesSet = !1),
            (this._stashView = void 0),
            (this._motionSyncManager = void 0),
            (this._clipOverrides = void 0),
            (this._controller = s),
            (this._origin = t),
            (this._layoutMaintainer = e),
            (this._varRegistry = i),
            (this._additiveFlagStack = [!1]);
        }
        get origin() {
          return this._origin;
        }
        get controller() {
          return this._controller;
        }
        get triggerResetter() {
          return this._triggerResetter;
        }
        get clipOverrides() {
          return this._clipOverrides;
        }
        get additive() {
          const { _additiveFlagStack: t } = this;
          return t[t.length - 1];
        }
        bindTransform(t) {
          const e = this._origin.getChildByPath(t);
          return e
            ? this._layoutMaintainer.getOrCreateTransformBinding(e)
            : null;
        }
        bindTransformByName(t) {
          const e = tJ(this._origin, t);
          return e
            ? this._layoutMaintainer.getOrCreateTransformBinding(e)
            : null;
        }
        getBoneChildren(t) {
          const e = tJ(this._origin, t);
          return e ? e.children.map((t) => t.name) : [];
        }
        getParentBoneNameByName(t) {
          var e;
          const i = tJ(this._origin, t);
          return i
            ? i === this._origin
              ? ""
              : null === (e = i.parent) || void 0 === e
              ? void 0
              : e.name
            : null;
        }
        bindAuxiliaryCurve(t) {
          return this._layoutMaintainer.getOrCreateAuxiliaryCurveBinding(t);
        }
        getEvaluationTimeAuxiliaryCurveView() {
          return this._layoutMaintainer.auxiliaryCurveRegistry;
        }
        getVar(t) {
          return this._varRegistry[t];
        }
        _pushAdditiveFlag(t) {
          this._additiveFlagStack.push(t);
        }
        _popAdditiveFlag() {
          this._additiveFlagStack.length, this._additiveFlagStack.pop();
        }
        _integrityCheck() {
          return 1 === this._additiveFlagStack.length;
        }
        get stashView() {
          return this._stashView, this._stashView;
        }
        get motionSyncManager() {
          return this._motionSyncManager, this._motionSyncManager;
        }
        _setLayerWideContextProperties(t, e) {
          this._isLayerWideContextPropertiesSet,
            (this._isLayerWideContextPropertiesSet = !0),
            (this._stashView = t),
            (this._motionSyncManager = e);
        }
        _unsetLayerWideContextProperties() {
          this._isLayerWideContextPropertiesSet,
            (this._isLayerWideContextPropertiesSet = !1),
            (this._stashView = void 0),
            (this._motionSyncManager = void 0);
        }
        _setClipOverrides(t) {
          this._clipOverrides = t;
        }
        _resetTrigger(t) {
          const e = this._varRegistry[t];
          e && (e.value = !1);
        }
      }
      const iJ = new oX();
      class sJ {
        constructor() {
          this._namedCurves = new Map();
        }
        names() {
          return this._namedCurves.keys();
        }
        has(t) {
          return this._namedCurves.has(t);
        }
        get(t) {
          var e;
          return null !== (e = this._namedCurves.get(t)) && void 0 !== e
            ? e
            : 0;
        }
        set(t, e) {
          this._namedCurves.set(t, e);
        }
      }
      let nJ;
      !(function (t) {
        (t[(t.TRANSFORM_COUNT = 1)] = "TRANSFORM_COUNT"),
          (t[(t.TRANSFORM_ORDER = 2)] = "TRANSFORM_ORDER"),
          (t[(t.AUXILIARY_CURVE_COUNT = 4)] = "AUXILIARY_CURVE_COUNT");
      })(nJ || (nJ = {}));
      let rJ =
        ((XQ = () => {}),
        (YQ = () => {}),
        (KQ = () => {}),
        (qQ = () => {}),
        ($Q = () => {}),
        (ZQ = () => {}),
        (QQ = () => {}),
        s(
          (JQ = class {
            constructor(t, e) {
              (this._origin = void 0),
                (this._auxiliaryCurveRegistry = void 0),
                (this._auxiliaryCurveRecords = []),
                (this._transformRecords = []),
                (this._parentTable = []),
                (this._bindStarted = !1),
                (this._transformCountBeforeBind = -1),
                (this._auxiliaryCurveCountBeforeBind = -1),
                (this._origin = t),
                (this._auxiliaryCurveRegistry = e);
            }
            get transformCount() {
              return this._transformRecords.length;
            }
            get auxiliaryCurveCount() {
              return this._auxiliaryCurveRecords.length;
            }
            get auxiliaryCurveRegistry() {
              return this._auxiliaryCurveRegistry;
            }
            getOrCreateTransformBinding(t) {
              const { _origin: e } = this;
              let i = !1;
              for (let s = t; s; s = s.parent)
                if (s === e) {
                  i = !0;
                  break;
                }
              if (!i) return null;
              const s = this._getOrCreateTransformBinding(t);
              if (t !== e)
                for (let i = t.parent; i !== e; i = i.parent)
                  this._getOrCreateTransformBinding(i);
              return s;
            }
            _getOrCreateTransformBinding(t) {
              const { _transformRecords: e } = this,
                i = e.findIndex((e) => e.node === t);
              if (i >= 0) {
                const t = e[i];
                return ++t.refCount, t.handle;
              }
              let s = 0;
              for (let i = t.parent; i; i = i.parent) {
                const t = e.findIndex((t) => t.node === i);
                if (t >= 0) {
                  s = t + 1;
                  break;
                }
              }
              for (let t = s; t < e.length; ++t) ++e[t].handle.index;
              const n = new aJ(new pJ(this, s), t);
              return e.splice(s, 0, n), n.handle;
            }
            getOrCreateAuxiliaryCurveBinding(t) {
              const { _auxiliaryCurveRecords: e } = this,
                i = e.findIndex((e) => e.name === t);
              if (i >= 0) {
                const t = e[i];
                return ++t.refCount, t.handle;
              }
              {
                const i = e.length,
                  s = new oJ(new mJ(this, i), t);
                return e.push(s), s.handle;
              }
            }
            createEvaluationContext() {
              return (
                this._bindStarted,
                new dJ(
                  this.transformCount,
                  this.auxiliaryCurveCount,
                  this._parentTable.slice(),
                  this._origin
                )
              );
            }
            resetPoseStashAllocator(t) {
              this._bindStarted,
                t._reset(this.transformCount, this.auxiliaryCurveCount);
            }
            createTransformFilter(t) {
              const { _origin: e } = this,
                i = [];
              for (const { node: n, handle: r } of this._transformRecords) {
                const a = s(e, n);
                if (void 0 === a)
                  R(
                    `${n.getPathInHierarchy()} is not a child of ${e.getPathInHierarchy()}`
                  );
                else if (t.isExcluded(a)) continue;
                i.push(r.index);
              }
              return i.sort(), new pX(i);
              function s(t, e) {
                const i = [];
                for (let s = e; s; s = s.parent) {
                  if (s === t) return i.join("/");
                  i.unshift(s.name);
                }
              }
            }
            fetchDefaultTransforms(t) {
              const e = this._transformRecords.length;
              t.length;
              for (let i = 0; i < e; ++i) {
                const { defaultTransform: e } = this._transformRecords[i];
                t.setTransform(i, e);
              }
            }
            apply(t) {
              const { transforms: e, auxiliaryCurves: i } = t,
                s = this._transformRecords.length;
              e.length;
              for (let t = 0; t < s; ++t) {
                const i = e.getTransform(t, iJ),
                  { node: s } = this._transformRecords[t];
                s.setRTS(i.rotation, i.position, i.scale);
              }
              const n = this._auxiliaryCurveRecords.length;
              for (let t = 0; t < n; ++t) {
                const { name: e } = this._auxiliaryCurveRecords[t],
                  s = i[t];
                this._auxiliaryCurveRegistry.set(e, s);
              }
            }
            _destroyTransformHandle(t) {
              t >= 0 && this._transformRecords.length;
              const e = this._transformRecords[t];
              e.refCount, --e.refCount;
            }
            _destroyAuxiliaryCurveHandle(t) {
              t >= 0 && this._auxiliaryCurveRecords.length;
              const e = this._auxiliaryCurveRecords[t];
              e.refCount, --e.refCount;
            }
            startBind() {
              (this._bindStarted = !0),
                (this._transformCountBeforeBind =
                  this._transformRecords.length),
                (this._auxiliaryCurveCountBeforeBind =
                  this._auxiliaryCurveRecords.length);
            }
            endBind() {
              const { _transformRecords: t, _auxiliaryCurveRecords: e } = this;
              let i = 0;
              if ((hJ(t), t.length !== this._transformCountBeforeBind)) {
                i |= nJ.TRANSFORM_COUNT;
                const e = t.length;
                for (let i = 0; i < e; ++i) t[i].order = i;
              } else {
                const e = t.length;
                let s = !1;
                for (let i = 0; i < e; ++i) {
                  const e = t[i];
                  e.order !== i && ((s = !0), (e.order = i));
                }
                s && (i |= nJ.TRANSFORM_ORDER);
              }
              hJ(e),
                e.length !== this._auxiliaryCurveCountBeforeBind &&
                  (i |= nJ.AUXILIARY_CURVE_COUNT);
              const { _parentTable: s, _origin: n } = this;
              s.length = t.length;
              for (let e = 0; e < t.length; ++e) {
                const { node: i } = t[e];
                if (i === n) {
                  s[e] = -1;
                  continue;
                }
                const r = i.parent;
                if (r === n) {
                  const i = t.findIndex((t) => t.node === r);
                  s[e] = i >= 0 ? i : -1;
                } else {
                  const i = t.findIndex((t) => t.node === r);
                  s[e] = i;
                }
              }
              return (this._bindStarted = !1), i;
            }
          }).prototype,
          "getOrCreateTransformBinding",
          [XQ],
          Object.getOwnPropertyDescriptor(
            JQ.prototype,
            "getOrCreateTransformBinding"
          ),
          JQ.prototype
        ),
        s(
          JQ.prototype,
          "_getOrCreateTransformBinding",
          [YQ],
          Object.getOwnPropertyDescriptor(
            JQ.prototype,
            "_getOrCreateTransformBinding"
          ),
          JQ.prototype
        ),
        s(
          JQ.prototype,
          "getOrCreateAuxiliaryCurveBinding",
          [KQ],
          Object.getOwnPropertyDescriptor(
            JQ.prototype,
            "getOrCreateAuxiliaryCurveBinding"
          ),
          JQ.prototype
        ),
        s(
          JQ.prototype,
          "_destroyTransformHandle",
          [qQ],
          Object.getOwnPropertyDescriptor(
            JQ.prototype,
            "_destroyTransformHandle"
          ),
          JQ.prototype
        ),
        s(
          JQ.prototype,
          "_destroyAuxiliaryCurveHandle",
          [$Q],
          Object.getOwnPropertyDescriptor(
            JQ.prototype,
            "_destroyAuxiliaryCurveHandle"
          ),
          JQ.prototype
        ),
        s(
          JQ.prototype,
          "startBind",
          [ZQ],
          Object.getOwnPropertyDescriptor(JQ.prototype, "startBind"),
          JQ.prototype
        ),
        s(
          JQ.prototype,
          "endBind",
          [QQ],
          Object.getOwnPropertyDescriptor(JQ.prototype, "endBind"),
          JQ.prototype
        ),
        JQ);
      class aJ {
        constructor(t, e) {
          (this.order = -1),
            (this.refCount = 1),
            (this.handle = void 0),
            (this.node = void 0),
            (this.defaultTransform = void 0),
            (this.handle = t),
            (this.node = e);
          const i = new oX();
          (i.position = e.position),
            (i.rotation = e.rotation),
            (i.scale = e.scale),
            (this.defaultTransform = i);
        }
      }
      class oJ {
        constructor(t, e) {
          (this.refCount = 1),
            (this.handle = void 0),
            (this.name = void 0),
            (this.handle = t),
            (this.name = e);
        }
      }
      function hJ(t) {
        const e = (function (t, e) {
          const i = t.length;
          let s = 0;
          for (; s < i && e(t[s]); ++s);
          if (s === i) return i;
          let n = s;
          for (let r = s + 1; r < i; ++r) {
            const i = t[r];
            if (e(i)) {
              const e = i;
              (t[r] = t[n]), (t[n] = e), ++n;
            }
          }
          return n;
        })(t, (t) => (t.refCount, t.refCount > 0));
        if ((t.length, e !== t.length)) {
          for (let i = 0; i < e; ++i) t[i].handle.index = i;
          t.splice(e, t.length - e);
        }
      }
      const lJ = Symbol("[[DefaultTransforms]]");
      class cJ {
        constructor(t) {
          this._layoutMaintainer = t;
        }
        get transformCount() {
          return this._layoutMaintainer.transformCount;
        }
        createTransformFilter(t) {
          return this._layoutMaintainer.createTransformFilter(t);
        }
      }
      const uJ = new oX(),
        _J = new oX();
      class dJ {
        constructor(t, e, i, s) {
          (this[lJ] = void 0),
            (this._poseAllocator = void 0),
            (this._parentTable = void 0),
            (this._componentNode = void 0),
            (this._cacheComponentToWorldTransform = new oX()),
            (this._poseAllocator = new LQ(t, e)),
            (this._parentTable = i),
            (this._componentNode = s),
            (this[lJ] = new wQ(t));
        }
        destroy() {
          this._poseAllocator.destroy();
        }
        get allocatedPoseCount() {
          return this._poseAllocator.allocatedCount;
        }
        get parentTable() {
          return this._parentTable;
        }
        pushDefaultedPose() {
          const t = this._poseAllocator.push();
          return (
            t.transforms.set(this[lJ]),
            (t._poseTransformSpace = dX.LOCAL),
            t.auxiliaryCurves.fill(0),
            t
          );
        }
        pushDefaultedPoseInComponentSpace() {
          const t = this.pushDefaultedPose();
          return this._poseTransformsSpaceLocalToComponent(t), t;
        }
        pushZeroDeltaPose() {
          const t = this._poseAllocator.push();
          return (
            t.transforms.fill(uX),
            (t._poseTransformSpace = dX.LOCAL),
            t.auxiliaryCurves.fill(0),
            t
          );
        }
        pushDuplicatedPose(t) {
          const e = this._poseAllocator.push();
          return (
            e.transforms.set(t.transforms),
            (e._poseTransformSpace = t._poseTransformSpace),
            e.auxiliaryCurves.set(t.auxiliaryCurves),
            e
          );
        }
        popPose() {
          this._poseAllocator.pop();
        }
        get _stackSize_debugging() {
          return this._poseAllocator.allocatedCount;
        }
        _isStackTopPose_debugging(t) {
          return t === this._poseAllocator.top;
        }
        _poseTransformsSpaceLocalToComponent(t) {
          const { transforms: e } = t,
            { length: i } = e;
          for (let t = 0; t < i; ++t) {
            const i = this._parentTable[t];
            if (i < 0) continue;
            const s = e.getTransform(t, uJ),
              n = e.getTransform(i, _J);
            oX.multiply(s, n, s), e.setTransform(t, s);
          }
          t._poseTransformSpace = dX.COMPONENT;
        }
        _poseTransformsSpaceComponentToLocal(t) {
          const { transforms: e } = t,
            { length: i } = e;
          for (let t = i - 1; t >= 0; --t) {
            const i = this._parentTable[t];
            if (i < 0) continue;
            const s = e.getTransform(t, uJ),
              n = e.getTransform(i, _J);
            oX.calculateRelative(s, s, n), e.setTransform(t, s);
          }
          t._poseTransformSpace = dX.LOCAL;
        }
        _convertPoseSpaceTransformToTargetSpace(t, e, i, s) {
          const n = i._poseTransformSpace;
          switch (e) {
            default:
              break;
            case kQ.WORLD:
              n === dX.COMPONENT
                ? oX.multiply(t, this._getComponentToWorldTransform(), t)
                : (dX.LOCAL,
                  oX.multiply(t, this._getLocalToWorldTransform(_J, i, s), t));
              break;
            case kQ.COMPONENT:
              n === dX.COMPONENT ||
                (dX.LOCAL,
                oX.multiply(
                  t,
                  this._getLocalToComponentTransform(_J, i, s),
                  t
                ));
              break;
            case kQ.PARENT:
              if (n === dX.COMPONENT) {
                const e = this._parentTable[s];
                if (e >= 0) {
                  const s = i.transforms.getTransform(e, _J),
                    n = oX.invert(s, s);
                  oX.multiply(t, n, t);
                }
              } else dX.LOCAL;
              break;
            case kQ.LOCAL: {
              n === dX.COMPONENT || dX.LOCAL;
              const e = i.transforms.getTransform(s, _J),
                r = oX.invert(e, e);
              oX.multiply(t, r, t);
              break;
            }
          }
          return t;
        }
        _convertTransformToPoseTransformSpace(t, e, i, s) {
          const n = i._poseTransformSpace;
          switch (e) {
            default:
              break;
            case kQ.WORLD:
              if (n === dX.COMPONENT) {
                const e = oX.invert(_J, this._getComponentToWorldTransform());
                oX.multiply(t, e, t);
              } else {
                dX.LOCAL;
                const e = this._getLocalToWorldTransform(_J, i, s),
                  n = oX.invert(e, e);
                oX.multiply(t, n, t);
              }
              break;
            case kQ.COMPONENT:
              if (n === dX.COMPONENT);
              else {
                dX.LOCAL;
                const e = this._getLocalToComponentTransform(_J, i, s),
                  n = oX.invert(e, e);
                oX.multiply(t, n, t);
              }
              break;
            case kQ.PARENT:
              if (n === dX.COMPONENT) {
                const e = this._parentTable[s];
                if (e >= 0) {
                  const s = i.transforms.getTransform(e, _J);
                  oX.multiply(t, s, t);
                }
              }
              break;
            case kQ.LOCAL: {
              n === dX.COMPONENT || dX.LOCAL;
              const e = i.transforms.getTransform(s, _J);
              oX.multiply(t, e, t);
              break;
            }
          }
          return t;
        }
        _getComponentToWorldTransform() {
          const t = this._cacheComponentToWorldTransform,
            e = this._componentNode;
          return (
            (t.position = e.worldPosition),
            (t.rotation = e.worldRotation),
            (t.scale = e.worldScale),
            t
          );
        }
        _getLocalToComponentTransform(t, e, i) {
          const { _parentTable: s } = this;
          oX.setIdentity(t);
          for (let n = s[i]; n >= 0; n = s[n]) {
            const i = e.transforms.getTransform(n, uJ);
            oX.multiply(t, i, t);
          }
          return t;
        }
        _getLocalToWorldTransform(t, e, i) {
          return (
            this._getLocalToComponentTransform(t, e, i),
            oX.multiply(t, this._getComponentToWorldTransform(), t),
            t
          );
        }
      }
      class pJ {
        constructor(t, e) {
          (this.index = -1),
            (this._host = void 0),
            (this._host = t),
            (this.index = e);
        }
        destroy() {
          this._host._destroyTransformHandle(this.index);
        }
      }
      class mJ {
        constructor(t, e) {
          (this.index = -1),
            (this._host = void 0),
            (this._host = t),
            (this.index = e);
        }
        destroy() {
          this._host._destroyAuxiliaryCurveHandle(this.index);
        }
      }
      class fJ {
        constructor() {
          this._context = { deltaTime: 0, indicativeWeight: 0 };
        }
        generate(t, e) {
          return (
            (this._context.deltaTime = t),
            (this._context.indicativeWeight = e),
            this._context
          );
        }
        forkSubWeight(t, e) {
          (this._context.deltaTime = t.deltaTime),
            (this._context.indicativeWeight = t.indicativeWeight * e);
        }
      }
      class gJ {
        constructor() {
          this._allocator = null;
        }
        get allocatedPoseCount() {
          return this._allocator, this._allocator.allocatedCount;
        }
        _reset(t, e) {
          this._allocator = new HQ(t, e);
        }
        allocatePose() {
          return this._allocator, this._allocator.allocatePose();
        }
        destroyPose(t) {
          return this._allocator, this._allocator.destroyPose(t);
        }
      }
      var yJ, TJ, SJ, EJ;
      const { ccclass: vJ, serializable: bJ } = go;
      var AJ;
      !(function (t) {
        (t[(t.TRUTHY = 0)] = "TRUTHY"), (t[(t.FALSY = 1)] = "FALSY");
      })(AJ || (AJ = {})),
        vJ("cc.animation.UnaryCondition")(
          (((EJ = class t {
            constructor() {
              (this.operator = TJ && TJ()), (this.operand = SJ && SJ());
            }
            clone() {
              const e = new t();
              return (
                (e.operator = this.operator),
                (e.operand = this.operand.clone()),
                e
              );
            }
            [iK](t) {
              const { operator: e, operand: i } = this,
                s = new CJ(e, !1),
                n = hZ(t, i, vj.BOOLEAN, s.setOperand, s);
              return s.reset(n), s;
            }
          }).Operator = AJ),
          (TJ = fa((yJ = EJ).prototype, "operator", [bJ], function () {
            return AJ.TRUTHY;
          })),
          (SJ = fa(yJ.prototype, "operand", [bJ], function () {
            return new oZ();
          })),
          yJ)
        );
      class CJ {
        constructor(t, e) {
          (this._operator = t), (this._operand = e), this._eval();
        }
        reset(t) {
          this.setOperand(t);
        }
        setOperand(t) {
          (this._operand = t), this._eval();
        }
        eval() {
          return this._result;
        }
        _eval() {
          const { _operand: t } = this;
          switch (this._operator) {
            default:
            case AJ.TRUTHY:
              this._result = !!t;
              break;
            case AJ.FALSY:
              this._result = !t;
          }
        }
      }
      let OJ, IJ;
      !(function (t) {
        (t[(t.FLOAT = 0)] = "FLOAT"), (t[(t.INTEGER = 3)] = "INTEGER");
      })(OJ || (OJ = {}));
      class wJ {}
      var RJ, DJ, xJ, MJ, PJ;
      !(function (t) {
        (t[(t.MOTION = 1)] = "MOTION"),
          (t[(t.POSE = 2)] = "POSE"),
          (t[(t.EMPTY = 4)] = "EMPTY"),
          (t[(t.WEIGHTED = 7)] = "WEIGHTED");
      })(IJ || (IJ = {}));
      const { ccclass: NJ, serializable: LJ } = go;
      let BJ =
        ((RJ = NJ("cc.animation.TCVariableBinding")),
        OJ.FLOAT,
        OJ.INTEGER,
        RJ(
          ((xJ = class extends wJ {
            constructor(...t) {
              super(...t),
                (this.type = MJ && MJ()),
                (this.variableName = PJ && PJ());
            }
            getValueType() {
              return this.type;
            }
            bind(t) {
              const e = t.getVar(this.variableName);
              if (e) return new FJ(e);
            }
          }),
          (MJ = fa(xJ.prototype, "type", [LJ, Ba], function () {
            return OJ.FLOAT;
          })),
          (PJ = fa(xJ.prototype, "variableName", [LJ], function () {
            return "";
          })),
          (DJ = void (DJ = xJ) || DJ))
        ) || DJ);
      class FJ {
        constructor(t) {
          this._varInstance = t;
        }
        evaluate() {
          return this._varInstance.value;
        }
      }
      var UJ, kJ, zJ, HJ;
      const { ccclass: GJ, serializable: VJ } = go;
      (UJ = GJ("cc.animation.TCAuxiliaryCurveBinding")),
        OJ.FLOAT,
        UJ(
          ((zJ = class extends wJ {
            constructor(...t) {
              super(...t), (this.curveName = HJ && HJ());
            }
            getValueType() {
              return OJ.FLOAT;
            }
            bind(t) {
              const e = t.getEvaluationTimeAuxiliaryCurveView();
              return new jJ(e, this.curveName);
            }
          }),
          (HJ = fa(zJ.prototype, "curveName", [VJ], function () {
            return "";
          })),
          (kJ = void (kJ = zJ) || kJ))
        );
      class jJ {
        constructor(t, e) {
          (this._view = t), (this._curveName = e);
        }
        evaluate() {
          return this._view.get(this._curveName);
        }
      }
      var WJ, XJ;
      const { ccclass: YJ } = go;
      (WJ = YJ("cc.animation.TCStateWeightBinding")),
        OJ.FLOAT,
        IJ.WEIGHTED,
        WJ(
          (XJ =
            void (XJ =
              void (XJ = class extends wJ {
                getValueType() {
                  return OJ.FLOAT;
                }
                bind(t) {
                  return new KJ();
                }
              }) || XJ) || XJ)
        );
      class KJ {
        evaluate(t) {
          return t.sourceStateWeight;
        }
      }
      var qJ, $J;
      const { ccclass: ZJ } = go;
      (qJ = ZJ("cc.animation.TCStateMotionTimeBinding")),
        OJ.FLOAT,
        IJ.POSE,
        qJ(
          ($J =
            void ($J =
              void ($J = class extends wJ {
                getValueType() {
                  return OJ.FLOAT;
                }
                bind(t) {
                  return new QJ();
                }
              }) || $J) || $J)
        );
      class QJ {
        evaluate(t) {
          return t.sourceStateMotionTimeNormalized;
        }
      }
      var JJ, t0, e0, i0, s0, n0;
      const { ccclass: r0, serializable: a0 } = go;
      var o0, h0, l0, c0;
      !(function (t) {
        (t[(t.EQUAL_TO = 0)] = "EQUAL_TO"),
          (t[(t.NOT_EQUAL_TO = 1)] = "NOT_EQUAL_TO"),
          (t[(t.LESS_THAN = 2)] = "LESS_THAN"),
          (t[(t.LESS_THAN_OR_EQUAL_TO = 3)] = "LESS_THAN_OR_EQUAL_TO"),
          (t[(t.GREATER_THAN = 4)] = "GREATER_THAN"),
          (t[(t.GREATER_THAN_OR_EQUAL_TO = 5)] = "GREATER_THAN_OR_EQUAL_TO");
      })(o0 || (o0 = {})),
        r0("cc.animation.BinaryCondition")(
          (((n0 = class t {
            constructor() {
              (this.operator = t0 && t0()),
                (this.lhs = e0 && e0()),
                (this.lhsBinding = i0 && i0()),
                (this.rhs = s0 && s0());
            }
            clone() {
              const e = new t();
              return (
                (e.operator = this.operator),
                (e.lhs = this.lhs),
                (e.lhsBinding = Jj(this.lhsBinding)),
                (e.rhs = this.rhs),
                e
              );
            }
            [iK](t) {
              var e;
              const i =
                null === (e = this.lhsBinding) || void 0 === e
                  ? void 0
                  : e.bind(t);
              return new u0(this.operator, this.lhs, this.rhs, i);
            }
          }).Operator = o0),
          (t0 = fa((JJ = n0).prototype, "operator", [a0], function () {
            return o0.EQUAL_TO;
          })),
          (e0 = fa(JJ.prototype, "lhs", [a0], function () {
            return 0;
          })),
          (i0 = fa(JJ.prototype, "lhsBinding", [a0], function () {
            return new BJ();
          })),
          (s0 = fa(JJ.prototype, "rhs", [a0], function () {
            return 0;
          })),
          JJ)
        );
      class u0 {
        constructor(t, e, i, s) {
          (this._operator = t),
            (this._lhsBindingEvaluation = s),
            (this._lhsValue = e),
            (this._rhsValue = i);
        }
        eval(t) {
          var e, i;
          const s =
              null !==
                (e =
                  null === (i = this._lhsBindingEvaluation) || void 0 === i
                    ? void 0
                    : i.evaluate(t)) && void 0 !== e
                ? e
                : this._lhsValue,
            n = this._rhsValue;
          switch (this._operator) {
            default:
            case o0.EQUAL_TO:
              return s === n;
            case o0.NOT_EQUAL_TO:
              return s !== n;
            case o0.LESS_THAN:
              return s < n;
            case o0.LESS_THAN_OR_EQUAL_TO:
              return s <= n;
            case o0.GREATER_THAN:
              return s > n;
            case o0.GREATER_THAN_OR_EQUAL_TO:
              return s >= n;
          }
        }
      }
      const { ccclass: _0, serializable: d0 } = go;
      let p0 =
        _0("cc.animation.TriggerCondition")(
          ((l0 = class t {
            constructor() {
              this.trigger = c0 && c0();
            }
            clone() {
              const e = new t();
              return (e.trigger = this.trigger), e;
            }
            [iK](t) {
              const e = new m0(!1),
                i = t.getVar(this.trigger);
              return (
                lZ(i, this.trigger) &&
                  ((function (t, e) {
                    if (t !== vj.TRIGGER) throw new qj(e, "trigger");
                  })(i.type, this.trigger),
                  e.setTrigger(i.bind(e.setTrigger, e))),
                e
              );
            }
          }),
          (c0 = fa(l0.prototype, "trigger", [d0], function () {
            return "";
          })),
          (h0 = l0))
        ) || h0;
      class m0 {
        constructor(t) {
          (this._triggered = !1), (this._triggered = t);
        }
        setTrigger(t) {
          this._triggered = t;
        }
        eval() {
          return this._triggered;
        }
      }
      var f0;
      let g0 =
        Ca("cc.animation.StateMachineComponent")(
          (f0 = class {
            onMotionStateEnter(t, e) {}
            onMotionStateExit(t, e) {}
            onMotionStateUpdate(t, e) {}
            onStateMachineEnter(t) {}
            onStateMachineExit(t) {}
          })
        ) || f0;
      var y0, T0, S0;
      let E0 =
        Ca("cc.animation.MotionSyncInfo")(
          ((T0 = class {
            constructor() {
              this.group = S0 && S0();
            }
          }),
          (S0 = fa(T0.prototype, "group", [Na], function () {
            return "";
          })),
          (y0 = T0))
        ) || y0;
      var v0, b0, A0, C0, O0, I0, w0, R0, D0, x0, M0, P0;
      const N0 = 1e-5;
      let L0 =
        ((v0 = Ca("cc.animation.PoseNodePlayMotion")),
        "i18n:ENGINE.animation_graph.pose_graph_node_sub_categories.pose_nodes/",
        (b0 = ZW((t) => {
          t.category =
            "i18n:ENGINE.animation_graph.pose_graph_node_sub_categories.pose_nodes/";
        })),
        (A0 = ((t) =>
          ZW((e) => {
            e.factory = t;
          }))(
          ((B0 = (t) => {
            const e = new L0();
            return (e.motion = t), e;
          }),
          {
            listEntries: () => [
              {
                arg: { type: "clip-motion" },
                menu: "i18n:ENGINE.animation_graph.pose_graph_node_sub_menus.play_or_sample_clip_motion",
              },
              {
                arg: { type: "animation-blend-1d" },
                menu: "i18n:ENGINE.animation_graph.pose_graph_node_sub_menus.play_or_sample_animation_blend_1d",
              },
              {
                arg: { type: "animation-blend-2d" },
                menu: "i18n:ENGINE.animation_graph.pose_graph_node_sub_menus.play_or_sample_animation_blend_2d",
              },
            ],
            create: (t) => {
              let e = null;
              switch (t.type) {
                case "clip-motion":
                  e = new N$();
                  break;
                case "animation-blend-1d":
                  e = new EZ();
                  break;
                case "animation-blend-2d":
                  e = new HZ();
              }
              return B0(e);
            },
          })
        )),
        (C0 = QW({ themeColor: "#227F9B" })),
        (O0 = AX({ type: WW.FLOAT })),
        (I0 = AX({ type: WW.FLOAT })),
        v0(
          (w0 =
            b0(
              (w0 =
                A0(
                  (w0 =
                    C0(
                      ((R0 = class extends vX {
                        constructor(...t) {
                          super(...t),
                            (this.motion = D0 && D0()),
                            (this.syncInfo = x0 && x0()),
                            i(this, "startTime", M0, this),
                            i(this, "speedMultiplier", P0, this),
                            (this._workspace = null),
                            (this._runtimeSyncRecord = void 0);
                        }
                        get lastIndicativeWeight() {
                          var t, e;
                          return null !==
                            (t =
                              null === (e = this._workspace) || void 0 === e
                                ? void 0
                                : e.lastIndicativeWeight) && void 0 !== t
                            ? t
                            : 0;
                        }
                        get elapsedMotionTime() {
                          var t, e;
                          return null !==
                            (t =
                              null === (e = this._workspace) || void 0 === e
                                ? void 0
                                : e.normalizedTime) && void 0 !== t
                            ? t
                            : 0;
                        }
                        bind(t) {
                          const { motion: e } = this;
                          if (!e) return;
                          const i = e[iK](t, !1);
                          i &&
                            ((this._workspace = new F0(i, i.createPort())),
                            this.syncInfo.group &&
                              (this._runtimeSyncRecord =
                                t.motionSyncManager.register(this.syncInfo)));
                        }
                        settle(t) {}
                        reenter() {
                          if (this._workspace) {
                            const {
                              _runtimeSyncRecord: t,
                              _workspace: {
                                motionEval: { duration: e },
                              },
                            } = this;
                            this._forceEvaluateEvaluation();
                            const i = e < N0 ? 0 : Ei(this.startTime / e);
                            t
                              ? t.notifyRenter(i)
                              : (this._workspace.normalizedTime = i),
                              (this._workspace.lastIndicativeWeight = 0);
                          }
                        }
                        doUpdate(t) {
                          if (this._workspace) {
                            const { deltaTime: e } = t,
                              { _runtimeSyncRecord: i } = this,
                              s = this._workspace.motionEval.duration;
                            let n = 0;
                            s > N0 && (n = (e * this.speedMultiplier) / s),
                              i
                                ? i.notifyUpdate(n, t.indicativeWeight)
                                : (this._workspace.normalizedTime += n),
                              (this._workspace.lastIndicativeWeight =
                                t.indicativeWeight);
                          }
                        }
                        doEvaluate(t) {
                          if (this._workspace) {
                            const e = this._runtimeSyncRecord
                              ? this._runtimeSyncRecord.getSyncedEnterTime()
                              : this._workspace.normalizedTime;
                            return this._workspace.motionEvalPort.evaluate(
                              e,
                              t
                            );
                          }
                          return t.pushDefaultedPose();
                        }
                      }),
                      (D0 = fa(R0.prototype, "motion", [Na], function () {
                        return new N$();
                      })),
                      (x0 = fa(R0.prototype, "syncInfo", [Na], function () {
                        return new E0();
                      })),
                      (M0 = s(R0.prototype, "startTime", [Na, O0], {
                        configurable: !0,
                        enumerable: !0,
                        writable: !0,
                        initializer: function () {
                          return 0;
                        },
                      })),
                      (P0 = s(R0.prototype, "speedMultiplier", [Na, I0], {
                        configurable: !0,
                        enumerable: !0,
                        writable: !0,
                        initializer: function () {
                          return 1;
                        },
                      })),
                      (w0 = R0))
                    ) || w0)
                ) || w0)
            ) || w0)
        ) || w0);
      var B0;
      class F0 {
        constructor(t, e) {
          (this.normalizedTime = 0),
            (this.lastIndicativeWeight = 0),
            (this.motionEval = t),
            (this.motionEvalPort = e);
        }
      }
      function U0(t) {
        return t instanceof vX || t instanceof bX;
      }
      class k0 {
        constructor(t, e) {
          (this._rootPoseNode = t), (this._countingPlayMotionNodes = e);
        }
        bind(t) {
          var e;
          null === (e = this._rootPoseNode) || void 0 === e || e.bind(t);
        }
        settle(t) {
          var e;
          null === (e = this._rootPoseNode) || void 0 === e || e.settle(t);
        }
        reenter() {
          var t;
          null === (t = this._rootPoseNode) || void 0 === t || t.reenter();
        }
        update(t) {
          var e;
          null === (e = this._rootPoseNode) || void 0 === e || e.update(t);
        }
        evaluate(t) {
          var e, i;
          return null !==
            (e =
              null === (i = this._rootPoseNode) || void 0 === i
                ? void 0
                : i.evaluate(t, EX.LOCAL)) && void 0 !== e
            ? e
            : null;
        }
        countMotionTime() {
          const { _countingPlayMotionNodes: t } = this;
          if (!t) return 0;
          let e = 0,
            i = Number.NEGATIVE_INFINITY;
          for (let s = 0; s < t.length; ++s) {
            const { elapsedMotionTime: n, lastIndicativeWeight: r } = t[s];
            r > i && ((i = r), (e = n));
          }
          return e;
        }
      }
      function z0(t, e, i = !1) {
        const { outputNode: s } = t,
          n = t.getShell(s).getBindings();
        if ((n.length, 0 === n.length)) return new k0(void 0, i ? [] : void 0);
        const r = n[0];
        r.outputIndex, r.producer;
        const a = new Map(),
          o = H0(t, r.producer, a, e);
        return new k0(
          o,
          i ? Array.from(a.values()).filter((t) => t instanceof L0) : void 0
        );
      }
      function H0(t, e, i, s) {
        const n = t.getShell(e),
          r = i.get(e);
        if (r) return r;
        const a = Jj(e);
        "__callOnAfterDeserializeRecursive" in a &&
          a.__callOnAfterDeserializeRecursive(),
          a instanceof bX && a.link(s);
        const o = a,
          h = [];
        for (const {
          producer: e,
          outputIndex: r,
          inputPath: a,
        } of n.getBindings()) {
          if (!U0(e)) {
            w("There's a input bound to a node with unrecognized type.");
            continue;
          }
          const n = H0(t, e, i, s);
          if (n instanceof vX) j0(o, a, n, r);
          else {
            const t = Y0(o, a, n, r);
            t && h.push(t);
          }
        }
        const l = new G0(h);
        let c;
        return (
          o instanceof vX
            ? (o._setDependencyEvaluation(l), (c = o))
            : (c = new V0(o, l)),
          i.set(e, c),
          c
        );
      }
      class G0 {
        constructor(t) {
          (this._bindingEvaluations = void 0), (this._bindingEvaluations = t);
        }
        evaluate() {
          const { _bindingEvaluations: t } = this;
          for (const e of t) e.evaluate();
        }
      }
      class V0 {
        constructor(t, e) {
          (this._outputs = void 0),
            (this._node = t),
            (this._dependency = e),
            (this._outputs = new Array(t.outputCount));
        }
        get node() {
          return this._node;
        }
        get outputCount() {
          return this._outputs.length;
        }
        getDefaultOutput() {
          return this.getOutput(0);
        }
        getOutput(t) {
          return this._outputs[t];
        }
        evaluate() {
          const { _node: t, _dependency: e } = this;
          e.evaluate(), t.selfEvaluate(this._outputs);
        }
      }
      function j0(t, e, i, s) {
        const [n, r = -1] = e;
        if (!(n in t))
          return void w(`Invalid binding: consumer node has no property ${n}`);
        if (0 !== s)
          return void w(
            `Node ${i.toString()} does not have specified output ${s}.`
          );
        const a = t[n];
        if (r < 0)
          return null !== a
            ? void w(
                `Invalid binding: consumer node's input ${n} should be leaved as evaluation before evaluation.`
              )
            : void (t[n] = i);
        Array.isArray(a)
          ? r >= a.length
            ? w(
                `Invalid binding: consumer node's input ${n} have length ${a.length} but the binding specified ${r}`
              )
            : null === a[r]
            ? (a[r] = i)
            : w(
                `Invalid binding: consumer node's input ${n}[${r}] should be leaved as null before evaluation`
              )
          : w(
              `Invalid binding: consumer node's input ${n} should be an array.`
            );
      }
      class W0 {
        constructor(t, e, i, s) {
          (this._consumerNode = t),
            (this._consumerPropertyKey = e),
            (this._producerRecord = i),
            (this._producerOutputIndex = s);
        }
        evaluate() {
          this._producerRecord.evaluate(),
            (this._consumerNode[this._consumerPropertyKey] =
              this._producerRecord.getOutput(this._producerOutputIndex));
        }
      }
      class X0 {
        constructor(t, e, i, s, n) {
          (this._consumerNode = t),
            (this._consumerPropertyKey = e),
            (this._consumerElementIndex = i),
            (this._producerRecord = s),
            (this._producerOutputIndex = n);
        }
        evaluate() {
          this._producerRecord.evaluate(),
            (this._consumerNode[this._consumerPropertyKey][
              this._consumerElementIndex
            ] = this._producerRecord.getOutput(this._producerOutputIndex));
        }
      }
      function Y0(t, e, i, s) {
        const [n, r = -1] = e;
        if (!(n in t))
          return void w(`Invalid binding: consumer node has no property ${n}`);
        const a = t[n];
        if (r < 0) return new W0(t, n, i, s);
        if (Array.isArray(a)) {
          if (!(r >= a.length)) return new X0(t, n, r, i, s);
          w(
            `Invalid binding: consumer node's input ${n} have length ${a.length} but the binding specified ${r}`
          );
        } else
          w(`Invalid binding: consumer node's input ${n} should be an array.`);
      }
      class K0 {
        constructor(t, e, i) {
          (this.passthroughWeight = 1),
            (this._motionStates = []),
            (this._proceduralPoseStates = []),
            (this._topLevelEntry = void 0),
            (this._topLevelExit = void 0),
            (this._currentNode = void 0),
            (this._pendingTransitionPath = []),
            (this._activatedTransitions = []),
            (this._activatedTransitionPool = g1.createPool(4)),
            (this._updateContextGenerator = new fJ()),
            (this._conditionEvaluationContext = new f1()),
            (this._additive = !1),
            (this._additive = i.additive),
            (this.name = e),
            (this._controller = i.controller);
          const { entry: s, exit: n } = this._addStateMachine(t, null, i, e);
          (this._topLevelEntry = s),
            (this._topLevelExit = n),
            (this._currentNode = s),
            s.increaseActiveReference(),
            (this._resetTrigger = i.triggerResetter);
        }
        get exited() {
          return this._currentNode === this._topLevelExit;
        }
        settle(t) {
          const { _proceduralPoseStates: e } = this,
            i = e.length;
          for (let s = 0; s < i; ++s) e[s].settle(t);
        }
        reenter() {
          for (const t of this._activatedTransitions)
            t.destination.decreaseActiveReference(),
              this._activatedTransitionPool.free(t);
          (this._activatedTransitions.length = 0),
            this._topLevelEntry.increaseActiveReference(),
            this._currentNode.decreaseActiveReference(),
            (this._currentNode = this._topLevelEntry);
        }
        update(t) {
          this.exited,
            this._loopMatchTransitions(),
            this._resetStateTickFlagsAndWeights(),
            this._updateActivatedTransitions(t.deltaTime),
            this._commitStateUpdates(t);
        }
        evaluate(t) {
          return this._sample(t) || this._pushNullishPose(t);
        }
        getCurrentStateStatus() {
          const { _currentNode: t } = this;
          return t.kind === Q0.animation || t.kind === Q0.procedural
            ? t.getStatus()
            : null;
        }
        getCurrentClipStatuses() {
          const { _currentNode: t } = this;
          return t.kind === Q0.animation
            ? t.getClipStatuses(t.absoluteWeight)
            : Z0;
        }
        getCurrentTransition(t) {
          const { _activatedTransitions: e } = this;
          if (0 === e.length) return !1;
          const i = e[e.length - 1],
            s =
              1 === e.length ? this._currentNode : e[e.length - 2].destination,
            n = i.getAbsoluteDuration(s);
          return (t.duration = n), (t.time = i.normalizedElapsedTime * n), !0;
        }
        getNextStateStatus() {
          const { _activatedTransitions: t } = this;
          if (0 === t.length) return null;
          const e = t[t.length - 1].destination;
          switch (e.kind) {
            default:
              break;
            case Q0.procedural:
            case Q0.animation:
              return e.getStatus();
          }
          return null;
        }
        getNextClipStatuses() {
          var t;
          const { _activatedTransitions: e } = this;
          if (0 === e.length) return Z0;
          const i = e[e.length - 1],
            s = i.destination;
          switch (s.kind) {
            default:
              return Z0;
            case Q0.animation:
              return null !==
                (t = s.getClipStatuses(i.destination.absoluteWeight)) &&
                void 0 !== t
                ? t
                : Z0;
          }
        }
        overrideClips(t) {
          const { _motionStates: e } = this,
            i = e.length;
          for (let s = 0; s < i; ++s) e[s].overrideClips(t);
        }
        _addStateMachine(t, e, i, s) {
          const n = Array.from(t.states());
          let r, a, o;
          const h = n.map((e) => {
              if (e instanceof RW) {
                const t = new c1(e, i);
                return this._motionStates.push(t), t;
              }
              if (e === t.entryState) return (r = new d1(e, Q0.entry, e.name));
              if (e === t.exitState) return (o = new d1(e, Q0.exit, e.name));
              if (e === t.anyState) return (a = new d1(e, Q0.any, e.name));
              if (e instanceof jY) return new p1(e);
              if (e instanceof YY) {
                const t = new m1(e, i);
                return this._proceduralPoseStates.push(t), t;
              }
              return null;
            }),
            l = { components: null, parent: e, entry: r, exit: o, any: a };
          for (let t = 0; t < n.length; ++t) {
            const e = h[t];
            e && (e.stateMachine = l);
          }
          const c = n.map((t) => {
            if (t instanceof QY) {
              const e = this._addStateMachine(
                t.stateMachine,
                l,
                i,
                `${s}/${t.name}`
              );
              return (e.components = new l1(t)), e;
            }
            return null;
          });
          for (let e = 0; e < n.length; ++e) {
            const s = n[e],
              r = t.getOutgoings(s);
            let a;
            a = s instanceof QY ? c[e].exit : h[e];
            for (const t of r) {
              const e = t.to,
                s = n.findIndex((e) => e === t.to);
              let r;
              if (e instanceof QY) r = c[s].entry;
              else {
                const t = h[s];
                r = t instanceof c1 ? t.entry : t;
              }
              const o = {
                conditions: t.conditions.map((t) => t[iK](i)),
                to: r,
                triggers: void 0,
                duration: 0,
                normalizedDuration: !1,
                destinationStart: 0,
                relativeDestinationStart: !1,
                exitCondition: 0,
                exitConditionEnabled: !1,
                activated: !1,
                startEventBinding: void 0,
                endEventBinding: void 0,
              };
              (VY(t) || t instanceof WY || t instanceof qY) &&
                ((o.duration = t.duration),
                (o.destinationStart = t.destinationStart),
                (o.relativeDestinationStart = t.relativeDestinationStart),
                t.startEventBinding.isBound &&
                  (o.startEventBinding = t.startEventBinding),
                t.endEventBinding.isBound &&
                  (o.endEventBinding = t.endEventBinding),
                VY(t) &&
                  ((o.normalizedDuration = t.relativeDuration),
                  (o.exitConditionEnabled = t.exitConditionEnabled),
                  (o.exitCondition = t.exitCondition))),
                o.conditions.forEach((e, i) => {
                  const s = t.conditions[i];
                  var n;
                  s instanceof p0 &&
                    s.trigger &&
                    (null !== (n = o.triggers) && void 0 !== n
                      ? n
                      : (o.triggers = [])
                    ).push(s.trigger);
                }),
                a.addTransition(o);
            }
          }
          return l;
        }
        _loopMatchTransitions() {
          const { _pendingTransitionPath: t, _activatedTransitions: e } = this;
          t.length;
          let i =
            0 === e.length ? this._currentNode : e[e.length - 1].destination;
          for (let e = 0; ; ++e) {
            if (e >= 16) {
              z(14e3, 16, "");
              break;
            }
            const s = this._matchNextTransition(i);
            if (!s) break;
            const n = s.to,
              r = i;
            if (((i = n), q0(n))) {
              if (n === r) break;
              this._activateTransition(t, s), (t.length = 0);
            } else t.push(s);
          }
          t.length = 0;
        }
        _resetStateTickFlagsAndWeights() {
          const { _currentNode: t, _activatedTransitions: e } = this;
          t.resetTickFlagsAndWeight();
          for (let t = 0; t < e.length; ++t) {
            const { destination: i } = e[t];
            i.resetTickFlagsAndWeight();
          }
        }
        _commitStateUpdates(t) {
          const {
            _currentNode: e,
            _activatedTransitions: i,
            _updateContextGenerator: s,
          } = this;
          this._commitStateUpdate(e, t);
          for (let e = 0; e < i.length; ++e) {
            const s = i[e],
              { destination: n } = s;
            this._commitStateUpdate(n, t);
          }
        }
        _commitStateUpdate(t, e) {
          const { _updateContextGenerator: i } = this;
          if (!t.testTickFlag(J0.UPDATED))
            if ((t.setTickFlag(J0.UPDATED), t.kind === Q0.animation))
              t.update(e.deltaTime, this._controller);
            else if (t.kind === Q0.procedural) {
              const s = i.generate(
                e.deltaTime,
                e.indicativeWeight * t.absoluteWeight
              );
              t.update(s);
            }
        }
        _sample(t) {
          const { _currentNode: e, _activatedTransitions: i } = this;
          let s = 1,
            n = null,
            r = 0;
          var a;
          if (e.kind === Q0.animation)
            n =
              null !== (a = e.evaluate(t)) && void 0 !== a
                ? a
                : this._pushNullishPose(t);
          else if (e.kind === Q0.procedural) {
            var o;
            n =
              null !== (o = e.evaluate(t)) && void 0 !== o
                ? o
                : this._pushNullishPose(t);
          } else (s -= e.absoluteWeight), (n = null);
          n && (r = e.absoluteWeight), e.setTickFlag(J0.EVALUATED);
          for (let e = 0; e < i.length; ++e) {
            const a = i[e],
              { destination: o } = a;
            if (o.testTickFlag(J0.EVALUATED)) continue;
            o.setTickFlag(J0.EVALUATED);
            const l = o.absoluteWeight;
            let c;
            var h;
            o.kind === Q0.empty
              ? ((s -= l), (c = null))
              : (c =
                  null !== (h = o.evaluate(t)) && void 0 !== h
                    ? h
                    : this._pushNullishPose(t)),
              c &&
                (n
                  ? ((r += l), r ? (mX(n, c, l / r), t.popPose()) : (n = c))
                  : (n = c));
          }
          return (this.passthroughWeight = s), n;
        }
        _pushNullishPose(t) {
          return this._additive ? t.pushZeroDeltaPose() : t.pushDefaultedPose();
        }
        _matchNextTransition(t) {
          const e = this._matchTransition(t, t);
          if (e) return e;
          if (t.kind === Q0.animation || t.kind === Q0.procedural) {
            const e = this._matchAnyScoped(t);
            if (e) return e;
          }
          return null;
        }
        _matchAnyScoped(t) {
          for (let e = t.stateMachine; null !== e; e = e.parent) {
            const i = this._matchTransition(e.any, t);
            if (i) return i;
          }
          return null;
        }
        _matchTransition(t, e) {
          t === e || (t.kind, Q0.any);
          const { _conditionEvaluationContext: i } = this;
          i.set(e);
          const { outgoingTransitions: s } = t,
            n = s.length;
          for (let i = 0; i < n; ++i) {
            const n = s[i];
            if (n.activated) continue;
            const { conditions: r } = n,
              a = r.length;
            if (0 === a) {
              if (t.kind === Q0.entry || t.kind === Q0.exit) return n;
              if (!n.exitConditionEnabled) continue;
            }
            if (e.kind === Q0.animation && n.exitConditionEnabled) {
              const t = e.duration * n.exitCondition;
              if (e.time < t) break;
            }
            let o = !0;
            for (let t = 0; t < a; ++t)
              if (!r[t].eval(this._conditionEvaluationContext)) {
                o = !1;
                break;
              }
            if (o) return n;
          }
          return null;
        }
        _activateTransition(t, e) {
          const i = e.to;
          q0(i);
          const s = this._activatedTransitionPool.alloc();
          s.reset(t, e), this._activatedTransitions.push(s);
          const n = s.path.length;
          for (let t = 0; t < n; ++t) {
            const e = s.path[t];
            this._resetTriggersOnTransition(e);
          }
          for (let t = 0; t < s.path.length; ++t) {
            const e = s.path[t];
            this._callEnterMethods(e.to);
          }
          this._activatedTransitions.length;
          const r =
            1 === this._activatedTransitions.length
              ? this._currentNode
              : this._activatedTransitions[
                  this._activatedTransitions.length - 2
                ].destination;
          r instanceof h1 &&
            r.transitionOutEventBinding &&
            this._emit(r.transitionOutEventBinding),
            e.startEventBinding && this._emit(e.startEventBinding),
            i instanceof h1 &&
              i.transitionInEventBinding &&
              this._emit(i.transitionInEventBinding);
        }
        _updateActivatedTransitions(t) {
          const { _activatedTransitions: e } = this;
          let i = e.length - 1,
            s = 1,
            n = i;
          for (; i >= 0; --i) {
            const r = e[i],
              a = 0 === i ? this._currentNode : e[i - 1].destination;
            if ((r.update(t, a), r.done)) {
              this._dropActivatedTransitions(n);
              break;
            }
            const o = r.normalizedElapsedTime * s;
            r.destination.increaseAbsoluteWeight(o),
              (s *= 1 - r.normalizedElapsedTime),
              (n = i - 1);
          }
          this._currentNode.increaseAbsoluteWeight(s);
        }
        _dropActivatedTransitions(t) {
          const { _activatedTransitions: e, _activatedTransitionPool: i } =
            this;
          t >= 0 && e.length;
          const s = t + 1,
            n = e[t],
            r = n.destination;
          {
            n.path.length;
            const t = n.path[n.path.length - 1];
            t.endEventBinding && this._emit(t.endEventBinding);
          }
          this._callExitMethods(this._currentNode);
          for (let s = 0; s <= t; ++s) {
            const n = e[s];
            s !== t && n.destination.decreaseActiveReference();
            const r = s === t ? n.path.length - 1 : n.path.length;
            for (let t = 0; t < r; ++t) {
              const e = n.path[t];
              this._callExitMethods(e.to);
            }
            i.free(n);
          }
          if (t === e.length - 1) e.length = 0;
          else {
            for (let i = t + 1; i < e.length; ++i) e[i - s] = e[i];
            e.length -= s;
          }
          this._currentNode.decreaseActiveReference(), (this._currentNode = r);
        }
        _resetTriggersOnTransition(t) {
          const { triggers: e } = t;
          if (e) {
            const t = e.length;
            for (let i = 0; i < t; ++i) {
              const t = e[i];
              this._resetTrigger(t);
            }
          }
        }
        _resetTrigger(t) {
          const { _triggerReset: e } = this;
          e(t);
        }
        _callEnterMethods(t) {
          var e;
          const { _controller: i } = this;
          switch (t.kind) {
            default:
              break;
            case Q0.animation:
              t.components.callMotionStateEnterMethods(i, t.getStatus());
              break;
            case Q0.entry:
              null === (e = t.stateMachine.components) ||
                void 0 === e ||
                e.callStateMachineEnterMethods(i);
          }
        }
        _callExitMethods(t) {
          var e;
          const { _controller: i } = this;
          switch (t.kind) {
            default:
              break;
            case Q0.animation:
              t.components.callMotionStateExitMethods(i, t.getStatus());
              break;
            case Q0.exit:
              null === (e = t.stateMachine.components) ||
                void 0 === e ||
                e.callStateMachineExitMethods(i);
          }
        }
        _emit(t) {
          t.emit(this._controller.node);
        }
      }
      function q0(t) {
        return (
          t.kind === Q0.animation ||
          t.kind === Q0.empty ||
          t.kind === Q0.procedural
        );
      }
      const $0 = { next: () => ({ done: !0, value: void 0 }) },
        Z0 = { [Symbol.iterator]: () => $0 };
      var Q0, J0, t1, e1, i1, s1, n1, r1, a1;
      !(function (t) {
        (t[(t.entry = 0)] = "entry"),
          (t[(t.exit = 1)] = "exit"),
          (t[(t.any = 2)] = "any"),
          (t[(t.animation = 3)] = "animation"),
          (t[(t.empty = 4)] = "empty"),
          (t[(t.procedural = 5)] = "procedural");
      })(Q0 || (Q0 = {}));
      class o1 {
        constructor(t) {
          (this.name = void 0),
            (this.outgoingTransitions = []),
            (this._activeReferenceCount = 0),
            (this._tickFlags = 0),
            (this._absoluteWeight = 0),
            (this.name = t.name);
        }
        get absoluteWeight() {
          return this._absoluteWeight;
        }
        get activeReferenceCount() {
          return this._activeReferenceCount;
        }
        setPrefix_debug(t) {
          this.__DEBUG_ID__ = `${t}${this.name}`;
        }
        addTransition(t) {
          this.outgoingTransitions.push(t);
        }
        increaseActiveReference() {
          0 === this._activeReferenceCount &&
            ((this._absoluteWeight = 0), (this._tickFlags = 0)),
            ++this._activeReferenceCount;
        }
        decreaseActiveReference() {
          --this._activeReferenceCount;
        }
        resetTickFlagsAndWeight() {
          this._checkActivated(),
            (this._absoluteWeight = 0),
            (this._tickFlags = 0);
        }
        increaseAbsoluteWeight(t) {
          this._absoluteWeight += t;
        }
        testTickFlag(t) {
          return !!(this._tickFlags & t);
        }
        setTickFlag(t) {
          this.testTickFlag(t), J0[t], (this._tickFlags |= t);
        }
        _checkActivated() {
          this._activeReferenceCount;
        }
      }
      class h1 extends o1 {
        constructor(t) {
          super(t),
            (this.transitionInEventBinding = void 0),
            (this.transitionOutEventBinding = void 0),
            t.transitionInEventBinding.isBound &&
              (this.transitionInEventBinding = t.transitionInEventBinding),
            t.transitionOutEventBinding.isBound &&
              (this.transitionOutEventBinding = t.transitionOutEventBinding);
        }
      }
      !(function (t) {
        (t[(t.UPDATED = 1)] = "UPDATED"), (t[(t.EVALUATED = 2)] = "EVALUATED");
      })(J0 || (J0 = {}));
      class l1 {
        constructor(t) {
          this._components = t.instantiateComponents();
        }
        callMotionStateEnterMethods(t, e) {
          this._callMotionStateCallbackIfNonDefault("onMotionStateEnter", t, e);
        }
        callMotionStateUpdateMethods(t, e) {
          this._callMotionStateCallbackIfNonDefault(
            "onMotionStateUpdate",
            t,
            e
          );
        }
        callMotionStateExitMethods(t, e) {
          this._callMotionStateCallbackIfNonDefault("onMotionStateExit", t, e);
        }
        callStateMachineEnterMethods(t) {
          this._callStateMachineCallbackIfNonDefault("onStateMachineEnter", t);
        }
        callStateMachineExitMethods(t) {
          this._callStateMachineCallbackIfNonDefault("onStateMachineExit", t);
        }
        _callMotionStateCallbackIfNonDefault(t, e, i) {
          const { _components: s } = this,
            n = s.length;
          for (let r = 0; r < n; ++r) {
            const n = s[r];
            n[t] !== g0.prototype[t] && n[t](e, i);
          }
        }
        _callStateMachineCallbackIfNonDefault(t, e) {
          const { _components: i } = this,
            s = i.length;
          for (let n = 0; n < s; ++n) {
            const s = i[n];
            s[t] !== g0.prototype[t] && s[t](e);
          }
        }
      }
      class c1 {
        constructor(t, e) {
          var i, s;
          (this._source = null),
            (this._baseSpeed = 1),
            (this._speed = 1),
            (this._publicState = void 0),
            (this._privateState = void 0);
          const n = t.name;
          if (
            ((this._baseSpeed = t.speed),
            this._setSpeedMultiplier(1),
            t.speedMultiplierEnabled && t.speedMultiplier)
          ) {
            const i = t.speedMultiplier,
              s = e.getVar(i);
            if (lZ(s, i)) {
              !(function (t, e, i) {
                if (t !== e) throw new qj(i, "number");
              })(s.type, vj.FLOAT, i),
                s.bind(this._setSpeedMultiplier, this);
              const t = s.value;
              this._setSpeedMultiplier(t);
            }
          }
          const r =
            null !==
              (i =
                null === (s = t.motion) || void 0 === s
                  ? void 0
                  : s[iK](e, !1)) && void 0 !== i
              ? i
              : null;
          r && Object.defineProperty(r, "__DEBUG_ID__", { value: n }),
            (this._source = r),
            (this._publicState = new u1(
              this,
              t,
              null == r ? void 0 : r.createPort()
            )),
            (this._privateState = new u1(
              this,
              t,
              null == r ? void 0 : r.createPort()
            )),
            (this.components = new l1(t));
        }
        get duration() {
          var t, e;
          return null !==
            (t =
              null === (e = this._source) || void 0 === e
                ? void 0
                : e.duration) && void 0 !== t
            ? t
            : 0;
        }
        get speed() {
          return this._speed;
        }
        get entry() {
          return this._publicState;
        }
        get stateMachine() {
          return this._stateMachine;
        }
        set stateMachine(t) {
          (this._stateMachine = t),
            (this._publicState.stateMachine = t),
            (this._privateState.stateMachine = t);
        }
        setPrefix_debug(t) {
          this._publicState.setPrefix_debug(t),
            this._privateState.setPrefix_debug(t);
        }
        addTransition(t) {
          t.to === this._publicState
            ? this._publicState.addTransition({ ...t, to: this._privateState })
            : this._publicState.addTransition(t),
            this._privateState.addTransition(t);
        }
        getClipStatuses(t) {
          const { _source: e } = this;
          return e ? { [Symbol.iterator]: () => e.getClipStatuses(t) } : Z0;
        }
        overrideClips(t) {
          var e;
          null === (e = this._source) || void 0 === e || e.overrideClips(t);
        }
        _setSpeedMultiplier(t) {
          this._speed = this._baseSpeed * t;
        }
      }
      class u1 extends h1 {
        constructor(t, e, i) {
          super(e),
            (this.kind = Q0.animation),
            (this._container = void 0),
            (this._progress = 0),
            (this._port = void 0),
            (this._statusCache = { progress: 0 }),
            (this._container = t),
            (this._port = i);
        }
        get duration() {
          return this._container.duration;
        }
        get components() {
          return this._container.components;
        }
        get normalizedTime() {
          return this._progress;
        }
        get time() {
          return this._progress * this._container.duration;
        }
        reenter(t) {
          var e;
          (this._progress = t),
            null === (e = this._port) || void 0 === e || e.reenter();
        }
        getStatus() {
          const { _statusCache: t } = this;
          return (t.progress = _1(this._progress)), t;
        }
        getClipStatuses(t) {
          return this._container.getClipStatuses(t);
        }
        update(t, e) {
          (this._progress = (function (t, e, i) {
            return 0 === e ? 0 : t + i / e;
          })(this._progress, this.duration, t * this._container.speed)),
            this._container.components.callMotionStateUpdateMethods(
              e,
              this.getStatus()
            );
        }
        evaluate(t) {
          var e, i;
          return null !==
            (e =
              null === (i = this._port) || void 0 === i
                ? void 0
                : i.evaluate(this._progress, t)) && void 0 !== e
            ? e
            : null;
        }
      }
      function _1(t) {
        const e = t - Math.trunc(t);
        return e >= 0 ? e : 1 + e;
      }
      class d1 extends o1 {
        constructor(t, e, i) {
          super(t), (this.kind = void 0), (this.kind = e);
        }
      }
      class p1 extends o1 {
        constructor(t) {
          super(t), (this.kind = Q0.empty);
        }
      }
      class m1 extends h1 {
        constructor(t, e) {
          super(t),
            (this.kind = Q0.procedural),
            (this.elapsedTime = 0),
            (this.statusCache = { progress: 0 }),
            (this._instantiatedPoseGraph = void 0),
            (this._statusCache = { progress: 0 }),
            (this._elapsedTime = 0);
          const i = z0(t.graph, e, !0);
          i.bind(e),
            (this._instantiatedPoseGraph = i),
            (this._statusCache.progress = 0);
        }
        settle(t) {
          this._instantiatedPoseGraph.settle(t);
        }
        reenter() {
          (this._statusCache.progress = 0),
            this._instantiatedPoseGraph.reenter();
        }
        update(t) {
          (this._elapsedTime += t.deltaTime),
            this._instantiatedPoseGraph.update(t);
        }
        evaluate(t) {
          var e;
          return null !== (e = this._instantiatedPoseGraph.evaluate(t)) &&
            void 0 !== e
            ? e
            : null;
        }
        getStatus() {
          return (
            (this._statusCache.progress = _1(this._elapsedTime)),
            this._statusCache
          );
        }
        countMotionTime() {
          return this._instantiatedPoseGraph.countMotionTime();
        }
      }
      class f1 {
        constructor() {
          (this.sourceStateWeight = 0), (this._sourceState = void 0);
        }
        set(t) {
          (this._sourceState = t),
            q0(t)
              ? (t.activeReferenceCount,
                (this.sourceStateWeight = t.absoluteWeight))
              : (this.sourceStateWeight = 0);
        }
        unset() {
          (this._sourceState = void 0), (this.sourceStateWeight = 0);
        }
        get sourceStateMotionTimeNormalized() {
          const { _sourceState: t } = this;
          switch (
            (t &&
              (t.kind === Q0.animation || t.kind === Q0.procedural) &&
              t.activeReferenceCount,
            t.kind)
          ) {
            case Q0.animation:
              return t.normalizedTime;
            case Q0.procedural:
              return t.countMotionTime();
            default:
              return 0;
          }
        }
      }
      class g1 {
        constructor() {
          (this.normalizedElapsedTime = 0),
            (this.path = []),
            (this._durationMultiplier = 1);
        }
        get done() {
          return Ti(this.normalizedElapsedTime, 1, 1e-6);
        }
        getAbsoluteDuration(t) {
          return (
            this._getAbsoluteDurationUnscaled(t) * this._durationMultiplier
          );
        }
        update(t, e) {
          if (!q0(e)) return void (this.normalizedElapsedTime = 1);
          const i = this.getAbsoluteDuration(e);
          let s = 0;
          if (i <= 0) (s = 0), (this.normalizedElapsedTime = 1);
          else {
            const e = this.normalizedElapsedTime * i,
              n = i - e;
            s = Math.min(n, t);
            const r = Ei((e + s) / i);
            this.normalizedElapsedTime = r;
          }
        }
        static createPool(t) {
          return new Wn(() => new g1(), t, void 0);
        }
        reset(t, e) {
          const i = e.to;
          q0(i),
            (this.normalizedElapsedTime = 0),
            (this.destination = i),
            (this.path = [...t, e]);
          const s = i.activeReferenceCount;
          if ((i.increaseActiveReference(), 0 === s))
            if (i.kind === Q0.animation) {
              const { destinationStart: t, relativeDestinationStart: e } =
                  this.path[0],
                s = e ? t : 0 === i.duration ? 0 : t / i.duration;
              i.reenter(s);
            } else i.kind === Q0.procedural && i.reenter();
          i.activeReferenceCount,
            (this._durationMultiplier = 1 - i.absoluteWeight);
        }
        _getAbsoluteDurationUnscaled(t) {
          this.path.length;
          const { duration: e, normalizedDuration: i } = this.path[0];
          return i ? (t.kind === Q0.animation ? t.duration : 1) * e : e;
        }
      }
      class y1 {
        constructor() {
          this._groups = [];
        }
        register(t) {
          const { group: e } = t;
          let i = this._groups.find((t) => t.name === e);
          return i || ((i = new T1(e)), this._groups.push(i)), i.addMember();
        }
        sync() {
          for (const t of this._groups) t.sync();
        }
      }
      class T1 {
        constructor(t) {
          (this._lastLeader = void 0), (this._records = []), (this.name = t);
        }
        addMember() {
          const t = new S1();
          return this._records.push(t), t;
        }
        sync() {
          const { _records: t } = this,
            e = t.length,
            { _lastLeader: i } = this;
          if (((this._lastLeader = void 0), t.every((t) => !t.active))) return;
          t.sort((t, e) => {
            const i = t.active ? t.weight : -1;
            return (e.active ? e.weight : -1) - i;
          });
          let s = 0;
          const n = t[0].weight;
          if (t[s] !== i)
            for (let r = 0; r < e; ++r) {
              const e = t[r];
              if (!e.active || !Ti(e.weight, n, 1e-6)) break;
              if (e === i) {
                s = r;
                break;
              }
            }
          t[s].active, (this._lastLeader = t[s]);
          const r = t[s].normalizedTime;
          for (let i = 0; i < e; ++i) {
            const e = t[i];
            if (!e.active) break;
            (e.normalizedTime = r), e.reset();
          }
        }
      }
      class S1 {
        constructor() {
          (this.normalizedTime = 0), (this.weight = 0), (this.active = !1);
        }
        notifyRenter(t) {
          this.reset(), (this.normalizedTime = t);
        }
        notifyUpdate(t, e) {
          (this.normalizedTime += t),
            this.active
              ? (this.weight += e)
              : ((this.active = !0), (this.weight = e));
        }
        reset() {
          (this.active = !1), (this.weight = 0);
        }
        getSyncedEnterTime() {
          return this.normalizedTime;
        }
      }
      !(function (t) {
        (t[(t.UNINITIALIZED = 0)] = "UNINITIALIZED"),
          (t[(t.UNSETTLED = 1)] = "UNSETTLED"),
          (t[(t.SETTLED = 2)] = "SETTLED"),
          (t[(t.UP_TO_DATE = 3)] = "UP_TO_DATE"),
          (t[(t.OUTDATED = 4)] = "OUTDATED"),
          (t[(t.UPDATING = 5)] = "UPDATING"),
          (t[(t.UPDATED = 6)] = "UPDATED"),
          (t[(t.EVALUATING = 7)] = "EVALUATING"),
          (t[(t.EVALUATED = 8)] = "EVALUATED");
      })(t1 || (t1 = {}));
      class E1 {
        constructor(t) {
          (this._state = t1.UNINITIALIZED),
            (this._instantiatedPoseGraph = void 0),
            (this._maxRequestedUpdateTime = 0),
            (this._evaluationCache = null),
            (this._updateContextGenerator = new fJ()),
            (this._allocator = t);
        }
        set(t, e) {
          this._state, t1.UNINITIALIZED;
          const i = z0(t.graph, e);
          i.bind(e),
            (this._instantiatedPoseGraph = i),
            (this._state = t1.UNSETTLED);
        }
        settle(t) {
          this._state === t1.UNSETTLED || (this._state, t1.SETTLED),
            this._instantiatedPoseGraph,
            this._instantiatedPoseGraph.settle(t),
            (this._state = t1.SETTLED);
        }
        reset() {
          switch (this._state) {
            case t1.SETTLED:
            case t1.OUTDATED:
              break;
            case t1.UP_TO_DATE:
              this._state = t1.OUTDATED;
              break;
            case t1.UPDATED:
            case t1.EVALUATED:
              this._evaluationCache &&
                (this._allocator.destroyPose(this._evaluationCache),
                (this._evaluationCache = null)),
                (this._maxRequestedUpdateTime = 0),
                (this._state = t1.UP_TO_DATE);
              break;
            case t1.UNINITIALIZED:
          }
        }
        reenter() {
          switch (this._state) {
            default:
              this._state;
              break;
            case t1.UP_TO_DATE:
            case t1.UPDATED:
              break;
            case t1.SETTLED:
            case t1.OUTDATED:
              (this._state = t1.UP_TO_DATE),
                this._instantiatedPoseGraph,
                this._instantiatedPoseGraph.reenter();
          }
        }
        requestUpdate(t) {
          const { deltaTime: e } = t;
          if (
            (this._state === t1.OUTDATED ||
              this._state === t1.UP_TO_DATE ||
              this._state === t1.UPDATING ||
              (this._state, t1.UPDATED),
            this._instantiatedPoseGraph,
            this._state === t1.UPDATING)
          )
            return;
          const i = Math.max(0, e - this._maxRequestedUpdateTime);
          if (this._state === t1.UPDATED && Ti(i, 0, 1e-8)) return;
          (this._state = t1.UPDATING),
            (this._maxRequestedUpdateTime = Math.max(
              e,
              this._maxRequestedUpdateTime
            ));
          const s = this._updateContextGenerator.generate(
            i,
            t.indicativeWeight
          );
          this._instantiatedPoseGraph.update(s), (this._state = t1.UPDATED);
        }
        evaluate(t) {
          switch (this._state) {
            default:
              this._state;
              break;
            case t1.EVALUATING:
              this._state = t1.EVALUATED;
              break;
            case t1.EVALUATED:
              break;
            case t1.UPDATED: {
              var e;
              this._evaluationCache, (this._state = t1.EVALUATING);
              const i =
                null === (e = this._instantiatedPoseGraph) || void 0 === e
                  ? void 0
                  : e.evaluate(t);
              if (((this._state = t1.EVALUATED), i)) {
                const e = this._allocator.allocatePose();
                e.transforms.set(i.transforms),
                  e.auxiliaryCurves.set(i.auxiliaryCurves),
                  (this._evaluationCache = e),
                  t.popPose();
              }
              this._state = t1.EVALUATED;
              break;
            }
          }
          return (
            this._state,
            t1.EVALUATED,
            this._instantiatedPoseGraph,
            this._evaluationCache
              ? t.pushDuplicatedPose(this._evaluationCache)
              : null
          );
        }
      }
      class v1 {
        constructor(t) {
          (this._allocator = void 0),
            (this._stashEvaluations = {}),
            (this._allocator = t);
        }
        bindStash(t) {
          return this._stashEvaluations[t];
        }
        getStash(t) {
          return this._stashEvaluations[t];
        }
        addStash(t) {
          this._stashEvaluations[t] = new E1(this._allocator);
        }
        setStash(t, e, i) {
          this._stashEvaluations, this._stashEvaluations[t].set(e, i);
        }
        reset() {
          for (const t in this._stashEvaluations)
            this._stashEvaluations[t].reset();
        }
        settle(t) {
          for (const e in this._stashEvaluations)
            this._stashEvaluations[e].settle(t);
        }
      }
      class b1 extends vX {
        constructor(t, e, i) {
          super(), (this._layerRecords = void 0);
          const s = t.layers.map((t) => new A1(t, e, i));
          this._layerRecords = s;
        }
        get layerCount() {
          return this._layerRecords.length;
        }
        reenter() {}
        bind(t) {}
        settle(t) {
          const { _layerRecords: e } = this,
            i = e.length;
          for (let s = 0; s < i; ++s) e[s].settle(t);
        }
        getLayerWeight(t) {
          return (
            t >= 0 && this._layerRecords.length, this._layerRecords[t].weight
          );
        }
        setLayerWeight(t, e) {
          t >= 0 && this._layerRecords.length,
            (this._layerRecords[t].weight = e);
        }
        getLayerTopLevelStateMachineEvaluation(t) {
          return this._layerRecords[t].stateMachineEvaluation;
        }
        overrideClips(t) {
          const { _layerRecords: e } = this,
            i = e.length;
          for (let s = 0; s < i; ++s) {
            const i = e[s];
            t._pushAdditiveFlag(i.additive),
              i.stateMachineEvaluation.overrideClips(t),
              t._popAdditiveFlag();
          }
        }
        doUpdate(t) {
          const { _layerRecords: e } = this,
            i = e.length;
          for (let s = 0; s < i; ++s) e[s].update(t);
        }
        doEvaluate(t) {
          const e = t.pushDefaultedPose(),
            { _layerRecords: i } = this,
            s = i.length;
          for (let n = 0; n < s; ++n) {
            const s = i[n],
              r = s.stateMachineEvaluation.evaluate(t),
              a = s.weight * s.stateMachineEvaluation.passthroughWeight,
              { transformFilter: o } = s;
            s.additive ? yX(e, r, a, o) : mX(e, r, a, o),
              t.popPose(),
              s.postEvaluate();
          }
          return e;
        }
      }
      class A1 {
        constructor(t, e, i) {
          var s;
          (this.additive = !1),
            (this.weight = 0),
            (this._topLevelStateMachineEval = void 0),
            (this._stashManager = void 0),
            (this._motionSyncManager = void 0),
            (this._mask = void 0),
            (this.transformFilter = void 0);
          const n = new v1(i);
          for (const [e, i] of t.stashes()) n.addStash(e);
          this._stashManager = n;
          const r = new y1();
          (this._motionSyncManager = r), e._setLayerWideContextProperties(n, r);
          for (const [i, s] of t.stashes()) n.setStash(i, s, e);
          this.weight = t.weight;
          const a = (this.additive = t.additive);
          (this._mask = null !== (s = t.mask) && void 0 !== s ? s : void 0),
            e._pushAdditiveFlag(a),
            (this._topLevelStateMachineEval = new K0(
              t.stateMachine,
              t.name,
              e
            )),
            e._popAdditiveFlag(),
            e._unsetLayerWideContextProperties();
        }
        get stateMachineEvaluation() {
          return this._topLevelStateMachineEval;
        }
        settle(t) {
          this._mask &&
            (this.transformFilter = t.createTransformFilter(this._mask)),
            this._stashManager.settle(t),
            this._topLevelStateMachineEval.settle(t);
        }
        update(t) {
          this.stateMachineEvaluation.update(t), this._motionSyncManager.sync();
        }
        postEvaluate() {
          this._stashManager.reset();
        }
      }
      class C1 {
        constructor(t, e, i, s) {
          (this._currentTransitionCache = { duration: 0, time: 0 }),
            (this._rootPoseNode = void 0),
            (this._varInstances = {}),
            (this._hasAutoTrigger = !1),
            (this._auxiliaryCurveRegistry = new sJ()),
            (this._poseLayoutMaintainer = void 0),
            (this._bindingContext = void 0),
            (this._settleContext = void 0),
            (this._rootUpdateContextGenerator = new fJ());
          for (const [e, i] of t.variables) {
            const t = i[bj]();
            (this._varInstances[e] = t),
              t instanceof Bj &&
                t.resetMode === Nj.NEXT_FRAME_OR_AFTER_CONSUMED &&
                (this._hasAutoTrigger = !0);
          }
          const n = new rJ(e, this._auxiliaryCurveRegistry);
          this._poseLayoutMaintainer = n;
          const r = new eJ(e, n, this._varInstances, i);
          r._setClipOverrides(null != s ? s : void 0),
            (this._bindingContext = r);
          const a = new cJ(n);
          (this._settleContext = a), n.startBind();
          const o = new gJ();
          (this._poseStashAllocator = o),
            (this._rootPoseNode = new b1(t, r, o)),
            (this._root = e),
            this._initializeContexts();
        }
        destroy() {
          this._evaluationContext.destroy();
        }
        _destroyAfterException_debugging() {
          const t = this._evaluationContext._stackSize_debugging;
          if (0 !== t)
            for (let e = 0; e < t; ++e) this._evaluationContext.popPose();
          this._evaluationContext.destroy();
        }
        get layerCount() {
          return this._rootPoseNode.layerCount;
        }
        update(t) {
          const {
              _evaluationContext: e,
              _poseLayoutMaintainer: i,
              _rootUpdateContextGenerator: s,
              _rootPoseNode: n,
            } = this,
            r = s.generate(t, 1);
          n.update(r);
          const a = n.evaluate(e, EX.LOCAL);
          if (this._hasAutoTrigger) {
            const { _varInstances: t } = this;
            for (const e in t) {
              const i = t[e];
              i instanceof Bj &&
                i.resetMode === Nj.NEXT_FRAME_OR_AFTER_CONSUMED &&
                (i.value = !1);
            }
          }
          i.apply(a), e.popPose();
        }
        getVariables() {
          return Object.entries(this._varInstances);
        }
        getCurrentStateStatus(t) {
          return this._rootPoseNode
            .getLayerTopLevelStateMachineEvaluation(t)
            .getCurrentStateStatus();
        }
        getCurrentClipStatuses(t) {
          return this._rootPoseNode
            .getLayerTopLevelStateMachineEvaluation(t)
            .getCurrentClipStatuses();
        }
        getCurrentTransition(t) {
          const { _currentTransitionCache: e } = this;
          return this._rootPoseNode
            .getLayerTopLevelStateMachineEvaluation(t)
            .getCurrentTransition(e)
            ? e
            : null;
        }
        getNextStateStatus(t) {
          return this._rootPoseNode
            .getLayerTopLevelStateMachineEvaluation(t)
            .getNextStateStatus();
        }
        getNextClipStatuses(t) {
          return this._rootPoseNode
            .getLayerTopLevelStateMachineEvaluation(t)
            .getNextClipStatuses();
        }
        getValue(t) {
          const e = this._varInstances[t];
          return e ? e.value : void 0;
        }
        setValue(t, e) {
          const i = this._varInstances[t];
          i && (i.value = e);
        }
        getLayerWeight(t) {
          return this._rootPoseNode.getLayerWeight(t);
        }
        setLayerWeight(t, e) {
          this._rootPoseNode.setLayerWeight(t, e);
        }
        overrideClips(t) {
          const { _poseLayoutMaintainer: e } = this;
          e.startBind(),
            this._bindingContext._setClipOverrides(t),
            this._rootPoseNode.overrideClips(this._bindingContext),
            this._updateAfterPossiblePoseLayoutChange();
        }
        getAuxiliaryCurveValue(t) {
          return this._auxiliaryCurveRegistry.get(t);
        }
        _initializeContexts() {
          const { _poseLayoutMaintainer: t } = this;
          t.endBind(), this._createOrUpdateTransformFilters();
          const e = t.createEvaluationContext();
          (this._evaluationContext = e),
            t.fetchDefaultTransforms(e[lJ]),
            t.resetPoseStashAllocator(this._poseStashAllocator);
        }
        _updateAfterPossiblePoseLayoutChange() {
          const { _poseLayoutMaintainer: t } = this,
            e = t.endBind();
          if (0 === e) return;
          (e & nJ.TRANSFORM_COUNT || e & nJ.TRANSFORM_ORDER) &&
            this._createOrUpdateTransformFilters();
          let i = !1;
          if (e & nJ.TRANSFORM_COUNT || e & nJ.AUXILIARY_CURVE_COUNT) {
            const e = t.createEvaluationContext();
            this._evaluationContext.destroy(),
              (this._evaluationContext = e),
              (i = !0),
              t.resetPoseStashAllocator(this._poseStashAllocator);
          }
          (i || e & nJ.TRANSFORM_COUNT || e & nJ.TRANSFORM_ORDER) &&
            t.fetchDefaultTransforms(this._evaluationContext[lJ]);
        }
        _createOrUpdateTransformFilters() {
          this._rootPoseNode.settle(this._settleContext);
        }
      }
      const {
        ccclass: O1,
        menu: I1,
        help: w1,
        type: R1,
        serializable: D1,
        editable: x1,
        formerlySerializedAs: M1,
      } = go;
      let P1 =
        ((e1 = O1("cc.animation.AnimationController")),
        (i1 = R1(MW)),
        (s1 = M1("graph")),
        e1(
          (s(
            (r1 = class extends np {
              constructor(...t) {
                super(...t),
                  (this._graph = a1 && a1()),
                  (this._graphEval = null);
              }
              get graph() {
                return this._graph;
              }
              set graph(t) {
                this._graph = t;
              }
              get layerCount() {
                var t, e;
                return null !==
                  (t =
                    null === (e = this._graphEval) || void 0 === e
                      ? void 0
                      : e.layerCount) && void 0 !== t
                  ? t
                  : 0;
              }
              __preload() {
                const { graph: t } = this;
                if (t) {
                  let e,
                    i = null;
                  if (t instanceof AQ) {
                    if (!t.original) return;
                    (e = t.original), (i = t.clipOverrides);
                  } else e = t;
                  const s = new C1(e, this.node, this, i);
                  this._graphEval = s;
                }
              }
              onDestroy() {
                var t;
                null === (t = this._graphEval) || void 0 === t || t.destroy();
              }
              update(t) {
                var e;
                null === (e = this._graphEval) || void 0 === e || e.update(t);
              }
              getVariables() {
                const { _graphEval: t } = this;
                return t.getVariables();
              }
              setValue(t, e) {
                return this.setValue_experimental(t, e);
              }
              setValue_experimental(t, e) {
                const { _graphEval: i } = this;
                i.setValue(t, e);
              }
              getValue(t) {
                const e = this.getValue_experimental(t);
                return "object" == typeof e ? void 0 : e;
              }
              getValue_experimental(t) {
                const { _graphEval: e } = this;
                return e.getValue(t);
              }
              getCurrentStateStatus(t) {
                const { _graphEval: e } = this;
                return e.getCurrentStateStatus(t);
              }
              getCurrentClipStatuses(t) {
                const { _graphEval: e } = this;
                return e.getCurrentClipStatuses(t);
              }
              getCurrentTransition(t) {
                const { _graphEval: e } = this;
                return e.getCurrentTransition(t);
              }
              getNextStateStatus(t) {
                const { _graphEval: e } = this;
                return e.getNextStateStatus(t);
              }
              getNextClipStatuses(t) {
                const { _graphEval: e } = this;
                return e.getNextClipStatuses(t);
              }
              getLayerWeight(t) {
                const { _graphEval: e } = this;
                return e.getLayerWeight(t);
              }
              setLayerWeight(t, e) {
                const { _graphEval: i } = this;
                return i.setLayerWeight(t, e);
              }
              overrideClips_experimental(t) {
                const { _graphEval: e } = this;
                e.overrideClips(t);
              }
              getAuxiliaryCurveValue_experimental(t) {
                const { _graphEval: e } = this;
                return e ? e.getAuxiliaryCurveValue(t) : 0;
              }
            }).prototype,
            "graph",
            [i1],
            Object.getOwnPropertyDescriptor(r1.prototype, "graph"),
            r1.prototype
          ),
          (a1 = fa(r1.prototype, "_graph", [D1, s1], function () {
            return null;
          })),
          (n1 = r1))
        ) || n1);
      var N1;
      t(
        "animation",
        Object.freeze({
          __proto__: null,
          UniformProxyFactory: vV,
          MorphWeightValueProxy: xV,
          MorphWeightsValueProxy: MV,
          MorphWeightsAllValueProxy: PV,
          Track: hV,
          TrackPath: rV,
          RealTrack: XV,
          VectorTrack: JV,
          QuatTrack: nj,
          ColorTrack: cj,
          SizeTrack: fj,
          ObjectTrack: Tj,
          isPropertyPath: BG,
          isCustomPath: function (t, e) {
            return t instanceof e;
          },
          HierarchyPath: FG,
          ComponentPath: UG,
          CubicSplineVec2Value: zV,
          CubicSplineVec3Value: HV,
          CubicSplineVec4Value: GV,
          CubicSplineQuatValue: VV,
          CubicSplineNumberValue: jV,
          AnimationController: P1,
          get VariableType() {
            return vj;
          },
          StateMachineComponent: g0,
        })
      );
      class L1 {
        constructor(t, e, i, s, n) {
          (this._node = t),
            (this._property = e),
            (this._propertyBlendState = i),
            (this._host = s),
            (this._constants = n);
        }
        get node() {
          return this._node;
        }
        get property() {
          return this._property;
        }
        getValue() {
          return this._node[this._property];
        }
        setValue(t) {
          const { _propertyBlendState: e, _host: i } = this,
            s = i.weight;
          e.blend(t, s);
        }
      }
      !(function (t) {
        (t[(t.POSITION = 1)] = "POSITION"),
          (t[(t.ROTATION = 2)] = "ROTATION"),
          (t[(t.SCALE = 4)] = "SCALE"),
          (t[(t.EULER_ANGLES = 8)] = "EULER_ANGLES");
      })(N1 || (N1 = {})),
        N1.POSITION,
        N1.ROTATION,
        N1.SCALE,
        N1.EULER_ANGLES;
      class B1 {
        constructor() {
          (this.refCount = 0),
            (this.accumulatedWeight = 0),
            (this.result = new Yi());
        }
        blend(t, e) {
          this.accumulatedWeight = (function (t, e, i, s, n) {
            const r = i + n;
            if (1 !== n || i) {
              if (r) {
                const e = n / r;
                Yi.lerp(t, t, s, e);
              }
            } else Yi.copy(t, s);
            return r;
          })(this.result, this.result, this.accumulatedWeight, t, e);
        }
        reset() {
          (this.accumulatedWeight = 0), Yi.zero(this.result);
        }
      }
      class F1 {
        constructor() {
          (this.refCount = 0),
            (this.accumulatedWeight = 0),
            (this.result = new as());
        }
        blend(t, e) {
          this.accumulatedWeight = (function (t, e, i, s, n) {
            const r = i + n;
            if (1 !== n || i) {
              if (r) {
                const i = n / r;
                as.slerp(t, e, s, i);
              }
            } else as.copy(t, s);
            return r;
          })(this.result, this.result, this.accumulatedWeight, t, e);
        }
        reset() {
          (this.accumulatedWeight = 0), as.identity(this.result);
        }
      }
      class U1 extends class {
        constructor() {
          (this._transformApplyFlags = 0), (this._properties = {});
        }
        get empty() {
          const { _properties: t } = this;
          return !(t.position || t.rotation || t.eulerAngles || t.scale);
        }
        refProperty(t, e) {
          var i, s;
          const { _properties: n } = this;
          let r;
          switch (e) {
            default:
            case "position":
            case "scale":
            case "eulerAngles":
              r =
                null !== (i = n[e]) && void 0 !== i
                  ? i
                  : (n[e] = this._createVec3BlendState(t[e]));
              break;
            case "rotation":
              r =
                null !== (s = n[e]) && void 0 !== s
                  ? s
                  : (n[e] = this._createQuatBlendState(t.rotation));
          }
          return ++r.refCount, r;
        }
        deRefProperty(t) {
          const { _properties: e } = this,
            i = e[t];
          i && (--i.refCount, i.refCount > 0 || delete e[t]);
        }
        apply(t) {
          const {
            _transformApplyFlags: e,
            _properties: { position: i, scale: s, rotation: n, eulerAngles: r },
          } = this;
          if (!e) return;
          let a, o, h;
          i && e & N1.POSITION && (a = i.result),
            s && e & N1.SCALE && (o = s.result),
            r && e & N1.EULER_ANGLES && (h = r.result),
            n && e & N1.ROTATION && (h = n.result),
            (h || a || o) && t.setRTS(h, a, o),
            (this._transformApplyFlags = 0);
        }
      } {
        apply(t) {
          const {
            _properties: { position: e, scale: i, rotation: s, eulerAngles: n },
          } = this;
          e &&
            e.accumulatedWeight &&
            ((this._transformApplyFlags |= N1.POSITION),
            e.accumulatedWeight < 1 &&
              e.blend(t.position, 1 - e.accumulatedWeight)),
            i &&
              i.accumulatedWeight &&
              ((this._transformApplyFlags |= N1.SCALE),
              i.accumulatedWeight < 1 &&
                i.blend(t.scale, 1 - i.accumulatedWeight)),
            n &&
              n.accumulatedWeight &&
              ((this._transformApplyFlags |= N1.EULER_ANGLES),
              n.accumulatedWeight < 1 &&
                n.blend(t.eulerAngles, 1 - n.accumulatedWeight)),
            s &&
              s.accumulatedWeight &&
              ((this._transformApplyFlags |= N1.ROTATION),
              s.accumulatedWeight < 1 &&
                s.blend(t.rotation, 1 - s.accumulatedWeight)),
            super.apply(t),
            null == e || e.reset(),
            null == i || i.reset(),
            null == s || s.reset(),
            null == n || n.reset();
        }
        _createVec3BlendState(t) {
          return new B1();
        }
        _createQuatBlendState(t) {
          return new F1();
        }
      }
      class k1 extends class {
        constructor() {
          this._nodeBlendStates = new Map();
        }
        createWriter(t, e, i, s) {
          const n = this.ref(t, e);
          return new L1(t, e, n, i, s);
        }
        destroyWriter(t) {
          const e = t;
          this.deRef(e.node, e.property);
        }
        ref(t, e) {
          let i = this._nodeBlendStates.get(t);
          return (
            i ||
              ((i = this.createNodeBlendState()),
              this._nodeBlendStates.set(t, i)),
            i.refProperty(t, e)
          );
        }
        deRef(t, e) {
          const i = this._nodeBlendStates.get(t);
          i && (i.deRefProperty(e), i.empty && this._nodeBlendStates.delete(t));
        }
        apply() {
          this._nodeBlendStates.forEach((t, e) => {
            t.apply(e);
          });
        }
      } {
        createNodeBlendState() {
          return new U1();
        }
      }
      const z1 = [],
        H1 = new Map();
      function G1(t, e) {
        let i = 0,
          s = ms.IDENTITY;
        for (; t; ) {
          if (t.stamp === e || (t.stamp + 1 === e && !t.node.hasChangedFlags)) {
            (s = t.world), (t.stamp = e);
            break;
          }
          (t.stamp = e), (z1[i++] = t), (t = t.parent);
        }
        for (; i > 0; ) {
          (t = z1[--i]), (z1[i] = null);
          const e = t.node;
          ms.fromRTS(t.local, e.rotation, e.position, e.scale),
            (s = ms.multiply(t.world, s, t.local));
        }
        return s;
      }
      function V1(t, e) {
        let i,
          s = null,
          n = 0;
        for (; t !== e; ) {
          const e = t.uuid;
          if (H1.has(e)) {
            s = H1.get(e);
            break;
          }
          (s = {
            node: t,
            local: new ms(),
            world: new ms(),
            stamp: -1,
            parent: null,
          }),
            H1.set(e, s),
            (z1[n++] = s),
            (t = t.parent),
            (s = null);
        }
        for (; n > 0; ) (i = z1[--n]), (z1[n] = null), (i.parent = s), (s = i);
        return s;
      }
      function j1(t) {
        let e = H1.get(t.uuid) || null;
        for (; e; ) H1.delete(e.node.uuid), (e = e.parent);
      }
      var W1, X1;
      let Y1 = t(
        "AnimationManager",
        Ca(
          (((X1 = class extends jl {
            constructor(...t) {
              super(...t),
                (this._anims = new Zt([])),
                (this._crossFades = new Zt([])),
                (this._delayEvents = []),
                (this._blendStateBuffer = new k1()),
                (this._sockets = []);
            }
            get blendState() {
              return this._blendStateBuffer;
            }
            addCrossFade(t) {
              -1 === this._crossFades.array.indexOf(t) &&
                this._crossFades.push(t);
            }
            removeCrossFade(t) {
              const e = this._crossFades.array.indexOf(t);
              e >= 0 ? this._crossFades.fastRemoveAt(e) : G(3907);
            }
            update(t) {
              const { _delayEvents: e, _crossFades: i, _sockets: s } = this;
              {
                const e = i.array;
                for (i.i = 0; i.i < e.length; ++i.i) e[i.i].update(t);
              }
              const n = this._anims,
                r = n.array;
              for (n.i = 0; n.i < r.length; ++n.i) {
                const e = r[n.i];
                e.isMotionless || e.update(t);
              }
              this._blendStateBuffer.apply();
              const a = Lv.getTotalFrames();
              for (let t = 0, e = s.length; t < e; t++) {
                const { target: e, transform: i } = s[t];
                e.matrix = G1(i, a);
              }
              for (let t = 0, i = e.length; t < i; t++) {
                const i = e[t];
                i.fn.apply(i.thisArg, i.args);
              }
              e.length = 0;
            }
            destruct() {}
            addAnimation(t) {
              -1 === this._anims.array.indexOf(t) && this._anims.push(t);
            }
            removeAnimation(t) {
              const e = this._anims.array.indexOf(t);
              e >= 0 ? this._anims.fastRemoveAt(e) : G(3907);
            }
            pushDelayEvent(t, e, i) {
              this._delayEvents.push({ fn: t, thisArg: e, args: i });
            }
            addSockets(t, e) {
              for (let i = 0; i < e.length; ++i) {
                const s = e[i];
                if (this._sockets.find((t) => t.target === s.target)) continue;
                const n = t.getChildByPath(s.path),
                  r = s.target && n && V1(n, t);
                r && this._sockets.push({ target: s.target, transform: r });
              }
            }
            removeSockets(t, e) {
              for (let t = 0; t < e.length; ++t) {
                const i = e[t];
                for (let t = 0; t < this._sockets.length; ++t) {
                  const e = this._sockets[t];
                  if (e.target === i.target) {
                    j1(e.transform.node),
                      (this._sockets[t] =
                        this._sockets[this._sockets.length - 1]),
                      this._sockets.length--;
                    break;
                  }
                }
              }
            }
          }).ID = "animation"),
          (W1 = X1))
        ) || W1
      );
      Lv.on(Nv.EVENT_INIT, () => {
        const t = new Y1();
        Lv.registerSystem(Y1.ID, t, jl.Priority.HIGH);
      }),
        (a.AnimationManager = Y1);
      class K1 extends fG {
        constructor(t) {
          super(),
            (this._managedStates = []),
            (this._fadings = []),
            (this._scheduled = !1),
            (this._scheduler = null != t ? t : EG());
        }
        update(t) {
          if (this.isMotionless) return;
          const e = this._managedStates,
            i = this._fadings;
          if (1 === e.length && 1 === i.length) {
            const t = e[0].state;
            t && (t.weight = 1);
          } else this._calculateWeights(t);
          1 === e.length && 1 === i.length && this._unscheduleThis();
        }
        crossFade(t, e) {
          var i;
          0 === this._managedStates.length && (e = 0), 0 === e && this.clear();
          let s = this._managedStates.find((e) => e.state === t);
          s
            ? null !== (i = s.state) &&
              void 0 !== i &&
              i.isMotionless &&
              s.state.play()
            : ((s = { state: t, reference: 0 }),
              t && t.play(),
              this._managedStates.push(s)),
            ++s.reference,
            this._fadings.unshift({ easeDuration: e, easeTime: 0, target: s }),
            this.isMotionless || this._scheduleThis();
        }
        clear() {
          for (let t = 0; t < this._managedStates.length; ++t) {
            const e = this._managedStates[t].state;
            e && e.stop();
          }
          (this._managedStates.length = 0), (this._fadings.length = 0);
        }
        onPlay() {
          super.onPlay(), this._scheduleThis();
        }
        onPause() {
          super.onPause();
          for (let t = 0; t < this._managedStates.length; ++t) {
            const e = this._managedStates[t].state;
            e && e.pause();
          }
          this._unscheduleThis();
        }
        onResume() {
          super.onResume();
          for (let t = 0; t < this._managedStates.length; ++t) {
            const e = this._managedStates[t].state;
            e && e.resume();
          }
          this._scheduleThis();
        }
        onStop() {
          super.onStop(), this.clear();
        }
        _calculateWeights(t) {
          const e = this._managedStates,
            i = this._fadings;
          for (let t = 0; t < e.length; ++t) {
            const i = e[t].state;
            i && (i.weight = 0);
          }
          let s = 1,
            n = i.length;
          for (let e = 0; e < i.length; ++e) {
            const r = i[e];
            r.easeTime += t;
            const a =
                0 === r.easeDuration ? 1 : Ei(r.easeTime / r.easeDuration),
              o = a * s;
            if (
              ((s *= 1 - a),
              r.target.state && (r.target.state.weight += o),
              r.easeTime >= r.easeDuration)
            ) {
              (n = e + 1), (r.easeTime = r.easeDuration);
              break;
            }
          }
          if (n !== i.length) {
            for (let t = n; t < i.length; ++t) {
              const e = i[t];
              --e.target.reference,
                e.target.reference <= 0 &&
                  (e.target.state && e.target.state.stop(),
                  te(this._managedStates, e.target));
            }
            i.splice(n);
          }
        }
        _scheduleThis() {
          this._scheduled ||
            (this._scheduler.addCrossFade(this), (this._scheduled = !0));
        }
        _unscheduleThis() {
          this._scheduled &&
            (this._scheduler.removeCrossFade(this), (this._scheduled = !1));
        }
      }
      var q1, $1, Z1, Q1, J1, t2, e2, i2, s2, n2, r2;
      let a2,
        o2,
        h2,
        l2 =
          ((q1 = Ca("cc.Animation")),
          ($1 = Ia(99)),
          (Z1 = ao([Jq])),
          (Q1 = ao(Jq)),
          (J1 = ao([Jq])),
          q1(
            (t2 =
              $1(
                (((r2 = class extends or(np) {
                  constructor(...t) {
                    super(...t),
                      (this.playOnLoad = i2 && i2()),
                      (this._crossFade = new K1()),
                      (this._nameToState = St(!0)),
                      (this._clips = s2 && s2()),
                      (this._defaultClip = n2 && n2()),
                      (this._hasBeenPlayed = !1);
                  }
                  get clips() {
                    return this._clips;
                  }
                  set clips(t) {
                    this._crossFade && this._crossFade.clear();
                    for (const t of this._clips)
                      t && this._removeStateOfAutomaticClip(t);
                    for (const e of t) e && this.createState(e);
                    const e = t.find((t) => c2(t, this._defaultClip));
                    (this._defaultClip = e || null), (this._clips = t);
                  }
                  get defaultClip() {
                    return this._defaultClip;
                  }
                  set defaultClip(t) {
                    (this._defaultClip = t),
                      t &&
                        (this._clips.findIndex((e) => c2(e, t)) >= 0 ||
                          (this._clips.push(t), this.createState(t)));
                  }
                  onLoad() {
                    this.clips = this._clips;
                    for (const t in this._nameToState)
                      this._nameToState[t].initialize(this.node);
                  }
                  start() {
                    this.playOnLoad &&
                      !this._hasBeenPlayed &&
                      this._defaultClip &&
                      this.crossFade(this._defaultClip.name, 0);
                  }
                  onEnable() {
                    this._crossFade.resume();
                  }
                  onDisable() {
                    this._crossFade.pause();
                  }
                  onDestroy() {
                    this._crossFade.stop();
                    for (const t in this._nameToState)
                      this._nameToState[t].destroy();
                    this._nameToState = St(!0);
                  }
                  play(t) {
                    if (((this._hasBeenPlayed = !0), !t)) {
                      if (!this._defaultClip) return;
                      t = this._defaultClip.name;
                    }
                    this.crossFade(t, 0);
                  }
                  crossFade(t, e = 0.3) {
                    this._hasBeenPlayed = !0;
                    const i = this._nameToState[t];
                    i && this.doPlayOrCrossFade(i, e);
                  }
                  pause() {
                    this._crossFade.pause();
                  }
                  resume() {
                    this._crossFade.resume();
                  }
                  stop() {
                    this._crossFade.stop();
                  }
                  getState(t) {
                    const e = this._nameToState[t];
                    return (
                      e && !e.curveLoaded && e.initialize(this.node), e || null
                    );
                  }
                  createState(t, e) {
                    return (
                      (e = e || t.name),
                      this.removeState(e),
                      this._doCreateState(t, e)
                    );
                  }
                  removeState(t) {
                    const e = this._nameToState[t];
                    e &&
                      (e.allowLastFrameEvent(!1),
                      e.stop(),
                      delete this._nameToState[t]);
                  }
                  addClip(t, e) {
                    return (
                      se(this._clips, t) || this._clips.push(t),
                      this.createState(t, e)
                    );
                  }
                  removeClip(t, e) {
                    let i;
                    for (const e in this._nameToState) {
                      const s = this._nameToState[e];
                      if (s.clip === t) {
                        i = s;
                        break;
                      }
                    }
                    if (t === this._defaultClip) {
                      if (!e) return void z(3902);
                      this._defaultClip = null;
                    }
                    if (i && i.isPlaying) {
                      if (!e) return void z(3903);
                      i.stop();
                    }
                    (this._clips = this._clips.filter((e) => e !== t)),
                      i && delete this._nameToState[i.name];
                  }
                  on(t, e, i, s) {
                    const n = super.on(t, e, i, s);
                    return (
                      t === yG.LASTFRAME && this._syncAllowLastFrameEvent(), n
                    );
                  }
                  once(t, e, i) {
                    const s = super.once(t, e, i);
                    return (
                      t === yG.LASTFRAME && this._syncAllowLastFrameEvent(), s
                    );
                  }
                  off(t, e, i) {
                    super.off(t, e, i),
                      t === yG.LASTFRAME && this._syncDisallowLastFrameEvent();
                  }
                  _createState(t, e) {
                    return new vG(t, e);
                  }
                  _doCreateState(t, e) {
                    const i = this._createState(t, e);
                    return (
                      i._setEventTarget(this),
                      i.allowLastFrameEvent(
                        this.hasEventListener(yG.LASTFRAME)
                      ),
                      this.node && i.initialize(this.node),
                      (this._nameToState[i.name] = i),
                      i
                    );
                  }
                  doPlayOrCrossFade(t, e) {
                    this._crossFade.play(), this._crossFade.crossFade(t, e);
                  }
                  _removeStateOfAutomaticClip(t) {
                    for (const e in this._nameToState) {
                      const i = this._nameToState[e];
                      c2(t, i.clip) && (i.stop(), delete this._nameToState[e]);
                    }
                  }
                  _syncAllowLastFrameEvent() {
                    if (this.hasEventListener(yG.LASTFRAME))
                      for (const t in this._nameToState)
                        this._nameToState[t].allowLastFrameEvent(!0);
                  }
                  _syncDisallowLastFrameEvent() {
                    if (!this.hasEventListener(yG.LASTFRAME))
                      for (const t in this._nameToState)
                        this._nameToState[t].allowLastFrameEvent(!1);
                  }
                }).EventType = yG),
                s(
                  (e2 = r2).prototype,
                  "clips",
                  [Z1],
                  Object.getOwnPropertyDescriptor(e2.prototype, "clips"),
                  e2.prototype
                ),
                s(
                  e2.prototype,
                  "defaultClip",
                  [Q1],
                  Object.getOwnPropertyDescriptor(e2.prototype, "defaultClip"),
                  e2.prototype
                ),
                (i2 = fa(e2.prototype, "playOnLoad", [Na], function () {
                  return !1;
                })),
                (s2 = fa(e2.prototype, "_clips", [J1], function () {
                  return [];
                })),
                (n2 = fa(e2.prototype, "_defaultClip", [Na], function () {
                  return null;
                })),
                (t2 = e2))
              ) || t2)
          ) || t2);
      function c2(t, e) {
        return t === e || (!!t && !!e && t._uuid === e._uuid && t._uuid);
      }
      t({ Animation: l2, AnimationComponent: l2 }),
        (a.Animation = l2),
        (a.AnimationComponent = l2),
        Vt(l2, "cc.AnimationComponent"),
        (function (t) {
          (t.PLAYED = "play"),
            (t.PAUSED = "pause"),
            (t.STOPPED = "stop"),
            (t.SEEKED = "seeked"),
            (t.ENDED = "ended"),
            (t.INTERRUPTION_BEGIN = "interruptionBegin"),
            (t.INTERRUPTION_END = "interruptionEnd"),
            (t.USER_GESTURE = "on_gesture");
        })(a2 || (a2 = {})),
        (function (t) {
          (t[(t.DOM_AUDIO = 0)] = "DOM_AUDIO"),
            (t[(t.WEB_AUDIO = 1)] = "WEB_AUDIO"),
            (t[(t.MINIGAME_AUDIO = 2)] = "MINIGAME_AUDIO"),
            (t[(t.NATIVE_AUDIO = 3)] = "NATIVE_AUDIO"),
            (t[(t.UNKNOWN_AUDIO = 4)] = "UNKNOWN_AUDIO");
        })(o2 || (o2 = {})),
        (function (t) {
          (t[(t.INIT = 0)] = "INIT"),
            (t[(t.PLAYING = 1)] = "PLAYING"),
            (t[(t.PAUSED = 2)] = "PAUSED"),
            (t[(t.STOPPED = 3)] = "STOPPED"),
            (t[(t.INTERRUPTED = 4)] = "INTERRUPTED");
        })(h2 || (h2 = {}));
      class u2 {
        constructor(...t) {
          if (
            ((this._bufferView = void 0),
            (this._normalizeFactor = 1),
            2 === t.length)
          )
            (this._bufferView = t[0]), (this._normalizeFactor = t[1]);
          else {
            const e = t[0],
              i = t[1],
              s = t[2];
            (this._bufferView = new i(e)), (this._normalizeFactor = s);
          }
        }
        get length() {
          return this._bufferView.length;
        }
        getData(t) {
          return this._bufferView[t] * this._normalizeFactor;
        }
      }
      t("AudioPCMDataView", u2);
      let _2 = 0;
      function d2(t, e) {
        e.invoking ||
          ((e.invoking = !0),
          e.func
            .call(t, ...e.args)
            .then(() => {
              (e.invoking = !1),
                t._operationQueue.shift(),
                t._eventTarget.emit(e.id.toString()),
                (function (t) {
                  const e = t._operationQueue.length,
                    i = t._operationQueue.slice(),
                    s = [];
                  let n = !1;
                  for (let t = e - 1; t >= 0; t--) {
                    const e = i[t];
                    if ("stop" === e.op) {
                      s.push(e);
                      break;
                    }
                    if ("seek" === e.op) n || (s.push(e), (n = !0));
                    else {
                      if (n) {
                        s.push(e);
                        break;
                      }
                      0 === s.length && s.push(e);
                    }
                  }
                  t._operationQueue = s.reverse();
                })(t);
              const i = t._operationQueue[0];
              i && d2(t, i);
            })
            .catch(() => {}));
      }
      function p2(t, e, i) {
        const s = i.value;
        i.value = function (...t) {
          return new Promise((i) => {
            const n = _2++,
              r = this;
            r._operationQueue.push({
              op: e,
              id: n,
              func: s,
              args: t,
              invoking: !1,
            }),
              r._eventTarget.once(n.toString(), i),
              d2(r, r._operationQueue[0]);
          });
        };
      }
      var m2, f2;
      const g2 = {},
        y2 = jsb.AudioEngine,
        T2 = -1;
      var S2;
      !(function (t) {
        (t[(t.UNKNOWN = 0)] = "UNKNOWN"),
          (t[(t.SIGNED_8 = 1)] = "SIGNED_8"),
          (t[(t.UNSIGNED_8 = 2)] = "UNSIGNED_8"),
          (t[(t.SIGNED_16 = 3)] = "SIGNED_16"),
          (t[(t.UNSIGNED_16 = 4)] = "UNSIGNED_16"),
          (t[(t.SIGNED_32 = 5)] = "SIGNED_32"),
          (t[(t.UNSIGNED_32 = 6)] = "UNSIGNED_32"),
          (t[(t.FLOAT_32 = 7)] = "FLOAT_32"),
          (t[(t.FLOAT_64 = 8)] = "FLOAT_64");
      })(S2 || (S2 = {}));
      const E2 = {
        [S2.UNKNOWN]: void 0,
        [S2.SIGNED_8]: { ctor: Int8Array, maxValue: 127 },
        [S2.UNSIGNED_8]: { ctor: Uint8Array, maxValue: 255 },
        [S2.SIGNED_16]: { ctor: Int16Array, maxValue: 32767 },
        [S2.UNSIGNED_16]: { ctor: Uint16Array, maxValue: 65535 },
        [S2.SIGNED_32]: { ctor: Int32Array, maxValue: 2147483647 },
        [S2.UNSIGNED_32]: { ctor: Uint32Array, maxValue: 4294967295 },
        [S2.FLOAT_32]: { ctor: Float32Array, maxValue: 1 },
        [S2.FLOAT_64]: { ctor: Float64Array, maxValue: 1 },
      };
      class v2 {
        get onPlay() {
          return this._onPlayCb;
        }
        set onPlay(t) {
          this._onPlayCb = t;
        }
        get onEnd() {
          return this._onEndCb;
        }
        set onEnd(t) {
          this._onEndCb = t;
        }
        constructor(t, e) {
          (this._id = T2),
            (this._url = void 0),
            (this._volume = void 0),
            (this._onPlayCb = void 0),
            (this._onEndCb = void 0),
            (this._url = t),
            (this._volume = e);
        }
        play() {
          var t;
          (this._id = jsb.AudioEngine.play2d(this._url, !1, this._volume)),
            jsb.AudioEngine.setFinishCallback(this._id, () => {
              var t;
              null === (t = this.onEnd) || void 0 === t || t.call(this);
            }),
            null === (t = this.onPlay) || void 0 === t || t.call(this);
        }
        stop() {
          this._id !== T2 && jsb.AudioEngine.stop(this._id);
        }
      }
      let b2 =
        (((f2 = class t {
          constructor(t) {
            (this._url = void 0),
              (this._id = T2),
              (this._state = h2.INIT),
              (this._pcmHeader = void 0),
              (this._eventTarget = new hr()),
              (this._operationQueue = []),
              (this._cachedState = {
                duration: 1,
                loop: !1,
                currentTime: 0,
                volume: 1,
              }),
              (this._url = t),
              (this._pcmHeader = null),
              YA.on(XA.EVENT_PAUSE, this._onInterruptedBegin, this),
              YA.on(XA.EVENT_RESUME, this._onInterruptedEnd, this);
          }
          destroy() {
            YA.off(XA.EVENT_PAUSE, this._onInterruptedBegin, this),
              YA.off(XA.EVENT_RESUME, this._onInterruptedEnd, this),
              --g2[this._url] <= 0 && y2.uncache(this._url);
          }
          _onInterruptedBegin() {
            this._state === h2.PLAYING &&
              this.pause()
                .then(() => {
                  (this._state = h2.INTERRUPTED),
                    this._eventTarget.emit(a2.INTERRUPTION_BEGIN);
                })
                .catch(() => {});
          }
          _onInterruptedEnd() {
            this._state === h2.INTERRUPTED &&
              this.play()
                .then(() => {
                  this._eventTarget.emit(a2.INTERRUPTION_END);
                })
                .catch(() => {});
          }
          static load(e, i) {
            return new Promise((s, n) => {
              t.loadNative(e, i)
                .then((e) => {
                  s(new t(e));
                })
                .catch((t) => n(t));
            });
          }
          static loadNative(t, e) {
            return new Promise((e, i) => {
              yr.platform === pr.WIN32
                ? (y2.preload(t, () => {
                    console.debug("somehow preload success on windows");
                  }),
                  e(t))
                : y2.preload(t, (s) => {
                    s ? e(t) : i(new Error("load audio failed"));
                  });
            });
          }
          static loadOneShotAudio(e, i, s) {
            return new Promise((n, r) => {
              t.loadNative(e, s)
                .then((t) => {
                  n(new v2(t, i));
                })
                .catch(r);
            });
          }
          get _isValid() {
            return this._id !== T2;
          }
          get src() {
            return this._url;
          }
          get type() {
            return o2.NATIVE_AUDIO;
          }
          get state() {
            return this._state;
          }
          get loop() {
            return this._isValid ? y2.isLoop(this._id) : this._cachedState.loop;
          }
          set loop(t) {
            this._isValid && y2.setLoop(this._id, t),
              (this._cachedState.loop = t);
          }
          get volume() {
            return this._isValid
              ? y2.getVolume(this._id)
              : this._cachedState.volume;
          }
          set volume(t) {
            (t = Ei(t)),
              this._isValid && y2.setVolume(this._id, t),
              (this._cachedState.volume = t);
          }
          get duration() {
            return this._isValid
              ? y2.getDuration(this._id)
              : this._cachedState.duration;
          }
          get currentTime() {
            return this._isValid
              ? y2.getCurrentTime(this._id)
              : this._cachedState.currentTime;
          }
          get sampleRate() {
            return (
              null === this._pcmHeader &&
                (this._pcmHeader = jsb.AudioEngine.getPCMHeader(this._url)),
              this._pcmHeader.sampleRate
            );
          }
          getPCMData(t) {
            const e = y2.getOriginalPCMBuffer(this._url, t);
            null === this._pcmHeader &&
              (this._pcmHeader = jsb.AudioEngine.getPCMHeader(this._url));
            const i = E2[this._pcmHeader.audioFormat];
            if (e && i) return new u2(e, i.ctor, 1 / i.maxValue);
          }
          seek(t) {
            return new Promise(
              (e) => (
                this._isValid && y2.setCurrentTime(this._id, t),
                (this._cachedState.currentTime = t),
                e()
              )
            );
          }
          play() {
            return new Promise((t) => {
              this._isValid
                ? this._state === h2.PAUSED || this._state === h2.INTERRUPTED
                  ? y2.resume(this._id)
                  : this._state === h2.PLAYING &&
                    (y2.pause(this._id),
                    y2.setCurrentTime(this._id, 0),
                    y2.resume(this._id))
                : ((this._id = y2.play2d(
                    this._url,
                    this._cachedState.loop,
                    this._cachedState.volume
                  )),
                  this._isValid &&
                    (0 !== this._cachedState.currentTime &&
                      (y2.setCurrentTime(
                        this._id,
                        this._cachedState.currentTime
                      ),
                      (this._cachedState.currentTime = 0)),
                    y2.setFinishCallback(this._id, () => {
                      (this._cachedState.currentTime = 0),
                        (this._id = T2),
                        (this._state = h2.INIT),
                        this._eventTarget.emit(a2.ENDED);
                    }))),
                (this._state = h2.PLAYING),
                t();
            });
          }
          pause() {
            return new Promise((t) => {
              this._isValid && y2.pause(this._id),
                (this._state = h2.PAUSED),
                t();
            });
          }
          stop() {
            return new Promise((t) => {
              this._isValid && y2.stop(this._id),
                (this._state = h2.STOPPED),
                (this._id = T2),
                (this._cachedState.currentTime = 0),
                t();
            });
          }
          onInterruptionBegin(t) {
            this._eventTarget.on(a2.INTERRUPTION_BEGIN, t);
          }
          offInterruptionBegin(t) {
            this._eventTarget.off(a2.INTERRUPTION_BEGIN, t);
          }
          onInterruptionEnd(t) {
            this._eventTarget.on(a2.INTERRUPTION_END, t);
          }
          offInterruptionEnd(t) {
            this._eventTarget.off(a2.INTERRUPTION_END, t);
          }
          onEnded(t) {
            this._eventTarget.on(a2.ENDED, t);
          }
          offEnded(t) {
            this._eventTarget.off(a2.ENDED, t);
          }
        }).maxAudioChannel = y2.getMaxAudioInstance()),
        s(
          (m2 = f2).prototype,
          "seek",
          [p2],
          Object.getOwnPropertyDescriptor(m2.prototype, "seek"),
          m2.prototype
        ),
        s(
          m2.prototype,
          "play",
          [p2],
          Object.getOwnPropertyDescriptor(m2.prototype, "play"),
          m2.prototype
        ),
        s(
          m2.prototype,
          "pause",
          [p2],
          Object.getOwnPropertyDescriptor(m2.prototype, "pause"),
          m2.prototype
        ),
        s(
          m2.prototype,
          "stop",
          [p2],
          Object.getOwnPropertyDescriptor(m2.prototype, "stop"),
          m2.prototype
        ),
        m2);
      var A2, C2, O2, I2;
      a.AudioPlayer = b2;
      let w2 = t(
        "AudioClip",
        Ca("cc.AudioClip")(
          (((I2 = class extends Ad {
            constructor(...t) {
              super(...t),
                (this._duration = O2 && O2()),
                (this._loadMode = o2.UNKNOWN_AUDIO),
                (this._meta = null),
                (this._player = null);
            }
            set duration(t) {
              this._duration = t;
            }
            destroy() {
              var t;
              const e = super.destroy();
              return (
                null === (t = this._player) || void 0 === t || t.destroy(),
                (this._player = null),
                this._meta && (this._meta.player = null),
                e
              );
            }
            set _nativeAsset(t) {
              (this._meta = t),
                t
                  ? ((this._loadMode = t.type), (this._player = t.player))
                  : ((this._meta = null),
                    (this._loadMode = o2.UNKNOWN_AUDIO),
                    (this._duration = 0));
            }
            get _nativeAsset() {
              return this._meta;
            }
            get _nativeDep() {
              return {
                uuid: this._uuid,
                audioLoadMode: this.loadMode,
                ext: this._native,
                __isNative__: !0,
              };
            }
            get loadMode() {
              return this._loadMode;
            }
            validate() {
              return !!this._meta;
            }
            getDuration() {
              return this._duration
                ? this._duration
                : this._meta
                ? this._meta.duration
                : 0;
            }
            get state() {
              return this._player ? this._player.state : h2.INIT;
            }
            getCurrentTime() {
              return this._player ? this._player.currentTime : 0;
            }
            getVolume() {
              return this._player ? this._player.volume : 0;
            }
            getLoop() {
              return !!this._player && this._player.loop;
            }
            setCurrentTime(t) {
              var e;
              null === (e = this._player) ||
                void 0 === e ||
                e.seek(t).catch(() => {});
            }
            setVolume(t) {
              this._player && (this._player.volume = t);
            }
            setLoop(t) {
              this._player && (this._player.loop = t);
            }
            play() {
              var t;
              null === (t = this._player) ||
                void 0 === t ||
                t.play().catch(() => {});
            }
            pause() {
              var t;
              null === (t = this._player) ||
                void 0 === t ||
                t.pause().catch(() => {});
            }
            stop() {
              var t;
              null === (t = this._player) ||
                void 0 === t ||
                t.stop().catch(() => {});
            }
            playOneShot(t = 1) {
              this._nativeAsset &&
                b2
                  .loadOneShotAudio(this._nativeAsset.url, t)
                  .then((t) => {
                    t.play();
                  })
                  .catch(() => {});
            }
          }).AudioType = o2),
          (O2 = fa((C2 = I2).prototype, "_duration", [Na], function () {
            return 0;
          })),
          s(
            C2.prototype,
            "_nativeDep",
            [oo],
            Object.getOwnPropertyDescriptor(C2.prototype, "_nativeDep"),
            C2.prototype
          ),
          (A2 = C2))
        ) || A2
      );
      function R2(t, e, i) {
        b2.load(t, { audioLoadMode: e.audioLoadMode })
          .then((e) => {
            const s = { player: e, url: t, duration: e.duration, type: e.type };
            i(null, s);
          })
          .catch((t) => {
            i(t);
          });
      }
      function D2(t, e, i, s) {
        const n = new w2();
        (n._nativeUrl = t),
          (n._nativeAsset = e),
          (n.duration = e.duration),
          s(null, n);
      }
      (a.AudioClip = w2),
        GE.register({ ".mp3": R2, ".ogg": R2, ".wav": R2, ".m4a": R2 }),
        ev.register({ ".mp3": D2, ".ogg": D2, ".wav": D2, ".m4a": D2 });
      const x2 = new (class {
        constructor() {
          (this._oneShotAudioInfoList = []), (this._audioPlayerInfoList = []);
        }
        _findIndex(t, e) {
          return t.findIndex((t) => t.audio === e);
        }
        _tryAddPlaying(t, e) {
          const i = this._findIndex(t, e);
          return i > -1
            ? ((t[i].playTime = performance.now()), !1)
            : (t.push({ audio: e, playTime: performance.now() }), !0);
        }
        addPlaying(t) {
          t instanceof b2
            ? this._tryAddPlaying(this._audioPlayerInfoList, t)
            : this._tryAddPlaying(this._oneShotAudioInfoList, t);
        }
        _tryRemovePlaying(t, e) {
          const i = this._findIndex(t, e);
          return -1 !== i && (Jt(t, i), !0);
        }
        removePlaying(t) {
          t instanceof b2
            ? this._tryRemovePlaying(this._audioPlayerInfoList, t)
            : this._tryRemovePlaying(this._oneShotAudioInfoList, t);
        }
        discardOnePlayingIfNeeded() {
          if (
            this._audioPlayerInfoList.length +
              this._oneShotAudioInfoList.length <
            b2.maxAudioChannel
          )
            return;
          let t;
          this._oneShotAudioInfoList.length > 0
            ? this._oneShotAudioInfoList.forEach((e) => {
                (!t || e.playTime < t.playTime) && (t = e);
              })
            : this._audioPlayerInfoList.forEach((e) => {
                e.audio.loop || (t && !(e.playTime < t.playTime)) || (t = e);
              }),
            t && (t.audio.stop(), this.removePlaying(t.audio));
        }
        pause() {
          this._oneShotAudioInfoList.forEach((t) => {
            t.audio.stop();
          }),
            this._audioPlayerInfoList.forEach((t) => {
              t.audio.pause().catch(() => {});
            });
        }
        resume() {
          this._audioPlayerInfoList.forEach((t) => {
            t.audio.play().catch(() => {});
          });
        }
      })();
      var M2, P2, N2, L2, B2, F2, U2, k2, z2, H2;
      const G2 = "audiosource-loaded";
      var V2, j2;
      !(function (t) {
        (t.STARTED = "started"), (t.ENDED = "ended");
      })(V2 || (V2 = {})),
        (function (t) {
          (t.PLAY = "play"),
            (t.STOP = "stop"),
            (t.PAUSE = "pause"),
            (t.SEEK = "seek");
        })(j2 || (j2 = {}));
      let W2 =
        ((M2 = Ca("cc.AudioSource")),
        (P2 = ao(w2)),
        (N2 = ao(w2)),
        M2(
          (((H2 = class t extends np {
            constructor(...t) {
              super(...t),
                (this._clip = F2 && F2()),
                (this._player = null),
                (this._hasRegisterListener = !1),
                (this._loop = U2 && U2()),
                (this._playOnAwake = k2 && k2()),
                (this._volume = z2 && z2()),
                (this._cachedCurrentTime = -1),
                (this._operationsBeforeLoading = []),
                (this._isLoaded = !1),
                (this._lastSetClip = null);
            }
            static get maxAudioChannel() {
              return b2.maxAudioChannel;
            }
            _resetPlayer() {
              this._player &&
                (x2.removePlaying(this._player),
                this._unregisterListener(),
                this._player.destroy(),
                (this._player = null));
            }
            set clip(t) {
              t !== this._clip && ((this._clip = t), this._syncPlayer());
            }
            get clip() {
              return this._clip;
            }
            _syncPlayer() {
              const t = this._clip;
              if (this._lastSetClip !== t)
                return t
                  ? void (t._nativeAsset
                      ? ((this._isLoaded = !1),
                        (this._lastSetClip = t),
                        (this._operationsBeforeLoading.length = 0),
                        b2
                          .load(t._nativeAsset.url, {
                            audioLoadMode: t.loadMode,
                          })
                          .then((e) => {
                            var i;
                            this._lastSetClip === t
                              ? ((this._isLoaded = !0),
                                this._resetPlayer(),
                                (this._player = e),
                                this._syncStates(),
                                null === (i = this.node) ||
                                  void 0 === i ||
                                  i.emit(G2))
                              : e.destroy();
                          })
                          .catch(() => {}))
                      : console.error("Invalid audio clip"))
                  : ((this._lastSetClip = null), void this._resetPlayer());
            }
            _registerListener() {
              if (!this._hasRegisterListener && this._player) {
                const t = this._player;
                t.onEnded(() => {
                  var e;
                  x2.removePlaying(t),
                    null === (e = this.node) ||
                      void 0 === e ||
                      e.emit(V2.ENDED, this);
                }),
                  t.onInterruptionBegin(() => {
                    x2.removePlaying(t);
                  }),
                  t.onInterruptionEnd(() => {
                    this._player === t && x2.addPlaying(t);
                  }),
                  (this._hasRegisterListener = !0);
              }
            }
            _unregisterListener() {
              this._player &&
                this._hasRegisterListener &&
                (this._player.offEnded(),
                this._player.offInterruptionBegin(),
                this._player.offInterruptionEnd(),
                (this._hasRegisterListener = !1));
            }
            set loop(t) {
              (this._loop = t), this._player && (this._player.loop = t);
            }
            get loop() {
              return this._loop;
            }
            set playOnAwake(t) {
              this._playOnAwake = t;
            }
            get playOnAwake() {
              return this._playOnAwake;
            }
            set volume(t) {
              Number.isNaN(t)
                ? w("illegal audio volume!")
                : ((t = Si(t, 0, 1)),
                  this._player
                    ? ((this._player.volume = t),
                      (this._volume = this._player.volume))
                    : (this._volume = t));
            }
            get volume() {
              return this._volume;
            }
            onLoad() {
              this._syncPlayer();
            }
            onEnable() {
              this._playOnAwake && !this.playing && this.play();
            }
            onDisable() {
              const t = this._getRootNode();
              (null != t && t._persistNode) || this.pause();
            }
            onDestroy() {
              this.stop(), (this.clip = null);
            }
            getPCMData(t) {
              return new Promise((e) => {
                if (0 !== t && 1 !== t)
                  return (
                    w("Only support channel index 0 or 1 to get buffer"),
                    void e(void 0)
                  );
                var i;
                this._player
                  ? e(this._player.getPCMData(t))
                  : null === (i = this.node) ||
                    void 0 === i ||
                    i.once(G2, () => {
                      var i;
                      e(
                        null === (i = this._player) || void 0 === i
                          ? void 0
                          : i.getPCMData(t)
                      );
                    });
              });
            }
            getSampleRate() {
              return new Promise((t) => {
                var e;
                this._player
                  ? t(this._player.sampleRate)
                  : null === (e = this.node) ||
                    void 0 === e ||
                    e.once(G2, () => {
                      t(this._player.sampleRate);
                    });
              });
            }
            _getRootNode() {
              var t, e;
              let i = this.node,
                s =
                  null === (t = i) ||
                  void 0 === t ||
                  null === (e = t.parent) ||
                  void 0 === e
                    ? void 0
                    : e.parent;
              for (; s; ) {
                var n, r, a;
                (i = null === (n = i) || void 0 === n ? void 0 : n.parent),
                  (s =
                    null === (r = i) ||
                    void 0 === r ||
                    null === (a = r.parent) ||
                    void 0 === a
                      ? void 0
                      : a.parent);
              }
              return i;
            }
            play() {
              if (!this._isLoaded && this.clip)
                return void this._operationsBeforeLoading.push({
                  op: j2.PLAY,
                  params: null,
                });
              var t;
              this._registerListener(),
                this.state === h2.PLAYING &&
                  (null === (t = this._player) ||
                    void 0 === t ||
                    t.stop().catch(() => {}));
              const e = this._player;
              e &&
                (e
                  .play()
                  .then(() => {
                    var t;
                    null === (t = this.node) ||
                      void 0 === t ||
                      t.emit(V2.STARTED, this);
                  })
                  .catch(() => {
                    x2.removePlaying(e);
                  }),
                x2.addPlaying(e));
            }
            pause() {
              var t;
              this._isLoaded || !this.clip
                ? null === (t = this._player) ||
                  void 0 === t ||
                  t.pause().catch(() => {})
                : this._operationsBeforeLoading.push({
                    op: j2.PAUSE,
                    params: null,
                  });
            }
            stop() {
              this._isLoaded || !this.clip
                ? this._player &&
                  (this._player.stop().catch(() => {}),
                  x2.removePlaying(this._player))
                : this._operationsBeforeLoading.push({
                    op: j2.STOP,
                    params: null,
                  });
            }
            playOneShot(t, e = 1) {
              if (!t._nativeAsset)
                return void console.error("Invalid audio clip");
              let i;
              b2.loadOneShotAudio(t._nativeAsset.url, this._volume * e, {
                audioLoadMode: t.loadMode,
              })
                .then((t) => {
                  (i = t),
                    (t.onEnd = () => {
                      var e;
                      x2.removePlaying(t),
                        null === (e = this.node) ||
                          void 0 === e ||
                          e.emit(V2.ENDED, this);
                    }),
                    t.play(),
                    x2.addPlaying(t);
                })
                .catch(() => {
                  i && x2.removePlaying(i);
                });
            }
            _syncStates() {
              this._player &&
                ((this._player.loop = this._loop),
                (this._player.volume = this._volume),
                this._operationsBeforeLoading.forEach((t) => {
                  var e;
                  t.op === j2.SEEK
                    ? ((this._cachedCurrentTime = t.params && t.params[0]),
                      this._player &&
                        this._player
                          .seek(this._cachedCurrentTime)
                          .catch(() => {}))
                    : null === (e = this[t.op]) || void 0 === e || e.call(this);
                }),
                (this._operationsBeforeLoading.length = 0));
            }
            set currentTime(t) {
              var e;
              Number.isNaN(t)
                ? w("illegal audio time!")
                : ((t = Si(t, 0, this.duration)),
                  this._isLoaded || !this.clip
                    ? ((this._cachedCurrentTime = t),
                      null === (e = this._player) ||
                        void 0 === e ||
                        e.seek(this._cachedCurrentTime).catch(() => {}))
                    : this._operationsBeforeLoading.push({
                        op: j2.SEEK,
                        params: [t],
                      }));
            }
            get currentTime() {
              return this._player
                ? this._player.currentTime
                : this._cachedCurrentTime < 0
                ? 0
                : this._cachedCurrentTime;
            }
            get duration() {
              var t, e;
              return null !==
                (t =
                  null === (e = this._clip) || void 0 === e
                    ? void 0
                    : e.getDuration()) && void 0 !== t
                ? t
                : this._player
                ? this._player.duration
                : 0;
            }
            get state() {
              return this._player ? this._player.state : h2.INIT;
            }
            get playing() {
              return this.state === t.AudioState.PLAYING;
            }
          }).AudioState = h2),
          (H2.EventType = V2),
          (F2 = fa((B2 = H2).prototype, "_clip", [P2], function () {
            return null;
          })),
          (U2 = fa(B2.prototype, "_loop", [Na], function () {
            return !1;
          })),
          (k2 = fa(B2.prototype, "_playOnAwake", [Na], function () {
            return !0;
          })),
          (z2 = fa(B2.prototype, "_volume", [Na], function () {
            return 1;
          })),
          s(
            B2.prototype,
            "clip",
            [N2],
            Object.getOwnPropertyDescriptor(B2.prototype, "clip"),
            B2.prototype
          ),
          (L2 = B2))
        ) || L2);
      t({ AudioSource: W2, AudioSourceComponent: W2 }),
        $(w2, "AudioClip", [
          {
            name: "PlayingState",
            newName: "AudioState",
            target: W2,
            targetName: "AudioSource",
          },
        ]),
        Q(
          w2.prototype,
          "AudioClip.prototype",
          [
            "state",
            "play",
            "pause",
            "stop",
            "playOneShot",
            "setCurrentTime",
            "setVolume",
            "setLoop",
            "getCurrentTime",
            "getVolume",
            "getLoop",
          ].map((t) => ({
            name: t,
            suggest: `please use AudioSource.prototype.${t} instead`,
          }))
        ),
        (a.AudioSourceComponent = W2),
        Vt(W2, "cc.AudioSourceComponent"),
        (a.log = I),
        (a.warn = w),
        (a.error = R),
        (a.assert = D),
        (a._throw = P),
        (a.logID = B),
        (a.warnID = z),
        (a.errorID = G),
        (a.assertID = j),
        (a.debug = q),
        (a.path = {
          join: vr,
          extname: br,
          mainFileName: Ar,
          basename: Cr,
          dirname: Or,
          changeExtname: Ir,
          changeBasename: wr,
          _normalize: Rr,
          stripSep: Dr,
          get sep() {
            return Mr();
          },
        });
      class X2 {
        constructor(t) {
          (this._pool = []), (this.poolHandlerComp = t);
        }
        size() {
          return this._pool.length;
        }
        clear() {
          const t = this._pool.length;
          for (let e = 0; e < t; ++e) this._pool[e].destroy();
          this._pool.length = 0;
        }
        put(t) {
          if (t && -1 === this._pool.indexOf(t)) {
            t.removeFromParent();
            const e = this.poolHandlerComp
              ? t.getComponent(this.poolHandlerComp)
              : null;
            e && e.unuse && e.unuse(), this._pool.push(t);
          }
        }
        get(...t) {
          const e = this._pool.length - 1;
          if (e < 0) return null;
          {
            const t = this._pool[e];
            this._pool.length = e;
            const i = this.poolHandlerComp
              ? t.getComponent(this.poolHandlerComp)
              : null;
            return i && i.reuse && i.reuse(arguments), t;
          }
        }
      }
      var Y2, K2;
      t("NodePool", X2), (a.NodePool = X2);
      const q2 = null !== (Y2 = globalThis.jsb) && void 0 !== Y2 ? Y2 : {};
      {
        Object.defineProperty(q2, "reflection", {
          get: () => (
            void 0 !== q2.__bridge ||
              (!globalThis.JavascriptJavaBridge ||
              (zr.os !== zr.OS.ANDROID && zr.os !== zr.OS.OHOS)
                ? !globalThis.JavaScriptObjCBridge ||
                  (zr.os !== zr.OS.IOS && zr.os !== zr.OS.OSX)
                  ? (q2.__bridge = null)
                  : (q2.__bridge = new globalThis.JavaScriptObjCBridge())
                : (q2.__bridge = new globalThis.JavascriptJavaBridge())),
            q2.__bridge
          ),
          enumerable: !0,
          configurable: !0,
          set(t) {
            q2.__bridge = t;
          },
        }),
          Object.defineProperty(q2, "bridge", {
            get: () => (
              void 0 !== q2.__ccbridge ||
                ((globalThis.ScriptNativeBridge && zr.os === zr.OS.ANDROID) ||
                zr.os === zr.OS.IOS ||
                zr.os === zr.OS.OSX ||
                zr.os === zr.OS.OHOS
                  ? (q2.__ccbridge = new ScriptNativeBridge())
                  : (q2.__ccbridge = null)),
              q2.__ccbridge
            ),
            enumerable: !0,
            configurable: !0,
            set(t) {
              q2.__ccbridge = t;
            },
          });
        const t = {
          eventMap: new Map(),
          addNativeEventListener(t, e) {
            this.eventMap.get(t) || this.eventMap.set(t, []);
            const i = this.eventMap.get(t);
            i.find(e) || i.push(e);
          },
          dispatchEventToNative(t, e) {
            q2.bridge.sendToNative(t, e);
          },
          removeAllListenersForEvent(t) {
            return this.eventMap.delete(t);
          },
          removeNativeEventListener(t, e) {
            const i = this.eventMap.get(t);
            if (!i) return !1;
            for (let t = 0, s = i.length; t < s; t++)
              if (i[t] === e) return i.splice(t, 1), !0;
            return !0;
          },
          removeAllListeners() {
            this.eventMap.clear();
          },
          triggerEvent(t, e) {
            const i = this.eventMap.get(t);
            i
              ? i.map((t) => t.call(null, e))
              : console.error(`${t} does not exist`);
          },
        };
        Object.defineProperty(q2, "jsbBridgeWrapper", {
          get: () => (
            void 0 !== q2.__JsbBridgeWrapper ||
              ((globalThis.ScriptNativeBridge && zr.os === zr.OS.ANDROID) ||
              zr.os === zr.OS.IOS ||
              zr.os === zr.OS.OSX ||
              zr.os === zr.OS.OHOS
                ? ((q2.__JsbBridgeWrapper = t),
                  (q2.bridge.onNative = (t, e) => {
                    q2.__JsbBridgeWrapper.triggerEvent(t, e);
                  }))
                : (q2.__JsbBridgeWrapper = null)),
            q2.__JsbBridgeWrapper
          ),
          enumerable: !0,
          configurable: !0,
          set(t) {
            q2.__JsbBridgeWrapper = t;
          },
        });
        const e = q2.saveImageData;
        (q2.saveImageData = (t, i, s, n) =>
          new Promise((r, a) => {
            e(t, i, s, n, (t) => {
              t ? r() : a();
            });
          })),
          Object.defineProperty(q2, "cppbridge", {
            get: () => (
              void 0 !== q2.__cppbridge ||
                (globalThis.JavaScriptCPPBridge && zr.os === zr.OS.WINDOWS
                  ? (q2.__cppbridge = new JavaScriptCPPBridge())
                  : (q2.__cppbridge = null)),
              q2.__cppbridge
            ),
            enumerable: !0,
            configurable: !0,
            set(t) {
              q2.__cppbridge = t;
            },
          });
      }
      const $2 = t("native", {
        DownloaderHints: q2.DownloaderHints,
        Downloader: q2.Downloader,
        zipUtils: q2.zipUtils,
        fileUtils: q2.fileUtils,
        DebugRenderer: q2.DebugRenderer,
        copyTextToClipboard:
          null === (K2 = q2.copyTextToClipboard) || void 0 === K2
            ? void 0
            : K2.bind(q2),
        garbageCollect: q2.garbageCollect,
        reflection: q2.reflection,
        bridge: q2.bridge,
        cppbridge: q2.cppbridge,
        jsbBridgeWrapper: q2.jsbBridgeWrapper,
        AssetsManager: q2.AssetsManager,
        EventAssetsManager: q2.EventAssetsManager,
        Manifest: q2.Manifest,
        saveImageData: q2.saveImageData,
        process: q2.process,
        adpf: q2.adpf,
      });
      a.renderer = GR;
      var Z2 = Object.setPrototypeOf;
      let Q2 = {};
      Q2 || (Q2 = {}),
        (function (t) {
          var e = (function () {
            function e(i) {
              (this._clock = new t.WorldClock()),
                (this._events = []),
                (this._objects = []),
                (this._eventManager = null),
                (this._eventManager = i),
                console.info(
                  "DragonBones: " +
                    e.VERSION +
                    "\nWebsite: http://dragonbones.com/\nSource and Demo: https://github.com/DragonBones/"
                );
            }
            return (
              (e.prototype.advanceTime = function (e) {
                if (this._objects.length > 0) {
                  for (var i = 0, s = this._objects; i < s.length; i++)
                    s[i].returnToPool();
                  this._objects.length = 0;
                }
                if ((this._clock.advanceTime(e), this._events.length > 0)) {
                  for (var n = 0; n < this._events.length; ++n) {
                    var r = this._events[n],
                      a = r.armature;
                    null !== a._armatureData &&
                      (a.eventDispatcher.dispatchDBEvent(r.type, r),
                      r.type === t.EventObject.SOUND_EVENT &&
                        this._eventManager.dispatchDBEvent(r.type, r)),
                      this.bufferObject(r);
                  }
                  this._events.length = 0;
                }
              }),
              (e.prototype.bufferEvent = function (t) {
                this._events.indexOf(t) < 0 && this._events.push(t);
              }),
              (e.prototype.bufferObject = function (t) {
                this._objects.indexOf(t) < 0 && this._objects.push(t);
              }),
              Object.defineProperty(e.prototype, "clock", {
                get: function () {
                  return this._clock;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(e.prototype, "eventManager", {
                get: function () {
                  return this._eventManager;
                },
                enumerable: !0,
                configurable: !0,
              }),
              (e.VERSION = "5.6.300"),
              (e.yDown = !1),
              (e.debug = !1),
              (e.debugDraw = !1),
              (e.webAssembly = !1),
              e
            );
          })();
          t.DragonBones = e;
        })(Q2 || (Q2 = {})),
        console.warn || (console.warn = function () {}),
        console.assert || (console.assert = function () {}),
        Date.now ||
          (Date.now = function () {
            return new Date().getTime();
          }),
        (Z2 = function (t, e) {
          function i() {
            this.constructor = t;
          }
          for (var s in e) e.hasOwnProperty(s) && (t[s] = e[s]);
          (i.prototype = e.prototype), (t.prototype = new i());
        }),
        (function (t) {
          var e = (function () {
            function t() {
              (this.hashCode = t._hashCode++), (this._isInPool = !1);
            }
            return (
              (t._returnObject = function (e) {
                var i = String(e.constructor),
                  s =
                    i in t._maxCountMap
                      ? t._maxCountMap[i]
                      : t._defaultMaxCount,
                  n = (t._poolsMap[i] = t._poolsMap[i] || []);
                n.length < s &&
                  (e._isInPool
                    ? console.warn("The object is already in the pool.")
                    : ((e._isInPool = !0), n.push(e)));
              }),
              (t.toString = function () {
                throw new Error();
              }),
              (t.setMaxCount = function (e, i) {
                if (((i < 0 || i != i) && (i = 0), null !== e))
                  null !==
                    (n =
                      (s = String(e)) in t._poolsMap ? t._poolsMap[s] : null) &&
                    n.length > i &&
                    (n.length = i),
                    (t._maxCountMap[s] = i);
                else
                  for (var s in ((t._defaultMaxCount = i), t._poolsMap)) {
                    var n;
                    (n = t._poolsMap[s]).length > i && (n.length = i),
                      s in t._maxCountMap && (t._maxCountMap[s] = i);
                  }
              }),
              (t.clearPool = function (e) {
                if ((void 0 === e && (e = null), null !== e)) {
                  var i = String(e);
                  null !== (n = i in t._poolsMap ? t._poolsMap[i] : null) &&
                    n.length > 0 &&
                    (n.length = 0);
                } else
                  for (var s in t._poolsMap) {
                    var n;
                    (n = t._poolsMap[s]).length = 0;
                  }
              }),
              (t.borrowObject = function (e) {
                var i = String(e),
                  s = i in t._poolsMap ? t._poolsMap[i] : null;
                if (null !== s && s.length > 0) {
                  var n = s.pop();
                  return (n._isInPool = !1), n;
                }
                var r = new e();
                return r._onClear(), r;
              }),
              (t.prototype.returnToPool = function () {
                this._onClear(), t._returnObject(this);
              }),
              (t._hashCode = 0),
              (t._defaultMaxCount = 3e3),
              (t._maxCountMap = {}),
              (t._poolsMap = {}),
              t
            );
          })();
          t.BaseObject = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function () {
            function t(t, e, i, s, n, r) {
              void 0 === t && (t = 1),
                void 0 === e && (e = 0),
                void 0 === i && (i = 0),
                void 0 === s && (s = 1),
                void 0 === n && (n = 0),
                void 0 === r && (r = 0),
                (this.a = t),
                (this.b = e),
                (this.c = i),
                (this.d = s),
                (this.tx = n),
                (this.ty = r);
            }
            return (
              (t.prototype.toString = function () {
                return (
                  "[object dragonBones.Matrix] a:" +
                  this.a +
                  " b:" +
                  this.b +
                  " c:" +
                  this.c +
                  " d:" +
                  this.d +
                  " tx:" +
                  this.tx +
                  " ty:" +
                  this.ty
                );
              }),
              (t.prototype.copyFrom = function (t) {
                return (
                  (this.a = t.a),
                  (this.b = t.b),
                  (this.c = t.c),
                  (this.d = t.d),
                  (this.tx = t.tx),
                  (this.ty = t.ty),
                  this
                );
              }),
              (t.prototype.copyFromArray = function (t, e) {
                return (
                  void 0 === e && (e = 0),
                  (this.a = t[e]),
                  (this.b = t[e + 1]),
                  (this.c = t[e + 2]),
                  (this.d = t[e + 3]),
                  (this.tx = t[e + 4]),
                  (this.ty = t[e + 5]),
                  this
                );
              }),
              (t.prototype.identity = function () {
                return (
                  (this.a = this.d = 1),
                  (this.b = this.c = 0),
                  (this.tx = this.ty = 0),
                  this
                );
              }),
              (t.prototype.concat = function (t) {
                var e = this.a * t.a,
                  i = 0,
                  s = 0,
                  n = this.d * t.d,
                  r = this.tx * t.a + t.tx,
                  a = this.ty * t.d + t.ty;
                return (
                  (0 === this.b && 0 === this.c) ||
                    ((e += this.b * t.c),
                    (i += this.b * t.d),
                    (s += this.c * t.a),
                    (n += this.c * t.b)),
                  (0 === t.b && 0 === t.c) ||
                    ((i += this.a * t.b),
                    (s += this.d * t.c),
                    (r += this.ty * t.c),
                    (a += this.tx * t.b)),
                  (this.a = e),
                  (this.b = i),
                  (this.c = s),
                  (this.d = n),
                  (this.tx = r),
                  (this.ty = a),
                  this
                );
              }),
              (t.prototype.invert = function () {
                var t = this.a,
                  e = this.b,
                  i = this.c,
                  s = this.d,
                  n = this.tx,
                  r = this.ty;
                if (0 === e && 0 === i)
                  return (
                    (this.b = this.c = 0),
                    0 === t || 0 === s
                      ? (this.a = this.b = this.tx = this.ty = 0)
                      : ((t = this.a = 1 / t),
                        (s = this.d = 1 / s),
                        (this.tx = -t * n),
                        (this.ty = -s * r)),
                    this
                  );
                var a = t * s - e * i;
                if (0 === a)
                  return (
                    (this.a = this.d = 1),
                    (this.b = this.c = 0),
                    (this.tx = this.ty = 0),
                    this
                  );
                a = 1 / a;
                var o = (this.a = s * a);
                return (
                  (e = this.b = -e * a),
                  (i = this.c = -i * a),
                  (s = this.d = t * a),
                  (this.tx = -(o * n + i * r)),
                  (this.ty = -(e * n + s * r)),
                  this
                );
              }),
              (t.prototype.transformPoint = function (t, e, i, s) {
                void 0 === s && (s = !1),
                  (i.x = this.a * t + this.c * e),
                  (i.y = this.b * t + this.d * e),
                  s || ((i.x += this.tx), (i.y += this.ty));
              }),
              (t.prototype.transformRectangle = function (t, e) {
                void 0 === e && (e = !1);
                var i = this.a,
                  s = this.b,
                  n = this.c,
                  r = this.d,
                  a = e ? 0 : this.tx,
                  o = e ? 0 : this.ty,
                  h = t.x,
                  l = t.y,
                  c = h + t.width,
                  u = l + t.height,
                  _ = i * h + n * l + a,
                  d = s * h + r * l + o,
                  p = i * c + n * l + a,
                  m = s * c + r * l + o,
                  f = i * c + n * u + a,
                  g = s * c + r * u + o,
                  y = i * h + n * u + a,
                  T = s * h + r * u + o,
                  S = 0;
                _ > p && ((S = _), (_ = p), (p = S)),
                  f > y && ((S = f), (f = y), (y = S)),
                  (t.x = Math.floor(_ < f ? _ : f)),
                  (t.width = Math.ceil((p > y ? p : y) - t.x)),
                  d > m && ((S = d), (d = m), (m = S)),
                  g > T && ((S = g), (g = T), (T = S)),
                  (t.y = Math.floor(d < g ? d : g)),
                  (t.height = Math.ceil((m > T ? m : T) - t.y));
              }),
              t
            );
          })();
          t.Matrix = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function () {
            function t(t, e, i, s, n, r) {
              void 0 === t && (t = 0),
                void 0 === e && (e = 0),
                void 0 === i && (i = 0),
                void 0 === s && (s = 0),
                void 0 === n && (n = 1),
                void 0 === r && (r = 1),
                (this.x = t),
                (this.y = e),
                (this.skew = i),
                (this.rotation = s),
                (this.scaleX = n),
                (this.scaleY = r);
            }
            return (
              (t.normalizeRadian = function (t) {
                return (
                  (t = (t + Math.PI) % (2 * Math.PI)) +
                  (t > 0 ? -Math.PI : Math.PI)
                );
              }),
              (t.prototype.toString = function () {
                return (
                  "[object dragonBones.Transform] x:" +
                  this.x +
                  " y:" +
                  this.y +
                  " skewX:" +
                  (180 * this.skew) / Math.PI +
                  " skewY:" +
                  (180 * this.rotation) / Math.PI +
                  " scaleX:" +
                  this.scaleX +
                  " scaleY:" +
                  this.scaleY
                );
              }),
              (t.prototype.copyFrom = function (t) {
                return (
                  (this.x = t.x),
                  (this.y = t.y),
                  (this.skew = t.skew),
                  (this.rotation = t.rotation),
                  (this.scaleX = t.scaleX),
                  (this.scaleY = t.scaleY),
                  this
                );
              }),
              (t.prototype.identity = function () {
                return (
                  (this.x = this.y = 0),
                  (this.skew = this.rotation = 0),
                  (this.scaleX = this.scaleY = 1),
                  this
                );
              }),
              (t.prototype.add = function (t) {
                return (
                  (this.x += t.x),
                  (this.y += t.y),
                  (this.skew += t.skew),
                  (this.rotation += t.rotation),
                  (this.scaleX *= t.scaleX),
                  (this.scaleY *= t.scaleY),
                  this
                );
              }),
              (t.prototype.minus = function (t) {
                return (
                  (this.x -= t.x),
                  (this.y -= t.y),
                  (this.skew -= t.skew),
                  (this.rotation -= t.rotation),
                  (this.scaleX /= t.scaleX),
                  (this.scaleY /= t.scaleY),
                  this
                );
              }),
              (t.prototype.fromMatrix = function (e) {
                var i = this.scaleX,
                  s = this.scaleY,
                  n = t.PI_Q;
                (this.x = e.tx),
                  (this.y = e.ty),
                  (this.rotation = Math.atan(e.b / e.a));
                var r = Math.atan(-e.c / e.d);
                return (
                  (this.scaleX =
                    this.rotation > -n && this.rotation < n
                      ? e.a / Math.cos(this.rotation)
                      : e.b / Math.sin(this.rotation)),
                  (this.scaleY =
                    r > -n && r < n ? e.d / Math.cos(r) : -e.c / Math.sin(r)),
                  i >= 0 &&
                    this.scaleX < 0 &&
                    ((this.scaleX = -this.scaleX),
                    (this.rotation = this.rotation - Math.PI)),
                  s >= 0 &&
                    this.scaleY < 0 &&
                    ((this.scaleY = -this.scaleY), (r -= Math.PI)),
                  (this.skew = r - this.rotation),
                  this
                );
              }),
              (t.prototype.toMatrix = function (t) {
                return (
                  0 === this.rotation
                    ? ((t.a = 1), (t.b = 0))
                    : ((t.a = Math.cos(this.rotation)),
                      (t.b = Math.sin(this.rotation))),
                  0 === this.skew
                    ? ((t.c = -t.b), (t.d = t.a))
                    : ((t.c = -Math.sin(this.skew + this.rotation)),
                      (t.d = Math.cos(this.skew + this.rotation))),
                  1 !== this.scaleX &&
                    ((t.a *= this.scaleX), (t.b *= this.scaleX)),
                  1 !== this.scaleY &&
                    ((t.c *= this.scaleY), (t.d *= this.scaleY)),
                  (t.tx = this.x),
                  (t.ty = this.y),
                  this
                );
              }),
              (t.PI = Math.PI),
              (t.PI_D = 2 * Math.PI),
              (t.PI_H = Math.PI / 2),
              (t.PI_Q = Math.PI / 4),
              (t.RAD_DEG = 180 / Math.PI),
              (t.DEG_RAD = Math.PI / 180),
              t
            );
          })();
          t.Transform = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function () {
            function t(t, e, i, s, n, r, a, o) {
              void 0 === t && (t = 1),
                void 0 === e && (e = 1),
                void 0 === i && (i = 1),
                void 0 === s && (s = 1),
                void 0 === n && (n = 0),
                void 0 === r && (r = 0),
                void 0 === a && (a = 0),
                void 0 === o && (o = 0),
                (this.alphaMultiplier = t),
                (this.redMultiplier = e),
                (this.greenMultiplier = i),
                (this.blueMultiplier = s),
                (this.alphaOffset = n),
                (this.redOffset = r),
                (this.greenOffset = a),
                (this.blueOffset = o);
            }
            return (
              (t.prototype.copyFrom = function (t) {
                (this.alphaMultiplier = t.alphaMultiplier),
                  (this.redMultiplier = t.redMultiplier),
                  (this.greenMultiplier = t.greenMultiplier),
                  (this.blueMultiplier = t.blueMultiplier),
                  (this.alphaOffset = t.alphaOffset),
                  (this.redOffset = t.redOffset),
                  (this.greenOffset = t.greenOffset),
                  (this.blueOffset = t.blueOffset);
              }),
              (t.prototype.identity = function () {
                (this.alphaMultiplier =
                  this.redMultiplier =
                  this.greenMultiplier =
                  this.blueMultiplier =
                    1),
                  (this.alphaOffset =
                    this.redOffset =
                    this.greenOffset =
                    this.blueOffset =
                      0);
              }),
              t
            );
          })();
          t.ColorTransform = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function () {
            function t(t, e) {
              void 0 === t && (t = 0),
                void 0 === e && (e = 0),
                (this.x = t),
                (this.y = e);
            }
            return (
              (t.prototype.copyFrom = function (t) {
                (this.x = t.x), (this.y = t.y);
              }),
              (t.prototype.clear = function () {
                this.x = this.y = 0;
              }),
              t
            );
          })();
          t.Point = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function () {
            function t(t, e, i, s) {
              void 0 === t && (t = 0),
                void 0 === e && (e = 0),
                void 0 === i && (i = 0),
                void 0 === s && (s = 0),
                (this.x = t),
                (this.y = e),
                (this.width = i),
                (this.height = s);
            }
            return (
              (t.prototype.copyFrom = function (t) {
                (this.x = t.x),
                  (this.y = t.y),
                  (this.width = t.width),
                  (this.height = t.height);
              }),
              (t.prototype.clear = function () {
                (this.x = this.y = 0), (this.width = this.height = 0);
              }),
              t
            );
          })();
          t.Rectangle = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (e.ints = []), (e.floats = []), (e.strings = []), e;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.UserData]";
              }),
              (e.prototype._onClear = function () {
                (this.ints.length = 0),
                  (this.floats.length = 0),
                  (this.strings.length = 0);
              }),
              (e.prototype.addInt = function (t) {
                this.ints.push(t);
              }),
              (e.prototype.addFloat = function (t) {
                this.floats.push(t);
              }),
              (e.prototype.addString = function (t) {
                this.strings.push(t);
              }),
              (e.prototype.getInt = function (t) {
                return (
                  void 0 === t && (t = 0),
                  t >= 0 && t < this.ints.length ? this.ints[t] : 0
                );
              }),
              (e.prototype.getFloat = function (t) {
                return (
                  void 0 === t && (t = 0),
                  t >= 0 && t < this.floats.length ? this.floats[t] : 0
                );
              }),
              (e.prototype.getString = function (t) {
                return (
                  void 0 === t && (t = 0),
                  t >= 0 && t < this.strings.length ? this.strings[t] : ""
                );
              }),
              e
            );
          })(t.BaseObject);
          t.UserData = e;
          var i = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (e.data = null), e;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.ActionData]";
              }),
              (e.prototype._onClear = function () {
                null !== this.data && this.data.returnToPool(),
                  (this.type = 0),
                  (this.name = ""),
                  (this.bone = null),
                  (this.slot = null),
                  (this.data = null);
              }),
              e
            );
          })(t.BaseObject);
          t.ActionData = i;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (
                (e.frameIndices = []),
                (e.cachedFrames = []),
                (e.armatureNames = []),
                (e.armatures = {}),
                (e.userData = null),
                e
              );
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.DragonBonesData]";
              }),
              (e.prototype._onClear = function () {
                for (var t in this.armatures)
                  this.armatures[t].returnToPool(), delete this.armatures[t];
                null !== this.userData && this.userData.returnToPool(),
                  (this.autoSearch = !1),
                  (this.frameRate = 0),
                  (this.version = ""),
                  (this.name = ""),
                  (this.stage = null),
                  (this.frameIndices.length = 0),
                  (this.cachedFrames.length = 0),
                  (this.armatureNames.length = 0),
                  (this.binary = null),
                  (this.intArray = null),
                  (this.floatArray = null),
                  (this.frameIntArray = null),
                  (this.frameFloatArray = null),
                  (this.frameArray = null),
                  (this.timelineArray = null),
                  (this.userData = null);
              }),
              (e.prototype.addArmature = function (t) {
                t.name in this.armatures
                  ? console.warn("Same armature: " + t.name)
                  : ((t.parent = this),
                    (this.armatures[t.name] = t),
                    this.armatureNames.push(t.name));
              }),
              (e.prototype.getArmature = function (t) {
                return t in this.armatures ? this.armatures[t] : null;
              }),
              (e.prototype.dispose = function () {
                console.warn("已废弃"), this.returnToPool();
              }),
              e
            );
          })(t.BaseObject);
          t.DragonBonesData = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (e) {
            function i() {
              var i = (null !== e && e.apply(this, arguments)) || this;
              return (
                (i.aabb = new t.Rectangle()),
                (i.animationNames = []),
                (i.sortedBones = []),
                (i.sortedSlots = []),
                (i.defaultActions = []),
                (i.actions = []),
                (i.bones = {}),
                (i.slots = {}),
                (i.constraints = {}),
                (i.skins = {}),
                (i.animations = {}),
                (i.canvas = null),
                (i.userData = null),
                i
              );
            }
            return (
              Z2(i, e),
              (i.toString = function () {
                return "[class dragonBones.ArmatureData]";
              }),
              (i.prototype._onClear = function () {
                for (var t = 0, e = this.defaultActions; t < e.length; t++)
                  e[t].returnToPool();
                for (var i = 0, s = this.actions; i < s.length; i++)
                  s[i].returnToPool();
                for (var n in this.bones)
                  this.bones[n].returnToPool(), delete this.bones[n];
                for (var n in this.slots)
                  this.slots[n].returnToPool(), delete this.slots[n];
                for (var n in this.constraints)
                  this.constraints[n].returnToPool(),
                    delete this.constraints[n];
                for (var n in this.skins)
                  this.skins[n].returnToPool(), delete this.skins[n];
                for (var n in this.animations)
                  this.animations[n].returnToPool(), delete this.animations[n];
                null !== this.canvas && this.canvas.returnToPool(),
                  null !== this.userData && this.userData.returnToPool(),
                  (this.type = 0),
                  (this.frameRate = 0),
                  (this.cacheFrameRate = 0),
                  (this.scale = 1),
                  (this.name = ""),
                  this.aabb.clear(),
                  (this.animationNames.length = 0),
                  (this.sortedBones.length = 0),
                  (this.sortedSlots.length = 0),
                  (this.defaultActions.length = 0),
                  (this.actions.length = 0),
                  (this.defaultSkin = null),
                  (this.defaultAnimation = null),
                  (this.canvas = null),
                  (this.userData = null),
                  (this.parent = null);
              }),
              (i.prototype.sortBones = function () {
                var t = this.sortedBones.length;
                if (!(t <= 0)) {
                  var e = this.sortedBones.concat(),
                    i = 0,
                    s = 0;
                  for (this.sortedBones.length = 0; s < t; ) {
                    var n = e[i++];
                    if (
                      (i >= t && (i = 0), !(this.sortedBones.indexOf(n) >= 0))
                    ) {
                      var r = !1;
                      for (var a in this.constraints) {
                        var o = this.constraints[a];
                        if (
                          o.root === n &&
                          this.sortedBones.indexOf(o.target) < 0
                        ) {
                          r = !0;
                          break;
                        }
                      }
                      r ||
                        (null !== n.parent &&
                          this.sortedBones.indexOf(n.parent) < 0) ||
                        (this.sortedBones.push(n), s++);
                    }
                  }
                }
              }),
              (i.prototype.cacheFrames = function (t) {
                if (!(this.cacheFrameRate > 0))
                  for (var e in ((this.cacheFrameRate = t), this.animations))
                    this.animations[e].cacheFrames(this.cacheFrameRate);
              }),
              (i.prototype.setCacheFrame = function (t, e) {
                var i = this.parent.cachedFrames,
                  s = i.length;
                return (
                  (i.length += 10),
                  (i[s] = t.a),
                  (i[s + 1] = t.b),
                  (i[s + 2] = t.c),
                  (i[s + 3] = t.d),
                  (i[s + 4] = t.tx),
                  (i[s + 5] = t.ty),
                  (i[s + 6] = e.rotation),
                  (i[s + 7] = e.skew),
                  (i[s + 8] = e.scaleX),
                  (i[s + 9] = e.scaleY),
                  s
                );
              }),
              (i.prototype.getCacheFrame = function (t, e, i) {
                var s = this.parent.cachedFrames;
                (t.a = s[i]),
                  (t.b = s[i + 1]),
                  (t.c = s[i + 2]),
                  (t.d = s[i + 3]),
                  (t.tx = s[i + 4]),
                  (t.ty = s[i + 5]),
                  (e.rotation = s[i + 6]),
                  (e.skew = s[i + 7]),
                  (e.scaleX = s[i + 8]),
                  (e.scaleY = s[i + 9]),
                  (e.x = t.tx),
                  (e.y = t.ty);
              }),
              (i.prototype.addBone = function (t) {
                t.name in this.bones
                  ? console.warn("Same bone: " + t.name)
                  : ((this.bones[t.name] = t), this.sortedBones.push(t));
              }),
              (i.prototype.addSlot = function (t) {
                t.name in this.slots
                  ? console.warn("Same slot: " + t.name)
                  : ((this.slots[t.name] = t), this.sortedSlots.push(t));
              }),
              (i.prototype.addConstraint = function (t) {
                t.name in this.constraints
                  ? console.warn("Same constraint: " + t.name)
                  : (this.constraints[t.name] = t);
              }),
              (i.prototype.addSkin = function (t) {
                t.name in this.skins
                  ? console.warn("Same skin: " + t.name)
                  : ((t.parent = this),
                    (this.skins[t.name] = t),
                    null === this.defaultSkin && (this.defaultSkin = t),
                    "default" === t.name && (this.defaultSkin = t));
              }),
              (i.prototype.addAnimation = function (t) {
                t.name in this.animations
                  ? console.warn("Same animation: " + t.name)
                  : ((t.parent = this),
                    (this.animations[t.name] = t),
                    this.animationNames.push(t.name),
                    null === this.defaultAnimation &&
                      (this.defaultAnimation = t));
              }),
              (i.prototype.addAction = function (t, e) {
                e ? this.defaultActions.push(t) : this.actions.push(t);
              }),
              (i.prototype.getBone = function (t) {
                return t in this.bones ? this.bones[t] : null;
              }),
              (i.prototype.getSlot = function (t) {
                return t in this.slots ? this.slots[t] : null;
              }),
              (i.prototype.getConstraint = function (t) {
                return t in this.constraints ? this.constraints[t] : null;
              }),
              (i.prototype.getSkin = function (t) {
                return t in this.skins ? this.skins[t] : null;
              }),
              (i.prototype.getMesh = function (t, e, i) {
                var s = this.getSkin(t);
                return null === s ? null : s.getDisplay(e, i);
              }),
              (i.prototype.getAnimation = function (t) {
                return t in this.animations ? this.animations[t] : null;
              }),
              i
            );
          })(t.BaseObject);
          t.ArmatureData = e;
          var i = (function (e) {
            function i() {
              var i = (null !== e && e.apply(this, arguments)) || this;
              return (i.transform = new t.Transform()), (i.userData = null), i;
            }
            return (
              Z2(i, e),
              (i.toString = function () {
                return "[class dragonBones.BoneData]";
              }),
              (i.prototype._onClear = function () {
                null !== this.userData && this.userData.returnToPool(),
                  (this.inheritTranslation = !1),
                  (this.inheritRotation = !1),
                  (this.inheritScale = !1),
                  (this.inheritReflection = !1),
                  (this.type = 0),
                  (this.length = 0),
                  (this.name = ""),
                  this.transform.identity(),
                  (this.userData = null),
                  (this.parent = null);
              }),
              i
            );
          })(t.BaseObject);
          t.BoneData = i;
          var s = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (e.vertices = []), e;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.SurfaceData]";
              }),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this),
                  (this.type = 1),
                  (this.segmentX = 0),
                  (this.segmentY = 0),
                  (this.vertices.length = 0);
              }),
              e
            );
          })(i);
          t.SurfaceData = s;
          var n = (function (e) {
            function i() {
              var t = (null !== e && e.apply(this, arguments)) || this;
              return (t.color = null), (t.userData = null), t;
            }
            return (
              Z2(i, e),
              (i.createColor = function () {
                return new t.ColorTransform();
              }),
              (i.toString = function () {
                return "[class dragonBones.SlotData]";
              }),
              (i.prototype._onClear = function () {
                null !== this.userData && this.userData.returnToPool(),
                  (this.blendMode = 0),
                  (this.displayIndex = 0),
                  (this.zOrder = 0),
                  (this.name = ""),
                  (this.color = null),
                  (this.userData = null),
                  (this.parent = null);
              }),
              (i.DEFAULT_COLOR = new t.ColorTransform()),
              i
            );
          })(t.BaseObject);
          t.SlotData = n;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.prototype._onClear = function () {
                (this.order = 0),
                  (this.name = ""),
                  (this.type = 0),
                  (this.target = null),
                  (this.root = null),
                  (this.bone = null);
              }),
              e
            );
          })(t.BaseObject);
          t.ConstraintData = e;
          var i = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.IKConstraintData]";
              }),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this),
                  (this.scaleEnabled = !1),
                  (this.bendPositive = !1),
                  (this.weight = 1);
              }),
              e
            );
          })(e);
          t.IKConstraintData = i;
          var s = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (e.bones = []), e;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.PathConstraintData]";
              }),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this),
                  (this.pathSlot = null),
                  (this.pathDisplayData = null),
                  (this.bones.length = 0),
                  (this.positionMode = 0),
                  (this.spacingMode = 1),
                  (this.rotateMode = 1),
                  (this.position = 0),
                  (this.spacing = 0),
                  (this.rotateOffset = 0),
                  (this.rotateMix = 0),
                  (this.translateMix = 0);
              }),
              (e.prototype.AddBone = function (t) {
                this.bones.push(t);
              }),
              e
            );
          })(e);
          t.PathConstraintData = s;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.CanvasData]";
              }),
              (e.prototype._onClear = function () {
                (this.hasBackground = !1),
                  (this.color = 0),
                  (this.x = 0),
                  (this.y = 0),
                  (this.width = 0),
                  (this.height = 0);
              }),
              e
            );
          })(t.BaseObject);
          t.CanvasData = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (e.displays = {}), e;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.SkinData]";
              }),
              (e.prototype._onClear = function () {
                for (var t in this.displays) {
                  for (var e = 0, i = this.displays[t]; e < i.length; e++) {
                    var s = i[e];
                    null !== s && s.returnToPool();
                  }
                  delete this.displays[t];
                }
                (this.name = ""), (this.parent = null);
              }),
              (e.prototype.addDisplay = function (t, e) {
                t in this.displays || (this.displays[t] = []),
                  null !== e && (e.parent = this),
                  this.displays[t].push(e);
              }),
              (e.prototype.getDisplay = function (t, e) {
                var i = this.getDisplays(t);
                if (null !== i)
                  for (var s = 0, n = i; s < n.length; s++) {
                    var r = n[s];
                    if (null !== r && r.name === e) return r;
                  }
                return null;
              }),
              (e.prototype.getDisplays = function (t) {
                return t in this.displays ? this.displays[t] : null;
              }),
              e
            );
          })(t.BaseObject);
          t.SkinData = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function () {
            function t() {
              this.weight = null;
            }
            return (
              (t.prototype.clear = function () {
                this.isShared ||
                  null === this.weight ||
                  this.weight.returnToPool(),
                  (this.isShared = !1),
                  (this.inheritDeform = !1),
                  (this.offset = 0),
                  (this.data = null),
                  (this.weight = null);
              }),
              (t.prototype.shareFrom = function (t) {
                (this.isShared = !0),
                  (this.offset = t.offset),
                  (this.weight = t.weight);
              }),
              t
            );
          })();
          t.VerticesData = e;
          var i = (function (e) {
            function i() {
              var i = (null !== e && e.apply(this, arguments)) || this;
              return (i.transform = new t.Transform()), i;
            }
            return (
              Z2(i, e),
              (i.prototype._onClear = function () {
                (this.name = ""),
                  (this.path = ""),
                  this.transform.identity(),
                  (this.parent = null);
              }),
              i
            );
          })(t.BaseObject);
          t.DisplayData = i;
          var s = (function (e) {
            function i() {
              var i = (null !== e && e.apply(this, arguments)) || this;
              return (i.pivot = new t.Point()), i;
            }
            return (
              Z2(i, e),
              (i.toString = function () {
                return "[class dragonBones.ImageDisplayData]";
              }),
              (i.prototype._onClear = function () {
                e.prototype._onClear.call(this),
                  (this.type = 0),
                  this.pivot.clear(),
                  (this.texture = null);
              }),
              i
            );
          })(i);
          t.ImageDisplayData = s;
          var n = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (e.actions = []), e;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.ArmatureDisplayData]";
              }),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this);
                for (var e = 0, i = this.actions; e < i.length; e++)
                  i[e].returnToPool();
                (this.type = 1),
                  (this.inheritAnimation = !1),
                  (this.actions.length = 0),
                  (this.armature = null);
              }),
              (e.prototype.addAction = function (t) {
                this.actions.push(t);
              }),
              e
            );
          })(i);
          t.ArmatureDisplayData = n;
          var r = (function (t) {
            function i() {
              var i = (null !== t && t.apply(this, arguments)) || this;
              return (i.vertices = new e()), i;
            }
            return (
              Z2(i, t),
              (i.toString = function () {
                return "[class dragonBones.MeshDisplayData]";
              }),
              (i.prototype._onClear = function () {
                t.prototype._onClear.call(this),
                  (this.type = 2),
                  this.vertices.clear(),
                  (this.texture = null);
              }),
              i
            );
          })(i);
          t.MeshDisplayData = r;
          var a = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (e.boundingBox = null), e;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.BoundingBoxDisplayData]";
              }),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this),
                  null !== this.boundingBox && this.boundingBox.returnToPool(),
                  (this.type = 3),
                  (this.boundingBox = null);
              }),
              e
            );
          })(i);
          t.BoundingBoxDisplayData = a;
          var o = (function (t) {
            function i() {
              var i = (null !== t && t.apply(this, arguments)) || this;
              return (i.vertices = new e()), (i.curveLengths = []), i;
            }
            return (
              Z2(i, t),
              (i.toString = function () {
                return "[class dragonBones.PathDisplayData]";
              }),
              (i.prototype._onClear = function () {
                t.prototype._onClear.call(this),
                  (this.type = 4),
                  (this.closed = !1),
                  (this.constantSpeed = !1),
                  this.vertices.clear(),
                  (this.curveLengths.length = 0);
              }),
              i
            );
          })(i);
          t.PathDisplayData = o;
          var h = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (e.bones = []), e;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.WeightData]";
              }),
              (e.prototype._onClear = function () {
                (this.count = 0), (this.offset = 0), (this.bones.length = 0);
              }),
              (e.prototype.addBone = function (t) {
                this.bones.push(t);
              }),
              e
            );
          })(t.BaseObject);
          t.WeightData = h;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.prototype._onClear = function () {
                (this.color = 0), (this.width = 0), (this.height = 0);
              }),
              e
            );
          })(t.BaseObject);
          t.BoundingBoxData = e;
          var i = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.RectangleBoundingBoxData]";
              }),
              (e._computeOutCode = function (t, e, i, s, n, r) {
                var a = 0;
                return (
                  t < i ? (a |= 1) : t > n && (a |= 2),
                  e < s ? (a |= 4) : e > r && (a |= 8),
                  a
                );
              }),
              (e.rectangleIntersectsSegment = function (
                t,
                i,
                s,
                n,
                r,
                a,
                o,
                h,
                l,
                c,
                u
              ) {
                void 0 === l && (l = null),
                  void 0 === c && (c = null),
                  void 0 === u && (u = null);
                var _ = t > r && t < o && i > a && i < h,
                  d = s > r && s < o && n > a && n < h;
                if (_ && d) return -1;
                for (
                  var p = 0,
                    m = e._computeOutCode(t, i, r, a, o, h),
                    f = e._computeOutCode(s, n, r, a, o, h);
                  ;

                ) {
                  if (0 == (m | f)) {
                    p = 2;
                    break;
                  }
                  if (0 != (m & f)) break;
                  var g = 0,
                    y = 0,
                    T = 0,
                    S = 0 !== m ? m : f;
                  0 != (4 & S)
                    ? ((g = t + ((s - t) * (a - i)) / (n - i)),
                      (y = a),
                      null !== u && (T = 0.5 * -Math.PI))
                    : 0 != (8 & S)
                    ? ((g = t + ((s - t) * (h - i)) / (n - i)),
                      (y = h),
                      null !== u && (T = 0.5 * Math.PI))
                    : 0 != (2 & S)
                    ? ((y = i + ((n - i) * (o - t)) / (s - t)),
                      (g = o),
                      null !== u && (T = 0))
                    : 0 != (1 & S) &&
                      ((y = i + ((n - i) * (r - t)) / (s - t)),
                      (g = r),
                      null !== u && (T = Math.PI)),
                    S === m
                      ? ((t = g),
                        (i = y),
                        (m = e._computeOutCode(t, i, r, a, o, h)),
                        null !== u && (u.x = T))
                      : ((s = g),
                        (n = y),
                        (f = e._computeOutCode(s, n, r, a, o, h)),
                        null !== u && (u.y = T));
                }
                return (
                  p &&
                    (_
                      ? ((p = 2),
                        null !== l && ((l.x = s), (l.y = n)),
                        null !== c && ((c.x = s), (c.y = s)),
                        null !== u && (u.x = u.y + Math.PI))
                      : d
                      ? ((p = 1),
                        null !== l && ((l.x = t), (l.y = i)),
                        null !== c && ((c.x = t), (c.y = i)),
                        null !== u && (u.y = u.x + Math.PI))
                      : ((p = 3),
                        null !== l && ((l.x = t), (l.y = i)),
                        null !== c && ((c.x = s), (c.y = n)))),
                  p
                );
              }),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this), (this.type = 0);
              }),
              (e.prototype.containsPoint = function (t, e) {
                var i = 0.5 * this.width;
                if (t >= -i && t <= i) {
                  var s = 0.5 * this.height;
                  if (e >= -s && e <= s) return !0;
                }
                return !1;
              }),
              (e.prototype.intersectsSegment = function (t, i, s, n, r, a, o) {
                void 0 === r && (r = null),
                  void 0 === a && (a = null),
                  void 0 === o && (o = null);
                var h = 0.5 * this.width,
                  l = 0.5 * this.height;
                return e.rectangleIntersectsSegment(
                  t,
                  i,
                  s,
                  n,
                  -h,
                  -l,
                  h,
                  l,
                  r,
                  a,
                  o
                );
              }),
              e
            );
          })(e);
          t.RectangleBoundingBoxData = i;
          var s = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.EllipseData]";
              }),
              (e.ellipseIntersectsSegment = function (
                t,
                e,
                i,
                s,
                n,
                r,
                a,
                o,
                h,
                l,
                c
              ) {
                void 0 === h && (h = null),
                  void 0 === l && (l = null),
                  void 0 === c && (c = null);
                var u = a / o,
                  _ = u * u,
                  d = i - t,
                  p = (s *= u) - (e *= u),
                  m = Math.sqrt(d * d + p * p),
                  f = d / m,
                  g = p / m,
                  y = (n - t) * f + (r - e) * g,
                  T = a * a,
                  S = T - (t * t + e * e) + y * y,
                  E = 0;
                if (S >= 0) {
                  var v = Math.sqrt(S),
                    b = y - v,
                    A = y + v,
                    C = b < 0 ? -1 : b <= m ? 0 : 1,
                    O = A < 0 ? -1 : A <= m ? 0 : 1,
                    I = C * O;
                  if (I < 0) return -1;
                  0 === I &&
                    (-1 === C
                      ? ((E = 2),
                        (i = t + A * f),
                        (s = (e + A * g) / u),
                        null !== h && ((h.x = i), (h.y = s)),
                        null !== l && ((l.x = i), (l.y = s)),
                        null !== c &&
                          ((c.x = Math.atan2((s / T) * _, i / T)),
                          (c.y = c.x + Math.PI)))
                      : 1 === O
                      ? ((E = 1),
                        (t += b * f),
                        (e = (e + b * g) / u),
                        null !== h && ((h.x = t), (h.y = e)),
                        null !== l && ((l.x = t), (l.y = e)),
                        null !== c &&
                          ((c.x = Math.atan2((e / T) * _, t / T)),
                          (c.y = c.x + Math.PI)))
                      : ((E = 3),
                        null !== h &&
                          ((h.x = t + b * f),
                          (h.y = (e + b * g) / u),
                          null !== c &&
                            (c.x = Math.atan2((h.y / T) * _, h.x / T))),
                        null !== l &&
                          ((l.x = t + A * f),
                          (l.y = (e + A * g) / u),
                          null !== c &&
                            (c.y = Math.atan2((l.y / T) * _, l.x / T)))));
                }
                return E;
              }),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this), (this.type = 1);
              }),
              (e.prototype.containsPoint = function (t, e) {
                var i = 0.5 * this.width;
                if (t >= -i && t <= i) {
                  var s = 0.5 * this.height;
                  if (e >= -s && e <= s)
                    return (e *= i / s), Math.sqrt(t * t + e * e) <= i;
                }
                return !1;
              }),
              (e.prototype.intersectsSegment = function (t, i, s, n, r, a, o) {
                return (
                  void 0 === r && (r = null),
                  void 0 === a && (a = null),
                  void 0 === o && (o = null),
                  e.ellipseIntersectsSegment(
                    t,
                    i,
                    s,
                    n,
                    0,
                    0,
                    0.5 * this.width,
                    0.5 * this.height,
                    r,
                    a,
                    o
                  )
                );
              }),
              e
            );
          })(e);
          t.EllipseBoundingBoxData = s;
          var n = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (e.vertices = []), e;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.PolygonBoundingBoxData]";
              }),
              (e.polygonIntersectsSegment = function (t, e, i, s, n, r, a, o) {
                void 0 === r && (r = null),
                  void 0 === a && (a = null),
                  void 0 === o && (o = null),
                  t === i && (t = i + 1e-6),
                  e === s && (e = s + 1e-6);
                for (
                  var h = n.length,
                    l = t - i,
                    c = e - s,
                    u = t * s - e * i,
                    _ = 0,
                    d = n[h - 2],
                    p = n[h - 1],
                    m = 0,
                    f = 0,
                    g = 0,
                    y = 0,
                    T = 0,
                    S = 0,
                    E = 0;
                  E < h;
                  E += 2
                ) {
                  var v = n[E],
                    b = n[E + 1];
                  d === v && (d = v + 1e-4), p === b && (p = b + 1e-4);
                  var A = d - v,
                    C = p - b,
                    O = d * b - p * v,
                    I = l * C - c * A,
                    w = (u * A - l * O) / I;
                  if (
                    ((w >= d && w <= v) || (w >= v && w <= d)) &&
                    (0 === l || (w >= t && w <= i) || (w >= i && w <= t))
                  ) {
                    var R = (u * C - c * O) / I;
                    if (
                      ((R >= p && R <= b) || (R >= b && R <= p)) &&
                      (0 === c || (R >= e && R <= s) || (R >= s && R <= e))
                    ) {
                      if (null === a) {
                        (g = w),
                          (y = R),
                          (T = w),
                          (S = R),
                          _++,
                          null !== o &&
                            ((o.x = Math.atan2(b - p, v - d) - 0.5 * Math.PI),
                            (o.y = o.x));
                        break;
                      }
                      var D = w - t;
                      D < 0 && (D = -D),
                        0 === _
                          ? ((m = D),
                            (f = D),
                            (g = w),
                            (y = R),
                            (T = w),
                            (S = R),
                            null !== o &&
                              ((o.x = Math.atan2(b - p, v - d) - 0.5 * Math.PI),
                              (o.y = o.x)))
                          : (D < m &&
                              ((m = D),
                              (g = w),
                              (y = R),
                              null !== o &&
                                (o.x =
                                  Math.atan2(b - p, v - d) - 0.5 * Math.PI)),
                            D > f &&
                              ((f = D),
                              (T = w),
                              (S = R),
                              null !== o &&
                                (o.y =
                                  Math.atan2(b - p, v - d) - 0.5 * Math.PI))),
                        _++;
                    }
                  }
                  (d = v), (p = b);
                }
                return (
                  1 === _
                    ? (null !== r && ((r.x = g), (r.y = y)),
                      null !== a && ((a.x = g), (a.y = y)),
                      null !== o && (o.y = o.x + Math.PI))
                    : _ > 1 &&
                      (_++,
                      null !== r && ((r.x = g), (r.y = y)),
                      null !== a && ((a.x = T), (a.y = S))),
                  _
                );
              }),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this),
                  (this.type = 2),
                  (this.x = 0),
                  (this.y = 0),
                  (this.vertices.length = 0);
              }),
              (e.prototype.containsPoint = function (t, e) {
                var i = !1;
                if (
                  t >= this.x &&
                  t <= this.width &&
                  e >= this.y &&
                  e <= this.height
                )
                  for (
                    var s = 0, n = this.vertices.length, r = n - 2;
                    s < n;
                    s += 2
                  ) {
                    var a = this.vertices[r + 1],
                      o = this.vertices[s + 1];
                    if ((o < e && a >= e) || (a < e && o >= e)) {
                      var h = this.vertices[r],
                        l = this.vertices[s];
                      ((e - o) * (h - l)) / (a - o) + l < t && (i = !i);
                    }
                    r = s;
                  }
                return i;
              }),
              (e.prototype.intersectsSegment = function (t, s, n, r, a, o, h) {
                void 0 === a && (a = null),
                  void 0 === o && (o = null),
                  void 0 === h && (h = null);
                var l = 0;
                return (
                  0 !==
                    i.rectangleIntersectsSegment(
                      t,
                      s,
                      n,
                      r,
                      this.x,
                      this.y,
                      this.x + this.width,
                      this.y + this.height,
                      null,
                      null,
                      null
                    ) &&
                    (l = e.polygonIntersectsSegment(
                      t,
                      s,
                      n,
                      r,
                      this.vertices,
                      a,
                      o,
                      h
                    )),
                  l
                );
              }),
              e
            );
          })(e);
          t.PolygonBoundingBoxData = n;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (
                (e.cachedFrames = []),
                (e.boneTimelines = {}),
                (e.surfaceTimelines = {}),
                (e.slotTimelines = {}),
                (e.constraintTimelines = {}),
                (e.animationTimelines = {}),
                (e.boneCachedFrameIndices = {}),
                (e.slotCachedFrameIndices = {}),
                (e.actionTimeline = null),
                (e.zOrderTimeline = null),
                e
              );
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.AnimationData]";
              }),
              (e.prototype._onClear = function () {
                for (var t in this.boneTimelines) {
                  for (var e = 0, i = this.boneTimelines[t]; e < i.length; e++)
                    i[e].returnToPool();
                  delete this.boneTimelines[t];
                }
                for (var t in this.surfaceTimelines) {
                  for (
                    var s = 0, n = this.surfaceTimelines[t];
                    s < n.length;
                    s++
                  )
                    n[s].returnToPool();
                  delete this.surfaceTimelines[t];
                }
                for (var t in this.slotTimelines) {
                  for (var r = 0, a = this.slotTimelines[t]; r < a.length; r++)
                    a[r].returnToPool();
                  delete this.slotTimelines[t];
                }
                for (var t in this.constraintTimelines) {
                  for (
                    var o = 0, h = this.constraintTimelines[t];
                    o < h.length;
                    o++
                  )
                    h[o].returnToPool();
                  delete this.constraintTimelines[t];
                }
                for (var t in this.animationTimelines) {
                  for (
                    var l = 0, c = this.animationTimelines[t];
                    l < c.length;
                    l++
                  )
                    c[l].returnToPool();
                  delete this.animationTimelines[t];
                }
                for (var t in this.boneCachedFrameIndices)
                  delete this.boneCachedFrameIndices[t];
                for (var t in this.slotCachedFrameIndices)
                  delete this.slotCachedFrameIndices[t];
                null !== this.actionTimeline &&
                  this.actionTimeline.returnToPool(),
                  null !== this.zOrderTimeline &&
                    this.zOrderTimeline.returnToPool(),
                  (this.frameIntOffset = 0),
                  (this.frameFloatOffset = 0),
                  (this.frameOffset = 0),
                  (this.frameCount = 0),
                  (this.playTimes = 0),
                  (this.duration = 0),
                  (this.scale = 1),
                  (this.fadeInTime = 0),
                  (this.cacheFrameRate = 0),
                  (this.name = ""),
                  (this.cachedFrames.length = 0),
                  (this.actionTimeline = null),
                  (this.zOrderTimeline = null),
                  (this.parent = null);
              }),
              (e.prototype.cacheFrames = function (t) {
                if (!(this.cacheFrameRate > 0)) {
                  this.cacheFrameRate = Math.max(Math.ceil(t * this.scale), 1);
                  var e = Math.ceil(this.cacheFrameRate * this.duration) + 1;
                  this.cachedFrames.length = e;
                  for (var i = 0, s = this.cacheFrames.length; i < s; ++i)
                    this.cachedFrames[i] = !1;
                  for (
                    var n = 0, r = this.parent.sortedBones;
                    n < r.length;
                    n++
                  ) {
                    var a = r[n];
                    for (i = 0, s = (l = new Array(e)).length; i < s; ++i)
                      l[i] = -1;
                    this.boneCachedFrameIndices[a.name] = l;
                  }
                  for (
                    var o = 0, h = this.parent.sortedSlots;
                    o < h.length;
                    o++
                  ) {
                    var l,
                      c = h[o];
                    for (i = 0, s = (l = new Array(e)).length; i < s; ++i)
                      l[i] = -1;
                    this.slotCachedFrameIndices[c.name] = l;
                  }
                }
              }),
              (e.prototype.addBoneTimeline = function (t, e) {
                var i =
                  t.name in this.boneTimelines
                    ? this.boneTimelines[t.name]
                    : (this.boneTimelines[t.name] = []);
                i.indexOf(e) < 0 && i.push(e);
              }),
              (e.prototype.addSurfaceTimeline = function (t, e) {
                var i =
                  t.name in this.surfaceTimelines
                    ? this.surfaceTimelines[t.name]
                    : (this.surfaceTimelines[t.name] = []);
                i.indexOf(e) < 0 && i.push(e);
              }),
              (e.prototype.addSlotTimeline = function (t, e) {
                var i =
                  t.name in this.slotTimelines
                    ? this.slotTimelines[t.name]
                    : (this.slotTimelines[t.name] = []);
                i.indexOf(e) < 0 && i.push(e);
              }),
              (e.prototype.addConstraintTimeline = function (t, e) {
                var i =
                  t.name in this.constraintTimelines
                    ? this.constraintTimelines[t.name]
                    : (this.constraintTimelines[t.name] = []);
                i.indexOf(e) < 0 && i.push(e);
              }),
              (e.prototype.addAnimationTimeline = function (t, e) {
                var i =
                  t in this.animationTimelines
                    ? this.animationTimelines[t]
                    : (this.animationTimelines[t] = []);
                i.indexOf(e) < 0 && i.push(e);
              }),
              (e.prototype.getBoneTimelines = function (t) {
                return t in this.boneTimelines ? this.boneTimelines[t] : null;
              }),
              (e.prototype.getSurfaceTimelines = function (t) {
                return t in this.surfaceTimelines
                  ? this.surfaceTimelines[t]
                  : null;
              }),
              (e.prototype.getSlotTimelines = function (t) {
                return t in this.slotTimelines ? this.slotTimelines[t] : null;
              }),
              (e.prototype.getConstraintTimelines = function (t) {
                return t in this.constraintTimelines
                  ? this.constraintTimelines[t]
                  : null;
              }),
              (e.prototype.getAnimationTimelines = function (t) {
                return t in this.animationTimelines
                  ? this.animationTimelines[t]
                  : null;
              }),
              (e.prototype.getBoneCachedFrameIndices = function (t) {
                return t in this.boneCachedFrameIndices
                  ? this.boneCachedFrameIndices[t]
                  : null;
              }),
              (e.prototype.getSlotCachedFrameIndices = function (t) {
                return t in this.slotCachedFrameIndices
                  ? this.slotCachedFrameIndices[t]
                  : null;
              }),
              e
            );
          })(t.BaseObject);
          t.AnimationData = e;
          var i = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.TimelineData]";
              }),
              (e.prototype._onClear = function () {
                (this.type = 10),
                  (this.offset = 0),
                  (this.frameIndicesOffset = -1);
              }),
              e
            );
          })(t.BaseObject);
          t.TimelineData = i;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (e.boneMask = []), e;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.AnimationConfig]";
              }),
              (e.prototype._onClear = function () {
                (this.pauseFadeOut = !0),
                  (this.fadeOutMode = 4),
                  (this.fadeOutTweenType = 1),
                  (this.fadeOutTime = -1),
                  (this.actionEnabled = !0),
                  (this.additiveBlending = !1),
                  (this.displayControl = !0),
                  (this.pauseFadeIn = !0),
                  (this.resetToPose = !0),
                  (this.fadeInTweenType = 1),
                  (this.playTimes = -1),
                  (this.layer = 0),
                  (this.position = 0),
                  (this.duration = -1),
                  (this.timeScale = -100),
                  (this.weight = 1),
                  (this.fadeInTime = -1),
                  (this.autoFadeOutTime = -1),
                  (this.name = ""),
                  (this.animation = ""),
                  (this.group = ""),
                  (this.boneMask.length = 0);
              }),
              (e.prototype.clear = function () {
                this._onClear();
              }),
              (e.prototype.copyFrom = function (t) {
                (this.pauseFadeOut = t.pauseFadeOut),
                  (this.fadeOutMode = t.fadeOutMode),
                  (this.autoFadeOutTime = t.autoFadeOutTime),
                  (this.fadeOutTweenType = t.fadeOutTweenType),
                  (this.actionEnabled = t.actionEnabled),
                  (this.additiveBlending = t.additiveBlending),
                  (this.displayControl = t.displayControl),
                  (this.pauseFadeIn = t.pauseFadeIn),
                  (this.resetToPose = t.resetToPose),
                  (this.playTimes = t.playTimes),
                  (this.layer = t.layer),
                  (this.position = t.position),
                  (this.duration = t.duration),
                  (this.timeScale = t.timeScale),
                  (this.fadeInTime = t.fadeInTime),
                  (this.fadeOutTime = t.fadeOutTime),
                  (this.fadeInTweenType = t.fadeInTweenType),
                  (this.weight = t.weight),
                  (this.name = t.name),
                  (this.animation = t.animation),
                  (this.group = t.group),
                  (this.boneMask.length = t.boneMask.length);
                for (var e = 0, i = this.boneMask.length; e < i; ++e)
                  this.boneMask[e] = t.boneMask[e];
              }),
              (e.prototype.containsBoneMask = function (t) {
                return (
                  0 === this.boneMask.length || this.boneMask.indexOf(t) >= 0
                );
              }),
              (e.prototype.addBoneMask = function (t, e, i) {
                void 0 === i && (i = !0);
                var s = t.getBone(e);
                if (
                  null !== s &&
                  (this.boneMask.indexOf(e) < 0 && this.boneMask.push(e), i)
                )
                  for (var n = 0, r = t.getBones(); n < r.length; n++) {
                    var a = r[n];
                    this.boneMask.indexOf(a.name) < 0 &&
                      s.contains(a) &&
                      this.boneMask.push(a.name);
                  }
              }),
              (e.prototype.removeBoneMask = function (t, e, i) {
                void 0 === i && (i = !0);
                var s = this.boneMask.indexOf(e);
                if ((s >= 0 && this.boneMask.splice(s, 1), i)) {
                  var n = t.getBone(e);
                  if (null !== n)
                    if (this.boneMask.length > 0)
                      for (var r = 0, a = t.getBones(); r < a.length; r++) {
                        var o = a[r],
                          h = this.boneMask.indexOf(o.name);
                        h >= 0 && n.contains(o) && this.boneMask.splice(h, 1);
                      }
                    else
                      for (var l = 0, c = t.getBones(); l < c.length; l++)
                        (o = c[l]) !== n &&
                          (n.contains(o) || this.boneMask.push(o.name));
                }
              }),
              e
            );
          })(t.BaseObject);
          t.AnimationConfig = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (e.textures = {}), e;
            }
            return (
              Z2(e, t),
              (e.prototype._onClear = function () {
                for (var t in this.textures)
                  this.textures[t].returnToPool(), delete this.textures[t];
                (this.autoSearch = !1),
                  (this.width = 0),
                  (this.height = 0),
                  (this.scale = 1),
                  (this.name = ""),
                  (this.imagePath = "");
              }),
              (e.prototype.copyFrom = function (t) {
                for (var e in ((this.autoSearch = t.autoSearch),
                (this.scale = t.scale),
                (this.width = t.width),
                (this.height = t.height),
                (this.name = t.name),
                (this.imagePath = t.imagePath),
                this.textures))
                  this.textures[e].returnToPool(), delete this.textures[e];
                for (var e in t.textures) {
                  var i = this.createTexture();
                  i.copyFrom(t.textures[e]), (this.textures[e] = i);
                }
              }),
              (e.prototype.addTexture = function (t) {
                t.name in this.textures
                  ? console.warn("Same texture: " + t.name)
                  : ((t.parent = this), (this.textures[t.name] = t));
              }),
              (e.prototype.getTexture = function (t) {
                return t in this.textures ? this.textures[t] : null;
              }),
              e
            );
          })(t.BaseObject);
          t.TextureAtlasData = e;
          var i = (function (e) {
            function i() {
              var i = (null !== e && e.apply(this, arguments)) || this;
              return (i.region = new t.Rectangle()), (i.frame = null), i;
            }
            return (
              Z2(i, e),
              (i.createRectangle = function () {
                return new t.Rectangle();
              }),
              (i.prototype._onClear = function () {
                (this.rotated = !1),
                  (this.name = ""),
                  this.region.clear(),
                  (this.parent = null),
                  (this.frame = null);
              }),
              (i.prototype.copyFrom = function (t) {
                (this.rotated = t.rotated),
                  (this.name = t.name),
                  this.region.copyFrom(t.region),
                  (this.parent = t.parent),
                  null === this.frame && null !== t.frame
                    ? (this.frame = i.createRectangle())
                    : null !== this.frame &&
                      null === t.frame &&
                      (this.frame = null),
                  null !== this.frame &&
                    null !== t.frame &&
                    this.frame.copyFrom(t.frame);
              }),
              i
            );
          })(t.BaseObject);
          t.TextureData = i;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (e.vertices = []), (e.bones = []), e;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.DeformVertices]";
              }),
              (e.prototype._onClear = function () {
                (this.verticesDirty = !1),
                  (this.vertices.length = 0),
                  (this.bones.length = 0),
                  (this.verticesData = null);
              }),
              (e.prototype.init = function (t, e) {
                if (((this.verticesData = t), null !== this.verticesData)) {
                  var i;
                  (i =
                    null !== this.verticesData.weight
                      ? 2 * this.verticesData.weight.count
                      : 2 *
                        this.verticesData.data.intArray[
                          this.verticesData.offset + 0
                        ]),
                    (this.verticesDirty = !0),
                    (this.vertices.length = i),
                    (this.bones.length = 0);
                  for (var s = 0, n = this.vertices.length; s < n; ++s)
                    this.vertices[s] = 0;
                  if (null !== this.verticesData.weight)
                    for (
                      s = 0, n = this.verticesData.weight.bones.length;
                      s < n;
                      ++s
                    ) {
                      var r = e.getBone(this.verticesData.weight.bones[s].name);
                      this.bones.push(r);
                    }
                } else
                  (this.verticesDirty = !1),
                    (this.vertices.length = 0),
                    (this.bones.length = 0),
                    (this.verticesData = null);
              }),
              (e.prototype.isBonesUpdate = function () {
                for (var t = 0, e = this.bones; t < e.length; t++) {
                  var i = e[t];
                  if (null !== i && i._childrenTransformDirty) return !0;
                }
                return !1;
              }),
              e
            );
          })(t.BaseObject);
          t.DeformVertices = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (e) {
            function i() {
              var t = (null !== e && e.apply(this, arguments)) || this;
              return (
                (t._bones = []),
                (t._slots = []),
                (t._constraints = []),
                (t._actions = []),
                (t._animation = null),
                (t._proxy = null),
                (t._replaceTextureAtlasData = null),
                (t._clock = null),
                t
              );
            }
            return (
              Z2(i, e),
              (i.toString = function () {
                return "[class dragonBones.Armature]";
              }),
              (i._onSortSlots = function (t, e) {
                return t._zOrder > e._zOrder ? 1 : -1;
              }),
              (i.prototype._onClear = function () {
                null !== this._clock && this._clock.remove(this);
                for (var t = 0, e = this._bones; t < e.length; t++)
                  e[t].returnToPool();
                for (var i = 0, s = this._slots; i < s.length; i++)
                  s[i].returnToPool();
                for (var n = 0, r = this._constraints; n < r.length; n++)
                  r[n].returnToPool();
                for (var a = 0, o = this._actions; a < o.length; a++)
                  o[a].returnToPool();
                null !== this._animation && this._animation.returnToPool(),
                  null !== this._proxy && this._proxy.dbClear(),
                  null !== this._replaceTextureAtlasData &&
                    this._replaceTextureAtlasData.returnToPool(),
                  (this.inheritAnimation = !0),
                  (this.userData = null),
                  (this._lockUpdate = !1),
                  (this._slotsDirty = !0),
                  (this._zOrderDirty = !1),
                  (this._flipX = !1),
                  (this._flipY = !1),
                  (this._cacheFrameIndex = -1),
                  (this._bones.length = 0),
                  (this._slots.length = 0),
                  (this._constraints.length = 0),
                  (this._actions.length = 0),
                  (this._armatureData = null),
                  (this._animation = null),
                  (this._proxy = null),
                  (this._display = null),
                  (this._replaceTextureAtlasData = null),
                  (this._replacedTexture = null),
                  (this._dragonBones = null),
                  (this._clock = null),
                  (this._parent = null);
              }),
              (i.prototype._sortZOrder = function (t, e) {
                var i = this._armatureData.sortedSlots,
                  s = null === t;
                if (this._zOrderDirty || !s) {
                  for (var n = 0, r = i.length; n < r; ++n) {
                    var a = s ? n : t[e + n];
                    if (!(a < 0 || a >= r)) {
                      var o = i[a],
                        h = this.getSlot(o.name);
                      null !== h && h._setZorder(n);
                    }
                  }
                  (this._slotsDirty = !0), (this._zOrderDirty = !s);
                }
              }),
              (i.prototype._addBone = function (t) {
                this._bones.indexOf(t) < 0 && this._bones.push(t);
              }),
              (i.prototype._addSlot = function (t) {
                this._slots.indexOf(t) < 0 && this._slots.push(t);
              }),
              (i.prototype._addConstraint = function (t) {
                this._constraints.indexOf(t) < 0 && this._constraints.push(t);
              }),
              (i.prototype._bufferAction = function (t, e) {
                this._actions.indexOf(t) < 0 &&
                  (e ? this._actions.push(t) : this._actions.unshift(t));
              }),
              (i.prototype.dispose = function () {
                null !== this._armatureData &&
                  ((this._lockUpdate = !0),
                  this._dragonBones.bufferObject(this));
              }),
              (i.prototype.init = function (e, i, s, n) {
                null === this._armatureData &&
                  ((this._armatureData = e),
                  (this._animation = t.BaseObject.borrowObject(t.Animation)),
                  (this._proxy = i),
                  (this._display = s),
                  (this._dragonBones = n),
                  this._proxy.dbInit(this),
                  this._animation.init(this),
                  (this._animation.animations = this._armatureData.animations));
              }),
              (i.prototype.advanceTime = function (t) {
                if (!this._lockUpdate)
                  if (null !== this._armatureData)
                    if (null !== this._armatureData.parent) {
                      var e = this._cacheFrameIndex;
                      if (
                        (this._animation.advanceTime(t),
                        this._slotsDirty &&
                          ((this._slotsDirty = !1),
                          this._slots.sort(i._onSortSlots)),
                        this._cacheFrameIndex < 0 ||
                          this._cacheFrameIndex !== e)
                      ) {
                        var s = 0,
                          n = 0;
                        for (s = 0, n = this._bones.length; s < n; ++s)
                          this._bones[s].update(this._cacheFrameIndex);
                        for (s = 0, n = this._slots.length; s < n; ++s)
                          this._slots[s].update(this._cacheFrameIndex);
                      }
                      if (this._actions.length > 0) {
                        this._lockUpdate = !0;
                        for (var r = 0, a = this._actions; r < a.length; r++) {
                          var o = a[r],
                            h = o.actionData;
                          if (null !== h && 0 === h.type)
                            if (null !== o.slot)
                              null !== (u = o.slot.childArmature) &&
                                u.animation.fadeIn(h.name);
                            else if (null !== o.bone)
                              for (
                                var l = 0, c = this.getSlots();
                                l < c.length;
                                l++
                              ) {
                                var u,
                                  _ = c[l];
                                _.parent === o.bone &&
                                  null !== (u = _.childArmature) &&
                                  u.animation.fadeIn(h.name);
                              }
                            else this._animation.fadeIn(h.name);
                          o.returnToPool();
                        }
                        (this._actions.length = 0), (this._lockUpdate = !1);
                      }
                      this._proxy.dbUpdate();
                    } else
                      console.warn(
                        "The armature data has been disposed.\nPlease make sure dispose armature before call factory.clear()."
                      );
                  else console.warn("The armature has been disposed.");
              }),
              (i.prototype.invalidUpdate = function (t, e) {
                if (
                  (void 0 === t && (t = null),
                  void 0 === e && (e = !1),
                  null !== t && t.length > 0)
                ) {
                  if (null !== (a = this.getBone(t)) && (a.invalidUpdate(), e))
                    for (var i = 0, s = this._slots; i < s.length; i++)
                      (l = s[i]).parent === a && l.invalidUpdate();
                } else {
                  for (var n = 0, r = this._bones; n < r.length; n++) {
                    var a;
                    (a = r[n]).invalidUpdate();
                  }
                  if (e)
                    for (var o = 0, h = this._slots; o < h.length; o++) {
                      var l;
                      (l = h[o]).invalidUpdate();
                    }
                }
              }),
              (i.prototype.containsPoint = function (t, e) {
                for (var i = 0, s = this._slots; i < s.length; i++) {
                  var n = s[i];
                  if (n.containsPoint(t, e)) return n;
                }
                return null;
              }),
              (i.prototype.intersectsSegment = function (t, e, i, s, n, r, a) {
                void 0 === n && (n = null),
                  void 0 === r && (r = null),
                  void 0 === a && (a = null);
                for (
                  var o = t === i,
                    h = 0,
                    l = 0,
                    c = 0,
                    u = 0,
                    _ = 0,
                    d = 0,
                    p = 0,
                    m = 0,
                    f = null,
                    g = null,
                    y = 0,
                    T = this._slots;
                  y < T.length;
                  y++
                ) {
                  var S = T[y];
                  if (S.intersectsSegment(t, e, i, s, n, r, a) > 0) {
                    if (null === n && null === r) {
                      f = S;
                      break;
                    }
                    var E;
                    null !== n &&
                      ((E = o ? n.y - e : n.x - t) < 0 && (E = -E),
                      (null === f || E < h) &&
                        ((h = E),
                        (c = n.x),
                        (u = n.y),
                        (f = S),
                        a && (p = a.x))),
                      null !== r &&
                        ((E = r.x - t) < 0 && (E = -E),
                        (null === g || E > l) &&
                          ((l = E),
                          (_ = r.x),
                          (d = r.y),
                          (g = S),
                          null !== a && (m = a.y)));
                  }
                }
                return (
                  null !== f &&
                    null !== n &&
                    ((n.x = c), (n.y = u), null !== a && (a.x = p)),
                  null !== g &&
                    null !== r &&
                    ((r.x = _), (r.y = d), null !== a && (a.y = m)),
                  f
                );
              }),
              (i.prototype.getBone = function (t) {
                for (var e = 0, i = this._bones; e < i.length; e++) {
                  var s = i[e];
                  if (s.name === t) return s;
                }
                return null;
              }),
              (i.prototype.getBoneByDisplay = function (t) {
                var e = this.getSlotByDisplay(t);
                return null !== e ? e.parent : null;
              }),
              (i.prototype.getSlot = function (t) {
                for (var e = 0, i = this._slots; e < i.length; e++) {
                  var s = i[e];
                  if (s.name === t) return s;
                }
                return null;
              }),
              (i.prototype.getSlotByDisplay = function (t) {
                if (null !== t)
                  for (var e = 0, i = this._slots; e < i.length; e++) {
                    var s = i[e];
                    if (s.display === t) return s;
                  }
                return null;
              }),
              (i.prototype.getBones = function () {
                return this._bones;
              }),
              (i.prototype.getSlots = function () {
                return this._slots;
              }),
              Object.defineProperty(i.prototype, "flipX", {
                get: function () {
                  return this._flipX;
                },
                set: function (t) {
                  this._flipX !== t &&
                    ((this._flipX = t), this.invalidUpdate());
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "flipY", {
                get: function () {
                  return this._flipY;
                },
                set: function (t) {
                  this._flipY !== t &&
                    ((this._flipY = t), this.invalidUpdate());
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "cacheFrameRate", {
                get: function () {
                  return this._armatureData.cacheFrameRate;
                },
                set: function (t) {
                  if (this._armatureData.cacheFrameRate !== t) {
                    this._armatureData.cacheFrames(t);
                    for (var e = 0, i = this._slots; e < i.length; e++) {
                      var s = i[e].childArmature;
                      null !== s && (s.cacheFrameRate = t);
                    }
                  }
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "name", {
                get: function () {
                  return this._armatureData.name;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "armatureData", {
                get: function () {
                  return this._armatureData;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "animation", {
                get: function () {
                  return this._animation;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "proxy", {
                get: function () {
                  return this._proxy;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "eventDispatcher", {
                get: function () {
                  return this._proxy;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "display", {
                get: function () {
                  return this._display;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "replacedTexture", {
                get: function () {
                  return this._replacedTexture;
                },
                set: function (t) {
                  if (this._replacedTexture !== t) {
                    null !== this._replaceTextureAtlasData &&
                      (this._replaceTextureAtlasData.returnToPool(),
                      (this._replaceTextureAtlasData = null)),
                      (this._replacedTexture = t);
                    for (var e = 0, i = this._slots; e < i.length; e++) {
                      var s = i[e];
                      s.invalidUpdate(), s.update(-1);
                    }
                  }
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "clock", {
                get: function () {
                  return this._clock;
                },
                set: function (t) {
                  if (this._clock !== t) {
                    null !== this._clock && this._clock.remove(this),
                      (this._clock = t),
                      this._clock && this._clock.add(this);
                    for (var e = 0, i = this._slots; e < i.length; e++) {
                      var s = i[e].childArmature;
                      null !== s && (s.clock = this._clock);
                    }
                  }
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "parent", {
                get: function () {
                  return this._parent;
                },
                enumerable: !0,
                configurable: !0,
              }),
              (i.prototype.replaceTexture = function (t) {
                this.replacedTexture = t;
              }),
              (i.prototype.hasEventListener = function (t) {
                return this._proxy.hasDBEventListener(t);
              }),
              (i.prototype.addEventListener = function (t, e, i) {
                this._proxy.addDBEventListener(t, e, i);
              }),
              (i.prototype.removeEventListener = function (t, e, i) {
                this._proxy.removeDBEventListener(t, e, i);
              }),
              (i.prototype.enableAnimationCache = function (t) {
                console.warn("Deprecated."), (this.cacheFrameRate = t);
              }),
              (i.prototype.getDisplay = function () {
                return this._display;
              }),
              i
            );
          })(t.BaseObject);
          t.Armature = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (e) {
            function i() {
              var i = (null !== e && e.apply(this, arguments)) || this;
              return (
                (i.globalTransformMatrix = new t.Matrix()),
                (i.global = new t.Transform()),
                (i.offset = new t.Transform()),
                i
              );
            }
            return (
              Z2(i, e),
              (i.prototype._onClear = function () {
                this.globalTransformMatrix.identity(),
                  this.global.identity(),
                  this.offset.identity(),
                  (this.origin = null),
                  (this.userData = null),
                  (this._globalDirty = !1),
                  (this._armature = null);
              }),
              (i.prototype.updateGlobalTransform = function () {
                this._globalDirty &&
                  ((this._globalDirty = !1),
                  this.global.fromMatrix(this.globalTransformMatrix));
              }),
              Object.defineProperty(i.prototype, "armature", {
                get: function () {
                  return this._armature;
                },
                enumerable: !0,
                configurable: !0,
              }),
              (i._helpMatrix = new t.Matrix()),
              (i._helpTransform = new t.Transform()),
              (i._helpPoint = new t.Point()),
              i
            );
          })(t.BaseObject);
          t.TransformObject = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (e) {
            function i() {
              var i = (null !== e && e.apply(this, arguments)) || this;
              return (
                (i.animationPose = new t.Transform()),
                (i._blendState = new t.BlendState()),
                i
              );
            }
            return (
              Z2(i, e),
              (i.toString = function () {
                return "[class dragonBones.Bone]";
              }),
              (i.prototype._onClear = function () {
                e.prototype._onClear.call(this),
                  (this.offsetMode = 1),
                  this.animationPose.identity(),
                  (this._transformDirty = !1),
                  (this._childrenTransformDirty = !1),
                  (this._localDirty = !0),
                  (this._hasConstraint = !1),
                  (this._visible = !0),
                  (this._cachedFrameIndex = -1),
                  this._blendState.clear(),
                  (this._boneData = null),
                  (this._parent = null),
                  (this._cachedFrameIndices = null);
              }),
              (i.prototype._updateGlobalTransformMatrix = function (e) {
                var i = this._boneData,
                  s = this.global,
                  n = this.globalTransformMatrix,
                  r = this.origin,
                  a = this.offset,
                  o = this.animationPose,
                  h = this._parent,
                  l = this._armature.flipX,
                  c = this._armature.flipY === t.DragonBones.yDown,
                  u = null !== h,
                  _ = 0;
                if (
                  (1 === this.offsetMode
                    ? null !== r
                      ? ((s.x = r.x + a.x + o.x),
                        (s.scaleX = r.scaleX * a.scaleX * o.scaleX),
                        (s.scaleY = r.scaleY * a.scaleY * o.scaleY),
                        t.DragonBones.yDown
                          ? ((s.y = r.y + a.y + o.y),
                            (s.skew = r.skew + a.skew + o.skew),
                            (s.rotation = r.rotation + a.rotation + o.rotation))
                          : ((s.y = r.y - a.y + o.y),
                            (s.skew = r.skew - a.skew + o.skew),
                            (s.rotation =
                              r.rotation - a.rotation + o.rotation)))
                      : (s.copyFrom(a),
                        t.DragonBones.yDown ||
                          ((s.y = -s.y),
                          (s.skew = -s.skew),
                          (s.rotation = -s.rotation)),
                        s.add(o))
                    : 0 === this.offsetMode
                    ? null !== r
                      ? s.copyFrom(r).add(o)
                      : s.copyFrom(o)
                    : ((u = !1),
                      s.copyFrom(a),
                      t.DragonBones.yDown ||
                        ((s.y = -s.y),
                        (s.skew = -s.skew),
                        (s.rotation = -s.rotation))),
                  u)
                ) {
                  var d =
                    0 === h._boneData.type
                      ? h.globalTransformMatrix
                      : h._getGlobalTransformMatrix(s.x, s.y);
                  if (i.inheritScale)
                    i.inheritRotation ||
                      (h.updateGlobalTransform(),
                      (_ =
                        l && c
                          ? s.rotation - (h.global.rotation + Math.PI)
                          : l
                          ? s.rotation + h.global.rotation + Math.PI
                          : c
                          ? s.rotation + h.global.rotation
                          : s.rotation - h.global.rotation),
                      (s.rotation = _)),
                      s.toMatrix(n),
                      n.concat(d),
                      i.inheritTranslation
                        ? ((s.x = n.tx), (s.y = n.ty))
                        : ((n.tx = s.x), (n.ty = s.y)),
                      e ? s.fromMatrix(n) : (this._globalDirty = !0);
                  else {
                    if (i.inheritTranslation) {
                      var p = s.x,
                        m = s.y;
                      (s.x = d.a * p + d.c * m + d.tx),
                        (s.y = d.b * p + d.d * m + d.ty);
                    } else l && (s.x = -s.x), c && (s.y = -s.y);
                    i.inheritRotation
                      ? (h.updateGlobalTransform(),
                        (_ =
                          h.global.scaleX < 0
                            ? s.rotation + h.global.rotation + Math.PI
                            : s.rotation + h.global.rotation),
                        d.a * d.d - d.b * d.c < 0 &&
                          ((_ -= 2 * s.rotation),
                          (l !== c || i.inheritReflection) &&
                            (s.skew += Math.PI),
                          t.DragonBones.yDown || (s.skew = -s.skew)),
                        (s.rotation = _))
                      : (l || c) &&
                        (l && c
                          ? (_ = s.rotation + Math.PI)
                          : ((_ = l ? Math.PI - s.rotation : -s.rotation),
                            (s.skew += Math.PI)),
                        (s.rotation = _)),
                      s.toMatrix(n);
                  }
                } else
                  (l || c) &&
                    (l && (s.x = -s.x),
                    c && (s.y = -s.y),
                    l && c
                      ? (_ = s.rotation + Math.PI)
                      : ((_ = l ? Math.PI - s.rotation : -s.rotation),
                        (s.skew += Math.PI)),
                    (s.rotation = _)),
                    s.toMatrix(n);
              }),
              (i.prototype.init = function (t, e) {
                null === this._boneData &&
                  ((this._boneData = t),
                  (this._armature = e),
                  null !== this._boneData.parent &&
                    (this._parent = this._armature.getBone(
                      this._boneData.parent.name
                    )),
                  this._armature._addBone(this),
                  (this.origin = this._boneData.transform));
              }),
              (i.prototype.update = function (t) {
                if (
                  ((this._blendState.dirty = !1),
                  t >= 0 && null !== this._cachedFrameIndices)
                ) {
                  var e = this._cachedFrameIndices[t];
                  if (e >= 0 && this._cachedFrameIndex === e)
                    this._transformDirty = !1;
                  else if (e >= 0)
                    (this._transformDirty = !0), (this._cachedFrameIndex = e);
                  else {
                    if (this._hasConstraint)
                      for (
                        var i = 0, s = this._armature._constraints;
                        i < s.length;
                        i++
                      )
                        (a = s[i])._root === this && a.update();
                    this._transformDirty ||
                    (null !== this._parent &&
                      this._parent._childrenTransformDirty)
                      ? ((this._transformDirty = !0),
                        (this._cachedFrameIndex = -1))
                      : this._cachedFrameIndex >= 0
                      ? ((this._transformDirty = !1),
                        (this._cachedFrameIndices[t] = this._cachedFrameIndex))
                      : ((this._transformDirty = !0),
                        (this._cachedFrameIndex = -1));
                  }
                } else {
                  if (this._hasConstraint)
                    for (
                      var n = 0, r = this._armature._constraints;
                      n < r.length;
                      n++
                    ) {
                      var a;
                      (a = r[n])._root === this && a.update();
                    }
                  (this._transformDirty ||
                    (null !== this._parent &&
                      this._parent._childrenTransformDirty)) &&
                    ((t = -1),
                    (this._transformDirty = !0),
                    (this._cachedFrameIndex = -1));
                }
                if (this._transformDirty)
                  if (
                    ((this._transformDirty = !1),
                    (this._childrenTransformDirty = !0),
                    this._cachedFrameIndex < 0)
                  ) {
                    var o = t >= 0;
                    this._localDirty && this._updateGlobalTransformMatrix(o),
                      o &&
                        null !== this._cachedFrameIndices &&
                        (this._cachedFrameIndex = this._cachedFrameIndices[t] =
                          this._armature._armatureData.setCacheFrame(
                            this.globalTransformMatrix,
                            this.global
                          ));
                  } else
                    this._armature._armatureData.getCacheFrame(
                      this.globalTransformMatrix,
                      this.global,
                      this._cachedFrameIndex
                    );
                else
                  this._childrenTransformDirty &&
                    (this._childrenTransformDirty = !1);
                this._localDirty = !0;
              }),
              (i.prototype.updateByConstraint = function () {
                this._localDirty &&
                  ((this._localDirty = !1),
                  (this._transformDirty ||
                    (null !== this._parent &&
                      this._parent._childrenTransformDirty)) &&
                    this._updateGlobalTransformMatrix(!0),
                  (this._transformDirty = !0));
              }),
              (i.prototype.invalidUpdate = function () {
                this._transformDirty = !0;
              }),
              (i.prototype.contains = function (t) {
                if (t === this) return !1;
                for (var e = t; e !== this && null !== e; ) e = e.parent;
                return e === this;
              }),
              Object.defineProperty(i.prototype, "boneData", {
                get: function () {
                  return this._boneData;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "visible", {
                get: function () {
                  return this._visible;
                },
                set: function (t) {
                  if (this._visible !== t) {
                    this._visible = t;
                    for (
                      var e = 0, i = this._armature.getSlots();
                      e < i.length;
                      e++
                    ) {
                      var s = i[e];
                      s.parent === this && s._updateVisible();
                    }
                  }
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "name", {
                get: function () {
                  return this._boneData.name;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "parent", {
                get: function () {
                  return this._parent;
                },
                enumerable: !0,
                configurable: !0,
              }),
              (i.prototype.getBones = function () {
                console.warn("Deprecated.");
                for (
                  var t = new Array(), e = 0, i = this._armature.getBones();
                  e < i.length;
                  e++
                ) {
                  var s = i[e];
                  s.parent === this && t.push(s);
                }
                return t;
              }),
              (i.prototype.getSlots = function () {
                console.warn("Deprecated.");
                for (
                  var t = new Array(), e = 0, i = this._armature.getSlots();
                  e < i.length;
                  e++
                ) {
                  var s = i[e];
                  s.parent === this && t.push(s);
                }
                return t;
              }),
              Object.defineProperty(i.prototype, "slot", {
                get: function () {
                  console.warn("Deprecated.");
                  for (
                    var t = 0, e = this._armature.getSlots();
                    t < e.length;
                    t++
                  ) {
                    var i = e[t];
                    if (i.parent === this) return i;
                  }
                  return null;
                },
                enumerable: !0,
                configurable: !0,
              }),
              i
            );
          })(t.TransformObject);
          t.Bone = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (
                (e._vertices = []),
                (e._deformVertices = []),
                (e._hullCache = []),
                (e._matrixCahce = []),
                e
              );
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.Surface]";
              }),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this),
                  (this._dX = 0),
                  (this._dY = 0),
                  (this._k = 0),
                  (this._kX = 0),
                  (this._kY = 0),
                  (this._vertices.length = 0),
                  (this._deformVertices.length = 0),
                  (this._matrixCahce.length = 0),
                  (this._hullCache.length = 0);
              }),
              (e.prototype._getAffineTransform = function (
                t,
                e,
                i,
                s,
                n,
                r,
                a,
                o,
                h,
                l,
                c,
                u,
                _
              ) {
                var d = a - n,
                  p = o - r,
                  m = h - n,
                  f = l - r;
                (c.rotation = Math.atan2(p, d)),
                  (c.skew = Math.atan2(f, m) - 0.5 * Math.PI - c.rotation),
                  _ && (c.rotation += Math.PI),
                  (c.scaleX = Math.sqrt(d * d + p * p) / i),
                  (c.scaleY = Math.sqrt(m * m + f * f) / s),
                  c.toMatrix(u),
                  (c.x = u.tx = n - (u.a * t + u.c * e)),
                  (c.y = u.ty = r - (u.b * t + u.d * e));
              }),
              (e.prototype._updateVertices = function () {
                var t = this._boneData.vertices,
                  e = this._vertices,
                  i = this._deformVertices;
                if (null !== this._parent)
                  if (1 === this._parent._boneData.type)
                    for (var s = 0, n = t.length; s < n; s += 2) {
                      var r = t[s] + i[s],
                        a = t[s + 1] + i[s],
                        o = this._parent._getGlobalTransformMatrix(r, a);
                      (e[s] = o.a * r + o.c * a + o.tx),
                        (e[s + 1] = o.b * r + o.d * a + o.ty);
                    }
                  else {
                    var h = this._parent.globalTransformMatrix;
                    for (s = 0, n = t.length; s < n; s += 2)
                      (r = t[s] + i[s]),
                        (a = t[s + 1] + i[s + 1]),
                        (e[s] = h.a * r + h.c * a + h.tx),
                        (e[s + 1] = h.b * r + h.d * a + h.ty);
                  }
                else
                  for (s = 0, n = t.length; s < n; s += 2)
                    (e[s] = t[s] + i[s]), (e[s + 1] = t[s + 1] + i[s + 1]);
              }),
              (e.prototype._updateGlobalTransformMatrix = function () {
                var t = 2 * this._boneData.segmentX,
                  e = this._vertices.length - 2,
                  i = this._vertices[0],
                  s = this._vertices[1],
                  n = this._vertices[t],
                  r = this._vertices[t + 1],
                  a = this._vertices[e],
                  o = this._vertices[e + 1],
                  h = this._vertices[e - t],
                  l = this._vertices[e - t + 1],
                  c = i + 0.5 * (a - i),
                  u = s + 0.5 * (o - s),
                  _ = c + 0.5 * (n + 0.5 * (h - n) - c),
                  d = u + 0.5 * (r + 0.5 * (l - r) - u),
                  p = n + 0.5 * (a - n),
                  m = r + 0.5 * (o - r),
                  f = h + 0.5 * (a - h),
                  g = l + 0.5 * (o - l);
                (this._globalDirty = !1),
                  this._getAffineTransform(
                    0,
                    0,
                    200,
                    200,
                    _,
                    d,
                    p,
                    m,
                    f,
                    g,
                    this.global,
                    this.globalTransformMatrix,
                    !1
                  );
              }),
              (e.prototype._getGlobalTransformMatrix = function (t, i) {
                var s = 1e3;
                if (t < -s || s < t || i < -s || s < i)
                  return this.globalTransformMatrix;
                var n = !1,
                  r = 200,
                  a = this._boneData,
                  o = a.segmentX,
                  h = a.segmentY,
                  l = 2 * a.segmentX,
                  c = this._dX,
                  u = this._dY,
                  _ = Math.floor((t + r) / c),
                  d = Math.floor((i + r) / u),
                  p = 0,
                  m = _ * c - r,
                  f = d * u - r,
                  g = this._matrixCahce,
                  y = e._helpMatrix;
                if (t < -r) {
                  if (i < -r || i >= r) return this.globalTransformMatrix;
                  if (
                    ((p =
                      7 *
                      (2 * (o * (h + 1) + 2 * o + h + d) +
                        ((n = i > this._kX * (t + r) + f) ? 1 : 0))),
                    this._matrixCahce[p] > 0)
                  )
                    y.copyFromArray(g, p + 1);
                  else {
                    var T = d * (l + 2),
                      S = this._hullCache[4],
                      E = this._hullCache[5],
                      v = this._hullCache[2] - (h - d) * S,
                      b = this._hullCache[3] - (h - d) * E,
                      A = this._vertices;
                    n
                      ? this._getAffineTransform(
                          -r,
                          f + u,
                          800,
                          u,
                          A[T + l + 2],
                          A[T + l + 3],
                          v + S,
                          b + E,
                          A[T],
                          A[T + 1],
                          e._helpTransform,
                          y,
                          !0
                        )
                      : this._getAffineTransform(
                          -s,
                          f,
                          800,
                          u,
                          v,
                          b,
                          A[T],
                          A[T + 1],
                          v + S,
                          b + E,
                          e._helpTransform,
                          y,
                          !1
                        ),
                      (g[p] = 1),
                      (g[p + 1] = y.a),
                      (g[p + 2] = y.b),
                      (g[p + 3] = y.c),
                      (g[p + 4] = y.d),
                      (g[p + 5] = y.tx),
                      (g[p + 6] = y.ty);
                  }
                } else if (t >= r) {
                  if (i < -r || i >= r) return this.globalTransformMatrix;
                  (p =
                    7 *
                    (2 * (o * (h + 1) + o + d) +
                      ((n = i > this._kX * (t - s) + f) ? 1 : 0))),
                    this._matrixCahce[p] > 0
                      ? y.copyFromArray(g, p + 1)
                      : ((T = (d + 1) * (l + 2) - 2),
                        (S = this._hullCache[4]),
                        (E = this._hullCache[5]),
                        (v = this._hullCache[0] + d * S),
                        (b = this._hullCache[1] + d * E),
                        (A = this._vertices),
                        n
                          ? this._getAffineTransform(
                              s,
                              f + u,
                              800,
                              u,
                              v + S,
                              b + E,
                              A[T + l + 2],
                              A[T + l + 3],
                              v,
                              b,
                              e._helpTransform,
                              y,
                              !0
                            )
                          : this._getAffineTransform(
                              r,
                              f,
                              800,
                              u,
                              A[T],
                              A[T + 1],
                              v,
                              b,
                              A[T + l + 2],
                              A[T + l + 3],
                              e._helpTransform,
                              y,
                              !1
                            ),
                        (g[p] = 1),
                        (g[p + 1] = y.a),
                        (g[p + 2] = y.b),
                        (g[p + 3] = y.c),
                        (g[p + 4] = y.d),
                        (g[p + 5] = y.tx),
                        (g[p + 6] = y.ty));
                } else if (i < -r) {
                  if (t < -r || t >= r) return this.globalTransformMatrix;
                  (p =
                    7 *
                    (o * (h + 1) +
                      2 * _ +
                      ((n = i > this._kY * (t - m - c) - s) ? 1 : 0))),
                    this._matrixCahce[p] > 0
                      ? y.copyFromArray(g, p + 1)
                      : ((T = 2 * _),
                        (S = this._hullCache[10]),
                        (E = this._hullCache[11]),
                        (v = this._hullCache[8] + _ * S),
                        (b = this._hullCache[9] + _ * E),
                        (A = this._vertices),
                        n
                          ? this._getAffineTransform(
                              m + c,
                              -r,
                              c,
                              800,
                              A[T + 2],
                              A[T + 3],
                              A[T],
                              A[T + 1],
                              v + S,
                              b + E,
                              e._helpTransform,
                              y,
                              !0
                            )
                          : this._getAffineTransform(
                              m,
                              -s,
                              c,
                              800,
                              v,
                              b,
                              v + S,
                              b + E,
                              A[T],
                              A[T + 1],
                              e._helpTransform,
                              y,
                              !1
                            ),
                        (g[p] = 1),
                        (g[p + 1] = y.a),
                        (g[p + 2] = y.b),
                        (g[p + 3] = y.c),
                        (g[p + 4] = y.d),
                        (g[p + 5] = y.tx),
                        (g[p + 6] = y.ty));
                } else if (i >= r) {
                  if (t < -r || t >= r) return this.globalTransformMatrix;
                  (p =
                    7 *
                    (2 * (o * (h + 1) + o + h + d) +
                      ((n = i > this._kY * (t - m - c) + r) ? 1 : 0))),
                    this._matrixCahce[p] > 0
                      ? y.copyFromArray(g, p + 1)
                      : ((T = h * (l + 2) + 2 * _),
                        (S = this._hullCache[10]),
                        (E = this._hullCache[11]),
                        (v = this._hullCache[6] - (o - _) * S),
                        (b = this._hullCache[7] - (o - _) * E),
                        (A = this._vertices),
                        n
                          ? this._getAffineTransform(
                              m + c,
                              s,
                              c,
                              800,
                              v + S,
                              b + E,
                              v,
                              b,
                              A[T + 2],
                              A[T + 3],
                              e._helpTransform,
                              y,
                              !0
                            )
                          : this._getAffineTransform(
                              m,
                              r,
                              c,
                              800,
                              A[T],
                              A[T + 1],
                              A[T + 2],
                              A[T + 3],
                              v,
                              b,
                              e._helpTransform,
                              y,
                              !1
                            ),
                        (g[p] = 1),
                        (g[p + 1] = y.a),
                        (g[p + 2] = y.b),
                        (g[p + 3] = y.c),
                        (g[p + 4] = y.d),
                        (g[p + 5] = y.tx),
                        (g[p + 6] = y.ty));
                } else
                  (p =
                    7 *
                    (2 * (o * d + _) +
                      ((n = i > this._k * (t - m - c) + f) ? 1 : 0))),
                    this._matrixCahce[p] > 0
                      ? y.copyFromArray(g, p + 1)
                      : ((T = 2 * _ + d * (l + 2)),
                        (A = this._vertices),
                        n
                          ? this._getAffineTransform(
                              m + c,
                              f + u,
                              c,
                              u,
                              A[T + l + 4],
                              A[T + l + 5],
                              A[T + l + 2],
                              A[T + l + 3],
                              A[T + 2],
                              A[T + 3],
                              e._helpTransform,
                              y,
                              !0
                            )
                          : this._getAffineTransform(
                              m,
                              f,
                              c,
                              u,
                              A[T],
                              A[T + 1],
                              A[T + 2],
                              A[T + 3],
                              A[T + l + 2],
                              A[T + l + 3],
                              e._helpTransform,
                              y,
                              !1
                            ),
                        (g[p] = 1),
                        (g[p + 1] = y.a),
                        (g[p + 2] = y.b),
                        (g[p + 3] = y.c),
                        (g[p + 4] = y.d),
                        (g[p + 5] = y.tx),
                        (g[p + 6] = y.ty));
                return y;
              }),
              (e.prototype.init = function (e, i) {
                if (null === this._boneData) {
                  t.prototype.init.call(this, e, i);
                  var s = e.segmentX,
                    n = e.segmentY,
                    r = e.vertices.length;
                  (this._dX = 400 / s),
                    (this._dY = 400 / n),
                    (this._k = -this._dY / this._dX),
                    (this._kX = -this._dY / 800),
                    (this._kY = -800 / this._dX),
                    (this._vertices.length = r),
                    (this._deformVertices.length = r),
                    (this._matrixCahce.length = 14 * (s * n + 2 * s + 2 * n)),
                    (this._hullCache.length = 10);
                  for (var a = 0; a < r; ++a) this._deformVertices[a] = 0;
                }
              }),
              (e.prototype.update = function (t) {
                if (
                  ((this._blendState.dirty = !1),
                  t >= 0 && null !== this._cachedFrameIndices)
                ) {
                  var i = this._cachedFrameIndices[t];
                  if (i >= 0 && this._cachedFrameIndex === i)
                    this._transformDirty = !1;
                  else if (i >= 0)
                    (this._transformDirty = !0), (this._cachedFrameIndex = i);
                  else {
                    if (this._hasConstraint)
                      for (
                        var s = 0, n = this._armature._constraints;
                        s < n.length;
                        s++
                      )
                        (o = n[s])._root === this && o.update();
                    this._transformDirty ||
                    (null !== this._parent &&
                      this._parent._childrenTransformDirty)
                      ? ((this._transformDirty = !0),
                        (this._cachedFrameIndex = -1))
                      : this._cachedFrameIndex >= 0
                      ? ((this._transformDirty = !1),
                        (this._cachedFrameIndices[t] = this._cachedFrameIndex))
                      : ((this._transformDirty = !0),
                        (this._cachedFrameIndex = -1));
                  }
                } else {
                  if (this._hasConstraint)
                    for (
                      var r = 0, a = this._armature._constraints;
                      r < a.length;
                      r++
                    ) {
                      var o;
                      (o = a[r])._root === this && o.update();
                    }
                  (this._transformDirty ||
                    (null !== this._parent &&
                      this._parent._childrenTransformDirty)) &&
                    ((t = -1),
                    (this._transformDirty = !0),
                    (this._cachedFrameIndex = -1));
                }
                if (this._transformDirty) {
                  (this._transformDirty = !1),
                    (this._childrenTransformDirty = !0);
                  for (var h = 0, l = this._matrixCahce.length; h < l; h += 7)
                    this._matrixCahce[h] = -1;
                  if ((this._updateVertices(), this._cachedFrameIndex < 0)) {
                    var c = t >= 0;
                    this._localDirty && this._updateGlobalTransformMatrix(c),
                      c &&
                        null !== this._cachedFrameIndices &&
                        (this._cachedFrameIndex = this._cachedFrameIndices[t] =
                          this._armature._armatureData.setCacheFrame(
                            this.globalTransformMatrix,
                            this.global
                          ));
                  } else
                    this._armature._armatureData.getCacheFrame(
                      this.globalTransformMatrix,
                      this.global,
                      this._cachedFrameIndex
                    );
                  var u = 2 * this.global.x,
                    _ = 2 * this.global.y,
                    d = e._helpPoint;
                  this.globalTransformMatrix.transformPoint(1e3, -200, d),
                    (this._hullCache[0] = d.x),
                    (this._hullCache[1] = d.y),
                    (this._hullCache[2] = u - d.x),
                    (this._hullCache[3] = _ - d.y),
                    this.globalTransformMatrix.transformPoint(
                      0,
                      this._dY,
                      d,
                      !0
                    ),
                    (this._hullCache[4] = d.x),
                    (this._hullCache[5] = d.y),
                    this.globalTransformMatrix.transformPoint(200, 1e3, d),
                    (this._hullCache[6] = d.x),
                    (this._hullCache[7] = d.y),
                    (this._hullCache[8] = u - d.x),
                    (this._hullCache[9] = _ - d.y),
                    this.globalTransformMatrix.transformPoint(
                      this._dX,
                      0,
                      d,
                      !0
                    ),
                    (this._hullCache[10] = d.x),
                    (this._hullCache[11] = d.y);
                } else
                  this._childrenTransformDirty &&
                    (this._childrenTransformDirty = !1);
                this._localDirty = !0;
              }),
              e
            );
          })(t.Bone);
          t.Surface = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (e) {
            function i() {
              var i = (null !== e && e.apply(this, arguments)) || this;
              return (
                (i._localMatrix = new t.Matrix()),
                (i._colorTransform = new t.ColorTransform()),
                (i._displayDatas = []),
                (i._displayList = []),
                (i._deformVertices = null),
                (i._rawDisplay = null),
                (i._meshDisplay = null),
                i
              );
            }
            return (
              Z2(i, e),
              (i.prototype._onClear = function () {
                e.prototype._onClear.call(this);
                for (
                  var i = [], s = 0, n = this._displayList;
                  s < n.length;
                  s++
                )
                  null !== (o = n[s]) &&
                    o !== this._rawDisplay &&
                    o !== this._meshDisplay &&
                    i.indexOf(o) < 0 &&
                    i.push(o);
                for (var r = 0, a = i; r < a.length; r++) {
                  var o;
                  (o = a[r]) instanceof t.Armature
                    ? o.dispose()
                    : this._disposeDisplay(o, !0);
                }
                null !== this._deformVertices &&
                  this._deformVertices.returnToPool(),
                  null !== this._meshDisplay &&
                    this._meshDisplay !== this._rawDisplay &&
                    this._disposeDisplay(this._meshDisplay, !1),
                  null !== this._rawDisplay &&
                    this._disposeDisplay(this._rawDisplay, !1),
                  (this.displayController = null),
                  (this._displayDirty = !1),
                  (this._zOrderDirty = !1),
                  (this._blendModeDirty = !1),
                  (this._colorDirty = !1),
                  (this._transformDirty = !1),
                  (this._visible = !0),
                  (this._blendMode = 0),
                  (this._displayIndex = -1),
                  (this._animationDisplayIndex = -1),
                  (this._zOrder = 0),
                  (this._cachedFrameIndex = -1),
                  (this._pivotX = 0),
                  (this._pivotY = 0),
                  this._localMatrix.identity(),
                  this._colorTransform.identity(),
                  (this._displayList.length = 0),
                  (this._displayDatas.length = 0),
                  (this._slotData = null),
                  (this._rawDisplayDatas = null),
                  (this._displayData = null),
                  (this._boundingBoxData = null),
                  (this._textureData = null),
                  (this._deformVertices = null),
                  (this._rawDisplay = null),
                  (this._meshDisplay = null),
                  (this._display = null),
                  (this._childArmature = null),
                  (this._parent = null),
                  (this._cachedFrameIndices = null);
              }),
              (i.prototype._getDefaultRawDisplayData = function (t) {
                var e = this._armature._armatureData.defaultSkin;
                if (null !== e) {
                  var i = e.getDisplays(this._slotData.name);
                  if (null !== i) return t < i.length ? i[t] : null;
                }
                return null;
              }),
              (i.prototype._updateDisplayData = function () {
                var e = this._displayData,
                  s =
                    null !== this._deformVertices
                      ? this._deformVertices.verticesData
                      : null,
                  n = this._textureData,
                  r = null,
                  a = null;
                if (
                  ((this._displayData = null),
                  (this._boundingBoxData = null),
                  (this._textureData = null),
                  this._displayIndex >= 0 &&
                    (null !== this._rawDisplayDatas &&
                      (r =
                        this._displayIndex < this._rawDisplayDatas.length
                          ? this._rawDisplayDatas[this._displayIndex]
                          : null),
                    null === r &&
                      (r = this._getDefaultRawDisplayData(this._displayIndex)),
                    this._displayIndex < this._displayDatas.length &&
                      (this._displayData =
                        this._displayDatas[this._displayIndex])),
                  null !== this._displayData &&
                    (2 === this._displayData.type ||
                    4 === this._displayData.type
                      ? (a = this._displayData.vertices)
                      : null !== r &&
                        (2 === r.type || 4 === r.type) &&
                        (a = r.vertices),
                    3 === this._displayData.type
                      ? (this._boundingBoxData = this._displayData.boundingBox)
                      : null !== r &&
                        3 === r.type &&
                        (this._boundingBoxData = r.boundingBox),
                    (0 === this._displayData.type ||
                      2 === this._displayData.type) &&
                      (this._textureData = this._displayData.texture)),
                  this._displayData !== e || a !== s || this._textureData !== n)
                ) {
                  if (null === a && null !== this._textureData) {
                    var o = this._displayData,
                      h =
                        this._textureData.parent.scale *
                        this._armature._armatureData.scale,
                      l = this._textureData.frame;
                    (this._pivotX = o.pivot.x), (this._pivotY = o.pivot.y);
                    var c = null !== l ? l : this._textureData.region,
                      u = c.width,
                      _ = c.height;
                    this._textureData.rotated &&
                      null === l &&
                      ((u = c.height), (_ = c.width)),
                      (this._pivotX *= u * h),
                      (this._pivotY *= _ * h),
                      null !== l &&
                        ((this._pivotX += l.x * h), (this._pivotY += l.y * h)),
                      null !== this._displayData &&
                        null !== r &&
                        this._displayData !== r &&
                        (r.transform.toMatrix(i._helpMatrix),
                        i._helpMatrix.invert(),
                        i._helpMatrix.transformPoint(0, 0, i._helpPoint),
                        (this._pivotX -= i._helpPoint.x),
                        (this._pivotY -= i._helpPoint.y),
                        this._displayData.transform.toMatrix(i._helpMatrix),
                        i._helpMatrix.invert(),
                        i._helpMatrix.transformPoint(0, 0, i._helpPoint),
                        (this._pivotX += i._helpPoint.x),
                        (this._pivotY += i._helpPoint.y)),
                      t.DragonBones.yDown ||
                        (this._pivotY =
                          (this._textureData.rotated
                            ? this._textureData.region.width
                            : this._textureData.region.height) *
                            h -
                          this._pivotY);
                  } else (this._pivotX = 0), (this._pivotY = 0);
                  null !== r
                    ? (this.origin = r.transform)
                    : null !== this._displayData
                    ? (this.origin = this._displayData.transform)
                    : (this.origin = null),
                    a !== s
                      ? (null === this._deformVertices &&
                          (this._deformVertices = t.BaseObject.borrowObject(
                            t.DeformVertices
                          )),
                        this._deformVertices.init(a, this._armature))
                      : null !== this._deformVertices &&
                        this._textureData !== n &&
                        (this._deformVertices.verticesDirty = !0),
                    (this._displayDirty = !0),
                    (this._transformDirty = !0);
                }
              }),
              (i.prototype._updateDisplay = function () {
                var e =
                    null !== this._display ? this._display : this._rawDisplay,
                  i = this._childArmature;
                this._displayIndex >= 0 &&
                this._displayIndex < this._displayList.length
                  ? ((this._display = this._displayList[this._displayIndex]),
                    null !== this._display &&
                    this._display instanceof t.Armature
                      ? ((this._childArmature = this._display),
                        (this._display = this._childArmature.display))
                      : (this._childArmature = null))
                  : ((this._display = null), (this._childArmature = null));
                var s =
                  null !== this._display ? this._display : this._rawDisplay;
                if (
                  (s !== e &&
                    (this._onUpdateDisplay(),
                    this._replaceDisplay(e),
                    (this._transformDirty = !0),
                    (this._visibleDirty = !0),
                    (this._blendModeDirty = !0),
                    (this._colorDirty = !0)),
                  (s !== this._rawDisplay && s !== this._meshDisplay) ||
                    this._updateFrame(),
                  this._childArmature !== i &&
                    (null !== i &&
                      ((i._parent = null),
                      (i.clock = null),
                      i.inheritAnimation && i.animation.reset()),
                    null !== this._childArmature &&
                      ((this._childArmature._parent = this),
                      (this._childArmature.clock = this._armature.clock),
                      this._childArmature.inheritAnimation)))
                ) {
                  if (0 === this._childArmature.cacheFrameRate) {
                    var n = this._armature.cacheFrameRate;
                    0 !== n && (this._childArmature.cacheFrameRate = n);
                  }
                  var r = null;
                  if (
                    null !== this._displayData &&
                    1 === this._displayData.type
                  )
                    r = this._displayData.actions;
                  else if (
                    this._displayIndex >= 0 &&
                    null !== this._rawDisplayDatas
                  ) {
                    var a =
                      this._displayIndex < this._rawDisplayDatas.length
                        ? this._rawDisplayDatas[this._displayIndex]
                        : null;
                    null === a &&
                      (a = this._getDefaultRawDisplayData(this._displayIndex)),
                      null !== a && 1 === a.type && (r = a.actions);
                  }
                  if (null !== r && r.length > 0)
                    for (var o = 0, h = r; o < h.length; o++) {
                      var l = h[o],
                        c = t.BaseObject.borrowObject(t.EventObject);
                      t.EventObject.actionDataToInstance(l, c, this._armature),
                        (c.slot = this),
                        this._armature._bufferAction(c, !1);
                    }
                  else this._childArmature.animation.play();
                }
              }),
              (i.prototype._updateGlobalTransformMatrix = function (t) {
                var e =
                  0 === this._parent._boneData.type
                    ? this._parent.globalTransformMatrix
                    : this._parent._getGlobalTransformMatrix(
                        this.global.x,
                        this.global.y
                      );
                this.globalTransformMatrix.copyFrom(this._localMatrix),
                  this.globalTransformMatrix.concat(e),
                  t
                    ? this.global.fromMatrix(this.globalTransformMatrix)
                    : (this._globalDirty = !0);
              }),
              (i.prototype._setDisplayIndex = function (t, e) {
                if ((void 0 === e && (e = !1), e)) {
                  if (this._animationDisplayIndex === t) return !1;
                  this._animationDisplayIndex = t;
                }
                return (
                  this._displayIndex !== t &&
                  ((this._displayIndex = t),
                  (this._displayDirty = !0),
                  this._updateDisplayData(),
                  this._displayDirty)
                );
              }),
              (i.prototype._setZorder = function (t) {
                return (
                  this._zOrder,
                  (this._zOrder = t),
                  (this._zOrderDirty = !0),
                  this._zOrderDirty
                );
              }),
              (i.prototype._setColor = function (t) {
                return (
                  this._colorTransform.copyFrom(t),
                  (this._colorDirty = !0),
                  this._colorDirty
                );
              }),
              (i.prototype._setDisplayList = function (e) {
                if (null !== e && e.length > 0) {
                  this._displayList.length !== e.length &&
                    (this._displayList.length = e.length);
                  for (var i = 0, s = e.length; i < s; ++i) {
                    var n = e[i];
                    null !== n &&
                      n !== this._rawDisplay &&
                      n !== this._meshDisplay &&
                      !(n instanceof t.Armature) &&
                      this._displayList.indexOf(n) < 0 &&
                      this._initDisplay(n, !0),
                      (this._displayList[i] = n);
                  }
                } else
                  this._displayList.length > 0 &&
                    (this._displayList.length = 0);
                return (
                  this._displayIndex >= 0 &&
                  this._displayIndex < this._displayList.length
                    ? (this._displayDirty =
                        this._display !== this._displayList[this._displayIndex])
                    : (this._displayDirty = null !== this._display),
                  this._updateDisplayData(),
                  this._displayDirty
                );
              }),
              (i.prototype.init = function (t, e, i, s) {
                if (null === this._slotData) {
                  (this._slotData = t),
                    (this._isFromCache = !1),
                    (this._visibleDirty = !0),
                    (this._blendModeDirty = !0),
                    (this._colorDirty = !0),
                    (this._blendMode = this._slotData.blendMode),
                    (this._zOrder = this._slotData.zOrder),
                    this._colorTransform.copyFrom(this._slotData.color),
                    (this._rawDisplay = i),
                    (this._meshDisplay = s),
                    (this._armature = e);
                  var n = this._armature.getBone(this._slotData.parent.name);
                  null !== n && (this._parent = n),
                    this._armature._addSlot(this),
                    this._initDisplay(this._rawDisplay, !1),
                    this._rawDisplay !== this._meshDisplay &&
                      this._initDisplay(this._meshDisplay, !1),
                    this._onUpdateDisplay(),
                    this._addDisplay();
                }
              }),
              (i.prototype.update = function (t) {
                if (
                  ((this._isFromCache = !1),
                  this._displayDirty &&
                    ((this._displayDirty = !1),
                    this._updateDisplay(),
                    this._transformDirty &&
                      (null !== this.origin
                        ? this.global
                            .copyFrom(this.origin)
                            .add(this.offset)
                            .toMatrix(this._localMatrix)
                        : this.global
                            .copyFrom(this.offset)
                            .toMatrix(this._localMatrix))),
                  this._zOrderDirty &&
                    ((this._zOrderDirty = !1), this._updateZOrder()),
                  t >= 0 && null !== this._cachedFrameIndices)
                ) {
                  var e = this._cachedFrameIndices[t];
                  e >= 0 && this._cachedFrameIndex === e
                    ? (this._transformDirty = !1)
                    : e >= 0
                    ? ((this._transformDirty = !0),
                      (this._cachedFrameIndex = e))
                    : this._transformDirty ||
                      this._parent._childrenTransformDirty
                    ? ((this._transformDirty = !0),
                      (this._cachedFrameIndex = -1))
                    : this._cachedFrameIndex >= 0
                    ? ((this._transformDirty = !1),
                      (this._cachedFrameIndices[t] = this._cachedFrameIndex))
                    : ((this._transformDirty = !0),
                      (this._cachedFrameIndex = -1));
                } else
                  (this._transformDirty ||
                    this._parent._childrenTransformDirty) &&
                    ((t = -1),
                    (this._transformDirty = !0),
                    (this._cachedFrameIndex = -1));
                if (null !== this._display) {
                  if (
                    (this._visibleDirty &&
                      ((this._visibleDirty = !1), this._updateVisible()),
                    this._blendModeDirty &&
                      ((this._blendModeDirty = !1), this._updateBlendMode()),
                    this._colorDirty &&
                      ((this._colorDirty = !1), this._updateColor()),
                    null !== this._deformVertices &&
                      null !== this._deformVertices.verticesData &&
                      this._display === this._meshDisplay)
                  ) {
                    var i = null !== this._deformVertices.verticesData.weight,
                      s = 0 !== this._parent._boneData.type;
                    if (
                      ((this._deformVertices.verticesDirty ||
                        (i && this._deformVertices.isBonesUpdate()) ||
                        (s && this._parent._childrenTransformDirty)) &&
                        ((this._deformVertices.verticesDirty = !1),
                        this._updateMesh()),
                      i || s)
                    )
                      return;
                  }
                  if (this._transformDirty) {
                    if (
                      ((this._transformDirty = !1), this._cachedFrameIndex < 0)
                    ) {
                      var n = t >= 0;
                      this._updateGlobalTransformMatrix(n),
                        n &&
                          null !== this._cachedFrameIndices &&
                          (this._cachedFrameIndex = this._cachedFrameIndices[
                            t
                          ] =
                            this._armature._armatureData.setCacheFrame(
                              this.globalTransformMatrix,
                              this.global
                            ));
                    } else
                      (this._isFromCache = !0),
                        this._armature._armatureData.getCacheFrame(
                          this.globalTransformMatrix,
                          this.global,
                          this._cachedFrameIndex
                        );
                    this._updateTransform();
                  }
                }
              }),
              (i.prototype.updateTransformAndMatrix = function () {
                this._transformDirty &&
                  ((this._transformDirty = !1),
                  this._updateGlobalTransformMatrix(!1));
              }),
              (i.prototype.replaceDisplayData = function (t, e) {
                if (
                  (void 0 === e && (e = -1),
                  e < 0 &&
                    (e = this._displayIndex < 0 ? 0 : this._displayIndex),
                  this._displayDatas.length <= e)
                ) {
                  this._displayDatas.length = e + 1;
                  for (var i = 0, s = this._displayDatas.length; i < s; ++i)
                    this._displayDatas[i] || (this._displayDatas[i] = null);
                }
                this._displayDatas[e] = t;
              }),
              (i.prototype.containsPoint = function (t, e) {
                return (
                  null !== this._boundingBoxData &&
                  (this.updateTransformAndMatrix(),
                  i._helpMatrix.copyFrom(this.globalTransformMatrix),
                  i._helpMatrix.invert(),
                  i._helpMatrix.transformPoint(t, e, i._helpPoint),
                  this._boundingBoxData.containsPoint(
                    i._helpPoint.x,
                    i._helpPoint.y
                  ))
                );
              }),
              (i.prototype.intersectsSegment = function (t, e, s, n, r, a, o) {
                if (
                  (void 0 === r && (r = null),
                  void 0 === a && (a = null),
                  void 0 === o && (o = null),
                  null === this._boundingBoxData)
                )
                  return 0;
                this.updateTransformAndMatrix(),
                  i._helpMatrix.copyFrom(this.globalTransformMatrix),
                  i._helpMatrix.invert(),
                  i._helpMatrix.transformPoint(t, e, i._helpPoint),
                  (t = i._helpPoint.x),
                  (e = i._helpPoint.y),
                  i._helpMatrix.transformPoint(s, n, i._helpPoint),
                  (s = i._helpPoint.x),
                  (n = i._helpPoint.y);
                var h = this._boundingBoxData.intersectsSegment(
                  t,
                  e,
                  s,
                  n,
                  r,
                  a,
                  o
                );
                return (
                  h > 0 &&
                    (1 === h || 2 === h
                      ? null !== r
                        ? (this.globalTransformMatrix.transformPoint(
                            r.x,
                            r.y,
                            r
                          ),
                          null !== a && ((a.x = r.x), (a.y = r.y)))
                        : null !== a &&
                          this.globalTransformMatrix.transformPoint(a.x, a.y, a)
                      : (null !== r &&
                          this.globalTransformMatrix.transformPoint(
                            r.x,
                            r.y,
                            r
                          ),
                        null !== a &&
                          this.globalTransformMatrix.transformPoint(
                            a.x,
                            a.y,
                            a
                          )),
                    null !== o &&
                      (this.globalTransformMatrix.transformPoint(
                        Math.cos(o.x),
                        Math.sin(o.x),
                        i._helpPoint,
                        !0
                      ),
                      (o.x = Math.atan2(i._helpPoint.y, i._helpPoint.x)),
                      this.globalTransformMatrix.transformPoint(
                        Math.cos(o.y),
                        Math.sin(o.y),
                        i._helpPoint,
                        !0
                      ),
                      (o.y = Math.atan2(i._helpPoint.y, i._helpPoint.x)))),
                  h
                );
              }),
              (i.prototype.invalidUpdate = function () {
                (this._displayDirty = !0), (this._transformDirty = !0);
              }),
              Object.defineProperty(i.prototype, "visible", {
                get: function () {
                  return this._visible;
                },
                set: function (t) {
                  this._visible !== t &&
                    ((this._visible = t), this._updateVisible());
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "displayIndex", {
                get: function () {
                  return this._displayIndex;
                },
                set: function (t) {
                  this._setDisplayIndex(t) && this.update(-1);
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "name", {
                get: function () {
                  return this._slotData.name;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "displayList", {
                get: function () {
                  return this._displayList.concat();
                },
                set: function (e) {
                  var i = this._displayList.concat(),
                    s = new Array();
                  this._setDisplayList(e) && this.update(-1);
                  for (var n = 0, r = i; n < r.length; n++)
                    null !== (h = r[n]) &&
                      h !== this._rawDisplay &&
                      h !== this._meshDisplay &&
                      this._displayList.indexOf(h) < 0 &&
                      s.indexOf(h) < 0 &&
                      s.push(h);
                  for (var a = 0, o = s; a < o.length; a++) {
                    var h;
                    (h = o[a]) instanceof t.Armature ||
                      this._disposeDisplay(h, !0);
                  }
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "slotData", {
                get: function () {
                  return this._slotData;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "rawDisplayDatas", {
                get: function () {
                  return this._rawDisplayDatas;
                },
                set: function (t) {
                  if (this._rawDisplayDatas !== t)
                    if (
                      ((this._displayDirty = !0),
                      (this._rawDisplayDatas = t),
                      null !== this._rawDisplayDatas)
                    ) {
                      this._displayDatas.length = this._rawDisplayDatas.length;
                      for (
                        var e = 0, i = this._displayDatas.length;
                        e < i;
                        ++e
                      ) {
                        var s = this._rawDisplayDatas[e];
                        null === s && (s = this._getDefaultRawDisplayData(e)),
                          (this._displayDatas[e] = s);
                      }
                    } else this._displayDatas.length = 0;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "displayData", {
                get: function () {
                  return this._displayData;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "boundingBoxData", {
                get: function () {
                  return this._boundingBoxData;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "rawDisplay", {
                get: function () {
                  return this._rawDisplay;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "meshDisplay", {
                get: function () {
                  return this._meshDisplay;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "display", {
                get: function () {
                  return this._display;
                },
                set: function (t) {
                  if (this._display !== t) {
                    var e = this._displayList.length;
                    if (
                      (this._displayIndex < 0 &&
                        0 === e &&
                        (this._displayIndex = 0),
                      !(this._displayIndex < 0))
                    ) {
                      var i = this.displayList;
                      e <= this._displayIndex &&
                        (i.length = this._displayIndex + 1),
                        (i[this._displayIndex] = t),
                        (this.displayList = i);
                    }
                  }
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "childArmature", {
                get: function () {
                  return this._childArmature;
                },
                set: function (t) {
                  this._childArmature !== t && (this.display = t);
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "parent", {
                get: function () {
                  return this._parent;
                },
                enumerable: !0,
                configurable: !0,
              }),
              (i.prototype.getDisplay = function () {
                return this._display;
              }),
              (i.prototype.setDisplay = function (t) {
                this.display = t;
              }),
              i
            );
          })(t.TransformObject);
          t.Slot = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (e) {
            function i() {
              return (null !== e && e.apply(this, arguments)) || this;
            }
            return (
              Z2(i, e),
              (i.prototype._onClear = function () {
                (this._armature = null),
                  (this._target = null),
                  (this._root = null),
                  (this._bone = null);
              }),
              Object.defineProperty(i.prototype, "name", {
                get: function () {
                  return this._constraintData.name;
                },
                enumerable: !0,
                configurable: !0,
              }),
              (i._helpMatrix = new t.Matrix()),
              (i._helpTransform = new t.Transform()),
              (i._helpPoint = new t.Point()),
              i
            );
          })(t.BaseObject);
          t.Constraint = e;
          var i = (function (e) {
            function i() {
              return (null !== e && e.apply(this, arguments)) || this;
            }
            return (
              Z2(i, e),
              (i.toString = function () {
                return "[class dragonBones.IKConstraint]";
              }),
              (i.prototype._onClear = function () {
                e.prototype._onClear.call(this),
                  (this._scaleEnabled = !1),
                  (this._bendPositive = !1),
                  (this._weight = 1),
                  (this._constraintData = null);
              }),
              (i.prototype._computeA = function () {
                var e = this._target.global,
                  i = this._root.global,
                  s = this._root.globalTransformMatrix,
                  n = Math.atan2(e.y - i.y, e.x - i.x);
                i.scaleX < 0 && (n += Math.PI),
                  (i.rotation +=
                    t.Transform.normalizeRadian(n - i.rotation) * this._weight),
                  i.toMatrix(s);
              }),
              (i.prototype._computeB = function () {
                var e = this._bone._boneData.length,
                  i = this._root,
                  s = this._target.global,
                  n = i.global,
                  r = this._bone.global,
                  a = this._bone.globalTransformMatrix,
                  o = a.a * e,
                  h = a.b * e,
                  l = o * o + h * h,
                  c = Math.sqrt(l),
                  u = r.x - n.x,
                  _ = r.y - n.y,
                  d = u * u + _ * _,
                  p = Math.sqrt(d),
                  m = r.rotation,
                  f = n.rotation,
                  g = Math.atan2(_, u),
                  y = (u = s.x - n.x) * u + (_ = s.y - n.y) * _,
                  T = Math.sqrt(y),
                  S = 0;
                if (c + p <= T || T + c <= p || T + p <= c)
                  (S = Math.atan2(s.y - n.y, s.x - n.x)),
                    c + p <= T || (p < c && (S += Math.PI));
                else {
                  var E = (d - l + y) / (2 * y),
                    v = Math.sqrt(d - E * E * y) / T,
                    b = n.x + u * E,
                    A = n.y + _ * E,
                    C = -_ * v,
                    O = u * v,
                    I = !1,
                    w = i.parent;
                  if (null !== w) {
                    var R = w.globalTransformMatrix;
                    I = R.a * R.d - R.b * R.c < 0;
                  }
                  I !== this._bendPositive
                    ? ((r.x = b - C), (r.y = A - O))
                    : ((r.x = b + C), (r.y = A + O)),
                    (S = Math.atan2(r.y - n.y, r.x - n.x));
                }
                var D = t.Transform.normalizeRadian(S - g);
                (n.rotation = f + D * this._weight),
                  n.toMatrix(i.globalTransformMatrix);
                var x = g + D * this._weight;
                (r.x = n.x + Math.cos(x) * p), (r.y = n.y + Math.sin(x) * p);
                var M = Math.atan2(s.y - r.y, s.x - r.x);
                r.scaleX < 0 && (M += Math.PI),
                  (r.rotation =
                    n.rotation +
                    m -
                    f +
                    t.Transform.normalizeRadian(M - D - m) * this._weight),
                  r.toMatrix(a);
              }),
              (i.prototype.init = function (t, e) {
                if (null === this._constraintData) {
                  (this._constraintData = t),
                    (this._armature = e),
                    (this._target = this._armature.getBone(
                      this._constraintData.target.name
                    )),
                    (this._root = this._armature.getBone(
                      this._constraintData.root.name
                    )),
                    (this._bone =
                      null !== this._constraintData.bone
                        ? this._armature.getBone(this._constraintData.bone.name)
                        : null);
                  var i = this._constraintData;
                  (this._scaleEnabled = i.scaleEnabled),
                    (this._bendPositive = i.bendPositive),
                    (this._weight = i.weight),
                    (this._root._hasConstraint = !0);
                }
              }),
              (i.prototype.update = function () {
                this._root.updateByConstraint(),
                  null !== this._bone
                    ? (this._bone.updateByConstraint(), this._computeB())
                    : this._computeA();
              }),
              (i.prototype.invalidUpdate = function () {
                this._root.invalidUpdate(),
                  null !== this._bone && this._bone.invalidUpdate();
              }),
              i
            );
          })(e);
          t.IKConstraint = i;
          var s = (function (e) {
            function i() {
              var t = (null !== e && e.apply(this, arguments)) || this;
              return (
                (t._bones = []),
                (t._spaces = []),
                (t._positions = []),
                (t._curves = []),
                (t._boneLengths = []),
                (t._pathGlobalVertices = []),
                (t._segments = [10]),
                t
              );
            }
            return (
              Z2(i, e),
              (i.toString = function () {
                return "[class dragonBones.PathConstraint]";
              }),
              (i.prototype._onClear = function () {
                e.prototype._onClear.call(this),
                  (this.dirty = !1),
                  (this.pathOffset = 0),
                  (this.position = 0),
                  (this.spacing = 0),
                  (this.rotateOffset = 0),
                  (this.rotateMix = 1),
                  (this.translateMix = 1),
                  (this._pathSlot = null),
                  (this._bones.length = 0),
                  (this._spaces.length = 0),
                  (this._positions.length = 0),
                  (this._curves.length = 0),
                  (this._boneLengths.length = 0),
                  (this._pathGlobalVertices.length = 0);
              }),
              (i.prototype._updatePathVertices = function (t) {
                var e = this._armature,
                  i = e.armatureData.parent,
                  s = e.armatureData.scale,
                  n = i.intArray,
                  r = i.floatArray,
                  a = t.offset,
                  o = n[a + 0],
                  h = n[a + 2];
                this._pathGlobalVertices.length = 2 * o;
                var l = t.weight;
                if (null !== l)
                  for (
                    var c = this._pathSlot._deformVertices.bones,
                      u = l.bones.length,
                      _ = l.offset,
                      d = n[_ + 1],
                      p = _ + 2 + u,
                      m = ((A = 0), 0);
                    A < o;
                    A++
                  ) {
                    for (var f = 0, g = 0, y = 0, T = n[p++]; y < T; y++) {
                      var S = c[n[p++]];
                      if (null !== S) {
                        S.updateByConstraint(), (b = S.globalTransformMatrix);
                        var E = r[d++];
                        (O = r[d++] * s),
                          (I = r[d++] * s),
                          (f += (b.a * O + b.c * I + b.tx) * E),
                          (g += (b.b * O + b.d * I + b.ty) * E);
                      }
                    }
                    (this._pathGlobalVertices[m++] = f),
                      (this._pathGlobalVertices[m++] = g);
                  }
                else {
                  var v = this._pathSlot.parent;
                  v.updateByConstraint();
                  for (
                    var b = v.globalTransformMatrix, A = 0, C = h;
                    A < o;
                    A += 2
                  ) {
                    var O = r[C++] * s,
                      I = r[C++] * s,
                      w = b.a * O + b.c * I + b.tx,
                      R = b.b * O + b.d * I + b.ty;
                    (this._pathGlobalVertices[A] = w),
                      (this._pathGlobalVertices[A + 1] = R);
                  }
                }
              }),
              (i.prototype._computeVertices = function (t, e, i, s) {
                for (var n = i, r = t; n < e; n += 2)
                  (s[n] = this._pathGlobalVertices[r++]),
                    (s[n + 1] = this._pathGlobalVertices[r++]);
              }),
              (i.prototype._computeBezierCurve = function (t, e, i, s, n) {
                var r =
                    this._armature.armatureData.parent.intArray[
                      t.vertices.offset + 0
                    ],
                  a = this._positions,
                  o = this._spaces,
                  h = t.closed,
                  l = Array(),
                  c = 2 * r,
                  u = c / 6,
                  _ = -1,
                  d = this.position;
                a.length = 3 * e + 2;
                var p = 0;
                if (t.constantSpeed) {
                  h
                    ? ((c += 2),
                      (l.length = r),
                      this._computeVertices(2, c - 4, 0, l),
                      this._computeVertices(0, 2, c - 4, l),
                      (l[c - 2] = l[0]),
                      (l[c - 1] = l[1]))
                    : (u--,
                      (c -= 4),
                      (l.length = c),
                      this._computeVertices(2, c, 0, l));
                  var m = new Array(u);
                  p = 0;
                  for (
                    var f,
                      g,
                      y,
                      T,
                      S,
                      E,
                      v,
                      b,
                      A = l[0],
                      C = l[1],
                      O = 0,
                      I = 0,
                      w = 0,
                      R = 0,
                      D = 0,
                      x = 0,
                      M = ((G = 0), 2);
                    G < u;
                    G++, M += 6
                  )
                    (O = l[M]),
                      (I = l[M + 1]),
                      (w = l[M + 2]),
                      (R = l[M + 3]),
                      (S =
                        2 * (f = 0.1875 * (A - 2 * O + w)) +
                        (y = 0.09375 * (3 * (O - w) - A + (D = l[M + 4])))),
                      (E =
                        2 * (g = 0.1875 * (C - 2 * I + R)) +
                        (T = 0.09375 * (3 * (I - R) - C + (x = l[M + 5])))),
                      (v = 0.75 * (O - A) + f + 0.16666667 * y),
                      (b = 0.75 * (I - C) + g + 0.16666667 * T),
                      (p += Math.sqrt(v * v + b * b)),
                      (v += S),
                      (b += E),
                      (S += y),
                      (E += T),
                      (p += Math.sqrt(v * v + b * b)),
                      (v += S),
                      (b += E),
                      (p += Math.sqrt(v * v + b * b)),
                      (v += S + y),
                      (b += E + T),
                      (p += Math.sqrt(v * v + b * b)),
                      (m[G] = p),
                      (A = D),
                      (C = x);
                  if ((s && (d *= p), n)) for (G = 0; G < e; G++) o[G] *= p;
                  for (
                    var P = this._segments,
                      N = 0,
                      L = ((G = 0), (V = 0), (j = 0), 0);
                    G < e;
                    G++, V += 3
                  ) {
                    var B = (d += o[G]);
                    if (h) (B %= p) < 0 && (B += p), (j = 0);
                    else {
                      if (B < 0) continue;
                      if (B > p) continue;
                    }
                    for (; ; j++) {
                      var F = m[j];
                      if (!(B > F)) {
                        0 === j
                          ? (B /= F)
                          : (B = (B - (z = m[j - 1])) / (F - z));
                        break;
                      }
                    }
                    if (j !== _) {
                      _ = j;
                      var U = 6 * j;
                      for (
                        A = l[U],
                          C = l[U + 1],
                          O = l[U + 2],
                          I = l[U + 3],
                          w = l[U + 4],
                          R = l[U + 5],
                          S =
                            2 * (f = 0.03 * (A - 2 * O + w)) +
                            (y = 0.006 * (3 * (O - w) - A + (D = l[U + 6]))),
                          E =
                            2 * (g = 0.03 * (C - 2 * I + R)) +
                            (T = 0.006 * (3 * (I - R) - C + (x = l[U + 7]))),
                          v = 0.3 * (O - A) + f + 0.16666667 * y,
                          b = 0.3 * (I - C) + g + 0.16666667 * T,
                          N = Math.sqrt(v * v + b * b),
                          P[0] = N,
                          U = 1;
                        U < 8;
                        U++
                      )
                        (v += S),
                          (b += E),
                          (S += y),
                          (E += T),
                          (N += Math.sqrt(v * v + b * b)),
                          (P[U] = N);
                      (v += S),
                        (b += E),
                        (N += Math.sqrt(v * v + b * b)),
                        (P[8] = N),
                        (v += S + y),
                        (b += E + T),
                        (N += Math.sqrt(v * v + b * b)),
                        (P[9] = N),
                        (L = 0);
                    }
                    for (B *= N; ; L++) {
                      var k = P[L];
                      if (!(B > k)) {
                        var z;
                        0 === L
                          ? (B /= k)
                          : (B = L + (B - (z = P[L - 1])) / (k - z));
                        break;
                      }
                    }
                    this.addCurvePosition(
                      0.1 * B,
                      A,
                      C,
                      O,
                      I,
                      w,
                      R,
                      D,
                      x,
                      a,
                      V,
                      i
                    );
                  }
                } else {
                  var H = t.curveLengths;
                  if (((p = H[(u -= h ? 1 : 2)]), s && (d *= p), n))
                    for (var G = 0; G < e; G++) o[G] *= p;
                  l.length = 8;
                  G = 0;
                  for (var V = 0, j = 0; G < e; G++, V += 3) {
                    if (((d += o[G]), h)) (d %= p) < 0 && (d += p), (j = 0);
                    else {
                      if (d < 0) continue;
                      if (d > p) continue;
                    }
                    for (var W = 0; ; j++) {
                      var X = H[j];
                      if (!(d > X)) {
                        if (0 === j) W = d / X;
                        else {
                          var Y = H[j - 1];
                          W = (d - Y) / (X - Y);
                        }
                        break;
                      }
                    }
                    j !== _ &&
                      ((_ = j),
                      h && j === u
                        ? (this._computeVertices(c - 4, 4, 0, l),
                          this._computeVertices(0, 4, 4, l))
                        : this._computeVertices(6 * j + 2, 8, 0, l)),
                      this.addCurvePosition(
                        W,
                        l[0],
                        l[1],
                        l[2],
                        l[3],
                        l[4],
                        l[5],
                        l[6],
                        l[7],
                        a,
                        V,
                        i
                      );
                  }
                }
              }),
              (i.prototype.addCurvePosition = function (
                t,
                e,
                i,
                s,
                n,
                r,
                a,
                o,
                h,
                l,
                c,
                u
              ) {
                if (0 === t)
                  return (l[c] = e), (l[c + 1] = i), void (l[c + 2] = 0);
                if (1 === t)
                  return (l[c] = o), (l[c + 1] = h), void (l[c + 2] = 0);
                var _ = 1 - t,
                  d = _ * _,
                  p = t * t,
                  m = d * _,
                  f = d * t * 3,
                  g = _ * p * 3,
                  y = t * p,
                  T = m * e + f * s + g * r + y * o,
                  S = m * i + f * n + g * a + y * h;
                (l[c] = T),
                  (l[c + 1] = S),
                  (l[c + 2] = u
                    ? Math.atan2(
                        S - (m * i + f * n + g * a),
                        T - (m * e + f * s + g * r)
                      )
                    : 0);
              }),
              (i.prototype.init = function (t, e) {
                (this._constraintData = t), (this._armature = e);
                var i = t;
                (this.pathOffset = i.pathDisplayData.vertices.offset),
                  (this.position = i.position),
                  (this.spacing = i.spacing),
                  (this.rotateOffset = i.rotateOffset),
                  (this.rotateMix = i.rotateMix),
                  (this.translateMix = i.translateMix),
                  (this._root = this._armature.getBone(i.root.name)),
                  (this._target = this._armature.getBone(i.target.name)),
                  (this._pathSlot = this._armature.getSlot(i.pathSlot.name));
                for (var s = 0, n = i.bones.length; s < n; s++) {
                  var r = this._armature.getBone(i.bones[s].name);
                  null !== r && this._bones.push(r);
                }
                2 === i.rotateMode &&
                  (this._boneLengths.length = this._bones.length),
                  (this._root._hasConstraint = !0);
              }),
              (i.prototype.update = function () {
                var e = this._pathSlot;
                if (
                  null !== e._deformVertices &&
                  null !== e._deformVertices.verticesData &&
                  e._deformVertices.verticesData.offset === this.pathOffset
                ) {
                  var i = this._constraintData,
                    s = e._displayData,
                    n = !1,
                    r = e._deformVertices;
                  if (
                    (this._root._childrenTransformDirty
                      ? (this._updatePathVertices(s.vertices), (n = !0))
                      : null !== r &&
                        (r.verticesDirty || r.isBonesUpdate()) &&
                        (this._updatePathVertices(s.vertices),
                        (r.verticesDirty = !1),
                        (n = !0)),
                    n || this.dirty)
                  ) {
                    var a = i.positionMode,
                      o = i.spacingMode,
                      h = i.rotateMode,
                      l = this._bones,
                      c = 0 === o,
                      u = 2 === h,
                      _ = 0 === h,
                      d = l.length,
                      p = _ ? d : d + 1,
                      m = this.spacing,
                      f = this._spaces;
                    if (((f.length = p), u || c)) {
                      f[0] = 0;
                      for (var g = 0, y = p - 1; g < y; g++) {
                        (x = l[g]).updateByConstraint();
                        var T = x._boneData.length,
                          S = T * (M = x.globalTransformMatrix).a,
                          E = T * M.b,
                          v = Math.sqrt(S * S + E * E);
                        u && (this._boneLengths[g] = v),
                          (f[g + 1] = ((T + m) * v) / T);
                      }
                    } else for (g = 0; g < p; g++) f[g] = m;
                    this._computeBezierCurve(s, p, _, 1 === a, 2 === o);
                    var b,
                      A = this._positions,
                      C = this.rotateOffset,
                      O = A[0],
                      I = A[1];
                    0 === C
                      ? (b = 1 === h)
                      : ((b = !1),
                        null !== (x = e.parent) &&
                          (C *=
                            (M = x.globalTransformMatrix).a * M.d - M.b * M.c >
                            0
                              ? t.Transform.DEG_RAD
                              : -t.Transform.DEG_RAD));
                    for (
                      var w = this.rotateMix,
                        R = this.translateMix,
                        D = ((g = 0), 3);
                      g < d;
                      g++, D += 3
                    ) {
                      var x, M;
                      (x = l[g]).updateByConstraint(),
                        ((M = x.globalTransformMatrix).tx += (O - M.tx) * R),
                        (M.ty += (I - M.ty) * R);
                      var P = (S = A[D]) - O,
                        N = (E = A[D + 1]) - I;
                      if (u) {
                        var L = this._boneLengths[g],
                          B = (Math.sqrt(P * P + N * N) / L - 1) * w + 1;
                        (M.a *= B), (M.b *= B);
                      }
                      if (((O = S), (I = E), w > 0)) {
                        var F = M.a,
                          U = M.b,
                          k = M.c,
                          z = M.d,
                          H = void 0,
                          G = void 0,
                          V = void 0;
                        if (
                          ((H = _ ? A[D - 1] : Math.atan2(N, P)),
                          (H -= Math.atan2(U, F)),
                          b)
                        ) {
                          (G = Math.cos(H)), (V = Math.sin(H));
                          var j = x._boneData.length;
                          (O += (j * (G * F - V * U) - P) * w),
                            (I += (j * (V * F + G * U) - N) * w);
                        } else H += C;
                        H > t.Transform.PI
                          ? (H -= t.Transform.PI_D)
                          : H < -t.Transform.PI && (H += t.Transform.PI_D),
                          (H *= w),
                          (G = Math.cos(H)),
                          (V = Math.sin(H)),
                          (M.a = G * F - V * U),
                          (M.b = V * F + G * U),
                          (M.c = G * k - V * z),
                          (M.d = V * k + G * z);
                      }
                      x.global.fromMatrix(M);
                    }
                    this.dirty = !1;
                  }
                }
              }),
              (i.prototype.invalidUpdate = function () {}),
              i
            );
          })(e);
          t.PathConstraint = s;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function () {
            function t(t) {
              void 0 === t && (t = 0),
                (this.time = 0),
                (this.timeScale = 1),
                (this._systemTime = 0),
                (this._animatebles = []),
                (this._clock = null),
                (this.time = t),
                (this._systemTime = 0.001 * new Date().getTime());
            }
            return (
              (t.prototype.advanceTime = function (t) {
                t != t && (t = 0);
                var e = 0.001 * Date.now();
                if (
                  (t < 0 && (t = e - this._systemTime),
                  (this._systemTime = e),
                  1 !== this.timeScale && (t *= this.timeScale),
                  0 !== t)
                ) {
                  t < 0 ? (this.time -= t) : (this.time += t);
                  for (
                    var i = 0, s = 0, n = this._animatebles.length;
                    i < n;
                    ++i
                  ) {
                    var r = this._animatebles[i];
                    null !== r
                      ? (s > 0 &&
                          ((this._animatebles[i - s] = r),
                          (this._animatebles[i] = null)),
                        r.advanceTime(t))
                      : s++;
                  }
                  if (s > 0) {
                    for (n = this._animatebles.length; i < n; ++i) {
                      var a = this._animatebles[i];
                      null !== a ? (this._animatebles[i - s] = a) : s++;
                    }
                    this._animatebles.length -= s;
                  }
                }
              }),
              (t.prototype.contains = function (t) {
                if (t === this) return !1;
                for (var e = t; e !== this && null !== e; ) e = e.clock;
                return e === this;
              }),
              (t.prototype.add = function (t) {
                this._animatebles.indexOf(t) < 0 &&
                  (this._animatebles.push(t), (t.clock = this));
              }),
              (t.prototype.remove = function (t) {
                var e = this._animatebles.indexOf(t);
                e >= 0 && ((this._animatebles[e] = null), (t.clock = null));
              }),
              (t.prototype.clear = function () {
                for (var t = 0, e = this._animatebles; t < e.length; t++) {
                  var i = e[t];
                  null !== i && (i.clock = null);
                }
              }),
              Object.defineProperty(t.prototype, "clock", {
                get: function () {
                  return this._clock;
                },
                set: function (t) {
                  this._clock !== t &&
                    (null !== this._clock && this._clock.remove(this),
                    (this._clock = t),
                    null !== this._clock && this._clock.add(this));
                },
                enumerable: !0,
                configurable: !0,
              }),
              (t.clock = new t()),
              t
            );
          })();
          t.WorldClock = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (e) {
            function i() {
              var t = (null !== e && e.apply(this, arguments)) || this;
              return (
                (t._animationNames = []),
                (t._animationStates = []),
                (t._animations = {}),
                (t._animationConfig = null),
                t
              );
            }
            return (
              Z2(i, e),
              (i.toString = function () {
                return "[class dragonBones.Animation]";
              }),
              (i.prototype._onClear = function () {
                for (var t = 0, e = this._animationStates; t < e.length; t++)
                  e[t].returnToPool();
                for (var i in this._animations) delete this._animations[i];
                null !== this._animationConfig &&
                  this._animationConfig.returnToPool(),
                  (this.timeScale = 1),
                  (this._lockUpdate = !1),
                  (this._animationDirty = !1),
                  (this._inheritTimeScale = 1),
                  (this._animationNames.length = 0),
                  (this._animationStates.length = 0),
                  (this._armature = null),
                  (this._animationConfig = null),
                  (this._lastAnimationState = null);
              }),
              (i.prototype._fadeOut = function (t) {
                switch (t.fadeOutMode) {
                  case 1:
                    for (
                      var e = 0, i = this._animationStates;
                      e < i.length;
                      e++
                    )
                      null === (l = i[e])._parent &&
                        l.layer === t.layer &&
                        l.fadeOut(t.fadeOutTime, t.pauseFadeOut);
                    break;
                  case 2:
                    for (
                      var s = 0, n = this._animationStates;
                      s < n.length;
                      s++
                    )
                      null === (l = n[s])._parent &&
                        l.group === t.group &&
                        l.fadeOut(t.fadeOutTime, t.pauseFadeOut);
                    break;
                  case 3:
                    for (
                      var r = 0, a = this._animationStates;
                      r < a.length;
                      r++
                    )
                      null === (l = a[r])._parent &&
                        l.layer === t.layer &&
                        l.group === t.group &&
                        l.fadeOut(t.fadeOutTime, t.pauseFadeOut);
                    break;
                  case 4:
                    for (
                      var o = 0, h = this._animationStates;
                      o < h.length;
                      o++
                    ) {
                      var l;
                      null === (l = h[o])._parent &&
                        l.fadeOut(t.fadeOutTime, t.pauseFadeOut);
                    }
                }
              }),
              (i.prototype.init = function (e) {
                null === this._armature &&
                  ((this._armature = e),
                  (this._animationConfig = t.BaseObject.borrowObject(
                    t.AnimationConfig
                  )));
              }),
              (i.prototype.advanceTime = function (t) {
                t < 0 && (t = -t),
                  this._armature.inheritAnimation &&
                  null !== this._armature._parent
                    ? (this._inheritTimeScale =
                        this._armature._parent._armature.animation
                          ._inheritTimeScale * this.timeScale)
                    : (this._inheritTimeScale = this.timeScale),
                  1 !== this._inheritTimeScale && (t *= this._inheritTimeScale);
                var e = this._animationStates.length;
                if (1 === e)
                  if (
                    (p = this._animationStates[0])._fadeState > 0 &&
                    p._subFadeState > 0
                  )
                    this._armature._dragonBones.bufferObject(p),
                      (this._animationStates.length = 0),
                      (this._lastAnimationState = null);
                  else {
                    var i = p._animationData,
                      s = i.cacheFrameRate;
                    if (this._animationDirty && s > 0) {
                      this._animationDirty = !1;
                      for (
                        var n = 0, r = this._armature.getBones();
                        n < r.length;
                        n++
                      ) {
                        var a = r[n];
                        a._cachedFrameIndices = i.getBoneCachedFrameIndices(
                          a.name
                        );
                      }
                      for (
                        var o = 0, h = this._armature.getSlots();
                        o < h.length;
                        o++
                      ) {
                        var l = h[o],
                          c = l.rawDisplayDatas;
                        if (null !== c && c.length > 0) {
                          var u = c[0];
                          if (
                            null !== u &&
                            u.parent === this._armature.armatureData.defaultSkin
                          ) {
                            l._cachedFrameIndices = i.getSlotCachedFrameIndices(
                              l.name
                            );
                            continue;
                          }
                        }
                        l._cachedFrameIndices = null;
                      }
                    }
                    p.advanceTime(t, s);
                  }
                else if (e > 1) {
                  for (var _ = 0, d = 0; _ < e; ++_) {
                    var p;
                    (p = this._animationStates[_])._fadeState > 0 &&
                    p._subFadeState > 0
                      ? (d++,
                        this._armature._dragonBones.bufferObject(p),
                        (this._animationDirty = !0),
                        this._lastAnimationState === p &&
                          (this._lastAnimationState = null))
                      : (d > 0 && (this._animationStates[_ - d] = p),
                        p.advanceTime(t, 0)),
                      _ === e - 1 &&
                        d > 0 &&
                        ((this._animationStates.length -= d),
                        null === this._lastAnimationState &&
                          this._animationStates.length > 0 &&
                          (this._lastAnimationState =
                            this._animationStates[
                              this._animationStates.length - 1
                            ]));
                  }
                  this._armature._cacheFrameIndex = -1;
                } else this._armature._cacheFrameIndex = -1;
              }),
              (i.prototype.reset = function () {
                for (var t = 0, e = this._animationStates; t < e.length; t++)
                  e[t].returnToPool();
                (this._animationDirty = !1),
                  this._animationConfig.clear(),
                  (this._animationStates.length = 0),
                  (this._lastAnimationState = null);
              }),
              (i.prototype.stop = function (t) {
                if ((void 0 === t && (t = null), null !== t))
                  null !== (s = this.getState(t)) && s.stop();
                else
                  for (
                    var e = 0, i = this._animationStates;
                    e < i.length;
                    e++
                  ) {
                    var s;
                    (s = i[e]).stop();
                  }
              }),
              (i.prototype.playConfig = function (e) {
                var i = e.animation;
                if (!(i in this._animations))
                  return (
                    console.warn(
                      "Non-existent animation.\n",
                      "DragonBones name: " +
                        this._armature.armatureData.parent.name,
                      "Armature name: " + this._armature.name,
                      "Animation name: " + i
                    ),
                    null
                  );
                var s = this._animations[i];
                if (5 === e.fadeOutMode)
                  for (
                    var n = 0, r = this._animationStates;
                    n < r.length;
                    n++
                  ) {
                    var a = r[n];
                    if (a._animationData === s) return a;
                  }
                0 === this._animationStates.length
                  ? (e.fadeInTime = 0)
                  : e.fadeInTime < 0 && (e.fadeInTime = s.fadeInTime),
                  e.fadeOutTime < 0 && (e.fadeOutTime = e.fadeInTime),
                  e.timeScale <= -100 && (e.timeScale = 1 / s.scale),
                  s.frameCount > 1
                    ? (e.position < 0
                        ? ((e.position %= s.duration),
                          (e.position = s.duration - e.position))
                        : e.position === s.duration
                        ? (e.position -= 1e-6)
                        : e.position > s.duration && (e.position %= s.duration),
                      e.duration > 0 &&
                        e.position + e.duration > s.duration &&
                        (e.duration = s.duration - e.position),
                      e.playTimes < 0 && (e.playTimes = s.playTimes))
                    : ((e.playTimes = 1),
                      (e.position = 0),
                      e.duration > 0 && (e.duration = 0)),
                  0 === e.duration && (e.duration = -1),
                  this._fadeOut(e);
                var o = t.BaseObject.borrowObject(t.AnimationState);
                if (
                  (o.init(this._armature, s, e),
                  (this._animationDirty = !0),
                  (this._armature._cacheFrameIndex = -1),
                  this._animationStates.length > 0)
                ) {
                  for (
                    var h = !1, l = 0, c = this._animationStates.length;
                    l < c;
                    ++l
                  ) {
                    if (o.layer > this._animationStates[l].layer) {
                      (h = !0), this._animationStates.splice(l, 0, o);
                      break;
                    }
                    if (
                      l !== c - 1 &&
                      o.layer > this._animationStates[l + 1].layer
                    ) {
                      (h = !0), this._animationStates.splice(l + 1, 0, o);
                      break;
                    }
                  }
                  h || this._animationStates.push(o);
                } else this._animationStates.push(o);
                for (
                  var u = 0, _ = this._armature.getSlots();
                  u < _.length;
                  u++
                ) {
                  var d = _[u].childArmature;
                  null !== d &&
                    d.inheritAnimation &&
                    d.animation.hasAnimation(i) &&
                    null === d.animation.getState(i) &&
                    d.animation.fadeIn(i);
                }
                var p = !1;
                for (var m in s.animationTimelines) {
                  this._lockUpdate || ((p = !0), (this._lockUpdate = !0));
                  var f = this.fadeIn(m, e.fadeInTime, 1, o.layer, null, 0);
                  null !== f &&
                    ((f.resetToPose = !1), (f._parent = o), f.stop());
                }
                return (
                  p && (this._lockUpdate = !1),
                  this._lockUpdate ||
                    (e.fadeInTime <= 0 && this._armature.advanceTime(0),
                    (this._lastAnimationState = o)),
                  o
                );
              }),
              (i.prototype.play = function (t, e) {
                if (
                  (void 0 === t && (t = null),
                  void 0 === e && (e = -1),
                  this._animationConfig.clear(),
                  (this._animationConfig.resetToPose = !0),
                  (this._animationConfig.playTimes = e),
                  (this._animationConfig.fadeInTime = 0),
                  (this._animationConfig.animation = null !== t ? t : ""),
                  null !== t && t.length > 0)
                )
                  this.playConfig(this._animationConfig);
                else if (null === this._lastAnimationState) {
                  var i = this._armature.armatureData.defaultAnimation;
                  null !== i &&
                    ((this._animationConfig.animation = i.name),
                    this.playConfig(this._animationConfig));
                } else
                  this._lastAnimationState.isPlaying ||
                  this._lastAnimationState.isCompleted
                    ? ((this._animationConfig.animation =
                        this._lastAnimationState.name),
                      this.playConfig(this._animationConfig))
                    : this._lastAnimationState.play();
                return this._lastAnimationState;
              }),
              (i.prototype.fadeIn = function (t, e, i, s, n, r) {
                return (
                  void 0 === e && (e = -1),
                  void 0 === i && (i = -1),
                  void 0 === s && (s = 0),
                  void 0 === n && (n = null),
                  void 0 === r && (r = 3),
                  this._animationConfig.clear(),
                  (this._animationConfig.fadeOutMode = r),
                  (this._animationConfig.playTimes = i),
                  (this._animationConfig.layer = s),
                  (this._animationConfig.fadeInTime = e),
                  (this._animationConfig.animation = t),
                  (this._animationConfig.group = null !== n ? n : ""),
                  this.playConfig(this._animationConfig)
                );
              }),
              (i.prototype.gotoAndPlayByTime = function (t, e, i) {
                return (
                  void 0 === e && (e = 0),
                  void 0 === i && (i = -1),
                  this._animationConfig.clear(),
                  (this._animationConfig.resetToPose = !0),
                  (this._animationConfig.playTimes = i),
                  (this._animationConfig.position = e),
                  (this._animationConfig.fadeInTime = 0),
                  (this._animationConfig.animation = t),
                  this.playConfig(this._animationConfig)
                );
              }),
              (i.prototype.gotoAndPlayByFrame = function (t, e, i) {
                void 0 === e && (e = 0),
                  void 0 === i && (i = -1),
                  this._animationConfig.clear(),
                  (this._animationConfig.resetToPose = !0),
                  (this._animationConfig.playTimes = i),
                  (this._animationConfig.fadeInTime = 0),
                  (this._animationConfig.animation = t);
                var s = t in this._animations ? this._animations[t] : null;
                return (
                  null !== s &&
                    (this._animationConfig.position =
                      (s.duration * e) / s.frameCount),
                  this.playConfig(this._animationConfig)
                );
              }),
              (i.prototype.gotoAndPlayByProgress = function (t, e, i) {
                void 0 === e && (e = 0),
                  void 0 === i && (i = -1),
                  this._animationConfig.clear(),
                  (this._animationConfig.resetToPose = !0),
                  (this._animationConfig.playTimes = i),
                  (this._animationConfig.fadeInTime = 0),
                  (this._animationConfig.animation = t);
                var s = t in this._animations ? this._animations[t] : null;
                return (
                  null !== s &&
                    (this._animationConfig.position =
                      s.duration * (e > 0 ? e : 0)),
                  this.playConfig(this._animationConfig)
                );
              }),
              (i.prototype.gotoAndStopByTime = function (t, e) {
                void 0 === e && (e = 0);
                var i = this.gotoAndPlayByTime(t, e, 1);
                return null !== i && i.stop(), i;
              }),
              (i.prototype.gotoAndStopByFrame = function (t, e) {
                void 0 === e && (e = 0);
                var i = this.gotoAndPlayByFrame(t, e, 1);
                return null !== i && i.stop(), i;
              }),
              (i.prototype.gotoAndStopByProgress = function (t, e) {
                void 0 === e && (e = 0);
                var i = this.gotoAndPlayByProgress(t, e, 1);
                return null !== i && i.stop(), i;
              }),
              (i.prototype.getState = function (t) {
                for (var e = this._animationStates.length; e--; ) {
                  var i = this._animationStates[e];
                  if (i.name === t) return i;
                }
                return null;
              }),
              (i.prototype.hasAnimation = function (t) {
                return t in this._animations;
              }),
              (i.prototype.getStates = function () {
                return this._animationStates;
              }),
              Object.defineProperty(i.prototype, "isPlaying", {
                get: function () {
                  for (var t = 0, e = this._animationStates; t < e.length; t++)
                    if (e[t].isPlaying) return !0;
                  return !1;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "isCompleted", {
                get: function () {
                  for (var t = 0, e = this._animationStates; t < e.length; t++)
                    if (!e[t].isCompleted) return !1;
                  return this._animationStates.length > 0;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "lastAnimationName", {
                get: function () {
                  return null !== this._lastAnimationState
                    ? this._lastAnimationState.name
                    : "";
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "animationNames", {
                get: function () {
                  return this._animationNames;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "animations", {
                get: function () {
                  return this._animations;
                },
                set: function (t) {
                  if (this._animations !== t) {
                    for (var e in ((this._animationNames.length = 0),
                    this._animations))
                      delete this._animations[e];
                    for (var e in t)
                      this._animationNames.push(e),
                        (this._animations[e] = t[e]);
                  }
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "animationConfig", {
                get: function () {
                  return this._animationConfig.clear(), this._animationConfig;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "lastAnimationState", {
                get: function () {
                  return this._lastAnimationState;
                },
                enumerable: !0,
                configurable: !0,
              }),
              (i.prototype.gotoAndPlay = function (t, e, i, s, n, r, a) {
                void 0 === e && (e = -1),
                  void 0 === i && (i = -1),
                  void 0 === s && (s = -1),
                  void 0 === n && (n = 0),
                  void 0 === r && (r = null),
                  void 0 === a && (a = 3),
                  console.warn("Deprecated."),
                  this._animationConfig.clear(),
                  (this._animationConfig.resetToPose = !0),
                  (this._animationConfig.fadeOutMode = a),
                  (this._animationConfig.playTimes = s),
                  (this._animationConfig.layer = n),
                  (this._animationConfig.fadeInTime = e),
                  (this._animationConfig.animation = t),
                  (this._animationConfig.group = null !== r ? r : "");
                var o = this._animations[t];
                return (
                  o &&
                    i > 0 &&
                    (this._animationConfig.timeScale = o.duration / i),
                  this.playConfig(this._animationConfig)
                );
              }),
              (i.prototype.gotoAndStop = function (t, e) {
                return (
                  void 0 === e && (e = 0),
                  console.warn("Deprecated."),
                  this.gotoAndStopByTime(t, e)
                );
              }),
              Object.defineProperty(i.prototype, "animationList", {
                get: function () {
                  return console.warn("Deprecated."), this._animationNames;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(i.prototype, "animationDataList", {
                get: function () {
                  console.warn("Deprecated.");
                  for (
                    var t = [], e = 0, i = this._animationNames.length;
                    e < i;
                    ++e
                  )
                    t.push(this._animations[this._animationNames[e]]);
                  return t;
                },
                enumerable: !0,
                configurable: !0,
              }),
              i
            );
          })(t.BaseObject);
          t.Animation = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (e) {
            function n() {
              var t = (null !== e && e.apply(this, arguments)) || this;
              return (
                (t._blendState = new s()),
                (t._boneMask = []),
                (t._boneTimelines = []),
                (t._surfaceTimelines = []),
                (t._slotTimelines = []),
                (t._constraintTimelines = []),
                (t._animationTimelines = []),
                (t._poseTimelines = []),
                (t._bonePoses = {}),
                (t._actionTimeline = null),
                (t._zOrderTimeline = null),
                (t._parent = null),
                t
              );
            }
            return (
              Z2(n, e),
              (n.toString = function () {
                return "[class dragonBones.AnimationState]";
              }),
              (n.prototype._onClear = function () {
                for (var t = 0, e = this._boneTimelines; t < e.length; t++)
                  e[t].returnToPool();
                for (var i = 0, s = this._surfaceTimelines; i < s.length; i++)
                  s[i].returnToPool();
                for (var n = 0, r = this._slotTimelines; n < r.length; n++)
                  r[n].returnToPool();
                for (
                  var a = 0, o = this._constraintTimelines;
                  a < o.length;
                  a++
                )
                  o[a].returnToPool();
                for (var h = 0, l = this._animationTimelines; h < l.length; h++)
                  l[h].returnToPool();
                for (var c in this._bonePoses)
                  this._bonePoses[c].returnToPool(), delete this._bonePoses[c];
                null !== this._actionTimeline &&
                  this._actionTimeline.returnToPool(),
                  null !== this._zOrderTimeline &&
                    this._zOrderTimeline.returnToPool(),
                  (this.actionEnabled = !1),
                  (this.additiveBlending = !1),
                  (this.displayControl = !1),
                  (this.resetToPose = !1),
                  (this.playTimes = 1),
                  (this.layer = 0),
                  (this.timeScale = 1),
                  (this.weight = 1),
                  (this.autoFadeOutTime = 0),
                  (this.fadeTotalTime = 0),
                  (this.name = ""),
                  (this.group = ""),
                  (this._timelineDirty = 2),
                  (this._playheadState = 0),
                  (this._fadeState = -1),
                  (this._subFadeState = -1),
                  (this._position = 0),
                  (this._duration = 0),
                  (this._fadeTime = 0),
                  (this._time = 0),
                  (this._fadeProgress = 0),
                  (this._weightResult = 0),
                  this._blendState.clear(),
                  (this._boneMask.length = 0),
                  (this._boneTimelines.length = 0),
                  (this._surfaceTimelines.length = 0),
                  (this._slotTimelines.length = 0),
                  (this._constraintTimelines.length = 0),
                  (this._animationTimelines.length = 0),
                  (this._poseTimelines.length = 0),
                  (this._animationData = null),
                  (this._armature = null),
                  (this._actionTimeline = null),
                  (this._zOrderTimeline = null),
                  (this._parent = null);
              }),
              (n.prototype._updateTimelines = function () {
                for (
                  var e = 0, i = this._armature._constraints;
                  e < i.length;
                  e++
                ) {
                  var s = i[e];
                  if (
                    null !==
                    (h = this._animationData.getConstraintTimelines(s.name))
                  )
                    for (var n = 0, r = h; n < r.length; n++)
                      switch ((_ = r[n]).type) {
                        case 30:
                          ((d = t.BaseObject.borrowObject(
                            t.IKConstraintTimelineState
                          )).constraint = s),
                            d.init(this._armature, this, _),
                            this._constraintTimelines.push(d);
                      }
                  else
                    this.resetToPose &&
                      (((d = t.BaseObject.borrowObject(
                        t.IKConstraintTimelineState
                      )).constraint = s),
                      d.init(this._armature, this, null),
                      this._constraintTimelines.push(d),
                      this._poseTimelines.push(d));
                }
                for (
                  var a = 0, o = this._armature.animation.getStates();
                  a < o.length;
                  a++
                ) {
                  var h,
                    l = o[a];
                  if (
                    l._parent === this &&
                    null !==
                      (h = this._animationData.getAnimationTimelines(l.name))
                  )
                    for (var c = 0, u = h; c < u.length; c++) {
                      var _;
                      switch ((_ = u[c]).type) {
                        case 40:
                          var d;
                          ((d = t.BaseObject.borrowObject(
                            t.AnimationTimelineState
                          )).animationState = l),
                            d.init(this._armature, this, _),
                            this._animationTimelines.push(d);
                      }
                    }
                }
              }),
              (n.prototype._updateBoneAndSlotTimelines = function () {
                for (
                  var e = {}, s = 0, n = this._boneTimelines;
                  s < n.length;
                  s++
                )
                  (h = (y = n[s]).bone.name) in e || (e[h] = []), e[h].push(y);
                for (
                  var r = 0, a = this._armature.getBones();
                  r < a.length;
                  r++
                ) {
                  var o = a[r],
                    h = o.name;
                  if (this.containsBoneMask(h))
                    if (h in e) delete e[h];
                    else if (0 === o._boneData.type) {
                      var l = this._animationData.getBoneTimelines(h),
                        c =
                          h in this._bonePoses
                            ? this._bonePoses[h]
                            : (this._bonePoses[h] =
                                t.BaseObject.borrowObject(i));
                      if (null !== l)
                        for (var u = 0, _ = l; u < _.length; u++)
                          switch ((x = _[u]).type) {
                            case 10:
                              ((y = t.BaseObject.borrowObject(
                                t.BoneAllTimelineState
                              )).bone = o),
                                (y.bonePose = c),
                                y.init(this._armature, this, x),
                                this._boneTimelines.push(y);
                              break;
                            case 11:
                              ((y = t.BaseObject.borrowObject(
                                t.BoneTranslateTimelineState
                              )).bone = o),
                                (y.bonePose = c),
                                y.init(this._armature, this, x),
                                this._boneTimelines.push(y);
                              break;
                            case 12:
                              ((y = t.BaseObject.borrowObject(
                                t.BoneRotateTimelineState
                              )).bone = o),
                                (y.bonePose = c),
                                y.init(this._armature, this, x),
                                this._boneTimelines.push(y);
                              break;
                            case 13:
                              ((y = t.BaseObject.borrowObject(
                                t.BoneScaleTimelineState
                              )).bone = o),
                                (y.bonePose = c),
                                y.init(this._armature, this, x),
                                this._boneTimelines.push(y);
                          }
                      else
                        this.resetToPose &&
                          (((y = t.BaseObject.borrowObject(
                            t.BoneAllTimelineState
                          )).bone = o),
                          (y.bonePose = c),
                          y.init(this._armature, this, null),
                          this._boneTimelines.push(y),
                          this._poseTimelines.push(y));
                    } else if (1 === o._boneData.type)
                      if (
                        null !==
                        (l = this._animationData.getSurfaceTimelines(h))
                      )
                        for (var d = 0, p = l; d < p.length; d++)
                          switch ((x = p[d]).type) {
                            case 50:
                              ((y = t.BaseObject.borrowObject(
                                t.SurfaceTimelineState
                              )).surface = o),
                                y.init(this._armature, this, x),
                                this._surfaceTimelines.push(y);
                          }
                      else
                        this.resetToPose &&
                          (((y = t.BaseObject.borrowObject(
                            t.SurfaceTimelineState
                          )).surface = o),
                          y.init(this._armature, this, null),
                          this._surfaceTimelines.push(y),
                          this._poseTimelines.push(y));
                }
                for (var m in e)
                  for (var f = 0, g = e[m]; f < g.length; f++) {
                    var y = g[f];
                    this._boneTimelines.splice(
                      this._boneTimelines.indexOf(y),
                      1
                    ),
                      y.returnToPool();
                  }
                for (
                  var T = {}, S = [], E = 0, v = this._slotTimelines;
                  E < v.length;
                  E++
                )
                  (h = (y = v[E]).slot.name) in T || (T[h] = []), T[h].push(y);
                for (
                  var b = 0, A = this._armature.getSlots();
                  b < A.length;
                  b++
                ) {
                  var C = A[b],
                    O = C.parent.name;
                  if (this.containsBoneMask(O))
                    if (
                      ((h = C.name),
                      (l = this._animationData.getSlotTimelines(h)),
                      h in T)
                    )
                      delete T[h];
                    else {
                      var I = !1,
                        w = !1;
                      if (((S.length = 0), null !== l))
                        for (var R = 0, D = l; R < D.length; R++) {
                          var x;
                          switch ((x = D[R]).type) {
                            case 20:
                              ((y = t.BaseObject.borrowObject(
                                t.SlotDislayTimelineState
                              )).slot = C),
                                y.init(this._armature, this, x),
                                this._slotTimelines.push(y),
                                (I = !0);
                              break;
                            case 21:
                              ((y = t.BaseObject.borrowObject(
                                t.SlotColorTimelineState
                              )).slot = C),
                                y.init(this._armature, this, x),
                                this._slotTimelines.push(y),
                                (w = !0);
                              break;
                            case 22:
                              ((y = t.BaseObject.borrowObject(
                                t.DeformTimelineState
                              )).slot = C),
                                y.init(this._armature, this, x),
                                this._slotTimelines.push(y),
                                S.push(y.vertexOffset);
                          }
                        }
                      if (
                        this.resetToPose &&
                        (I ||
                          (((y = t.BaseObject.borrowObject(
                            t.SlotDislayTimelineState
                          )).slot = C),
                          y.init(this._armature, this, null),
                          this._slotTimelines.push(y),
                          this._poseTimelines.push(y)),
                        w ||
                          (((y = t.BaseObject.borrowObject(
                            t.SlotColorTimelineState
                          )).slot = C),
                          y.init(this._armature, this, null),
                          this._slotTimelines.push(y),
                          this._poseTimelines.push(y)),
                        null !== C.rawDisplayDatas)
                      )
                        for (
                          var M = 0, P = C.rawDisplayDatas;
                          M < P.length;
                          M++
                        ) {
                          var N = P[M];
                          if (null !== N && 2 === N.type) {
                            var L = N.vertices.offset;
                            S.indexOf(L) < 0 &&
                              (((y = t.BaseObject.borrowObject(
                                t.DeformTimelineState
                              )).vertexOffset = L),
                              (y.slot = C),
                              y.init(this._armature, this, null),
                              this._slotTimelines.push(y),
                              this._poseTimelines.push(y));
                          }
                        }
                    }
                }
                for (var m in T)
                  for (var B = 0, F = T[m]; B < F.length; B++)
                    (y = F[B]),
                      this._slotTimelines.splice(
                        this._slotTimelines.indexOf(y),
                        1
                      ),
                      y.returnToPool();
              }),
              (n.prototype._advanceFadeTime = function (e) {
                var i,
                  s = this._fadeState > 0;
                if (this._subFadeState < 0) {
                  this._subFadeState = 0;
                  var n = s ? t.EventObject.FADE_OUT : t.EventObject.FADE_IN;
                  this._armature.eventDispatcher.hasDBEventListener(n) &&
                    (((i = t.BaseObject.borrowObject(t.EventObject)).type = n),
                    (i.armature = this._armature),
                    (i.animationState = this),
                    this._armature._dragonBones.bufferEvent(i));
                }
                (e < 0 && (e = -e),
                (this._fadeTime += e),
                this._fadeTime >= this.fadeTotalTime
                  ? ((this._subFadeState = 1), (this._fadeProgress = s ? 0 : 1))
                  : this._fadeTime > 0
                  ? (this._fadeProgress = s
                      ? 1 - this._fadeTime / this.fadeTotalTime
                      : this._fadeTime / this.fadeTotalTime)
                  : (this._fadeProgress = s ? 1 : 0),
                this._subFadeState > 0) &&
                  (s || ((this._playheadState |= 1), (this._fadeState = 0)),
                  (n = s
                    ? t.EventObject.FADE_OUT_COMPLETE
                    : t.EventObject.FADE_IN_COMPLETE),
                  this._armature.eventDispatcher.hasDBEventListener(n) &&
                    (((i = t.BaseObject.borrowObject(t.EventObject)).type = n),
                    (i.armature = this._armature),
                    (i.animationState = this),
                    this._armature._dragonBones.bufferEvent(i)));
              }),
              (n.prototype.init = function (e, i, s) {
                if (null === this._armature) {
                  if (
                    ((this._armature = e),
                    (this._animationData = i),
                    (this.resetToPose = s.resetToPose),
                    (this.additiveBlending = s.additiveBlending),
                    (this.displayControl = s.displayControl),
                    (this.actionEnabled = s.actionEnabled),
                    (this.layer = s.layer),
                    (this.playTimes = s.playTimes),
                    (this.timeScale = s.timeScale),
                    (this.fadeTotalTime = s.fadeInTime),
                    (this.autoFadeOutTime = s.autoFadeOutTime),
                    (this.weight = s.weight),
                    (this.name = s.name.length > 0 ? s.name : s.animation),
                    (this.group = s.group),
                    s.pauseFadeIn
                      ? (this._playheadState = 2)
                      : (this._playheadState = 3),
                    s.duration < 0
                      ? ((this._position = 0),
                        (this._duration = this._animationData.duration),
                        0 !== s.position
                          ? this.timeScale >= 0
                            ? (this._time = s.position)
                            : (this._time = s.position - this._duration)
                          : (this._time = 0))
                      : ((this._position = s.position),
                        (this._duration = s.duration),
                        (this._time = 0)),
                    this.timeScale < 0 &&
                      0 === this._time &&
                      (this._time = -1e-6),
                    this.fadeTotalTime <= 0 && (this._fadeProgress = 0.999999),
                    s.boneMask.length > 0)
                  ) {
                    this._boneMask.length = s.boneMask.length;
                    for (var n = 0, r = this._boneMask.length; n < r; ++n)
                      this._boneMask[n] = s.boneMask[n];
                  }
                  (this._actionTimeline = t.BaseObject.borrowObject(
                    t.ActionTimelineState
                  )),
                    this._actionTimeline.init(
                      this._armature,
                      this,
                      this._animationData.actionTimeline
                    ),
                    (this._actionTimeline.currentTime = this._time),
                    this._actionTimeline.currentTime < 0 &&
                      (this._actionTimeline.currentTime =
                        this._duration - this._actionTimeline.currentTime),
                    null !== this._animationData.zOrderTimeline &&
                      ((this._zOrderTimeline = t.BaseObject.borrowObject(
                        t.ZOrderTimelineState
                      )),
                      this._zOrderTimeline.init(
                        this._armature,
                        this,
                        this._animationData.zOrderTimeline
                      ));
                }
              }),
              (n.prototype.advanceTime = function (e, i) {
                if (
                  ((this._blendState.dirty = !1),
                  (0 === this._fadeState && 0 === this._subFadeState) ||
                    this._advanceFadeTime(e),
                  3 === this._playheadState &&
                    (1 !== this.timeScale && (e *= this.timeScale),
                    (this._time += e)),
                  0 !== this._timelineDirty &&
                    (2 === this._timelineDirty && this._updateTimelines(),
                    (this._timelineDirty = 0),
                    this._updateBoneAndSlotTimelines()),
                  0 !== this.weight)
                ) {
                  var s = 0 === this._fadeState && i > 0,
                    n = !0,
                    r = !0,
                    a = this._time;
                  if (
                    ((this._weightResult = this.weight * this._fadeProgress),
                    null !== this._parent &&
                      (this._weightResult *=
                        this._parent._weightResult /
                        this._parent._fadeProgress),
                    this._actionTimeline.playState <= 0 &&
                      this._actionTimeline.update(a),
                    s)
                  ) {
                    var o = 2 * i;
                    this._actionTimeline.currentTime =
                      Math.floor(this._actionTimeline.currentTime * o) / o;
                  }
                  if (
                    (null !== this._zOrderTimeline &&
                      this._zOrderTimeline.playState <= 0 &&
                      this._zOrderTimeline.update(a),
                    s)
                  ) {
                    var h = Math.floor(this._actionTimeline.currentTime * i);
                    this._armature._cacheFrameIndex === h
                      ? ((n = !1), (r = !1))
                      : ((this._armature._cacheFrameIndex = h),
                        this._animationData.cachedFrames[h]
                          ? (r = !1)
                          : (this._animationData.cachedFrames[h] = !0));
                  }
                  if (n) {
                    if (r)
                      for (
                        var l = 0, c = this._boneTimelines.length;
                        l < c;
                        ++l
                      )
                        (m = this._boneTimelines[l]).playState <= 0 &&
                          m.update(a),
                          (l === c - 1 ||
                            m.bone !== this._boneTimelines[l + 1].bone) &&
                            0 !==
                              (u = m.bone._blendState.update(
                                this._weightResult,
                                this.layer
                              )) &&
                            m.blend(u);
                    for (l = 0, c = this._surfaceTimelines.length; l < c; ++l) {
                      var u = (m =
                        this._surfaceTimelines[l]).surface._blendState.update(
                        this._weightResult,
                        this.layer
                      );
                      m.playState <= 0 && m.update(a), 0 !== u && m.blend(u);
                    }
                    if (this.displayControl)
                      for (l = 0, c = this._slotTimelines.length; l < c; ++l) {
                        var _ = (m = this._slotTimelines[l]).slot
                          .displayController;
                        (null !== _ && _ !== this.name && _ !== this.group) ||
                          (m.playState <= 0 && m.update(a));
                      }
                    for (
                      l = 0, c = this._constraintTimelines.length;
                      l < c;
                      ++l
                    )
                      (m = this._constraintTimelines[l]).playState <= 0 &&
                        m.update(a);
                    for (l = 0, c = this._animationTimelines.length; l < c; ++l)
                      (u = (m =
                        this._animationTimelines[
                          l
                        ]).animationState._blendState.update(
                        this._weightResult,
                        this.layer
                      )),
                        m.playState <= 0 && m.update(a),
                        0 !== u && m.blend(u);
                  }
                  if (0 === this._fadeState) {
                    if (
                      this._subFadeState > 0 &&
                      ((this._subFadeState = 0), this._poseTimelines.length > 0)
                    ) {
                      for (
                        var d = 0, p = this._poseTimelines;
                        d < p.length;
                        d++
                      ) {
                        var m;
                        (m = p[d]) instanceof t.BoneTimelineState
                          ? this._boneTimelines.splice(
                              this._boneTimelines.indexOf(m),
                              1
                            )
                          : m instanceof t.SurfaceTimelineState
                          ? this._surfaceTimelines.splice(
                              this._surfaceTimelines.indexOf(m),
                              1
                            )
                          : m instanceof t.SlotTimelineState
                          ? this._slotTimelines.splice(
                              this._slotTimelines.indexOf(m),
                              1
                            )
                          : m instanceof t.ConstraintTimelineState &&
                            this._constraintTimelines.splice(
                              this._constraintTimelines.indexOf(m),
                              1
                            ),
                          m.returnToPool();
                      }
                      this._poseTimelines.length = 0;
                    }
                    this._actionTimeline.playState > 0 &&
                      this.autoFadeOutTime >= 0 &&
                      this.fadeOut(this.autoFadeOutTime);
                  }
                }
              }),
              (n.prototype.play = function () {
                this._playheadState = 3;
              }),
              (n.prototype.stop = function () {
                this._playheadState &= 1;
              }),
              (n.prototype.fadeOut = function (t, e) {
                if (
                  (void 0 === e && (e = !0),
                  t < 0 && (t = 0),
                  e && (this._playheadState &= 2),
                  this._fadeState > 0)
                ) {
                  if (t > this.fadeTotalTime - this._fadeTime) return;
                } else {
                  (this._fadeState = 1),
                    (this._subFadeState = -1),
                    (t <= 0 || this._fadeProgress <= 0) &&
                      (this._fadeProgress = 1e-6);
                  for (var i = 0, s = this._boneTimelines; i < s.length; i++)
                    (_ = s[i]).fadeOut();
                  for (var n = 0, r = this._surfaceTimelines; n < r.length; n++)
                    (_ = r[n]).fadeOut();
                  for (var a = 0, o = this._slotTimelines; a < o.length; a++)
                    (_ = o[a]).fadeOut();
                  for (
                    var h = 0, l = this._constraintTimelines;
                    h < l.length;
                    h++
                  )
                    (_ = l[h]).fadeOut();
                  for (
                    var c = 0, u = this._animationTimelines;
                    c < u.length;
                    c++
                  ) {
                    var _;
                    (_ = u[c]).animationState.fadeOut(t, e), _.fadeOut();
                  }
                }
                (this.displayControl = !1),
                  (this.fadeTotalTime =
                    this._fadeProgress > 1e-6 ? t / this._fadeProgress : 0),
                  (this._fadeTime =
                    this.fadeTotalTime * (1 - this._fadeProgress));
              }),
              (n.prototype.containsBoneMask = function (t) {
                return (
                  0 === this._boneMask.length || this._boneMask.indexOf(t) >= 0
                );
              }),
              (n.prototype.addBoneMask = function (t, e) {
                void 0 === e && (e = !0);
                var i = this._armature.getBone(t);
                if (null !== i) {
                  if (
                    (this._boneMask.indexOf(t) < 0 && this._boneMask.push(t), e)
                  )
                    for (
                      var s = 0, n = this._armature.getBones();
                      s < n.length;
                      s++
                    ) {
                      var r = n[s];
                      this._boneMask.indexOf(r.name) < 0 &&
                        i.contains(r) &&
                        this._boneMask.push(r.name);
                    }
                  this._timelineDirty = 1;
                }
              }),
              (n.prototype.removeBoneMask = function (t, e) {
                void 0 === e && (e = !0);
                var i = this._boneMask.indexOf(t);
                if ((i >= 0 && this._boneMask.splice(i, 1), e)) {
                  var s = this._armature.getBone(t);
                  if (null !== s) {
                    var n = this._armature.getBones();
                    if (this._boneMask.length > 0)
                      for (var r = 0, a = n; r < a.length; r++) {
                        var o = a[r],
                          h = this._boneMask.indexOf(o.name);
                        h >= 0 && s.contains(o) && this._boneMask.splice(h, 1);
                      }
                    else
                      for (var l = 0, c = n; l < c.length; l++)
                        (o = c[l]) !== s &&
                          (s.contains(o) || this._boneMask.push(o.name));
                  }
                }
                this._timelineDirty = 1;
              }),
              (n.prototype.removeAllBoneMask = function () {
                (this._boneMask.length = 0), (this._timelineDirty = 1);
              }),
              Object.defineProperty(n.prototype, "isFadeIn", {
                get: function () {
                  return this._fadeState < 0;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(n.prototype, "isFadeOut", {
                get: function () {
                  return this._fadeState > 0;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(n.prototype, "isFadeComplete", {
                get: function () {
                  return 0 === this._fadeState;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(n.prototype, "isPlaying", {
                get: function () {
                  return (
                    0 != (2 & this._playheadState) &&
                    this._actionTimeline.playState <= 0
                  );
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(n.prototype, "isCompleted", {
                get: function () {
                  return this._actionTimeline.playState > 0;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(n.prototype, "currentPlayTimes", {
                get: function () {
                  return this._actionTimeline.currentPlayTimes;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(n.prototype, "totalTime", {
                get: function () {
                  return this._duration;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(n.prototype, "currentTime", {
                get: function () {
                  return this._actionTimeline.currentTime;
                },
                set: function (t) {
                  var e =
                    this._actionTimeline.currentPlayTimes -
                    (this._actionTimeline.playState > 0 ? 1 : 0);
                  if (
                    ((t < 0 || this._duration < t) &&
                      (t = (t % this._duration) + e * this._duration) < 0 &&
                      (t += this._duration),
                    this.playTimes > 0 &&
                      e === this.playTimes - 1 &&
                      t === this._duration &&
                      (t = this._duration - 1e-6),
                    this._time !== t)
                  ) {
                    (this._time = t),
                      this._actionTimeline.setCurrentTime(this._time),
                      null !== this._zOrderTimeline &&
                        (this._zOrderTimeline.playState = -1);
                    for (var i = 0, s = this._boneTimelines; i < s.length; i++)
                      s[i].playState = -1;
                    for (var n = 0, r = this._slotTimelines; n < r.length; n++)
                      r[n].playState = -1;
                  }
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(n.prototype, "animationData", {
                get: function () {
                  return this._animationData;
                },
                enumerable: !0,
                configurable: !0,
              }),
              n
            );
          })(t.BaseObject);
          t.AnimationState = e;
          var i = (function (e) {
            function i() {
              var i = (null !== e && e.apply(this, arguments)) || this;
              return (
                (i.current = new t.Transform()),
                (i.delta = new t.Transform()),
                (i.result = new t.Transform()),
                i
              );
            }
            return (
              Z2(i, e),
              (i.toString = function () {
                return "[class dragonBones.BonePose]";
              }),
              (i.prototype._onClear = function () {
                this.current.identity(),
                  this.delta.identity(),
                  this.result.identity();
              }),
              i
            );
          })(t.BaseObject);
          t.BonePose = i;
          var s = (function () {
            function t() {}
            return (
              (t.prototype.update = function (t, e) {
                if (this.dirty) {
                  if (!(this.leftWeight > 0)) return 0;
                  if (this.layer !== e) {
                    if (this.layerWeight >= this.leftWeight)
                      return (this.leftWeight = 0), 0;
                    (this.layer = e),
                      (this.leftWeight -= this.layerWeight),
                      (this.layerWeight = 0);
                  }
                  return (
                    (t *= this.leftWeight),
                    (this.layerWeight += t),
                    (this.blendWeight = t),
                    2
                  );
                }
                return (
                  (this.dirty = !0),
                  (this.layer = e),
                  (this.layerWeight = t),
                  (this.leftWeight = 1),
                  (this.blendWeight = t),
                  1
                );
              }),
              (t.prototype.clear = function () {
                (this.dirty = !1),
                  (this.layer = 0),
                  (this.leftWeight = 0),
                  (this.layerWeight = 0),
                  (this.blendWeight = 0);
              }),
              t
            );
          })();
          t.BlendState = s;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.prototype._onClear = function () {
                (this.playState = -1),
                  (this.currentPlayTimes = -1),
                  (this.currentTime = -1),
                  (this._tweenState = 0),
                  (this._frameRate = 0),
                  (this._frameValueOffset = 0),
                  (this._frameCount = 0),
                  (this._frameOffset = 0),
                  (this._frameIndex = -1),
                  (this._frameRateR = 0),
                  (this._position = 0),
                  (this._duration = 0),
                  (this._timeScale = 1),
                  (this._timeOffset = 0),
                  (this._dragonBonesData = null),
                  (this._animationData = null),
                  (this._timelineData = null),
                  (this._armature = null),
                  (this._animationState = null),
                  (this._actionTimeline = null),
                  (this._frameArray = null),
                  (this._frameIntArray = null),
                  (this._frameFloatArray = null),
                  (this._timelineArray = null),
                  (this._frameIndices = null);
              }),
              (e.prototype._setCurrentTime = function (t) {
                var e = this.playState,
                  i = this.currentPlayTimes,
                  s = this.currentTime;
                if (null !== this._actionTimeline && this._frameCount <= 1)
                  (this.playState =
                    this._actionTimeline.playState >= 0 ? 1 : -1),
                    (this.currentPlayTimes = 1),
                    (this.currentTime = this._actionTimeline.currentTime);
                else if (
                  null === this._actionTimeline ||
                  1 !== this._timeScale ||
                  0 !== this._timeOffset
                ) {
                  var n = this._animationState.playTimes,
                    r = n * this._duration;
                  (t *= this._timeScale),
                    0 !== this._timeOffset &&
                      (t += this._timeOffset * this._animationData.duration),
                    n > 0 && (t >= r || t <= -r)
                      ? (this.playState <= 0 &&
                          3 === this._animationState._playheadState &&
                          (this.playState = 1),
                        (this.currentPlayTimes = n),
                        (this.currentTime = t < 0 ? 0 : this._duration + 1e-6))
                      : (0 !== this.playState &&
                          3 === this._animationState._playheadState &&
                          (this.playState = 0),
                        t < 0
                          ? ((t = -t),
                            (this.currentPlayTimes = Math.floor(
                              t / this._duration
                            )),
                            (this.currentTime =
                              this._duration - (t % this._duration)))
                          : ((this.currentPlayTimes = Math.floor(
                              t / this._duration
                            )),
                            (this.currentTime = t % this._duration))),
                    (this.currentTime += this._position);
                } else
                  (this.playState = this._actionTimeline.playState),
                    (this.currentPlayTimes =
                      this._actionTimeline.currentPlayTimes),
                    (this.currentTime = this._actionTimeline.currentTime);
                return (
                  (this.currentPlayTimes !== i || this.currentTime !== s) &&
                  (((e < 0 && this.playState !== e) ||
                    (this.playState <= 0 && this.currentPlayTimes !== i)) &&
                    (this._frameIndex = -1),
                  !0)
                );
              }),
              (e.prototype.init = function (t, e, i) {
                (this._armature = t),
                  (this._animationState = e),
                  (this._timelineData = i),
                  (this._actionTimeline = this._animationState._actionTimeline),
                  this === this._actionTimeline &&
                    (this._actionTimeline = null),
                  (this._animationData = this._animationState._animationData),
                  (this._frameRate = this._animationData.parent.frameRate),
                  (this._frameRateR = 1 / this._frameRate),
                  (this._position = this._animationState._position),
                  (this._duration = this._animationState._duration),
                  (this._dragonBonesData = this._animationData.parent.parent),
                  null !== this._timelineData &&
                    ((this._frameIntArray =
                      this._dragonBonesData.frameIntArray),
                    (this._frameFloatArray =
                      this._dragonBonesData.frameFloatArray),
                    (this._frameArray = this._dragonBonesData.frameArray),
                    (this._timelineArray = this._dragonBonesData.timelineArray),
                    (this._frameIndices = this._dragonBonesData.frameIndices),
                    (this._frameCount =
                      this._timelineArray[this._timelineData.offset + 2]),
                    (this._frameValueOffset =
                      this._timelineArray[this._timelineData.offset + 4]),
                    (this._timeScale =
                      100 / this._timelineArray[this._timelineData.offset + 0]),
                    (this._timeOffset =
                      0.01 *
                      this._timelineArray[this._timelineData.offset + 1]));
              }),
              (e.prototype.fadeOut = function () {}),
              (e.prototype.update = function (t) {
                if (this._setCurrentTime(t)) {
                  if (this._frameCount > 1) {
                    var e = Math.floor(this.currentTime * this._frameRate),
                      i =
                        this._frameIndices[
                          this._timelineData.frameIndicesOffset + e
                        ];
                    this._frameIndex !== i &&
                      ((this._frameIndex = i),
                      (this._frameOffset =
                        this._animationData.frameOffset +
                        this._timelineArray[
                          this._timelineData.offset + 5 + this._frameIndex
                        ]),
                      this._onArriveAtFrame());
                  } else
                    this._frameIndex < 0 &&
                      ((this._frameIndex = 0),
                      null !== this._timelineData &&
                        (this._frameOffset =
                          this._animationData.frameOffset +
                          this._timelineArray[this._timelineData.offset + 5]),
                      this._onArriveAtFrame());
                  0 !== this._tweenState && this._onUpdateFrame();
                }
              }),
              e
            );
          })(t.BaseObject);
          t.TimelineState = e;
          var i = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e._getEasingValue = function (t, e, i) {
                var s = e;
                switch (t) {
                  case 3:
                    s = Math.pow(e, 2);
                    break;
                  case 4:
                    s = 1 - Math.pow(1 - e, 2);
                    break;
                  case 5:
                    s = 0.5 * (1 - Math.cos(e * Math.PI));
                }
                return (s - e) * i + e;
              }),
              (e._getEasingCurveValue = function (t, e, i, s) {
                if (t <= 0) return 0;
                if (t >= 1) return 1;
                var n = i + 1,
                  r = Math.floor(t * n),
                  a = 0 === r ? 0 : e[s + r - 1];
                return (
                  1e-4 *
                  (a + ((r === n - 1 ? 1e4 : e[s + r]) - a) * (t * n - r))
                );
              }),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this),
                  (this._tweenType = 0),
                  (this._curveCount = 0),
                  (this._framePosition = 0),
                  (this._frameDurationR = 0),
                  (this._tweenProgress = 0),
                  (this._tweenEasing = 0);
              }),
              (e.prototype._onArriveAtFrame = function () {
                if (
                  this._frameCount > 1 &&
                  (this._frameIndex !== this._frameCount - 1 ||
                    0 === this._animationState.playTimes ||
                    this._animationState.currentPlayTimes <
                      this._animationState.playTimes - 1)
                )
                  if (
                    ((this._tweenType =
                      this._frameArray[this._frameOffset + 1]),
                    (this._tweenState = 0 === this._tweenType ? 1 : 2),
                    2 === this._tweenType
                      ? (this._curveCount =
                          this._frameArray[this._frameOffset + 2])
                      : 0 !== this._tweenType &&
                        1 !== this._tweenType &&
                        (this._tweenEasing =
                          0.01 * this._frameArray[this._frameOffset + 2]),
                    (this._framePosition =
                      this._frameArray[this._frameOffset] * this._frameRateR),
                    this._frameIndex === this._frameCount - 1)
                  )
                    this._frameDurationR =
                      1 / (this._animationData.duration - this._framePosition);
                  else {
                    var t =
                        this._animationData.frameOffset +
                        this._timelineArray[
                          this._timelineData.offset + 5 + this._frameIndex + 1
                        ],
                      e =
                        this._frameArray[t] * this._frameRateR -
                        this._framePosition;
                    this._frameDurationR = e > 0 ? 1 / e : 0;
                  }
                else this._tweenState = 1;
              }),
              (e.prototype._onUpdateFrame = function () {
                2 === this._tweenState
                  ? ((this._tweenProgress =
                      (this.currentTime - this._framePosition) *
                      this._frameDurationR),
                    2 === this._tweenType
                      ? (this._tweenProgress = e._getEasingCurveValue(
                          this._tweenProgress,
                          this._frameArray,
                          this._curveCount,
                          this._frameOffset + 3
                        ))
                      : 1 !== this._tweenType &&
                        (this._tweenProgress = e._getEasingValue(
                          this._tweenType,
                          this._tweenProgress,
                          this._tweenEasing
                        )))
                  : (this._tweenProgress = 0);
              }),
              e
            );
          })(e);
          t.TweenTimelineState = i;
          var s = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this),
                  (this.bone = null),
                  (this.bonePose = null);
              }),
              (e.prototype.blend = function (t) {
                var e = this.bone._blendState.blendWeight,
                  i = this.bone.animationPose,
                  s = this.bonePose.result;
                2 === t
                  ? ((i.x += s.x * e),
                    (i.y += s.y * e),
                    (i.rotation += s.rotation * e),
                    (i.skew += s.skew * e),
                    (i.scaleX += (s.scaleX - 1) * e),
                    (i.scaleY += (s.scaleY - 1) * e))
                  : 1 !== e
                  ? ((i.x = s.x * e),
                    (i.y = s.y * e),
                    (i.rotation = s.rotation * e),
                    (i.skew = s.skew * e),
                    (i.scaleX = (s.scaleX - 1) * e + 1),
                    (i.scaleY = (s.scaleY - 1) * e + 1))
                  : ((i.x = s.x),
                    (i.y = s.y),
                    (i.rotation = s.rotation),
                    (i.skew = s.skew),
                    (i.scaleX = s.scaleX),
                    (i.scaleY = s.scaleY)),
                  (0 === this._animationState._fadeState &&
                    0 === this._animationState._subFadeState) ||
                    (this.bone._transformDirty = !0);
              }),
              e
            );
          })(i);
          t.BoneTimelineState = s;
          var n = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this), (this.slot = null);
              }),
              e
            );
          })(i);
          t.SlotTimelineState = n;
          var r = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this), (this.constraint = null);
              }),
              e
            );
          })(i);
          t.ConstraintTimelineState = r;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (e) {
            function i() {
              return (null !== e && e.apply(this, arguments)) || this;
            }
            return (
              Z2(i, e),
              (i.toString = function () {
                return "[class dragonBones.ActionTimelineState]";
              }),
              (i.prototype._onCrossFrame = function (e) {
                var i = this._armature.eventDispatcher;
                if (this._animationState.actionEnabled)
                  for (
                    var s =
                        this._animationData.frameOffset +
                        this._timelineArray[this._timelineData.offset + 5 + e],
                      n = this._frameArray[s + 1],
                      r = this._animationData.parent.actions,
                      a = 0;
                    a < n;
                    ++a
                  ) {
                    var o = r[this._frameArray[s + 2 + a]];
                    if (0 === o.type)
                      ((h = t.BaseObject.borrowObject(t.EventObject)).time =
                        this._frameArray[s] / this._frameRate),
                        (h.animationState = this._animationState),
                        t.EventObject.actionDataToInstance(
                          o,
                          h,
                          this._armature
                        ),
                        this._armature._bufferAction(h, !0);
                    else {
                      var h,
                        l =
                          10 === o.type
                            ? t.EventObject.FRAME_EVENT
                            : t.EventObject.SOUND_EVENT;
                      (11 === o.type || i.hasDBEventListener(l)) &&
                        (((h = t.BaseObject.borrowObject(t.EventObject)).time =
                          this._frameArray[s] / this._frameRate),
                        (h.animationState = this._animationState),
                        t.EventObject.actionDataToInstance(
                          o,
                          h,
                          this._armature
                        ),
                        this._armature._dragonBones.bufferEvent(h));
                    }
                  }
              }),
              (i.prototype._onArriveAtFrame = function () {}),
              (i.prototype._onUpdateFrame = function () {}),
              (i.prototype.update = function (e) {
                var i = this.playState,
                  s = this.currentPlayTimes,
                  n = this.currentTime;
                if (this._setCurrentTime(e)) {
                  var r = this._armature.eventDispatcher;
                  if (i < 0) {
                    if (this.playState === i) return;
                    if (
                      (this._animationState.displayControl &&
                        this._animationState.resetToPose &&
                        this._armature._sortZOrder(null, 0),
                      (s = this.currentPlayTimes),
                      r.hasDBEventListener(t.EventObject.START))
                    ) {
                      var a = t.BaseObject.borrowObject(t.EventObject);
                      (a.type = t.EventObject.START),
                        (a.armature = this._armature),
                        (a.animationState = this._animationState),
                        this._armature._dragonBones.bufferEvent(a);
                    }
                  }
                  var o = this._animationState.timeScale < 0,
                    h = null,
                    l = null;
                  if (
                    (this.currentPlayTimes !== s &&
                      (r.hasDBEventListener(t.EventObject.LOOP_COMPLETE) &&
                        (((h = t.BaseObject.borrowObject(t.EventObject)).type =
                          t.EventObject.LOOP_COMPLETE),
                        (h.armature = this._armature),
                        (h.animationState = this._animationState)),
                      this.playState > 0 &&
                        r.hasDBEventListener(t.EventObject.COMPLETE) &&
                        (((l = t.BaseObject.borrowObject(t.EventObject)).type =
                          t.EventObject.COMPLETE),
                        (l.armature = this._armature),
                        (l.animationState = this._animationState))),
                    this._frameCount > 1)
                  ) {
                    var c = this._timelineData,
                      u = Math.floor(this.currentTime * this._frameRate),
                      _ = this._frameIndices[c.frameIndicesOffset + u];
                    if (this._frameIndex !== _) {
                      var d = this._frameIndex;
                      if (
                        ((this._frameIndex = _), null !== this._timelineArray)
                      )
                        if (
                          ((this._frameOffset =
                            this._animationData.frameOffset +
                            this._timelineArray[
                              c.offset + 5 + this._frameIndex
                            ]),
                          o)
                        ) {
                          if (d < 0) {
                            var p = Math.floor(n * this._frameRate);
                            (d = this._frameIndices[c.frameIndicesOffset + p]),
                              this.currentPlayTimes === s &&
                                d === _ &&
                                (d = -1);
                          }
                          for (; d >= 0; ) {
                            var m =
                                this._animationData.frameOffset +
                                this._timelineArray[c.offset + 5 + d],
                              f = this._frameArray[m] / this._frameRate;
                            if (
                              (this._position <= f &&
                                f <= this._position + this._duration &&
                                this._onCrossFrame(d),
                              null !== h &&
                                0 === d &&
                                (this._armature._dragonBones.bufferEvent(h),
                                (h = null)),
                              d > 0 ? d-- : (d = this._frameCount - 1),
                              d === _)
                            )
                              break;
                          }
                        } else
                          for (
                            d < 0 &&
                            ((p = Math.floor(n * this._frameRate)),
                            (d = this._frameIndices[c.frameIndicesOffset + p]),
                            (m =
                              this._animationData.frameOffset +
                              this._timelineArray[c.offset + 5 + d]),
                            (f = this._frameArray[m] / this._frameRate),
                            this.currentPlayTimes === s &&
                              (n <= f
                                ? d > 0
                                  ? d--
                                  : (d = this._frameCount - 1)
                                : d === _ && (d = -1)));
                            d >= 0 &&
                            (d < this._frameCount - 1 ? d++ : (d = 0),
                            (m =
                              this._animationData.frameOffset +
                              this._timelineArray[c.offset + 5 + d]),
                            (f = this._frameArray[m] / this._frameRate),
                            this._position <= f &&
                              f <= this._position + this._duration &&
                              this._onCrossFrame(d),
                            null !== h &&
                              0 === d &&
                              (this._armature._dragonBones.bufferEvent(h),
                              (h = null)),
                            d !== _);

                          );
                    }
                  } else
                    this._frameIndex < 0 &&
                      ((this._frameIndex = 0), null !== this._timelineData) &&
                      ((this._frameOffset =
                        this._animationData.frameOffset +
                        this._timelineArray[this._timelineData.offset + 5]),
                      (f =
                        this._frameArray[this._frameOffset] / this._frameRate),
                      this.currentPlayTimes === s
                        ? n <= f && this._onCrossFrame(this._frameIndex)
                        : this._position <= f &&
                          (o ||
                            null === h ||
                            (this._armature._dragonBones.bufferEvent(h),
                            (h = null)),
                          this._onCrossFrame(this._frameIndex)));
                  null !== h && this._armature._dragonBones.bufferEvent(h),
                    null !== l && this._armature._dragonBones.bufferEvent(l);
                }
              }),
              (i.prototype.setCurrentTime = function (t) {
                this._setCurrentTime(t), (this._frameIndex = -1);
              }),
              i
            );
          })(t.TimelineState);
          t.ActionTimelineState = e;
          var i = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.ZOrderTimelineState]";
              }),
              (e.prototype._onArriveAtFrame = function () {
                this.playState >= 0 &&
                  (this._frameArray[this._frameOffset + 1] > 0
                    ? this._armature._sortZOrder(
                        this._frameArray,
                        this._frameOffset + 2
                      )
                    : this._armature._sortZOrder(null, 0));
              }),
              (e.prototype._onUpdateFrame = function () {}),
              e
            );
          })(t.TimelineState);
          t.ZOrderTimelineState = i;
          var s = (function (e) {
            function i() {
              return (null !== e && e.apply(this, arguments)) || this;
            }
            return (
              Z2(i, e),
              (i.toString = function () {
                return "[class dragonBones.BoneAllTimelineState]";
              }),
              (i.prototype._onArriveAtFrame = function () {
                if (
                  (e.prototype._onArriveAtFrame.call(this),
                  null !== this._timelineData)
                ) {
                  var t =
                      this._animationData.frameFloatOffset +
                      this._frameValueOffset +
                      6 * this._frameIndex,
                    i = this._armature._armatureData.scale,
                    s = this._frameFloatArray,
                    n = this.bonePose.current,
                    r = this.bonePose.delta;
                  (n.x = s[t++] * i),
                    (n.y = s[t++] * i),
                    (n.rotation = s[t++]),
                    (n.skew = s[t++]),
                    (n.scaleX = s[t++]),
                    (n.scaleY = s[t++]),
                    2 === this._tweenState
                      ? (this._frameIndex === this._frameCount - 1 &&
                          (t =
                            this._animationData.frameFloatOffset +
                            this._frameValueOffset),
                        (r.x = s[t++] * i - n.x),
                        (r.y = s[t++] * i - n.y),
                        (r.rotation = s[t++] - n.rotation),
                        (r.skew = s[t++] - n.skew),
                        (r.scaleX = s[t++] - n.scaleX),
                        (r.scaleY = s[t++] - n.scaleY))
                      : ((r.x = 0),
                        (r.y = 0),
                        (r.rotation = 0),
                        (r.skew = 0),
                        (r.scaleX = 0),
                        (r.scaleY = 0));
                } else
                  (n = this.bonePose.current),
                    (r = this.bonePose.delta),
                    (n.x = 0),
                    (n.y = 0),
                    (n.rotation = 0),
                    (n.skew = 0),
                    (n.scaleX = 1),
                    (n.scaleY = 1),
                    (r.x = 0),
                    (r.y = 0),
                    (r.rotation = 0),
                    (r.skew = 0),
                    (r.scaleX = 0),
                    (r.scaleY = 0);
              }),
              (i.prototype._onUpdateFrame = function () {
                e.prototype._onUpdateFrame.call(this);
                var t = this.bonePose.current,
                  i = this.bonePose.delta,
                  s = this.bonePose.result;
                (this.bone._transformDirty = !0),
                  2 !== this._tweenState && (this._tweenState = 0),
                  (s.x = t.x + i.x * this._tweenProgress),
                  (s.y = t.y + i.y * this._tweenProgress),
                  (s.rotation = t.rotation + i.rotation * this._tweenProgress),
                  (s.skew = t.skew + i.skew * this._tweenProgress),
                  (s.scaleX = t.scaleX + i.scaleX * this._tweenProgress),
                  (s.scaleY = t.scaleY + i.scaleY * this._tweenProgress);
              }),
              (i.prototype.fadeOut = function () {
                var e = this.bonePose.result;
                (e.rotation = t.Transform.normalizeRadian(e.rotation)),
                  (e.skew = t.Transform.normalizeRadian(e.skew));
              }),
              i
            );
          })(t.BoneTimelineState);
          t.BoneAllTimelineState = s;
          var n = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.BoneTranslateTimelineState]";
              }),
              (e.prototype._onArriveAtFrame = function () {
                if (
                  (t.prototype._onArriveAtFrame.call(this),
                  null !== this._timelineData)
                ) {
                  var e =
                      this._animationData.frameFloatOffset +
                      this._frameValueOffset +
                      2 * this._frameIndex,
                    i = this._armature._armatureData.scale,
                    s = this._frameFloatArray,
                    n = this.bonePose.current,
                    r = this.bonePose.delta;
                  (n.x = s[e++] * i),
                    (n.y = s[e++] * i),
                    2 === this._tweenState
                      ? (this._frameIndex === this._frameCount - 1 &&
                          (e =
                            this._animationData.frameFloatOffset +
                            this._frameValueOffset),
                        (r.x = s[e++] * i - n.x),
                        (r.y = s[e++] * i - n.y))
                      : ((r.x = 0), (r.y = 0));
                } else
                  (n = this.bonePose.current),
                    (r = this.bonePose.delta),
                    (n.x = 0),
                    (n.y = 0),
                    (r.x = 0),
                    (r.y = 0);
              }),
              (e.prototype._onUpdateFrame = function () {
                t.prototype._onUpdateFrame.call(this);
                var e = this.bonePose.current,
                  i = this.bonePose.delta,
                  s = this.bonePose.result;
                (this.bone._transformDirty = !0),
                  2 !== this._tweenState && (this._tweenState = 0),
                  (s.x = e.x + i.x * this._tweenProgress),
                  (s.y = e.y + i.y * this._tweenProgress);
              }),
              e
            );
          })(t.BoneTimelineState);
          t.BoneTranslateTimelineState = n;
          var r = (function (e) {
            function i() {
              return (null !== e && e.apply(this, arguments)) || this;
            }
            return (
              Z2(i, e),
              (i.toString = function () {
                return "[class dragonBones.BoneRotateTimelineState]";
              }),
              (i.prototype._onArriveAtFrame = function () {
                if (
                  (e.prototype._onArriveAtFrame.call(this),
                  null !== this._timelineData)
                ) {
                  var i =
                      this._animationData.frameFloatOffset +
                      this._frameValueOffset +
                      2 * this._frameIndex,
                    s = this._frameFloatArray,
                    n = this.bonePose.current,
                    r = this.bonePose.delta;
                  (n.rotation = s[i++]),
                    (n.skew = s[i++]),
                    2 === this._tweenState
                      ? (this._frameIndex === this._frameCount - 1
                          ? ((i =
                              this._animationData.frameFloatOffset +
                              this._frameValueOffset),
                            (r.rotation = t.Transform.normalizeRadian(
                              s[i++] - n.rotation
                            )))
                          : (r.rotation = s[i++] - n.rotation),
                        (r.skew = s[i++] - n.skew))
                      : ((r.rotation = 0), (r.skew = 0));
                } else
                  (n = this.bonePose.current),
                    (r = this.bonePose.delta),
                    (n.rotation = 0),
                    (n.skew = 0),
                    (r.rotation = 0),
                    (r.skew = 0);
              }),
              (i.prototype._onUpdateFrame = function () {
                e.prototype._onUpdateFrame.call(this);
                var t = this.bonePose.current,
                  i = this.bonePose.delta,
                  s = this.bonePose.result;
                (this.bone._transformDirty = !0),
                  2 !== this._tweenState && (this._tweenState = 0),
                  (s.rotation = t.rotation + i.rotation * this._tweenProgress),
                  (s.skew = t.skew + i.skew * this._tweenProgress);
              }),
              (i.prototype.fadeOut = function () {
                var e = this.bonePose.result;
                (e.rotation = t.Transform.normalizeRadian(e.rotation)),
                  (e.skew = t.Transform.normalizeRadian(e.skew));
              }),
              i
            );
          })(t.BoneTimelineState);
          t.BoneRotateTimelineState = r;
          var a = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.BoneScaleTimelineState]";
              }),
              (e.prototype._onArriveAtFrame = function () {
                if (
                  (t.prototype._onArriveAtFrame.call(this),
                  null !== this._timelineData)
                ) {
                  var e =
                      this._animationData.frameFloatOffset +
                      this._frameValueOffset +
                      2 * this._frameIndex,
                    i = this._frameFloatArray,
                    s = this.bonePose.current,
                    n = this.bonePose.delta;
                  (s.scaleX = i[e++]),
                    (s.scaleY = i[e++]),
                    2 === this._tweenState
                      ? (this._frameIndex === this._frameCount - 1 &&
                          (e =
                            this._animationData.frameFloatOffset +
                            this._frameValueOffset),
                        (n.scaleX = i[e++] - s.scaleX),
                        (n.scaleY = i[e++] - s.scaleY))
                      : ((n.scaleX = 0), (n.scaleY = 0));
                } else
                  (s = this.bonePose.current),
                    (n = this.bonePose.delta),
                    (s.scaleX = 1),
                    (s.scaleY = 1),
                    (n.scaleX = 0),
                    (n.scaleY = 0);
              }),
              (e.prototype._onUpdateFrame = function () {
                t.prototype._onUpdateFrame.call(this);
                var e = this.bonePose.current,
                  i = this.bonePose.delta,
                  s = this.bonePose.result;
                (this.bone._transformDirty = !0),
                  2 !== this._tweenState && (this._tweenState = 0),
                  (s.scaleX = e.scaleX + i.scaleX * this._tweenProgress),
                  (s.scaleY = e.scaleY + i.scaleY * this._tweenProgress);
              }),
              e
            );
          })(t.BoneTimelineState);
          t.BoneScaleTimelineState = a;
          var o = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (e._current = []), (e._delta = []), (e._result = []), e;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.SurfaceTimelineState]";
              }),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this),
                  (this.surface = null),
                  (this._frameFloatOffset = 0),
                  (this._valueCount = 0),
                  (this._deformCount = 0),
                  (this._valueOffset = 0),
                  (this._current.length = 0),
                  (this._delta.length = 0),
                  (this._result.length = 0);
              }),
              (e.prototype._onArriveAtFrame = function () {
                if (
                  (t.prototype._onArriveAtFrame.call(this),
                  null !== this._timelineData)
                ) {
                  var e =
                      this._animationData.frameFloatOffset +
                      this._frameValueOffset +
                      this._frameIndex * this._valueCount,
                    i = this._armature._armatureData.scale,
                    s = this._frameFloatArray;
                  if (2 === this._tweenState) {
                    var n = e + this._valueCount;
                    this._frameIndex === this._frameCount - 1 &&
                      (n =
                        this._animationData.frameFloatOffset +
                        this._frameValueOffset);
                    for (var r = 0; r < this._valueCount; ++r)
                      this._delta[r] =
                        s[n + r] * i - (this._current[r] = s[e + r] * i);
                  } else
                    for (r = 0; r < this._valueCount; ++r)
                      this._current[r] = s[e + r] * i;
                } else
                  for (r = 0; r < this._valueCount; ++r) this._current[r] = 0;
              }),
              (e.prototype._onUpdateFrame = function () {
                t.prototype._onUpdateFrame.call(this),
                  (this.surface._transformDirty = !0),
                  2 !== this._tweenState && (this._tweenState = 0);
                for (var e = 0; e < this._valueCount; ++e)
                  this._result[e] =
                    this._current[e] + this._delta[e] * this._tweenProgress;
              }),
              (e.prototype.init = function (e, i, s) {
                if (
                  (t.prototype.init.call(this, e, i, s),
                  null !== this._timelineData)
                ) {
                  var n =
                    this._animationData.frameIntOffset +
                    this._timelineArray[this._timelineData.offset + 3];
                  (this._deformCount = this._frameIntArray[n + 1]),
                    (this._valueCount = this._frameIntArray[n + 2]),
                    (this._valueOffset = this._frameIntArray[n + 3]),
                    (this._frameFloatOffset =
                      this._frameIntArray[n + 4] +
                      this._animationData.frameFloatOffset);
                } else
                  (this._deformCount = this.surface._deformVertices.length),
                    (this._valueCount = this._deformCount),
                    (this._valueOffset = 0),
                    (this._frameFloatOffset = 0);
                (this._current.length = this._valueCount),
                  (this._delta.length = this._valueCount),
                  (this._result.length = this._valueCount);
                for (var r = 0; r < this._valueCount; ++r) this._delta[r] = 0;
              }),
              (e.prototype.blend = function (t) {
                for (
                  var e = this.surface._blendState.blendWeight,
                    i = this.surface._deformVertices,
                    s = 0;
                  s < this._deformCount;
                  ++s
                ) {
                  var n;
                  (n =
                    s < this._valueOffset
                      ? this._frameFloatArray[this._frameFloatOffset + s]
                      : s < this._valueOffset + this._valueCount
                      ? this._result[s - this._valueOffset]
                      : this._frameFloatArray[
                          this._frameFloatOffset + s - this._valueCount
                        ]),
                    2 === t ? (i[s] += n * e) : (i[s] = 1 !== e ? n * e : n);
                }
                (0 === this._animationState._fadeState &&
                  0 === this._animationState._subFadeState) ||
                  (this.surface._transformDirty = !0);
              }),
              e
            );
          })(t.TweenTimelineState);
          t.SurfaceTimelineState = o;
          var h = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.SlotDislayTimelineState]";
              }),
              (e.prototype._onArriveAtFrame = function () {
                if (this.playState >= 0) {
                  var t =
                    null !== this._timelineData
                      ? this._frameArray[this._frameOffset + 1]
                      : this.slot._slotData.displayIndex;
                  this.slot.displayIndex !== t &&
                    this.slot._setDisplayIndex(t, !0);
                }
              }),
              e
            );
          })(t.SlotTimelineState);
          t.SlotDislayTimelineState = h;
          var l = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (
                (e._current = [0, 0, 0, 0, 0, 0, 0, 0]),
                (e._delta = [0, 0, 0, 0, 0, 0, 0, 0]),
                (e._result = [0, 0, 0, 0, 0, 0, 0, 0]),
                e
              );
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.SlotColorTimelineState]";
              }),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this), (this._dirty = !1);
              }),
              (e.prototype._onArriveAtFrame = function () {
                if (
                  (t.prototype._onArriveAtFrame.call(this),
                  null !== this._timelineData)
                ) {
                  var e = this._dragonBonesData.intArray,
                    i = this._frameIntArray,
                    s =
                      this._animationData.frameIntOffset +
                      this._frameValueOffset +
                      1 * this._frameIndex,
                    n = i[s];
                  n < 0 && (n += 65536),
                    (this._current[0] = e[n++]),
                    (this._current[1] = e[n++]),
                    (this._current[2] = e[n++]),
                    (this._current[3] = e[n++]),
                    (this._current[4] = e[n++]),
                    (this._current[5] = e[n++]),
                    (this._current[6] = e[n++]),
                    (this._current[7] = e[n++]),
                    2 === this._tweenState &&
                      ((n =
                        this._frameIndex === this._frameCount - 1
                          ? i[
                              this._animationData.frameIntOffset +
                                this._frameValueOffset
                            ]
                          : i[s + 1]) < 0 && (n += 65536),
                      (this._delta[0] = e[n++] - this._current[0]),
                      (this._delta[1] = e[n++] - this._current[1]),
                      (this._delta[2] = e[n++] - this._current[2]),
                      (this._delta[3] = e[n++] - this._current[3]),
                      (this._delta[4] = e[n++] - this._current[4]),
                      (this._delta[5] = e[n++] - this._current[5]),
                      (this._delta[6] = e[n++] - this._current[6]),
                      (this._delta[7] = e[n++] - this._current[7]));
                } else {
                  var r = this.slot._slotData.color;
                  (this._current[0] = 100 * r.alphaMultiplier),
                    (this._current[1] = 100 * r.redMultiplier),
                    (this._current[2] = 100 * r.greenMultiplier),
                    (this._current[3] = 100 * r.blueMultiplier),
                    (this._current[4] = r.alphaOffset),
                    (this._current[5] = r.redOffset),
                    (this._current[6] = r.greenOffset),
                    (this._current[7] = r.blueOffset);
                }
              }),
              (e.prototype._onUpdateFrame = function () {
                t.prototype._onUpdateFrame.call(this),
                  (this._dirty = !0),
                  2 !== this._tweenState && (this._tweenState = 0),
                  (this._result[0] =
                    0.01 *
                    (this._current[0] + this._delta[0] * this._tweenProgress)),
                  (this._result[1] =
                    0.01 *
                    (this._current[1] + this._delta[1] * this._tweenProgress)),
                  (this._result[2] =
                    0.01 *
                    (this._current[2] + this._delta[2] * this._tweenProgress)),
                  (this._result[3] =
                    0.01 *
                    (this._current[3] + this._delta[3] * this._tweenProgress)),
                  (this._result[4] =
                    this._current[4] + this._delta[4] * this._tweenProgress),
                  (this._result[5] =
                    this._current[5] + this._delta[5] * this._tweenProgress),
                  (this._result[6] =
                    this._current[6] + this._delta[6] * this._tweenProgress),
                  (this._result[7] =
                    this._current[7] + this._delta[7] * this._tweenProgress);
              }),
              (e.prototype.fadeOut = function () {
                (this._tweenState = 0), (this._dirty = !1);
              }),
              (e.prototype.update = function (e) {
                if (
                  (t.prototype.update.call(this, e),
                  0 !== this._tweenState || this._dirty)
                ) {
                  var i = this.slot._colorTransform;
                  if (
                    0 !== this._animationState._fadeState ||
                    0 !== this._animationState._subFadeState
                  ) {
                    if (
                      i.alphaMultiplier !== this._result[0] ||
                      i.redMultiplier !== this._result[1] ||
                      i.greenMultiplier !== this._result[2] ||
                      i.blueMultiplier !== this._result[3] ||
                      i.alphaOffset !== this._result[4] ||
                      i.redOffset !== this._result[5] ||
                      i.greenOffset !== this._result[6] ||
                      i.blueOffset !== this._result[7]
                    ) {
                      var s = Math.pow(this._animationState._fadeProgress, 4);
                      (i.alphaMultiplier +=
                        (this._result[0] - i.alphaMultiplier) * s),
                        (i.redMultiplier +=
                          (this._result[1] - i.redMultiplier) * s),
                        (i.greenMultiplier +=
                          (this._result[2] - i.greenMultiplier) * s),
                        (i.blueMultiplier +=
                          (this._result[3] - i.blueMultiplier) * s),
                        (i.alphaOffset +=
                          (this._result[4] - i.alphaOffset) * s),
                        (i.redOffset += (this._result[5] - i.redOffset) * s),
                        (i.greenOffset +=
                          (this._result[6] - i.greenOffset) * s),
                        (i.blueOffset += (this._result[7] - i.blueOffset) * s),
                        (this.slot._colorDirty = !0);
                    }
                  } else
                    this._dirty &&
                      ((this._dirty = !1),
                      (i.alphaMultiplier === this._result[0] &&
                        i.redMultiplier === this._result[1] &&
                        i.greenMultiplier === this._result[2] &&
                        i.blueMultiplier === this._result[3] &&
                        i.alphaOffset === this._result[4] &&
                        i.redOffset === this._result[5] &&
                        i.greenOffset === this._result[6] &&
                        i.blueOffset === this._result[7]) ||
                        ((i.alphaMultiplier = this._result[0]),
                        (i.redMultiplier = this._result[1]),
                        (i.greenMultiplier = this._result[2]),
                        (i.blueMultiplier = this._result[3]),
                        (i.alphaOffset = this._result[4]),
                        (i.redOffset = this._result[5]),
                        (i.greenOffset = this._result[6]),
                        (i.blueOffset = this._result[7]),
                        (this.slot._colorDirty = !0)));
                }
              }),
              e
            );
          })(t.SlotTimelineState);
          t.SlotColorTimelineState = l;
          var c = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (e._current = []), (e._delta = []), (e._result = []), e;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.DeformTimelineState]";
              }),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this),
                  (this.vertexOffset = 0),
                  (this._dirty = !1),
                  (this._frameFloatOffset = 0),
                  (this._valueCount = 0),
                  (this._deformCount = 0),
                  (this._valueOffset = 0),
                  (this._current.length = 0),
                  (this._delta.length = 0),
                  (this._result.length = 0);
              }),
              (e.prototype._onArriveAtFrame = function () {
                if (
                  (t.prototype._onArriveAtFrame.call(this),
                  null !== this._timelineData)
                ) {
                  var e =
                      this._animationData.frameFloatOffset +
                      this._frameValueOffset +
                      this._frameIndex * this._valueCount,
                    i = this._armature._armatureData.scale,
                    s = this._frameFloatArray;
                  if (2 === this._tweenState) {
                    var n = e + this._valueCount;
                    this._frameIndex === this._frameCount - 1 &&
                      (n =
                        this._animationData.frameFloatOffset +
                        this._frameValueOffset);
                    for (var r = 0; r < this._valueCount; ++r)
                      this._delta[r] =
                        s[n + r] * i - (this._current[r] = s[e + r] * i);
                  } else
                    for (r = 0; r < this._valueCount; ++r)
                      this._current[r] = s[e + r] * i;
                } else
                  for (r = 0; r < this._valueCount; ++r) this._current[r] = 0;
              }),
              (e.prototype._onUpdateFrame = function () {
                t.prototype._onUpdateFrame.call(this),
                  (this._dirty = !0),
                  2 !== this._tweenState && (this._tweenState = 0);
                for (var e = 0; e < this._valueCount; ++e)
                  this._result[e] =
                    this._current[e] + this._delta[e] * this._tweenProgress;
              }),
              (e.prototype.init = function (e, i, s) {
                if (
                  (t.prototype.init.call(this, e, i, s),
                  null !== this._timelineData)
                ) {
                  var n =
                    this._animationData.frameIntOffset +
                    this._timelineArray[this._timelineData.offset + 3];
                  (this.vertexOffset = this._frameIntArray[n + 0]),
                    this.vertexOffset < 0 && (this.vertexOffset += 65536),
                    (this._deformCount = this._frameIntArray[n + 1]),
                    (this._valueCount = this._frameIntArray[n + 2]),
                    (this._valueOffset = this._frameIntArray[n + 3]),
                    (this._frameFloatOffset =
                      this._frameIntArray[n + 4] +
                      this._animationData.frameFloatOffset);
                } else {
                  var r = this.slot._deformVertices;
                  (this._deformCount = null !== r ? r.vertices.length : 0),
                    (this._valueCount = this._deformCount),
                    (this._valueOffset = 0),
                    (this._frameFloatOffset = 0);
                }
                (this._current.length = this._valueCount),
                  (this._delta.length = this._valueCount),
                  (this._result.length = this._valueCount);
                for (var a = 0; a < this._valueCount; ++a) this._delta[a] = 0;
              }),
              (e.prototype.fadeOut = function () {
                (this._tweenState = 0), (this._dirty = !1);
              }),
              (e.prototype.update = function (e) {
                var i = this.slot._deformVertices;
                if (
                  null !== i &&
                  null !== i.verticesData &&
                  i.verticesData.offset === this.vertexOffset &&
                  (t.prototype.update.call(this, e),
                  0 !== this._tweenState || this._dirty)
                ) {
                  var s = i.vertices;
                  if (
                    0 !== this._animationState._fadeState ||
                    0 !== this._animationState._subFadeState
                  ) {
                    for (
                      var n = Math.pow(this._animationState._fadeProgress, 2),
                        r = 0;
                      r < this._deformCount;
                      ++r
                    )
                      r < this._valueOffset
                        ? (s[r] +=
                            (this._frameFloatArray[this._frameFloatOffset + r] -
                              s[r]) *
                            n)
                        : r < this._valueOffset + this._valueCount
                        ? (s[r] +=
                            (this._result[r - this._valueOffset] - s[r]) * n)
                        : (s[r] +=
                            (this._frameFloatArray[
                              this._frameFloatOffset + r - this._valueCount
                            ] -
                              s[r]) *
                            n);
                    i.verticesDirty = !0;
                  } else if (this._dirty) {
                    for (this._dirty = !1, r = 0; r < this._deformCount; ++r)
                      r < this._valueOffset
                        ? (s[r] =
                            this._frameFloatArray[this._frameFloatOffset + r])
                        : r < this._valueOffset + this._valueCount
                        ? (s[r] = this._result[r - this._valueOffset])
                        : (s[r] =
                            this._frameFloatArray[
                              this._frameFloatOffset + r - this._valueCount
                            ]);
                    i.verticesDirty = !0;
                  }
                }
              }),
              e
            );
          })(t.SlotTimelineState);
          t.DeformTimelineState = c;
          var u = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.IKConstraintTimelineState]";
              }),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this),
                  (this._current = 0),
                  (this._delta = 0);
              }),
              (e.prototype._onArriveAtFrame = function () {
                t.prototype._onArriveAtFrame.call(this);
                var e = this.constraint;
                if (null !== this._timelineData) {
                  var i =
                      this._animationData.frameIntOffset +
                      this._frameValueOffset +
                      2 * this._frameIndex,
                    s = this._frameIntArray,
                    n = 0 !== s[i++];
                  (this._current = 0.01 * s[i++]),
                    2 === this._tweenState
                      ? (this._frameIndex === this._frameCount - 1 &&
                          (i =
                            this._animationData.frameIntOffset +
                            this._frameValueOffset),
                        (this._delta = 0.01 * s[i + 1] - this._current))
                      : (this._delta = 0),
                    (e._bendPositive = n);
                } else {
                  var r = e._constraintData;
                  (this._current = r.weight),
                    (this._delta = 0),
                    (e._bendPositive = r.bendPositive);
                }
                e.invalidUpdate();
              }),
              (e.prototype._onUpdateFrame = function () {
                t.prototype._onUpdateFrame.call(this),
                  2 !== this._tweenState && (this._tweenState = 0);
                var e = this.constraint;
                (e._weight = this._current + this._delta * this._tweenProgress),
                  e.invalidUpdate();
              }),
              e
            );
          })(t.ConstraintTimelineState);
          t.IKConstraintTimelineState = u;
          var _ = (function (t) {
            function e() {
              var e = (null !== t && t.apply(this, arguments)) || this;
              return (e._floats = [0, 0, 0, 0, 0, 0]), e;
            }
            return (
              Z2(e, t),
              (e.toString = function () {
                return "[class dragonBones.AnimationTimelineState]";
              }),
              (e.prototype._onClear = function () {
                t.prototype._onClear.call(this), (this.animationState = null);
              }),
              (e.prototype._onArriveAtFrame = function () {
                if (
                  (t.prototype._onArriveAtFrame.call(this),
                  null !== this._timelineData)
                ) {
                  var e =
                      this._animationData.frameIntOffset +
                      this._frameValueOffset +
                      2 * this._frameIndex,
                    i = 1 / this.animationState._animationData.parent.frameRate,
                    s = this._frameIntArray;
                  (this._floats[0] = s[e++] * i),
                    (this._floats[3] = 0.01 * s[e++]),
                    2 === this._tweenState
                      ? (this._frameIndex === this._frameCount - 1 &&
                          (e =
                            this._animationData.frameIntOffset +
                            this._frameValueOffset),
                        (this._floats[1] = s[e++] * i - this._floats[0]),
                        (this._floats[4] = 0.01 * s[e++] - this._floats[3]))
                      : ((this._floats[1] = 0), (this._floats[4] = 0));
                }
              }),
              (e.prototype._onUpdateFrame = function () {
                t.prototype._onUpdateFrame.call(this),
                  2 !== this._tweenState && (this._tweenState = 0),
                  this._floats[0] >= 0 &&
                    (this._floats[2] =
                      this._floats[0] + this._floats[1] * this._tweenProgress),
                  (this._floats[5] =
                    this._floats[3] + this._floats[4] * this._tweenProgress);
              }),
              (e.prototype.blend = function (t) {
                var e = this.animationState,
                  i = e._blendState.blendWeight;
                2 === t
                  ? ((e.weight += this._floats[5] * i),
                    (e.currentTime += this._floats[2] * i))
                  : ((e.weight = this._floats[5] * i),
                    (e.currentTime = this._floats[2] * i));
              }),
              e
            );
          })(t.TweenTimelineState);
          t.AnimationTimelineState = _;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (t) {
            function e() {
              return (null !== t && t.apply(this, arguments)) || this;
            }
            return (
              Z2(e, t),
              (e.actionDataToInstance = function (t, i, s) {
                0 === t.type
                  ? (i.type = e.FRAME_EVENT)
                  : (i.type = 10 === t.type ? e.FRAME_EVENT : e.SOUND_EVENT),
                  (i.name = t.name),
                  (i.armature = s),
                  (i.actionData = t),
                  (i.data = t.data),
                  null !== t.bone && (i.bone = s.getBone(t.bone.name)),
                  null !== t.slot && (i.slot = s.getSlot(t.slot.name));
              }),
              (e.toString = function () {
                return "[class dragonBones.EventObject]";
              }),
              (e.prototype._onClear = function () {
                (this.time = 0),
                  (this.type = ""),
                  (this.name = ""),
                  (this.armature = null),
                  (this.bone = null),
                  (this.slot = null),
                  (this.animationState = null),
                  (this.actionData = null),
                  (this.data = null);
              }),
              (e.START = "start"),
              (e.LOOP_COMPLETE = "loopComplete"),
              (e.COMPLETE = "complete"),
              (e.FADE_IN = "fadeIn"),
              (e.FADE_IN_COMPLETE = "fadeInComplete"),
              (e.FADE_OUT = "fadeOut"),
              (e.FADE_OUT_COMPLETE = "fadeOutComplete"),
              (e.FRAME_EVENT = "frameEvent"),
              (e.SOUND_EVENT = "soundEvent"),
              e
            );
          })(t.BaseObject);
          t.EventObject = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function () {
            function e() {}
            return (
              (e._getArmatureType = function (t) {
                switch (t.toLowerCase()) {
                  case "stage":
                    return 2;
                  case "armature":
                    return 0;
                  case "movieclip":
                    return 1;
                  default:
                    return 0;
                }
              }),
              (e._getBoneType = function (t) {
                switch (t.toLowerCase()) {
                  case "bone":
                    return 0;
                  case "surface":
                    return 1;
                  default:
                    return 0;
                }
              }),
              (e._getDisplayType = function (t) {
                switch (t.toLowerCase()) {
                  case "image":
                    return 0;
                  case "mesh":
                    return 2;
                  case "armature":
                    return 1;
                  case "boundingbox":
                    return 3;
                  case "path":
                    return 4;
                  default:
                    return 0;
                }
              }),
              (e._getBoundingBoxType = function (t) {
                switch (t.toLowerCase()) {
                  case "rectangle":
                    return 0;
                  case "ellipse":
                    return 1;
                  case "polygon":
                    return 2;
                  default:
                    return 0;
                }
              }),
              (e._getActionType = function (t) {
                switch (t.toLowerCase()) {
                  case "play":
                    return 0;
                  case "frame":
                    return 10;
                  case "sound":
                    return 11;
                  default:
                    return 0;
                }
              }),
              (e._getBlendMode = function (t) {
                switch (t.toLowerCase()) {
                  case "normal":
                    return 0;
                  case "add":
                    return 1;
                  case "alpha":
                    return 2;
                  case "darken":
                    return 3;
                  case "difference":
                    return 4;
                  case "erase":
                    return 5;
                  case "hardlight":
                    return 6;
                  case "invert":
                    return 7;
                  case "layer":
                    return 8;
                  case "lighten":
                    return 9;
                  case "multiply":
                    return 10;
                  case "overlay":
                    return 11;
                  case "screen":
                    return 12;
                  case "subtract":
                    return 13;
                  default:
                    return 0;
                }
              }),
              (e._getPositionMode = function (t) {
                switch (t.toLocaleLowerCase()) {
                  case "percent":
                    return 1;
                  case "fixed":
                    return 0;
                  default:
                    return 1;
                }
              }),
              (e._getSpacingMode = function (t) {
                switch (t.toLocaleLowerCase()) {
                  case "length":
                    return 0;
                  case "percent":
                    return 2;
                  case "fixed":
                    return 1;
                  default:
                    return 0;
                }
              }),
              (e._getRotateMode = function (t) {
                switch (t.toLocaleLowerCase()) {
                  case "tangent":
                    return 0;
                  case "chain":
                    return 1;
                  case "chainscale":
                    return 2;
                  default:
                    return 0;
                }
              }),
              (e.parseDragonBonesData = function (e) {
                return (
                  console.warn("Deprecated."),
                  e instanceof ArrayBuffer
                    ? t.BinaryDataParser.getInstance().parseDragonBonesData(e)
                    : t.ObjectDataParser.getInstance().parseDragonBonesData(e)
                );
              }),
              (e.parseTextureAtlasData = function (i, s) {
                void 0 === s && (s = 1), console.warn("已废弃");
                for (
                  var n = {}, r = i[e.SUB_TEXTURE], a = 0, o = r.length;
                  a < o;
                  a++
                ) {
                  var h = r[a],
                    l = h[e.NAME],
                    c = new t.Rectangle(),
                    u = null;
                  (c.x = h[e.X] / s),
                    (c.y = h[e.Y] / s),
                    (c.width = h[e.WIDTH] / s),
                    (c.height = h[e.HEIGHT] / s),
                    e.FRAME_WIDTH in h &&
                      (((u = new t.Rectangle()).x = h[e.FRAME_X] / s),
                      (u.y = h[e.FRAME_Y] / s),
                      (u.width = h[e.FRAME_WIDTH] / s),
                      (u.height = h[e.FRAME_HEIGHT] / s)),
                    (n[l] = { region: c, frame: u, rotated: !1 });
                }
                return n;
              }),
              (e.DATA_VERSION_2_3 = "2.3"),
              (e.DATA_VERSION_3_0 = "3.0"),
              (e.DATA_VERSION_4_0 = "4.0"),
              (e.DATA_VERSION_4_5 = "4.5"),
              (e.DATA_VERSION_5_0 = "5.0"),
              (e.DATA_VERSION_5_5 = "5.5"),
              (e.DATA_VERSION = e.DATA_VERSION_5_5),
              (e.DATA_VERSIONS = [
                e.DATA_VERSION_4_0,
                e.DATA_VERSION_4_5,
                e.DATA_VERSION_5_0,
                e.DATA_VERSION_5_5,
              ]),
              (e.TEXTURE_ATLAS = "textureAtlas"),
              (e.SUB_TEXTURE = "SubTexture"),
              (e.FORMAT = "format"),
              (e.IMAGE_PATH = "imagePath"),
              (e.WIDTH = "width"),
              (e.HEIGHT = "height"),
              (e.ROTATED = "rotated"),
              (e.FRAME_X = "frameX"),
              (e.FRAME_Y = "frameY"),
              (e.FRAME_WIDTH = "frameWidth"),
              (e.FRAME_HEIGHT = "frameHeight"),
              (e.DRADON_BONES = "dragonBones"),
              (e.USER_DATA = "userData"),
              (e.ARMATURE = "armature"),
              (e.BONE = "bone"),
              (e.SURFACE = "surface"),
              (e.SLOT = "slot"),
              (e.CONSTRAINT = "constraint"),
              (e.IK = "ik"),
              (e.PATH_CONSTRAINT = "path"),
              (e.SKIN = "skin"),
              (e.DISPLAY = "display"),
              (e.ANIMATION = "animation"),
              (e.Z_ORDER = "zOrder"),
              (e.FFD = "ffd"),
              (e.FRAME = "frame"),
              (e.TRANSLATE_FRAME = "translateFrame"),
              (e.ROTATE_FRAME = "rotateFrame"),
              (e.SCALE_FRAME = "scaleFrame"),
              (e.DISPLAY_FRAME = "displayFrame"),
              (e.COLOR_FRAME = "colorFrame"),
              (e.DEFAULT_ACTIONS = "defaultActions"),
              (e.ACTIONS = "actions"),
              (e.EVENTS = "events"),
              (e.INTS = "ints"),
              (e.FLOATS = "floats"),
              (e.STRINGS = "strings"),
              (e.CANVAS = "canvas"),
              (e.TRANSFORM = "transform"),
              (e.PIVOT = "pivot"),
              (e.AABB = "aabb"),
              (e.COLOR = "color"),
              (e.VERSION = "version"),
              (e.COMPATIBLE_VERSION = "compatibleVersion"),
              (e.FRAME_RATE = "frameRate"),
              (e.TYPE = "type"),
              (e.SUB_TYPE = "subType"),
              (e.NAME = "name"),
              (e.PARENT = "parent"),
              (e.TARGET = "target"),
              (e.STAGE = "stage"),
              (e.SHARE = "share"),
              (e.PATH = "path"),
              (e.LENGTH = "length"),
              (e.DISPLAY_INDEX = "displayIndex"),
              (e.BLEND_MODE = "blendMode"),
              (e.INHERIT_TRANSLATION = "inheritTranslation"),
              (e.INHERIT_ROTATION = "inheritRotation"),
              (e.INHERIT_SCALE = "inheritScale"),
              (e.INHERIT_REFLECTION = "inheritReflection"),
              (e.INHERIT_ANIMATION = "inheritAnimation"),
              (e.INHERIT_DEFORM = "inheritDeform"),
              (e.SEGMENT_X = "segmentX"),
              (e.SEGMENT_Y = "segmentY"),
              (e.BEND_POSITIVE = "bendPositive"),
              (e.CHAIN = "chain"),
              (e.WEIGHT = "weight"),
              (e.FADE_IN_TIME = "fadeInTime"),
              (e.PLAY_TIMES = "playTimes"),
              (e.SCALE = "scale"),
              (e.OFFSET = "offset"),
              (e.POSITION = "position"),
              (e.DURATION = "duration"),
              (e.TWEEN_EASING = "tweenEasing"),
              (e.TWEEN_ROTATE = "tweenRotate"),
              (e.TWEEN_SCALE = "tweenScale"),
              (e.CLOCK_WISE = "clockwise"),
              (e.CURVE = "curve"),
              (e.SOUND = "sound"),
              (e.EVENT = "event"),
              (e.ACTION = "action"),
              (e.X = "x"),
              (e.Y = "y"),
              (e.SKEW_X = "skX"),
              (e.SKEW_Y = "skY"),
              (e.SCALE_X = "scX"),
              (e.SCALE_Y = "scY"),
              (e.VALUE = "value"),
              (e.ROTATE = "rotate"),
              (e.SKEW = "skew"),
              (e.ALPHA_OFFSET = "aO"),
              (e.RED_OFFSET = "rO"),
              (e.GREEN_OFFSET = "gO"),
              (e.BLUE_OFFSET = "bO"),
              (e.ALPHA_MULTIPLIER = "aM"),
              (e.RED_MULTIPLIER = "rM"),
              (e.GREEN_MULTIPLIER = "gM"),
              (e.BLUE_MULTIPLIER = "bM"),
              (e.UVS = "uvs"),
              (e.VERTICES = "vertices"),
              (e.TRIANGLES = "triangles"),
              (e.WEIGHTS = "weights"),
              (e.SLOT_POSE = "slotPose"),
              (e.BONE_POSE = "bonePose"),
              (e.GLUE_WEIGHTS = "glueWeights"),
              (e.GLUE_MESHES = "glueMeshes"),
              (e.BONES = "bones"),
              (e.POSITION_MODE = "positionMode"),
              (e.SPACING_MODE = "spacingMode"),
              (e.ROTATE_MODE = "rotateMode"),
              (e.SPACING = "spacing"),
              (e.ROTATE_OFFSET = "rotateOffset"),
              (e.ROTATE_MIX = "rotateMix"),
              (e.TRANSLATE_MIX = "translateMix"),
              (e.TARGET_DISPLAY = "targetDisplay"),
              (e.CLOSED = "closed"),
              (e.CONSTANT_SPEED = "constantSpeed"),
              (e.VERTEX_COUNT = "vertexCount"),
              (e.LENGTHS = "lengths"),
              (e.GOTO_AND_PLAY = "gotoAndPlay"),
              (e.DEFAULT_NAME = "default"),
              e
            );
          })();
          t.DataParser = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (e) {
            function s() {
              var i = (null !== e && e.apply(this, arguments)) || this;
              return (
                (i._rawTextureAtlasIndex = 0),
                (i._rawBones = []),
                (i._data = null),
                (i._armature = null),
                (i._bone = null),
                (i._surface = null),
                (i._slot = null),
                (i._skin = null),
                (i._mesh = null),
                (i._animation = null),
                (i._timeline = null),
                (i._rawTextureAtlases = null),
                (i._defaultColorOffset = -1),
                (i._prevClockwise = 0),
                (i._prevRotation = 0),
                (i._helpMatrixA = new t.Matrix()),
                (i._helpMatrixB = new t.Matrix()),
                (i._helpTransform = new t.Transform()),
                (i._helpColorTransform = new t.ColorTransform()),
                (i._helpPoint = new t.Point()),
                (i._helpArray = []),
                (i._intArray = []),
                (i._floatArray = []),
                (i._frameIntArray = []),
                (i._frameFloatArray = []),
                (i._frameArray = []),
                (i._timelineArray = []),
                (i._cacheRawMeshes = []),
                (i._cacheMeshes = []),
                (i._actionFrames = []),
                (i._weightSlotPose = {}),
                (i._weightBonePoses = {}),
                (i._cacheBones = {}),
                (i._slotChildActions = {}),
                i
              );
            }
            return (
              Z2(s, e),
              (s._getBoolean = function (t, e, i) {
                if (e in t) {
                  var s = t[e],
                    n = typeof s;
                  if ("boolean" === n) return s;
                  if ("string" !== n) return !!s;
                  switch (s) {
                    case "0":
                    case "NaN":
                    case "":
                    case "false":
                    case "null":
                    case "undefined":
                      return !1;
                    default:
                      return !0;
                  }
                }
                return i;
              }),
              (s._getNumber = function (t, e, i) {
                if (e in t) {
                  var s = t[e];
                  return null === s || "NaN" === s ? i : +s || 0;
                }
                return i;
              }),
              (s._getString = function (e, i, s) {
                if (i in e) {
                  var n = e[i];
                  if ("string" == typeof n) {
                    if (t.DragonBones.webAssembly)
                      for (var r = 0, a = n.length; r < a; ++r)
                        if (n.charCodeAt(r) > 255) return encodeURI(n);
                    return n;
                  }
                  return String(n);
                }
                return s;
              }),
              (s.prototype._getCurvePoint = function (
                t,
                e,
                i,
                s,
                n,
                r,
                a,
                o,
                h,
                l
              ) {
                var c = 1 - h,
                  u = c * c,
                  _ = h * h,
                  d = c * u,
                  p = 3 * h * u,
                  m = 3 * c * _,
                  f = h * _;
                (l.x = d * t + p * i + m * n + f * a),
                  (l.y = d * e + p * s + m * r + f * o);
              }),
              (s.prototype._samplingEasingCurve = function (t, e) {
                for (
                  var i = t.length, s = -2, n = 0, r = e.length;
                  n < r;
                  ++n
                ) {
                  for (
                    var a = (n + 1) / (r + 1);
                    (s + 6 < i ? t[s + 6] : 1) < a;

                  )
                    s += 6;
                  for (
                    var o = s >= 0 && s + 6 < i,
                      h = o ? t[s] : 0,
                      l = o ? t[s + 1] : 0,
                      c = t[s + 2],
                      u = t[s + 3],
                      _ = t[s + 4],
                      d = t[s + 5],
                      p = o ? t[s + 6] : 1,
                      m = o ? t[s + 7] : 1,
                      f = 0,
                      g = 1;
                    g - f > 1e-4;

                  ) {
                    var y = 0.5 * (g + f);
                    this._getCurvePoint(
                      h,
                      l,
                      c,
                      u,
                      _,
                      d,
                      p,
                      m,
                      y,
                      this._helpPoint
                    ),
                      a - this._helpPoint.x > 0 ? (f = y) : (g = y);
                  }
                  e[n] = this._helpPoint.y;
                }
              }),
              (s.prototype._parseActionDataInFrame = function (e, i, s, n) {
                t.DataParser.EVENT in e &&
                  this._mergeActionFrame(e[t.DataParser.EVENT], i, 10, s, n),
                  t.DataParser.SOUND in e &&
                    this._mergeActionFrame(e[t.DataParser.SOUND], i, 11, s, n),
                  t.DataParser.ACTION in e &&
                    this._mergeActionFrame(e[t.DataParser.ACTION], i, 0, s, n),
                  t.DataParser.EVENTS in e &&
                    this._mergeActionFrame(e[t.DataParser.EVENTS], i, 10, s, n),
                  t.DataParser.ACTIONS in e &&
                    this._mergeActionFrame(e[t.DataParser.ACTIONS], i, 0, s, n);
              }),
              (s.prototype._mergeActionFrame = function (e, s, n, r, a) {
                for (
                  var o = t.DragonBones.webAssembly
                      ? this._armature.actions.size()
                      : this._armature.actions.length,
                    h = this._parseActionData(e, n, r, a),
                    l = 0,
                    c = null,
                    u = 0,
                    _ = h;
                  u < _.length;
                  u++
                ) {
                  var d = _[u];
                  this._armature.addAction(d, !1);
                }
                0 === this._actionFrames.length &&
                  (((c = new i()).frameStart = 0),
                  this._actionFrames.push(c),
                  (c = null));
                for (var p = 0, m = this._actionFrames; p < m.length; p++) {
                  var f = m[p];
                  if (f.frameStart === s) {
                    c = f;
                    break;
                  }
                  if (f.frameStart > s) break;
                  l++;
                }
                null === c &&
                  (((c = new i()).frameStart = s),
                  this._actionFrames.splice(l + 1, 0, c));
                for (var g = 0; g < h.length; ++g) c.actions.push(o + g);
              }),
              (s.prototype._parseArmature = function (e, i) {
                var n = t.BaseObject.borrowObject(t.ArmatureData);
                if (
                  ((n.name = s._getString(e, t.DataParser.NAME, "")),
                  (n.frameRate = s._getNumber(
                    e,
                    t.DataParser.FRAME_RATE,
                    this._data.frameRate
                  )),
                  (n.scale = i),
                  t.DataParser.TYPE in e &&
                  "string" == typeof e[t.DataParser.TYPE]
                    ? (n.type = t.DataParser._getArmatureType(
                        e[t.DataParser.TYPE]
                      ))
                    : (n.type = s._getNumber(e, t.DataParser.TYPE, 0)),
                  0 === n.frameRate && (n.frameRate = 24),
                  (this._armature = n),
                  t.DataParser.CANVAS in e)
                ) {
                  var r = e[t.DataParser.CANVAS],
                    a = t.BaseObject.borrowObject(t.CanvasData);
                  t.DataParser.COLOR in r
                    ? (a.hasBackground = !0)
                    : (a.hasBackground = !1),
                    (a.color = s._getNumber(r, t.DataParser.COLOR, 0)),
                    (a.x = s._getNumber(r, t.DataParser.X, 0) * n.scale),
                    (a.y = s._getNumber(r, t.DataParser.Y, 0) * n.scale),
                    (a.width =
                      s._getNumber(r, t.DataParser.WIDTH, 0) * n.scale),
                    (a.height =
                      s._getNumber(r, t.DataParser.HEIGHT, 0) * n.scale),
                    (n.canvas = a);
                }
                if (t.DataParser.AABB in e) {
                  var o = e[t.DataParser.AABB];
                  (n.aabb.x = s._getNumber(o, t.DataParser.X, 0) * n.scale),
                    (n.aabb.y = s._getNumber(o, t.DataParser.Y, 0) * n.scale),
                    (n.aabb.width =
                      s._getNumber(o, t.DataParser.WIDTH, 0) * n.scale),
                    (n.aabb.height =
                      s._getNumber(o, t.DataParser.HEIGHT, 0) * n.scale);
                }
                if (t.DataParser.BONE in e)
                  for (var h = 0, l = e[t.DataParser.BONE]; h < l.length; h++) {
                    var c = l[h],
                      u = s._getString(c, t.DataParser.PARENT, ""),
                      _ = this._parseBone(c);
                    if (u.length > 0) {
                      var d = n.getBone(u);
                      null !== d
                        ? (_.parent = d)
                        : (u in this._cacheBones || (this._cacheBones[u] = []),
                          this._cacheBones[u].push(_));
                    }
                    if (_.name in this._cacheBones) {
                      for (
                        var p = 0, m = this._cacheBones[_.name];
                        p < m.length;
                        p++
                      )
                        m[p].parent = _;
                      delete this._cacheBones[_.name];
                    }
                    n.addBone(_), this._rawBones.push(_);
                  }
                if (t.DataParser.IK in e)
                  for (var f = 0, g = e[t.DataParser.IK]; f < g.length; f++) {
                    var y = g[f];
                    (w = this._parseIKConstraint(y)) && n.addConstraint(w);
                  }
                if ((n.sortBones(), t.DataParser.SLOT in e))
                  for (
                    var T = 0, S = 0, E = e[t.DataParser.SLOT];
                    S < E.length;
                    S++
                  ) {
                    var v = E[S];
                    n.addSlot(this._parseSlot(v, T++));
                  }
                if (t.DataParser.SKIN in e)
                  for (var b = 0, A = e[t.DataParser.SKIN]; b < A.length; b++) {
                    var C = A[b];
                    n.addSkin(this._parseSkin(C));
                  }
                if (t.DataParser.PATH_CONSTRAINT in e)
                  for (
                    var O = 0, I = e[t.DataParser.PATH_CONSTRAINT];
                    O < I.length;
                    O++
                  ) {
                    var w,
                      R = I[O];
                    (w = this._parsePathConstraint(R)) && n.addConstraint(w);
                  }
                for (var D = 0, x = this._cacheRawMeshes.length; D < x; ++D) {
                  var M = this._cacheRawMeshes[D];
                  t.DataParser.GLUE_WEIGHTS in M &&
                    t.DataParser.GLUE_MESHES in M &&
                    this._parseMeshGlue(M, this._cacheMeshes[D]);
                }
                for (D = 0, x = this._cacheRawMeshes.length; D < x; ++D) {
                  var P = this._cacheRawMeshes[D],
                    N = s._getString(P, t.DataParser.SHARE, "");
                  if (0 !== N.length) {
                    var L = s._getString(
                      P,
                      t.DataParser.SKIN,
                      t.DataParser.DEFAULT_NAME
                    );
                    0 === L.length && (L = t.DataParser.DEFAULT_NAME);
                    var B = n.getMesh(L, "", N);
                    null !== B &&
                      this._cacheMeshes[D].vertices.shareFrom(B.vertices);
                  }
                }
                if (t.DataParser.ANIMATION in e)
                  for (
                    var F = 0, U = e[t.DataParser.ANIMATION];
                    F < U.length;
                    F++
                  ) {
                    var k = U[F],
                      z = this._parseAnimation(k);
                    n.addAnimation(z);
                  }
                if (t.DataParser.DEFAULT_ACTIONS in e)
                  for (
                    var H = 0,
                      G = this._parseActionData(
                        e[t.DataParser.DEFAULT_ACTIONS],
                        0,
                        null,
                        null
                      );
                    H < G.length;
                    H++
                  ) {
                    var V = G[H];
                    n.addAction(V, !0),
                      0 === V.type &&
                        null !== (z = n.getAnimation(V.name)) &&
                        (n.defaultAnimation = z);
                  }
                if (t.DataParser.ACTIONS in e)
                  for (
                    var j = 0,
                      W = this._parseActionData(
                        e[t.DataParser.ACTIONS],
                        0,
                        null,
                        null
                      );
                    j < W.length;
                    j++
                  )
                    (V = W[j]), n.addAction(V, !1);
                for (var X in ((this._rawBones.length = 0),
                (this._cacheRawMeshes.length = 0),
                (this._cacheMeshes.length = 0),
                (this._armature = null),
                this._weightSlotPose))
                  delete this._weightSlotPose[X];
                for (var X in this._weightBonePoses)
                  delete this._weightBonePoses[X];
                for (var X in this._cacheBones) delete this._cacheBones[X];
                for (var X in this._slotChildActions)
                  delete this._slotChildActions[X];
                return n;
              }),
              (s.prototype._parseBone = function (e) {
                var i = this._armature.scale;
                if (
                  0 ===
                  (t.DataParser.TYPE in e &&
                  "string" == typeof e[t.DataParser.TYPE]
                    ? t.DataParser._getBoneType(e[t.DataParser.TYPE])
                    : s._getNumber(e, t.DataParser.TYPE, 0))
                ) {
                  var n = t.BaseObject.borrowObject(t.BoneData);
                  return (
                    (n.inheritTranslation = s._getBoolean(
                      e,
                      t.DataParser.INHERIT_TRANSLATION,
                      !0
                    )),
                    (n.inheritRotation = s._getBoolean(
                      e,
                      t.DataParser.INHERIT_ROTATION,
                      !0
                    )),
                    (n.inheritScale = s._getBoolean(
                      e,
                      t.DataParser.INHERIT_SCALE,
                      !0
                    )),
                    (n.inheritReflection = s._getBoolean(
                      e,
                      t.DataParser.INHERIT_REFLECTION,
                      !0
                    )),
                    (n.length = s._getNumber(e, t.DataParser.LENGTH, 0) * i),
                    (n.name = s._getString(e, t.DataParser.NAME, "")),
                    t.DataParser.TRANSFORM in e &&
                      this._parseTransform(
                        e[t.DataParser.TRANSFORM],
                        n.transform,
                        i
                      ),
                    n
                  );
                }
                var r = t.BaseObject.borrowObject(t.SurfaceData);
                if (
                  ((r.name = s._getString(e, t.DataParser.NAME, "")),
                  (r.segmentX = s._getNumber(e, t.DataParser.SEGMENT_X, 0)),
                  (r.segmentY = s._getNumber(e, t.DataParser.SEGMENT_Y, 0)),
                  (r.vertices.length = (r.segmentX + 1) * (r.segmentY + 1) * 2),
                  t.DataParser.VERTICES in e)
                )
                  for (
                    var a = e[t.DataParser.VERTICES],
                      o = 0,
                      h = r.vertices.length;
                    o < h;
                    ++o
                  )
                    o < a.length
                      ? (r.vertices[o] = a[o] * i)
                      : (r.vertices[o] = 0);
                return r;
              }),
              (s.prototype._parseIKConstraint = function (e) {
                var i = this._armature.getBone(
                  s._getString(e, t.DataParser.BONE, "")
                );
                if (null === i) return null;
                var n = this._armature.getBone(
                  s._getString(e, t.DataParser.TARGET, "")
                );
                if (null === n) return null;
                var r = t.BaseObject.borrowObject(t.IKConstraintData);
                return (
                  (r.scaleEnabled = s._getBoolean(e, t.DataParser.SCALE, !1)),
                  (r.bendPositive = s._getBoolean(
                    e,
                    t.DataParser.BEND_POSITIVE,
                    !0
                  )),
                  (r.weight = s._getNumber(e, t.DataParser.WEIGHT, 1)),
                  (r.name = s._getString(e, t.DataParser.NAME, "")),
                  (r.type = 0),
                  (r.target = n),
                  s._getNumber(e, t.DataParser.CHAIN, 0) > 0 &&
                  null !== i.parent
                    ? ((r.root = i.parent), (r.bone = i))
                    : ((r.root = i), (r.bone = null)),
                  r
                );
              }),
              (s.prototype._parsePathConstraint = function (e) {
                var i = this._armature.getSlot(
                  s._getString(e, t.DataParser.TARGET, "")
                );
                if (null === i) return null;
                var n = this._armature.defaultSkin;
                if (null === n) return null;
                var r = n.getDisplay(
                  i.name,
                  s._getString(e, t.DataParser.TARGET_DISPLAY, i.name)
                );
                if (null === r || !(r instanceof t.PathDisplayData))
                  return null;
                var a = e[t.DataParser.BONES];
                if (null === a || 0 === a.length) return null;
                var o = t.BaseObject.borrowObject(t.PathConstraintData);
                (o.name = s._getString(e, t.DataParser.NAME, "")),
                  (o.type = 1),
                  (o.pathSlot = i),
                  (o.pathDisplayData = r),
                  (o.target = i.parent),
                  (o.positionMode = t.DataParser._getPositionMode(
                    s._getString(e, t.DataParser.POSITION_MODE, "")
                  )),
                  (o.spacingMode = t.DataParser._getSpacingMode(
                    s._getString(e, t.DataParser.SPACING_MODE, "")
                  )),
                  (o.rotateMode = t.DataParser._getRotateMode(
                    s._getString(e, t.DataParser.ROTATE_MODE, "")
                  )),
                  (o.position = s._getNumber(e, t.DataParser.POSITION, 0)),
                  (o.spacing = s._getNumber(e, t.DataParser.SPACING, 0)),
                  (o.rotateOffset = s._getNumber(
                    e,
                    t.DataParser.ROTATE_OFFSET,
                    0
                  )),
                  (o.rotateMix = s._getNumber(e, t.DataParser.ROTATE_MIX, 1)),
                  (o.translateMix = s._getNumber(
                    e,
                    t.DataParser.TRANSLATE_MIX,
                    1
                  ));
                for (var h = 0, l = a; h < l.length; h++) {
                  var c = l[h],
                    u = this._armature.getBone(c);
                  null !== u && (o.AddBone(u), null === o.root && (o.root = u));
                }
                return o;
              }),
              (s.prototype._parseSlot = function (e, i) {
                var n = t.BaseObject.borrowObject(t.SlotData);
                return (
                  (n.displayIndex = s._getNumber(
                    e,
                    t.DataParser.DISPLAY_INDEX,
                    0
                  )),
                  (n.zOrder = i),
                  (n.name = s._getString(e, t.DataParser.NAME, "")),
                  (n.parent = this._armature.getBone(
                    s._getString(e, t.DataParser.PARENT, "")
                  )),
                  t.DataParser.BLEND_MODE in e &&
                  "string" == typeof e[t.DataParser.BLEND_MODE]
                    ? (n.blendMode = t.DataParser._getBlendMode(
                        e[t.DataParser.BLEND_MODE]
                      ))
                    : (n.blendMode = s._getNumber(
                        e,
                        t.DataParser.BLEND_MODE,
                        0
                      )),
                  t.DataParser.COLOR in e
                    ? ((n.color = t.SlotData.createColor()),
                      this._parseColorTransform(e[t.DataParser.COLOR], n.color))
                    : (n.color = t.SlotData.DEFAULT_COLOR),
                  t.DataParser.ACTIONS in e &&
                    (this._slotChildActions[n.name] = this._parseActionData(
                      e[t.DataParser.ACTIONS],
                      0,
                      null,
                      null
                    )),
                  n
                );
              }),
              (s.prototype._parseSkin = function (e) {
                var i = t.BaseObject.borrowObject(t.SkinData);
                if (
                  ((i.name = s._getString(
                    e,
                    t.DataParser.NAME,
                    t.DataParser.DEFAULT_NAME
                  )),
                  0 === i.name.length && (i.name = t.DataParser.DEFAULT_NAME),
                  t.DataParser.SLOT in e)
                ) {
                  var n = e[t.DataParser.SLOT];
                  this._skin = i;
                  for (var r = 0, a = n; r < a.length; r++) {
                    var o = a[r],
                      h = s._getString(o, t.DataParser.NAME, ""),
                      l = this._armature.getSlot(h);
                    if (null !== l) {
                      if (((this._slot = l), t.DataParser.DISPLAY in o))
                        for (
                          var c = 0, u = o[t.DataParser.DISPLAY];
                          c < u.length;
                          c++
                        ) {
                          var _ = u[c];
                          _
                            ? i.addDisplay(h, this._parseDisplay(_))
                            : i.addDisplay(h, null);
                        }
                      this._slot = null;
                    }
                  }
                  this._skin = null;
                }
                return i;
              }),
              (s.prototype._parseDisplay = function (e) {
                var i = s._getString(e, t.DataParser.NAME, ""),
                  n = s._getString(e, t.DataParser.PATH, ""),
                  r = 0,
                  a = null;
                switch (
                  (r =
                    t.DataParser.TYPE in e &&
                    "string" == typeof e[t.DataParser.TYPE]
                      ? t.DataParser._getDisplayType(e[t.DataParser.TYPE])
                      : s._getNumber(e, t.DataParser.TYPE, r))
                ) {
                  case 0:
                    var o = (a = t.BaseObject.borrowObject(t.ImageDisplayData));
                    (o.name = i),
                      (o.path = n.length > 0 ? n : i),
                      this._parsePivot(e, o);
                    break;
                  case 1:
                    var h = (a = t.BaseObject.borrowObject(
                      t.ArmatureDisplayData
                    ));
                    if (
                      ((h.name = i),
                      (h.path = n.length > 0 ? n : i),
                      (h.inheritAnimation = !0),
                      t.DataParser.ACTIONS in e)
                    )
                      for (
                        var l = 0,
                          c = this._parseActionData(
                            e[t.DataParser.ACTIONS],
                            0,
                            null,
                            null
                          );
                        l < c.length;
                        l++
                      ) {
                        var u = c[l];
                        h.addAction(u);
                      }
                    else if (this._slot.name in this._slotChildActions) {
                      var _ = this._skin.getDisplays(this._slot.name);
                      if (
                        null === _
                          ? 0 === this._slot.displayIndex
                          : this._slot.displayIndex === _.length
                      ) {
                        for (
                          var d = 0,
                            p = this._slotChildActions[this._slot.name];
                          d < p.length;
                          d++
                        )
                          (u = p[d]), h.addAction(u);
                        delete this._slotChildActions[this._slot.name];
                      }
                    }
                    break;
                  case 2:
                    var m = (a = t.BaseObject.borrowObject(t.MeshDisplayData));
                    (m.vertices.inheritDeform = s._getBoolean(
                      e,
                      t.DataParser.INHERIT_DEFORM,
                      !0
                    )),
                      (m.name = i),
                      (m.path = n.length > 0 ? n : i),
                      (m.vertices.data = this._data),
                      t.DataParser.SHARE in e
                        ? (this._cacheRawMeshes.push(e),
                          this._cacheMeshes.push(m))
                        : this._parseMesh(e, m),
                      t.DataParser.GLUE_WEIGHTS in e &&
                        t.DataParser.GLUE_MESHES in e &&
                        (this._cacheRawMeshes.push(e),
                        this._cacheMeshes.push(m));
                    break;
                  case 3:
                    var f = this._parseBoundingBox(e);
                    if (null !== f) {
                      var g = (a = t.BaseObject.borrowObject(
                        t.BoundingBoxDisplayData
                      ));
                      (g.name = i),
                        (g.path = n.length > 0 ? n : i),
                        (g.boundingBox = f);
                    }
                    break;
                  case 4:
                    var y = e[t.DataParser.LENGTHS],
                      T = (a = t.BaseObject.borrowObject(t.PathDisplayData));
                    (T.closed = s._getBoolean(e, t.DataParser.CLOSED, !1)),
                      (T.constantSpeed = s._getBoolean(
                        e,
                        t.DataParser.CONSTANT_SPEED,
                        !1
                      )),
                      (T.name = i),
                      (T.path = n.length > 0 ? n : i),
                      (T.vertices.data = this._data),
                      (T.curveLengths.length = y.length);
                    for (var S = 0, E = y.length; S < E; ++S)
                      T.curveLengths[S] = y[S];
                    this._parsePath(e, T);
                }
                return (
                  null !== a &&
                    t.DataParser.TRANSFORM in e &&
                    this._parseTransform(
                      e[t.DataParser.TRANSFORM],
                      a.transform,
                      this._armature.scale
                    ),
                  a
                );
              }),
              (s.prototype._parsePath = function (e, i) {
                var n = e[t.DataParser.VERTICES],
                  r = s._getNumber(e, t.DataParser.VERTEX_COUNT, 0),
                  a = this._floatArray.length,
                  o = this._intArray.length;
                if (
                  ((i.vertices.offset = o),
                  (this._intArray.length += 2),
                  (this._intArray[o + 0] = r),
                  (this._intArray[o + 2] = a),
                  t.DataParser.WEIGHTS in e)
                ) {
                  var h = e[t.DataParser.WEIGHTS],
                    l = e[t.DataParser.BONES],
                    c = l.length,
                    u = Math.floor(h.length - r) / 2,
                    _ = this._intArray.length,
                    d = this._floatArray.length,
                    p = this._armature.sortedBones,
                    m = t.BaseObject.borrowObject(t.WeightData);
                  for (
                    m.count = u,
                      m.offset = _,
                      this._intArray.length += 2 + c + r + u,
                      this._intArray[_ + 0] = c,
                      this._intArray[_ + 1] = d,
                      w = 0;
                    w < c;
                    w++
                  ) {
                    var f = l[w],
                      g = this._rawBones[f];
                    m.addBone(g), (this._intArray[_ + 2 + w] = p.indexOf(g));
                  }
                  (this._floatArray.length += 3 * u), (w = 0);
                  for (var y = 0, T = 0, S = _ + 2 + c, E = d; w < u; w++) {
                    var v = h[y++];
                    this._intArray[S++] = v;
                    for (var b = 0; b < v; b++) {
                      var A = h[y++],
                        C = h[y++],
                        O = n[T++],
                        I = n[T++];
                      (this._intArray[S++] = l.indexOf(A)),
                        (this._floatArray[E++] = C),
                        (this._floatArray[E++] = O),
                        (this._floatArray[E++] = I);
                    }
                  }
                  i.vertices.weight = m;
                } else {
                  this._floatArray.length += n.length;
                  for (var w = 0, R = n.length; w < R; ++w)
                    this._floatArray[a + w] = n[w];
                }
              }),
              (s.prototype._parsePivot = function (e, i) {
                if (t.DataParser.PIVOT in e) {
                  var n = e[t.DataParser.PIVOT];
                  (i.pivot.x = s._getNumber(n, t.DataParser.X, 0)),
                    (i.pivot.y = s._getNumber(n, t.DataParser.Y, 0));
                } else (i.pivot.x = 0.5), (i.pivot.y = 0.5);
              }),
              (s.prototype._parseMesh = function (e, i) {
                var s = e[t.DataParser.VERTICES],
                  n = e[t.DataParser.UVS],
                  r = e[t.DataParser.TRIANGLES],
                  a = Math.floor(s.length / 2),
                  o = Math.floor(r.length / 3),
                  h = this._floatArray.length,
                  l = h + 2 * a,
                  c = this._intArray.length,
                  u = this._skin.name + "_" + this._slot.name + "_" + i.name;
                (i.vertices.offset = c),
                  (this._intArray.length += 4 + 3 * o),
                  (this._intArray[c + 0] = a),
                  (this._intArray[c + 1] = o),
                  (this._intArray[c + 2] = h);
                for (var _ = 0, d = 3 * o; _ < d; ++_)
                  this._intArray[c + 4 + _] = r[_];
                for (
                  this._floatArray.length += 2 * a + 2 * a, _ = 0, d = 2 * a;
                  _ < d;
                  ++_
                )
                  (this._floatArray[h + _] = s[_]),
                    (this._floatArray[l + _] = n[_]);
                if (t.DataParser.WEIGHTS in e) {
                  var p = e[t.DataParser.WEIGHTS],
                    m = e[t.DataParser.SLOT_POSE],
                    f = e[t.DataParser.BONE_POSE],
                    g = this._armature.sortedBones,
                    y = new Array(),
                    T = Math.floor(f.length / 7),
                    S = this._floatArray.length,
                    E = Math.floor(p.length - a) / 2,
                    v = this._intArray.length,
                    b = t.BaseObject.borrowObject(t.WeightData);
                  for (
                    b.count = E,
                      b.offset = v,
                      y.length = T,
                      this._intArray.length += 2 + T + a + E,
                      this._intArray[v + 1] = S,
                      _ = 0;
                    _ < T;
                    ++_
                  ) {
                    var A = f[7 * _],
                      C = this._rawBones[A];
                    b.addBone(C),
                      (y[_] = A),
                      (this._intArray[v + 2 + _] = g.indexOf(C));
                  }
                  (this._floatArray.length += 3 * E),
                    this._helpMatrixA.copyFromArray(m, 0),
                    (_ = 0);
                  for (var O = 0, I = v + 2 + T, w = S; _ < a; ++_) {
                    var R = 2 * _,
                      D = (this._intArray[I++] = p[O++]),
                      x = this._floatArray[h + R],
                      M = this._floatArray[h + R + 1];
                    this._helpMatrixA.transformPoint(x, M, this._helpPoint),
                      (x = this._helpPoint.x),
                      (M = this._helpPoint.y);
                    for (var P = 0; P < D; ++P) {
                      A = p[O++];
                      var N = y.indexOf(A);
                      this._helpMatrixB.copyFromArray(f, 7 * N + 1),
                        this._helpMatrixB.invert(),
                        this._helpMatrixB.transformPoint(x, M, this._helpPoint),
                        (this._intArray[I++] = N),
                        (this._floatArray[w++] = p[O++]),
                        (this._floatArray[w++] = this._helpPoint.x),
                        (this._floatArray[w++] = this._helpPoint.y);
                    }
                  }
                  (i.vertices.weight = b),
                    (this._weightSlotPose[u] = m),
                    (this._weightBonePoses[u] = f);
                }
              }),
              (s.prototype._parseMeshGlue = function () {}),
              (s.prototype._parseBoundingBox = function (e) {
                var i = null,
                  n = 0;
                switch (
                  (n =
                    t.DataParser.SUB_TYPE in e &&
                    "string" == typeof e[t.DataParser.SUB_TYPE]
                      ? t.DataParser._getBoundingBoxType(
                          e[t.DataParser.SUB_TYPE]
                        )
                      : s._getNumber(e, t.DataParser.SUB_TYPE, n))
                ) {
                  case 0:
                    i = t.BaseObject.borrowObject(t.RectangleBoundingBoxData);
                    break;
                  case 1:
                    i = t.BaseObject.borrowObject(t.EllipseBoundingBoxData);
                    break;
                  case 2:
                    i = this._parsePolygonBoundingBox(e);
                }
                return (
                  null !== i &&
                    ((i.color = s._getNumber(e, t.DataParser.COLOR, 0)),
                    (0 !== i.type && 1 !== i.type) ||
                      ((i.width = s._getNumber(e, t.DataParser.WIDTH, 0)),
                      (i.height = s._getNumber(e, t.DataParser.HEIGHT, 0)))),
                  i
                );
              }),
              (s.prototype._parsePolygonBoundingBox = function (e) {
                var i = t.BaseObject.borrowObject(t.PolygonBoundingBoxData);
                if (t.DataParser.VERTICES in e) {
                  var s = this._armature.scale,
                    n = e[t.DataParser.VERTICES],
                    r = i.vertices;
                  t.DragonBones.webAssembly
                    ? r.resize(n.length, 0)
                    : (r.length = n.length);
                  for (var a = 0, o = n.length; a < o; a += 2) {
                    var h = n[a] * s,
                      l = n[a + 1] * s;
                    t.DragonBones.webAssembly
                      ? (r.set(a, h), r.set(a + 1, l))
                      : ((r[a] = h), (r[a + 1] = l)),
                      0 === a
                        ? ((i.x = h), (i.y = l), (i.width = h), (i.height = l))
                        : (h < i.x ? (i.x = h) : h > i.width && (i.width = h),
                          l < i.y ? (i.y = l) : l > i.height && (i.height = l));
                  }
                  (i.width -= i.x), (i.height -= i.y);
                } else
                  console.warn(
                    "Data error.\n Please reexport DragonBones Data to fixed the bug."
                  );
                return i;
              }),
              (s.prototype._parseAnimation = function (e) {
                var i = t.BaseObject.borrowObject(t.AnimationData);
                if (
                  ((i.frameCount = Math.max(
                    s._getNumber(e, t.DataParser.DURATION, 1),
                    1
                  )),
                  (i.playTimes = s._getNumber(e, t.DataParser.PLAY_TIMES, 1)),
                  (i.duration = i.frameCount / this._armature.frameRate),
                  (i.fadeInTime = s._getNumber(
                    e,
                    t.DataParser.FADE_IN_TIME,
                    0
                  )),
                  (i.scale = s._getNumber(e, t.DataParser.SCALE, 1)),
                  (i.name = s._getString(
                    e,
                    t.DataParser.NAME,
                    t.DataParser.DEFAULT_NAME
                  )),
                  0 === i.name.length && (i.name = t.DataParser.DEFAULT_NAME),
                  (i.frameIntOffset = this._frameIntArray.length),
                  (i.frameFloatOffset = this._frameFloatArray.length),
                  (i.frameOffset = this._frameArray.length),
                  (this._animation = i),
                  t.DataParser.FRAME in e)
                ) {
                  var n = e[t.DataParser.FRAME],
                    r = n.length;
                  if (r > 0)
                    for (var a = 0, o = 0; a < r; ++a) {
                      var h = n[a];
                      this._parseActionDataInFrame(h, o, null, null),
                        (o += s._getNumber(h, t.DataParser.DURATION, 1));
                    }
                }
                if (
                  (t.DataParser.Z_ORDER in e &&
                    (this._animation.zOrderTimeline = this._parseTimeline(
                      e[t.DataParser.Z_ORDER],
                      null,
                      t.DataParser.FRAME,
                      1,
                      !1,
                      !1,
                      0,
                      this._parseZOrderFrame
                    )),
                  t.DataParser.BONE in e)
                )
                  for (var l = 0, c = e[t.DataParser.BONE]; l < c.length; l++) {
                    var u = c[l];
                    this._parseBoneTimeline(u);
                  }
                if (t.DataParser.SURFACE in e)
                  for (
                    var _ = 0, d = e[t.DataParser.SURFACE];
                    _ < d.length;
                    _++
                  ) {
                    u = d[_];
                    var p = s._getString(u, t.DataParser.NAME, "");
                    (this._surface = this._armature.getBone(p)),
                      null !== this._surface &&
                        (null !==
                          (w = this._parseTimeline(
                            u,
                            null,
                            t.DataParser.FRAME,
                            50,
                            !1,
                            !0,
                            0,
                            this._parseSurfaceFrame
                          )) &&
                          this._animation.addSurfaceTimeline(this._surface, w),
                        (this._surface = null));
                  }
                if (t.DataParser.SLOT in e)
                  for (var m = 0, f = e[t.DataParser.SLOT]; m < f.length; m++)
                    (u = f[m]), this._parseSlotTimeline(u);
                if (t.DataParser.FFD in e)
                  for (var g = 0, y = e[t.DataParser.FFD]; g < y.length; g++) {
                    u = y[g];
                    var T = s._getString(
                        u,
                        t.DataParser.SKIN,
                        t.DataParser.DEFAULT_NAME
                      ),
                      S = s._getString(u, t.DataParser.SLOT, ""),
                      E = s._getString(u, t.DataParser.NAME, "");
                    0 === T.length && (T = t.DataParser.DEFAULT_NAME),
                      (this._slot = this._armature.getSlot(S)),
                      (this._mesh = this._armature.getMesh(T, S, E)),
                      null !== this._slot &&
                        null !== this._mesh &&
                        (null !==
                          (w = this._parseTimeline(
                            u,
                            null,
                            t.DataParser.FRAME,
                            22,
                            !1,
                            !0,
                            0,
                            this._parseSlotFFDFrame
                          )) && this._animation.addSlotTimeline(this._slot, w),
                        (this._slot = null),
                        (this._mesh = null));
                  }
                if (t.DataParser.IK in e)
                  for (var v = 0, b = e[t.DataParser.IK]; v < b.length; v++) {
                    u = b[v];
                    var A = s._getString(u, t.DataParser.NAME, ""),
                      C = this._armature.getConstraint(A);
                    null !== C &&
                      null !==
                        (w = this._parseTimeline(
                          u,
                          null,
                          t.DataParser.FRAME,
                          30,
                          !0,
                          !1,
                          2,
                          this._parseIKConstraintFrame
                        )) &&
                      this._animation.addConstraintTimeline(C, w);
                  }
                if (t.DataParser.ANIMATION in e)
                  for (
                    var O = 0, I = e[t.DataParser.ANIMATION];
                    O < I.length;
                    O++
                  ) {
                    u = I[O];
                    var w,
                      R = s._getString(u, t.DataParser.NAME, "");
                    null !==
                      (w = this._parseTimeline(
                        u,
                        null,
                        t.DataParser.FRAME,
                        40,
                        !0,
                        !1,
                        2,
                        this._parseAnimationFrame
                      )) && this._animation.addAnimationTimeline(R, w);
                  }
                return (
                  this._actionFrames.length > 0 &&
                    ((this._animation.actionTimeline = this._parseTimeline(
                      null,
                      this._actionFrames,
                      "",
                      0,
                      !1,
                      !1,
                      0,
                      this._parseActionFrame
                    )),
                    (this._actionFrames.length = 0)),
                  (this._animation = null),
                  i
                );
              }),
              (s.prototype._parseTimeline = function (e, n, r, a, o, h, l, c) {
                if (
                  (null !== e && r.length > 0 && r in e && (n = e[r]),
                  null === n)
                )
                  return null;
                var u = n.length;
                if (0 === u) return null;
                var _ = this._frameIntArray.length,
                  d = this._frameFloatArray.length,
                  p = t.BaseObject.borrowObject(t.TimelineData),
                  m = this._timelineArray.length;
                if (
                  ((this._timelineArray.length += 5 + u),
                  null !== e
                    ? ((this._timelineArray[m + 0] = Math.round(
                        100 * s._getNumber(e, t.DataParser.SCALE, 1)
                      )),
                      (this._timelineArray[m + 1] = Math.round(
                        100 * s._getNumber(e, t.DataParser.OFFSET, 0)
                      )))
                    : ((this._timelineArray[m + 0] = 100),
                      (this._timelineArray[m + 1] = 0)),
                  (this._timelineArray[m + 2] = u),
                  (this._timelineArray[m + 3] = l),
                  (this._timelineArray[m + 4] = o
                    ? _ - this._animation.frameIntOffset
                    : h
                    ? d - this._animation.frameFloatOffset
                    : 0),
                  (this._timeline = p),
                  (p.type = a),
                  (p.offset = m),
                  1 === u)
                )
                  (p.frameIndicesOffset = -1),
                    (this._timelineArray[m + 5 + 0] =
                      c.call(this, n[0], 0, 0) - this._animation.frameOffset);
                else {
                  var f = this._animation.frameCount + 1,
                    g = this._data.frameIndices,
                    y = 0;
                  t.DragonBones.webAssembly
                    ? ((y = g.size()), g.resize(y + f, 0))
                    : ((y = g.length), (g.length += f)),
                    (p.frameIndicesOffset = y);
                  for (var T = 0, S = 0, E = 0, v = 0; T < f; ++T) {
                    if (E + v <= T && S < u) {
                      var b = n[S];
                      (E = T),
                        (v =
                          S === u - 1
                            ? this._animation.frameCount - E
                            : b instanceof i
                            ? this._actionFrames[S + 1].frameStart - E
                            : s._getNumber(b, t.DataParser.DURATION, 1)),
                        (this._timelineArray[m + 5 + S] =
                          c.call(this, b, E, v) - this._animation.frameOffset),
                        S++;
                    }
                    t.DragonBones.webAssembly
                      ? g.set(y + T, S - 1)
                      : (g[y + T] = S - 1);
                  }
                }
                return (this._timeline = null), p;
              }),
              (s.prototype._parseBoneTimeline = function (e) {
                var i,
                  n = this._armature.getBone(
                    s._getString(e, t.DataParser.NAME, "")
                  );
                null !== n &&
                  ((this._bone = n),
                  (this._slot = this._armature.getSlot(this._bone.name)),
                  t.DataParser.TRANSLATE_FRAME in e &&
                    null !==
                      (i = this._parseTimeline(
                        e,
                        null,
                        t.DataParser.TRANSLATE_FRAME,
                        11,
                        !1,
                        !0,
                        2,
                        this._parseBoneTranslateFrame
                      )) &&
                    this._animation.addBoneTimeline(n, i),
                  t.DataParser.ROTATE_FRAME in e &&
                    null !==
                      (i = this._parseTimeline(
                        e,
                        null,
                        t.DataParser.ROTATE_FRAME,
                        12,
                        !1,
                        !0,
                        2,
                        this._parseBoneRotateFrame
                      )) &&
                    this._animation.addBoneTimeline(n, i),
                  t.DataParser.SCALE_FRAME in e &&
                    null !==
                      (i = this._parseTimeline(
                        e,
                        null,
                        t.DataParser.SCALE_FRAME,
                        13,
                        !1,
                        !0,
                        2,
                        this._parseBoneScaleFrame
                      )) &&
                    this._animation.addBoneTimeline(n, i),
                  t.DataParser.FRAME in e &&
                    null !==
                      (i = this._parseTimeline(
                        e,
                        null,
                        t.DataParser.FRAME,
                        10,
                        !1,
                        !0,
                        6,
                        this._parseBoneAllFrame
                      )) &&
                    this._animation.addBoneTimeline(n, i),
                  (this._bone = null),
                  (this._slot = null));
              }),
              (s.prototype._parseSlotTimeline = function (e) {
                var i = this._armature.getSlot(
                  s._getString(e, t.DataParser.NAME, "")
                );
                if (null !== i) {
                  this._slot = i;
                  var n;
                  null !==
                    (n =
                      t.DataParser.DISPLAY_FRAME in e
                        ? this._parseTimeline(
                            e,
                            null,
                            t.DataParser.DISPLAY_FRAME,
                            20,
                            !1,
                            !1,
                            0,
                            this._parseSlotDisplayFrame
                          )
                        : this._parseTimeline(
                            e,
                            null,
                            t.DataParser.FRAME,
                            20,
                            !1,
                            !1,
                            0,
                            this._parseSlotDisplayFrame
                          )) && this._animation.addSlotTimeline(i, n);
                  var r;
                  null !==
                    (r =
                      t.DataParser.COLOR_FRAME in e
                        ? this._parseTimeline(
                            e,
                            null,
                            t.DataParser.COLOR_FRAME,
                            21,
                            !0,
                            !1,
                            1,
                            this._parseSlotColorFrame
                          )
                        : this._parseTimeline(
                            e,
                            null,
                            t.DataParser.FRAME,
                            21,
                            !0,
                            !1,
                            1,
                            this._parseSlotColorFrame
                          )) && this._animation.addSlotTimeline(i, r),
                    (this._slot = null);
                }
              }),
              (s.prototype._parseFrame = function (t, e) {
                var i = this._frameArray.length;
                return (
                  (this._frameArray.length += 1),
                  (this._frameArray[i + 0] = e),
                  i
                );
              }),
              (s.prototype._parseTweenFrame = function (e, i, n) {
                var r = this._parseFrame(e, i, n);
                if (n > 0)
                  if (t.DataParser.CURVE in e) {
                    var a = n + 1;
                    (this._helpArray.length = a),
                      this._samplingEasingCurve(
                        e[t.DataParser.CURVE],
                        this._helpArray
                      ),
                      (this._frameArray.length += 2 + this._helpArray.length),
                      (this._frameArray[r + 1] = 2),
                      (this._frameArray[r + 2] = a);
                    for (var o = 0; o < a; ++o)
                      this._frameArray[r + 3 + o] = Math.round(
                        1e4 * this._helpArray[o]
                      );
                  } else {
                    var h = -2;
                    t.DataParser.TWEEN_EASING in e &&
                      (h = s._getNumber(e, t.DataParser.TWEEN_EASING, -2)),
                      -2 === h
                        ? ((this._frameArray.length += 1),
                          (this._frameArray[r + 1] = 0))
                        : 0 === h
                        ? ((this._frameArray.length += 1),
                          (this._frameArray[r + 1] = 1))
                        : h < 0
                        ? ((this._frameArray.length += 2),
                          (this._frameArray[r + 1] = 3),
                          (this._frameArray[r + 2] = Math.round(100 * -h)))
                        : h <= 1
                        ? ((this._frameArray.length += 2),
                          (this._frameArray[r + 1] = 4),
                          (this._frameArray[r + 2] = Math.round(100 * h)))
                        : ((this._frameArray.length += 2),
                          (this._frameArray[r + 1] = 5),
                          (this._frameArray[r + 2] = Math.round(
                            100 * h - 100
                          )));
                  }
                else
                  (this._frameArray.length += 1), (this._frameArray[r + 1] = 0);
                return r;
              }),
              (s.prototype._parseActionFrame = function (t, e) {
                var i = this._frameArray.length,
                  s = t.actions.length;
                (this._frameArray.length += 2 + s),
                  (this._frameArray[i + 0] = e),
                  (this._frameArray[i + 0 + 1] = s);
                for (var n = 0; n < s; ++n)
                  this._frameArray[i + 0 + 2 + n] = t.actions[n];
                return i;
              }),
              (s.prototype._parseZOrderFrame = function (e, i, s) {
                var n = this._parseFrame(e, i, s);
                if (t.DataParser.Z_ORDER in e) {
                  var r = e[t.DataParser.Z_ORDER];
                  if (r.length > 0) {
                    for (
                      var a = this._armature.sortedSlots.length,
                        o = new Array(a - r.length / 2),
                        h = new Array(a),
                        l = 0;
                      l < o.length;
                      ++l
                    )
                      o[l] = 0;
                    for (var c = 0; c < a; ++c) h[c] = -1;
                    for (var u = 0, _ = 0, d = 0, p = r.length; d < p; d += 2) {
                      for (var m = r[d], f = r[d + 1]; u !== m; ) o[_++] = u++;
                      h[u + f] = u++;
                    }
                    for (; u < a; ) o[_++] = u++;
                    (this._frameArray.length += 1 + a),
                      (this._frameArray[n + 1] = a);
                    for (var g = a; g--; )
                      -1 === h[g]
                        ? (this._frameArray[n + 2 + g] = o[--_] || 0)
                        : (this._frameArray[n + 2 + g] = h[g] || 0);
                    return n;
                  }
                }
                return (
                  (this._frameArray.length += 1),
                  (this._frameArray[n + 1] = 0),
                  n
                );
              }),
              (s.prototype._parseBoneAllFrame = function (e, i, n) {
                this._helpTransform.identity(),
                  t.DataParser.TRANSFORM in e &&
                    this._parseTransform(
                      e[t.DataParser.TRANSFORM],
                      this._helpTransform,
                      1
                    );
                var r = this._helpTransform.rotation;
                0 !== i &&
                  (0 === this._prevClockwise
                    ? (r =
                        this._prevRotation +
                        t.Transform.normalizeRadian(r - this._prevRotation))
                    : ((this._prevClockwise > 0
                        ? r >= this._prevRotation
                        : r <= this._prevRotation) &&
                        (this._prevClockwise =
                          this._prevClockwise > 0
                            ? this._prevClockwise - 1
                            : this._prevClockwise + 1),
                      (r =
                        this._prevRotation +
                        r -
                        this._prevRotation +
                        t.Transform.PI_D * this._prevClockwise))),
                  (this._prevClockwise = s._getNumber(
                    e,
                    t.DataParser.TWEEN_ROTATE,
                    0
                  )),
                  (this._prevRotation = r);
                var a = this._parseTweenFrame(e, i, n),
                  o = this._frameFloatArray.length;
                return (
                  (this._frameFloatArray.length += 6),
                  (this._frameFloatArray[o++] = this._helpTransform.x),
                  (this._frameFloatArray[o++] = this._helpTransform.y),
                  (this._frameFloatArray[o++] = r),
                  (this._frameFloatArray[o++] = this._helpTransform.skew),
                  (this._frameFloatArray[o++] = this._helpTransform.scaleX),
                  (this._frameFloatArray[o++] = this._helpTransform.scaleY),
                  this._parseActionDataInFrame(e, i, this._bone, this._slot),
                  a
                );
              }),
              (s.prototype._parseBoneTranslateFrame = function (e, i, n) {
                var r = this._parseTweenFrame(e, i, n),
                  a = this._frameFloatArray.length;
                return (
                  (this._frameFloatArray.length += 2),
                  (this._frameFloatArray[a++] = s._getNumber(
                    e,
                    t.DataParser.X,
                    0
                  )),
                  (this._frameFloatArray[a++] = s._getNumber(
                    e,
                    t.DataParser.Y,
                    0
                  )),
                  r
                );
              }),
              (s.prototype._parseBoneRotateFrame = function (e, i, n) {
                var r =
                  s._getNumber(e, t.DataParser.ROTATE, 0) * t.Transform.DEG_RAD;
                0 !== i &&
                  (0 === this._prevClockwise
                    ? (r =
                        this._prevRotation +
                        t.Transform.normalizeRadian(r - this._prevRotation))
                    : ((this._prevClockwise > 0
                        ? r >= this._prevRotation
                        : r <= this._prevRotation) &&
                        (this._prevClockwise =
                          this._prevClockwise > 0
                            ? this._prevClockwise - 1
                            : this._prevClockwise + 1),
                      (r =
                        this._prevRotation +
                        r -
                        this._prevRotation +
                        t.Transform.PI_D * this._prevClockwise))),
                  (this._prevClockwise = s._getNumber(
                    e,
                    t.DataParser.CLOCK_WISE,
                    0
                  )),
                  (this._prevRotation = r);
                var a = this._parseTweenFrame(e, i, n),
                  o = this._frameFloatArray.length;
                return (
                  (this._frameFloatArray.length += 2),
                  (this._frameFloatArray[o++] = r),
                  (this._frameFloatArray[o++] =
                    s._getNumber(e, t.DataParser.SKEW, 0) *
                    t.Transform.DEG_RAD),
                  a
                );
              }),
              (s.prototype._parseBoneScaleFrame = function (e, i, n) {
                var r = this._parseTweenFrame(e, i, n),
                  a = this._frameFloatArray.length;
                return (
                  (this._frameFloatArray.length += 2),
                  (this._frameFloatArray[a++] = s._getNumber(
                    e,
                    t.DataParser.X,
                    1
                  )),
                  (this._frameFloatArray[a++] = s._getNumber(
                    e,
                    t.DataParser.Y,
                    1
                  )),
                  r
                );
              }),
              (s.prototype._parseSurfaceFrame = function (e, i, n) {
                var r = this._frameFloatArray.length,
                  a = this._parseTweenFrame(e, i, n),
                  o = e[t.DataParser.VERTICES],
                  h = s._getNumber(e, t.DataParser.OFFSET, 0),
                  l = this._surface.vertices.length / 2,
                  c = 0,
                  u = 0;
                this._frameFloatArray.length += 2 * l;
                for (var _ = 0; _ < 2 * l; _ += 2)
                  (c = _ < h || _ - h >= o.length ? 0 : o[_ - h]),
                    (u = _ + 1 < h || _ + 1 - h >= o.length ? 0 : o[_ + 1 - h]),
                    (this._frameFloatArray[r + _] = c),
                    (this._frameFloatArray[r + _ + 1] = u);
                if (0 === i) {
                  var d = this._frameIntArray.length;
                  (this._frameIntArray.length += 5),
                    (this._frameIntArray[d + 0] = 0),
                    (this._frameIntArray[d + 1] =
                      this._frameFloatArray.length - r),
                    (this._frameIntArray[d + 2] =
                      this._frameFloatArray.length - r),
                    (this._frameIntArray[d + 3] = 0),
                    (this._frameIntArray[d + 4] =
                      r - this._animation.frameFloatOffset),
                    (this._timelineArray[this._timeline.offset + 3] =
                      d - this._animation.frameIntOffset);
                }
                return a;
              }),
              (s.prototype._parseSlotDisplayFrame = function (e, i, n) {
                var r = this._parseFrame(e, i, n);
                return (
                  (this._frameArray.length += 1),
                  t.DataParser.VALUE in e
                    ? (this._frameArray[r + 1] = s._getNumber(
                        e,
                        t.DataParser.VALUE,
                        0
                      ))
                    : (this._frameArray[r + 1] = s._getNumber(
                        e,
                        t.DataParser.DISPLAY_INDEX,
                        0
                      )),
                  this._parseActionDataInFrame(
                    e,
                    i,
                    this._slot.parent,
                    this._slot
                  ),
                  r
                );
              }),
              (s.prototype._parseSlotColorFrame = function (e, i, s) {
                var n = this._parseTweenFrame(e, i, s),
                  r = -1;
                if (t.DataParser.VALUE in e || t.DataParser.COLOR in e) {
                  var a =
                    t.DataParser.VALUE in e
                      ? e[t.DataParser.VALUE]
                      : e[t.DataParser.COLOR];
                  for (var o in a) {
                    this._parseColorTransform(a, this._helpColorTransform),
                      (r = this._intArray.length),
                      (this._intArray.length += 8),
                      (this._intArray[r++] = Math.round(
                        100 * this._helpColorTransform.alphaMultiplier
                      )),
                      (this._intArray[r++] = Math.round(
                        100 * this._helpColorTransform.redMultiplier
                      )),
                      (this._intArray[r++] = Math.round(
                        100 * this._helpColorTransform.greenMultiplier
                      )),
                      (this._intArray[r++] = Math.round(
                        100 * this._helpColorTransform.blueMultiplier
                      )),
                      (this._intArray[r++] = Math.round(
                        this._helpColorTransform.alphaOffset
                      )),
                      (this._intArray[r++] = Math.round(
                        this._helpColorTransform.redOffset
                      )),
                      (this._intArray[r++] = Math.round(
                        this._helpColorTransform.greenOffset
                      )),
                      (this._intArray[r++] = Math.round(
                        this._helpColorTransform.blueOffset
                      )),
                      (r -= 8);
                    break;
                  }
                }
                r < 0 &&
                  (this._defaultColorOffset < 0 &&
                    ((this._defaultColorOffset = r = this._intArray.length),
                    (this._intArray.length += 8),
                    (this._intArray[r++] = 100),
                    (this._intArray[r++] = 100),
                    (this._intArray[r++] = 100),
                    (this._intArray[r++] = 100),
                    (this._intArray[r++] = 0),
                    (this._intArray[r++] = 0),
                    (this._intArray[r++] = 0),
                    (this._intArray[r++] = 0)),
                  (r = this._defaultColorOffset));
                var h = this._frameIntArray.length;
                return (
                  (this._frameIntArray.length += 1),
                  (this._frameIntArray[h] = r),
                  n
                );
              }),
              (s.prototype._parseSlotFFDFrame = function (e, i, n) {
                var r = this._frameFloatArray.length,
                  a = this._parseTweenFrame(e, i, n),
                  o =
                    t.DataParser.VERTICES in e
                      ? e[t.DataParser.VERTICES]
                      : null,
                  h = s._getNumber(e, t.DataParser.OFFSET, 0),
                  l = this._intArray[this._mesh.vertices.offset + 0],
                  c =
                    this._mesh.parent.name +
                    "_" +
                    this._slot.name +
                    "_" +
                    this._mesh.name,
                  u = this._mesh.vertices.weight,
                  _ = 0,
                  d = 0,
                  p = 0,
                  m = 0;
                if (null !== u) {
                  var f = this._weightSlotPose[c];
                  this._helpMatrixA.copyFromArray(f, 0),
                    (this._frameFloatArray.length += 2 * u.count),
                    (p = u.offset + 2 + u.bones.length);
                } else this._frameFloatArray.length += 2 * l;
                for (var g = 0; g < 2 * l; g += 2)
                  if (
                    (null === o
                      ? ((_ = 0), (d = 0))
                      : ((_ = g < h || g - h >= o.length ? 0 : o[g - h]),
                        (d =
                          g + 1 < h || g + 1 - h >= o.length
                            ? 0
                            : o[g + 1 - h])),
                    null !== u)
                  ) {
                    var y = this._weightBonePoses[c],
                      T = this._intArray[p++];
                    this._helpMatrixA.transformPoint(_, d, this._helpPoint, !0),
                      (_ = this._helpPoint.x),
                      (d = this._helpPoint.y);
                    for (var S = 0; S < T; ++S) {
                      var E = this._intArray[p++];
                      this._helpMatrixB.copyFromArray(y, 7 * E + 1),
                        this._helpMatrixB.invert(),
                        this._helpMatrixB.transformPoint(
                          _,
                          d,
                          this._helpPoint,
                          !0
                        ),
                        (this._frameFloatArray[r + m++] = this._helpPoint.x),
                        (this._frameFloatArray[r + m++] = this._helpPoint.y);
                    }
                  } else
                    (this._frameFloatArray[r + g] = _),
                      (this._frameFloatArray[r + g + 1] = d);
                if (0 === i) {
                  var v = this._frameIntArray.length;
                  (this._frameIntArray.length += 5),
                    (this._frameIntArray[v + 0] = this._mesh.vertices.offset),
                    (this._frameIntArray[v + 1] =
                      this._frameFloatArray.length - r),
                    (this._frameIntArray[v + 2] =
                      this._frameFloatArray.length - r),
                    (this._frameIntArray[v + 3] = 0),
                    (this._frameIntArray[v + 4] =
                      r - this._animation.frameFloatOffset),
                    (this._timelineArray[this._timeline.offset + 3] =
                      v - this._animation.frameIntOffset);
                }
                return a;
              }),
              (s.prototype._parseIKConstraintFrame = function (e, i, n) {
                var r = this._parseTweenFrame(e, i, n),
                  a = this._frameIntArray.length;
                return (
                  (this._frameIntArray.length += 2),
                  (this._frameIntArray[a++] = s._getBoolean(
                    e,
                    t.DataParser.BEND_POSITIVE,
                    !0
                  )
                    ? 1
                    : 0),
                  (this._frameIntArray[a++] = Math.round(
                    100 * s._getNumber(e, t.DataParser.WEIGHT, 1)
                  )),
                  r
                );
              }),
              (s.prototype._parseAnimationFrame = function (e, i, n) {
                var r = this._parseTweenFrame(e, i, n),
                  a = this._frameIntArray.length;
                return (
                  (this._frameIntArray.length += 2),
                  (this._frameIntArray[a++] = s._getNumber(
                    e,
                    t.DataParser.VALUE,
                    0
                  )),
                  (this._frameIntArray[a++] = Math.round(
                    100 * s._getNumber(e, t.DataParser.WEIGHT, 1)
                  )),
                  r
                );
              }),
              (s.prototype._parseActionData = function (e, i, n, r) {
                var a = new Array();
                if ("string" == typeof e)
                  ((c = t.BaseObject.borrowObject(t.ActionData)).type = i),
                    (c.name = e),
                    (c.bone = n),
                    (c.slot = r),
                    a.push(c);
                else if (e instanceof Array)
                  for (var o = 0, h = e; o < h.length; o++) {
                    var l = h[o],
                      c = t.BaseObject.borrowObject(t.ActionData);
                    if (
                      (t.DataParser.GOTO_AND_PLAY in l
                        ? ((c.type = 0),
                          (c.name = s._getString(
                            l,
                            t.DataParser.GOTO_AND_PLAY,
                            ""
                          )))
                        : (t.DataParser.TYPE in l &&
                          "string" == typeof l[t.DataParser.TYPE]
                            ? (c.type = t.DataParser._getActionType(
                                l[t.DataParser.TYPE]
                              ))
                            : (c.type = s._getNumber(l, t.DataParser.TYPE, i)),
                          (c.name = s._getString(l, t.DataParser.NAME, ""))),
                      t.DataParser.BONE in l)
                    ) {
                      var u = s._getString(l, t.DataParser.BONE, "");
                      c.bone = this._armature.getBone(u);
                    } else c.bone = n;
                    if (t.DataParser.SLOT in l) {
                      var _ = s._getString(l, t.DataParser.SLOT, "");
                      c.slot = this._armature.getSlot(_);
                    } else c.slot = r;
                    var d = null;
                    if (t.DataParser.INTS in l) {
                      null === d && (d = t.BaseObject.borrowObject(t.UserData));
                      for (
                        var p = 0, m = l[t.DataParser.INTS];
                        p < m.length;
                        p++
                      ) {
                        var f = m[p];
                        d.addInt(f);
                      }
                    }
                    if (t.DataParser.FLOATS in l) {
                      null === d && (d = t.BaseObject.borrowObject(t.UserData));
                      for (
                        var g = 0, y = l[t.DataParser.FLOATS];
                        g < y.length;
                        g++
                      )
                        (f = y[g]), d.addFloat(f);
                    }
                    if (t.DataParser.STRINGS in l) {
                      null === d && (d = t.BaseObject.borrowObject(t.UserData));
                      for (
                        var T = 0, S = l[t.DataParser.STRINGS];
                        T < S.length;
                        T++
                      )
                        (f = S[T]), d.addString(f);
                    }
                    (c.data = d), a.push(c);
                  }
                return a;
              }),
              (s.prototype._parseTransform = function (e, i, n) {
                (i.x = s._getNumber(e, t.DataParser.X, 0) * n),
                  (i.y = s._getNumber(e, t.DataParser.Y, 0) * n),
                  t.DataParser.ROTATE in e || t.DataParser.SKEW in e
                    ? ((i.rotation = t.Transform.normalizeRadian(
                        s._getNumber(e, t.DataParser.ROTATE, 0) *
                          t.Transform.DEG_RAD
                      )),
                      (i.skew = t.Transform.normalizeRadian(
                        s._getNumber(e, t.DataParser.SKEW, 0) *
                          t.Transform.DEG_RAD
                      )))
                    : (t.DataParser.SKEW_X in e || t.DataParser.SKEW_Y in e) &&
                      ((i.rotation = t.Transform.normalizeRadian(
                        s._getNumber(e, t.DataParser.SKEW_Y, 0) *
                          t.Transform.DEG_RAD
                      )),
                      (i.skew =
                        t.Transform.normalizeRadian(
                          s._getNumber(e, t.DataParser.SKEW_X, 0) *
                            t.Transform.DEG_RAD
                        ) - i.rotation)),
                  (i.scaleX = s._getNumber(e, t.DataParser.SCALE_X, 1)),
                  (i.scaleY = s._getNumber(e, t.DataParser.SCALE_Y, 1));
              }),
              (s.prototype._parseColorTransform = function (e, i) {
                (i.alphaMultiplier =
                  0.01 * s._getNumber(e, t.DataParser.ALPHA_MULTIPLIER, 100)),
                  (i.redMultiplier =
                    0.01 * s._getNumber(e, t.DataParser.RED_MULTIPLIER, 100)),
                  (i.greenMultiplier =
                    0.01 * s._getNumber(e, t.DataParser.GREEN_MULTIPLIER, 100)),
                  (i.blueMultiplier =
                    0.01 * s._getNumber(e, t.DataParser.BLUE_MULTIPLIER, 100)),
                  (i.alphaOffset = s._getNumber(
                    e,
                    t.DataParser.ALPHA_OFFSET,
                    0
                  )),
                  (i.redOffset = s._getNumber(e, t.DataParser.RED_OFFSET, 0)),
                  (i.greenOffset = s._getNumber(
                    e,
                    t.DataParser.GREEN_OFFSET,
                    0
                  )),
                  (i.blueOffset = s._getNumber(e, t.DataParser.BLUE_OFFSET, 0));
              }),
              (s.prototype._parseArray = function () {
                (this._intArray.length = 0),
                  (this._floatArray.length = 0),
                  (this._frameIntArray.length = 0),
                  (this._frameFloatArray.length = 0),
                  (this._frameArray.length = 0),
                  (this._timelineArray.length = 0);
              }),
              (s.prototype._modifyArray = function () {
                this._intArray.length % Int16Array.BYTES_PER_ELEMENT != 0 &&
                  this._intArray.push(0),
                  this._frameIntArray.length % Int16Array.BYTES_PER_ELEMENT !=
                    0 && this._frameIntArray.push(0),
                  this._frameArray.length % Int16Array.BYTES_PER_ELEMENT != 0 &&
                    this._frameArray.push(0),
                  this._timelineArray.length % Uint16Array.BYTES_PER_ELEMENT !=
                    0 && this._timelineArray.push(0);
                var e = this._intArray.length * Int16Array.BYTES_PER_ELEMENT,
                  i = this._floatArray.length * Float32Array.BYTES_PER_ELEMENT,
                  s = this._frameIntArray.length * Int16Array.BYTES_PER_ELEMENT,
                  n =
                    this._frameFloatArray.length *
                    Float32Array.BYTES_PER_ELEMENT,
                  r = this._frameArray.length * Int16Array.BYTES_PER_ELEMENT,
                  a =
                    this._timelineArray.length * Uint16Array.BYTES_PER_ELEMENT,
                  o = e + i + s + n + r + a;
                if (t.DragonBones.webAssembly) {
                  for (
                    var h = t.webAssemblyModule.HEAP16.buffer,
                      l = t.webAssemblyModule._malloc(o),
                      c = new Int16Array(h, l, this._intArray.length),
                      u = new Float32Array(h, l + e, this._floatArray.length),
                      _ = new Int16Array(
                        h,
                        l + e + i,
                        this._frameIntArray.length
                      ),
                      d = new Float32Array(
                        h,
                        l + e + i + s,
                        this._frameFloatArray.length
                      ),
                      p = new Int16Array(
                        h,
                        l + e + i + s + n,
                        this._frameArray.length
                      ),
                      m = new Uint16Array(
                        h,
                        l + e + i + s + n + r,
                        this._timelineArray.length
                      ),
                      f = 0,
                      g = this._intArray.length;
                    f < g;
                    ++f
                  )
                    c[f] = this._intArray[f];
                  for (f = 0, g = this._floatArray.length; f < g; ++f)
                    u[f] = this._floatArray[f];
                  for (f = 0, g = this._frameIntArray.length; f < g; ++f)
                    _[f] = this._frameIntArray[f];
                  for (f = 0, g = this._frameFloatArray.length; f < g; ++f)
                    d[f] = this._frameFloatArray[f];
                  for (f = 0, g = this._frameArray.length; f < g; ++f)
                    p[f] = this._frameArray[f];
                  for (f = 0, g = this._timelineArray.length; f < g; ++f)
                    m[f] = this._timelineArray[f];
                  t.webAssemblyModule.setDataBinary(
                    this._data,
                    l,
                    e,
                    i,
                    s,
                    n,
                    r,
                    a
                  );
                } else {
                  var y = new ArrayBuffer(o);
                  for (
                    c = new Int16Array(y, 0, this._intArray.length),
                      u = new Float32Array(y, e, this._floatArray.length),
                      _ = new Int16Array(y, e + i, this._frameIntArray.length),
                      d = new Float32Array(
                        y,
                        e + i + s,
                        this._frameFloatArray.length
                      ),
                      p = new Int16Array(
                        y,
                        e + i + s + n,
                        this._frameArray.length
                      ),
                      m = new Uint16Array(
                        y,
                        e + i + s + n + r,
                        this._timelineArray.length
                      ),
                      f = 0,
                      g = this._intArray.length;
                    f < g;
                    ++f
                  )
                    c[f] = this._intArray[f];
                  for (f = 0, g = this._floatArray.length; f < g; ++f)
                    u[f] = this._floatArray[f];
                  for (f = 0, g = this._frameIntArray.length; f < g; ++f)
                    _[f] = this._frameIntArray[f];
                  for (f = 0, g = this._frameFloatArray.length; f < g; ++f)
                    d[f] = this._frameFloatArray[f];
                  for (f = 0, g = this._frameArray.length; f < g; ++f)
                    p[f] = this._frameArray[f];
                  for (f = 0, g = this._timelineArray.length; f < g; ++f)
                    m[f] = this._timelineArray[f];
                  (this._data.binary = y),
                    (this._data.intArray = c),
                    (this._data.floatArray = u),
                    (this._data.frameIntArray = _),
                    (this._data.frameFloatArray = d),
                    (this._data.frameArray = p),
                    (this._data.timelineArray = m);
                }
                this._defaultColorOffset = -1;
              }),
              (s.prototype.parseDragonBonesData = function (e, i) {
                void 0 === i && (i = 1),
                  console.assert(null != e, "Data error.");
                var n = s._getString(e, t.DataParser.VERSION, ""),
                  r = s._getString(e, t.DataParser.COMPATIBLE_VERSION, "");
                if (
                  t.DataParser.DATA_VERSIONS.indexOf(n) >= 0 ||
                  t.DataParser.DATA_VERSIONS.indexOf(r) >= 0
                ) {
                  var a = t.BaseObject.borrowObject(t.DragonBonesData);
                  if (
                    ((a.version = n),
                    (a.name = s._getString(e, t.DataParser.NAME, "")),
                    (a.frameRate = s._getNumber(
                      e,
                      t.DataParser.FRAME_RATE,
                      24
                    )),
                    0 === a.frameRate && (a.frameRate = 24),
                    t.DataParser.ARMATURE in e)
                  ) {
                    (this._data = a), this._parseArray(e);
                    for (
                      var o = 0, h = e[t.DataParser.ARMATURE];
                      o < h.length;
                      o++
                    ) {
                      var l = h[o];
                      a.addArmature(this._parseArmature(l, i));
                    }
                    this._data.binary || this._modifyArray(),
                      t.DataParser.STAGE in e
                        ? (a.stage = a.getArmature(
                            s._getString(e, t.DataParser.STAGE, "")
                          ))
                        : a.armatureNames.length > 0 &&
                          (a.stage = a.getArmature(a.armatureNames[0])),
                      (this._data = null);
                  }
                  return (
                    t.DataParser.TEXTURE_ATLAS in e &&
                      (this._rawTextureAtlases = e[t.DataParser.TEXTURE_ATLAS]),
                    a
                  );
                }
                return (
                  console.assert(
                    !1,
                    "Nonsupport data version: " +
                      n +
                      "\nPlease convert DragonBones data to support version.\nRead more: https://github.com/DragonBones/Tools/"
                  ),
                  null
                );
              }),
              (s.prototype.parseTextureAtlasData = function (e, i, n) {
                if (
                  (void 0 === n && (n = 1),
                  console.assert(void 0 !== e),
                  null === e)
                ) {
                  if (
                    null === this._rawTextureAtlases ||
                    0 === this._rawTextureAtlases.length
                  )
                    return !1;
                  var r = this._rawTextureAtlases[this._rawTextureAtlasIndex++];
                  return (
                    this.parseTextureAtlasData(r, i, n),
                    this._rawTextureAtlasIndex >=
                      this._rawTextureAtlases.length &&
                      ((this._rawTextureAtlasIndex = 0),
                      (this._rawTextureAtlases = null)),
                    !0
                  );
                }
                if (
                  ((i.width = s._getNumber(e, t.DataParser.WIDTH, 0)),
                  (i.height = s._getNumber(e, t.DataParser.HEIGHT, 0)),
                  (i.scale =
                    1 === n ? 1 / s._getNumber(e, t.DataParser.SCALE, 1) : n),
                  (i.name = s._getString(e, t.DataParser.NAME, "")),
                  (i.imagePath = s._getString(e, t.DataParser.IMAGE_PATH, "")),
                  t.DataParser.SUB_TEXTURE in e)
                )
                  for (
                    var a = e[t.DataParser.SUB_TEXTURE], o = 0, h = a.length;
                    o < h;
                    ++o
                  ) {
                    var l = a[o],
                      c = i.createTexture();
                    (c.rotated = s._getBoolean(l, t.DataParser.ROTATED, !1)),
                      (c.name = s._getString(l, t.DataParser.NAME, "")),
                      (c.region.x = s._getNumber(l, t.DataParser.X, 0)),
                      (c.region.y = s._getNumber(l, t.DataParser.Y, 0)),
                      (c.region.width = s._getNumber(l, t.DataParser.WIDTH, 0)),
                      (c.region.height = s._getNumber(
                        l,
                        t.DataParser.HEIGHT,
                        0
                      ));
                    var u = s._getNumber(l, t.DataParser.FRAME_WIDTH, -1),
                      _ = s._getNumber(l, t.DataParser.FRAME_HEIGHT, -1);
                    u > 0 &&
                      _ > 0 &&
                      ((c.frame = t.TextureData.createRectangle()),
                      (c.frame.x = s._getNumber(l, t.DataParser.FRAME_X, 0)),
                      (c.frame.y = s._getNumber(l, t.DataParser.FRAME_Y, 0)),
                      (c.frame.width = u),
                      (c.frame.height = _)),
                      i.addTexture(c);
                  }
                return !0;
              }),
              (s.getInstance = function () {
                return (
                  null === s._objectDataParserInstance &&
                    (s._objectDataParserInstance = new s()),
                  s._objectDataParserInstance
                );
              }),
              (s._objectDataParserInstance = null),
              s
            );
          })(t.DataParser);
          t.ObjectDataParser = e;
          var i = function () {
            (this.frameStart = 0), (this.actions = []);
          };
          t.ActionFrame = i;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function (e) {
            function i() {
              return (null !== e && e.apply(this, arguments)) || this;
            }
            return (
              Z2(i, e),
              (i.prototype._inRange = function (t, e, i) {
                return e <= t && t <= i;
              }),
              (i.prototype._decodeUTF8 = function (t) {
                for (
                  var e, i = 0, s = "", n = 0, r = 0, a = 0, o = 0;
                  t.length > i;

                ) {
                  var h = t[i++];
                  if (-1 === h) e = 0 !== r ? 65533 : -1;
                  else if (0 === r)
                    this._inRange(h, 0, 127)
                      ? (e = h)
                      : (this._inRange(h, 194, 223)
                          ? ((r = 1), (o = 128), (n = h - 192))
                          : this._inRange(h, 224, 239)
                          ? ((r = 2), (o = 2048), (n = h - 224))
                          : this._inRange(h, 240, 244) &&
                            ((r = 3), (o = 65536), (n = h - 240)),
                        (n *= Math.pow(64, r)),
                        (e = null));
                  else if (this._inRange(h, 128, 191))
                    if (
                      ((a += 1),
                      (n += (h - 128) * Math.pow(64, r - a)),
                      a !== r)
                    )
                      e = null;
                    else {
                      var l = n,
                        c = o;
                      (n = 0),
                        (r = 0),
                        (a = 0),
                        (o = 0),
                        (e =
                          this._inRange(l, c, 1114111) &&
                          !this._inRange(l, 55296, 57343)
                            ? l
                            : h);
                    }
                  else (n = 0), (r = 0), (a = 0), (o = 0), i--, (e = h);
                  null !== e &&
                    -1 !== e &&
                    (e <= 65535
                      ? e > 0 && (s += String.fromCharCode(e))
                      : ((e -= 65536),
                        (s += String.fromCharCode(55296 + ((e >> 10) & 1023))),
                        (s += String.fromCharCode(56320 + (1023 & e)))));
                }
                return s;
              }),
              (i.prototype._getUTF16Key = function (t) {
                for (var e = 0, i = t.length; e < i; ++e)
                  if (t.charCodeAt(e) > 255) return encodeURI(t);
                return t;
              }),
              (i.prototype._parseBinaryTimeline = function (e, i, s) {
                void 0 === s && (s = null);
                var n =
                  null !== s ? s : t.BaseObject.borrowObject(t.TimelineData);
                (n.type = e), (n.offset = i), (this._timeline = n);
                var r = this._timelineArrayBuffer[n.offset + 2];
                if (1 === r) n.frameIndicesOffset = -1;
                else {
                  var a = 0,
                    o = this._animation.frameCount + 1,
                    h = this._data.frameIndices;
                  t.DragonBones.webAssembly
                    ? ((a = h.size()), h.resize(a + o, 0))
                    : ((a = h.length), (h.length += o)),
                    (n.frameIndicesOffset = a);
                  for (var l = 0, c = 0, u = 0, _ = 0; l < o; ++l)
                    u + _ <= l &&
                      c < r &&
                      ((u =
                        this._frameArrayBuffer[
                          this._animation.frameOffset +
                            this._timelineArrayBuffer[n.offset + 5 + c]
                        ]),
                      (_ =
                        c === r - 1
                          ? this._animation.frameCount - u
                          : this._frameArrayBuffer[
                              this._animation.frameOffset +
                                this._timelineArrayBuffer[n.offset + 5 + c + 1]
                            ] - u),
                      c++),
                      t.DragonBones.webAssembly
                        ? h.set(a + l, c - 1)
                        : (h[a + l] = c - 1);
                }
                return (this._timeline = null), n;
              }),
              (i.prototype._parseVertices = function (e, i) {
                i.offset = e[t.DataParser.OFFSET];
                var s = this._intArrayBuffer[i.offset + 3];
                if (s >= 0) {
                  var n = t.BaseObject.borrowObject(t.WeightData),
                    r = this._intArrayBuffer[i.offset + 0],
                    a = this._intArrayBuffer[s + 0];
                  n.offset = s;
                  for (var o = 0; o < a; ++o) {
                    var h = this._intArrayBuffer[s + 2 + o];
                    n.addBone(this._rawBones[h]);
                  }
                  for (var l = s + 2 + a, c = 0, u = ((o = 0), r); o < u; ++o) {
                    var _ = this._intArrayBuffer[l++];
                    (c += _), (l += _);
                  }
                  (n.count = c), (i.weight = n);
                }
              }),
              (i.prototype._parseMesh = function (t, e) {
                this._parseVertices(t, e.vertices);
              }),
              (i.prototype._parsePath = function (t, e) {
                this._parseVertices(t, e.vertices);
              }),
              (i.prototype._parseAnimation = function (e) {
                var i = t.BaseObject.borrowObject(t.AnimationData);
                (i.frameCount = Math.max(
                  t.ObjectDataParser._getNumber(e, t.DataParser.DURATION, 1),
                  1
                )),
                  (i.playTimes = t.ObjectDataParser._getNumber(
                    e,
                    t.DataParser.PLAY_TIMES,
                    1
                  )),
                  (i.duration = i.frameCount / this._armature.frameRate),
                  (i.fadeInTime = t.ObjectDataParser._getNumber(
                    e,
                    t.DataParser.FADE_IN_TIME,
                    0
                  )),
                  (i.scale = t.ObjectDataParser._getNumber(
                    e,
                    t.DataParser.SCALE,
                    1
                  )),
                  (i.name = t.ObjectDataParser._getString(
                    e,
                    t.DataParser.NAME,
                    t.DataParser.DEFAULT_NAME
                  )),
                  0 === i.name.length && (i.name = t.DataParser.DEFAULT_NAME);
                var s = e[t.DataParser.OFFSET];
                if (
                  ((i.frameIntOffset = s[0]),
                  (i.frameFloatOffset = s[1]),
                  (i.frameOffset = s[2]),
                  (this._animation = i),
                  t.DataParser.ACTION in e &&
                    (i.actionTimeline = this._parseBinaryTimeline(
                      0,
                      e[t.DataParser.ACTION]
                    )),
                  t.DataParser.Z_ORDER in e &&
                    (i.zOrderTimeline = this._parseBinaryTimeline(
                      1,
                      e[t.DataParser.Z_ORDER]
                    )),
                  t.DataParser.BONE in e)
                ) {
                  var n = e[t.DataParser.BONE];
                  for (var r in n) {
                    var a = n[r];
                    t.DragonBones.webAssembly && (r = this._getUTF16Key(r));
                    var o = this._armature.getBone(r);
                    if (null !== o)
                      for (var h = 0, l = a.length; h < l; h += 2) {
                        var c = a[h],
                          u = a[h + 1],
                          _ = this._parseBinaryTimeline(c, u);
                        this._animation.addBoneTimeline(o, _);
                      }
                  }
                }
                if (t.DataParser.SURFACE in e)
                  for (var r in (n = e[t.DataParser.SURFACE])) {
                    (a = n[r]),
                      t.DragonBones.webAssembly && (r = this._getUTF16Key(r));
                    var d = this._armature.getBone(r);
                    if (null !== d)
                      for (h = 0, l = a.length; h < l; h += 2)
                        (c = a[h]),
                          (u = a[h + 1]),
                          (_ = this._parseBinaryTimeline(c, u)),
                          this._animation.addSurfaceTimeline(d, _);
                  }
                if (t.DataParser.SLOT in e)
                  for (var r in (n = e[t.DataParser.SLOT])) {
                    (a = n[r]),
                      t.DragonBones.webAssembly && (r = this._getUTF16Key(r));
                    var p = this._armature.getSlot(r);
                    if (null !== p)
                      for (h = 0, l = a.length; h < l; h += 2)
                        (c = a[h]),
                          (u = a[h + 1]),
                          (_ = this._parseBinaryTimeline(c, u)),
                          this._animation.addSlotTimeline(p, _);
                  }
                if (t.DataParser.CONSTRAINT in e)
                  for (var r in (n = e[t.DataParser.CONSTRAINT])) {
                    (a = n[r]),
                      t.DragonBones.webAssembly && (r = this._getUTF16Key(r));
                    var m = this._armature.getConstraint(r);
                    if (null !== m)
                      for (h = 0, l = a.length; h < l; h += 2)
                        (c = a[h]),
                          (u = a[h + 1]),
                          (_ = this._parseBinaryTimeline(c, u)),
                          this._animation.addConstraintTimeline(m, _);
                  }
                if (t.DataParser.ANIMATION in e)
                  for (var r in (n = e[t.DataParser.ANIMATION]))
                    for (
                      a = n[r],
                        t.DragonBones.webAssembly && (r = this._getUTF16Key(r)),
                        h = 0,
                        l = a.length;
                      h < l;
                      h += 2
                    )
                      (c = a[h]),
                        (u = a[h + 1]),
                        (_ = this._parseBinaryTimeline(c, u)),
                        this._animation.addAnimationTimeline(r, _);
                return (this._animation = null), i;
              }),
              (i.prototype._parseArray = function (e) {
                var i = e[t.DataParser.OFFSET],
                  s = i[1],
                  n = i[3],
                  r = i[5],
                  a = i[7],
                  o = i[9],
                  h = i[11],
                  l = new Int16Array(
                    this._binary,
                    this._binaryOffset + i[0],
                    s / Int16Array.BYTES_PER_ELEMENT
                  ),
                  c = new Float32Array(
                    this._binary,
                    this._binaryOffset + i[2],
                    n / Float32Array.BYTES_PER_ELEMENT
                  ),
                  u = new Int16Array(
                    this._binary,
                    this._binaryOffset + i[4],
                    r / Int16Array.BYTES_PER_ELEMENT
                  ),
                  _ = new Float32Array(
                    this._binary,
                    this._binaryOffset + i[6],
                    a / Float32Array.BYTES_PER_ELEMENT
                  ),
                  d = new Int16Array(
                    this._binary,
                    this._binaryOffset + i[8],
                    o / Int16Array.BYTES_PER_ELEMENT
                  ),
                  p = new Uint16Array(
                    this._binary,
                    this._binaryOffset + i[10],
                    h / Uint16Array.BYTES_PER_ELEMENT
                  );
                if (t.DragonBones.webAssembly) {
                  for (
                    var m = s + n + r + a + o + h,
                      f = t.webAssemblyModule._malloc(m),
                      g = new Uint8Array(
                        this._binary,
                        this._binaryOffset,
                        m / Uint8Array.BYTES_PER_ELEMENT
                      ),
                      y = new Uint8Array(
                        t.webAssemblyModule.HEAP16.buffer,
                        f,
                        g.length
                      ),
                      T = 0,
                      S = g.length;
                    T < S;
                    ++T
                  )
                    y[T] = g[T];
                  t.webAssemblyModule.setDataBinary(
                    this._data,
                    f,
                    s,
                    n,
                    r,
                    a,
                    o,
                    h
                  ),
                    (this._intArrayBuffer = l),
                    (this._floatArrayBuffer = c),
                    (this._frameIntArrayBuffer = u),
                    (this._frameFloatArrayBuffer = _),
                    (this._frameArrayBuffer = d),
                    (this._timelineArrayBuffer = p);
                } else
                  (this._data.binary = this._binary),
                    (this._data.intArray = this._intArrayBuffer = l),
                    (this._data.floatArray = this._floatArrayBuffer = c),
                    (this._data.frameIntArray = this._frameIntArrayBuffer = u),
                    (this._data.frameFloatArray = this._frameFloatArrayBuffer =
                      _),
                    (this._data.frameArray = this._frameArrayBuffer = d),
                    (this._data.timelineArray = this._timelineArrayBuffer = p);
              }),
              (i.prototype.parseDragonBonesData = function (t, i) {
                void 0 === i && (i = 1),
                  console.assert(
                    null != t && t instanceof ArrayBuffer,
                    "Data error."
                  );
                var s = new Uint8Array(t, 0, 8);
                if (
                  s[0] !== "D".charCodeAt(0) ||
                  s[1] !== "B".charCodeAt(0) ||
                  s[2] !== "D".charCodeAt(0) ||
                  s[3] !== "T".charCodeAt(0)
                )
                  return console.assert(!1, "Nonsupport data."), null;
                var n = new Uint32Array(t, 8, 1)[0],
                  r = new Uint8Array(t, 12, n),
                  a = this._decodeUTF8(r),
                  o = JSON.parse(a);
                return (
                  (this._binaryOffset = 12 + n),
                  (this._binary = t),
                  e.prototype.parseDragonBonesData.call(this, o, i)
                );
              }),
              (i.getInstance = function () {
                return (
                  null === i._binaryDataParserInstance &&
                    (i._binaryDataParserInstance = new i()),
                  i._binaryDataParserInstance
                );
              }),
              (i._binaryDataParserInstance = null),
              i
            );
          })(t.ObjectDataParser);
          t.BinaryDataParser = e;
        })(Q2 || (Q2 = {})),
        (function (t) {
          var e = (function () {
            function e(i) {
              void 0 === i && (i = null),
                (this.autoSearch = !1),
                (this._dragonBonesDataMap = {}),
                (this._textureAtlasDataMap = {}),
                (this._dragonBones = null),
                (this._dataParser = null),
                null === e._objectParser &&
                  (e._objectParser = new t.ObjectDataParser()),
                null === e._binaryParser &&
                  (e._binaryParser = new t.BinaryDataParser()),
                (this._dataParser = null !== i ? i : e._objectParser);
            }
            return (
              (e.prototype._isSupportMesh = function () {
                return !0;
              }),
              (e.prototype._getTextureData = function (t, e) {
                if (t in this._textureAtlasDataMap)
                  for (
                    var i = 0, s = this._textureAtlasDataMap[t];
                    i < s.length;
                    i++
                  )
                    if (null !== (h = (o = s[i]).getTexture(e))) return h;
                if (this.autoSearch)
                  for (var n in this._textureAtlasDataMap)
                    for (
                      var r = 0, a = this._textureAtlasDataMap[n];
                      r < a.length;
                      r++
                    ) {
                      var o, h;
                      if (
                        (o = a[r]).autoSearch &&
                        null !== (h = o.getTexture(e))
                      )
                        return h;
                    }
                return null;
              }),
              (e.prototype._fillBuildArmaturePackage = function (
                t,
                e,
                i,
                s,
                n
              ) {
                var r = null,
                  a = null;
                if (
                  (e.length > 0 &&
                    e in this._dragonBonesDataMap &&
                    (a = (r = this._dragonBonesDataMap[e]).getArmature(i)),
                  null === a && (0 === e.length || this.autoSearch))
                )
                  for (var o in this._dragonBonesDataMap)
                    if (
                      ((r = this._dragonBonesDataMap[o]),
                      (0 === e.length || r.autoSearch) &&
                        null !== (a = r.getArmature(i)))
                    ) {
                      e = o;
                      break;
                    }
                if (null !== a) {
                  if (
                    ((t.dataName = e),
                    (t.textureAtlasName = n),
                    (t.data = r),
                    (t.armature = a),
                    (t.skin = null),
                    s.length > 0 &&
                      ((t.skin = a.getSkin(s)),
                      null === t.skin && this.autoSearch))
                  )
                    for (var o in this._dragonBonesDataMap) {
                      var h = this._dragonBonesDataMap[o].getArmature(s);
                      if (null !== h) {
                        t.skin = h.defaultSkin;
                        break;
                      }
                    }
                  return null === t.skin && (t.skin = a.defaultSkin), !0;
                }
                return !1;
              }),
              (e.prototype._buildBones = function (e, i) {
                for (var s = 0, n = e.armature.sortedBones; s < n.length; s++) {
                  var r = n[s];
                  t.BaseObject.borrowObject(
                    0 === r.type ? t.Bone : t.Surface
                  ).init(r, i);
                }
              }),
              (e.prototype._buildSlots = function (e, i) {
                var s = e.skin,
                  n = e.armature.defaultSkin;
                if (null !== s && null !== n) {
                  var r = {};
                  for (var a in n.displays) {
                    var o = n.getDisplays(a);
                    r[a] = o;
                  }
                  if (s !== n)
                    for (var a in s.displays)
                      (o = s.getDisplays(a)), (r[a] = o);
                  for (
                    var h = 0, l = e.armature.sortedSlots;
                    h < l.length;
                    h++
                  ) {
                    var c = l[h],
                      u = c.name in r ? r[c.name] : null,
                      _ = this._buildSlot(e, c, i);
                    if (((_.rawDisplayDatas = u), null !== u)) {
                      for (
                        var d = new Array(),
                          p = 0,
                          m = t.DragonBones.webAssembly ? u.size() : u.length;
                        p < m;
                        ++p
                      ) {
                        var f = t.DragonBones.webAssembly ? u.get(p) : u[p];
                        null !== f
                          ? d.push(this._getSlotDisplay(e, f, null, _))
                          : d.push(null);
                      }
                      _._setDisplayList(d);
                    }
                    _._setDisplayIndex(c.displayIndex, !0);
                  }
                }
              }),
              (e.prototype._buildConstraints = function (e, i) {
                var s = e.armature.constraints;
                for (var n in s) {
                  var r = s[n];
                  switch (r.type) {
                    case 0:
                      var a = t.BaseObject.borrowObject(t.IKConstraint);
                      a.init(r, i), i._addConstraint(a);
                      break;
                    case 1:
                      var o = t.BaseObject.borrowObject(t.PathConstraint);
                      o.init(r, i), i._addConstraint(o);
                      break;
                    default:
                      var h = t.BaseObject.borrowObject(t.IKConstraint);
                      h.init(r, i), i._addConstraint(h);
                  }
                }
              }),
              (e.prototype._buildChildArmature = function (t, e, i) {
                return this.buildArmature(
                  i.path,
                  null !== t ? t.dataName : "",
                  "",
                  null !== t ? t.textureAtlasName : ""
                );
              }),
              (e.prototype._getSlotDisplay = function (e, i, s, n) {
                var r = null !== e ? e.dataName : i.parent.parent.parent.name,
                  a = null;
                switch (i.type) {
                  case 0:
                    var o = i;
                    null !== e &&
                      e.textureAtlasName.length > 0 &&
                      (o.texture = this._getTextureData(
                        e.textureAtlasName,
                        i.path
                      )),
                      null === o.texture &&
                        (o.texture = this._getTextureData(r, i.path)),
                      (a =
                        null !== s && 2 === s.type && this._isSupportMesh()
                          ? n.meshDisplay
                          : n.rawDisplay);
                    break;
                  case 2:
                    var h = i;
                    null !== e &&
                      e.textureAtlasName.length > 0 &&
                      (h.texture = this._getTextureData(
                        e.textureAtlasName,
                        h.path
                      )),
                      null === h.texture &&
                        (h.texture = this._getTextureData(r, h.path)),
                      (a = this._isSupportMesh()
                        ? n.meshDisplay
                        : n.rawDisplay);
                    break;
                  case 1:
                    var l = i,
                      c = this._buildChildArmature(e, n, i);
                    if (null !== c) {
                      if (
                        ((c.inheritAnimation = l.inheritAnimation),
                        !c.inheritAnimation)
                      ) {
                        var u =
                          l.actions.length > 0
                            ? l.actions
                            : c.armatureData.defaultActions;
                        if (u.length > 0)
                          for (var _ = 0, d = u; _ < d.length; _++) {
                            var p = d[_],
                              m = t.BaseObject.borrowObject(t.EventObject);
                            t.EventObject.actionDataToInstance(
                              p,
                              m,
                              n.armature
                            ),
                              (m.slot = n),
                              n.armature._bufferAction(m, !1);
                          }
                        else c.animation.play();
                      }
                      l.armature = c.armatureData;
                    }
                    a = c;
                }
                return a;
              }),
              (e.prototype.parseDragonBonesData = function (t, i, s) {
                void 0 === i && (i = null), void 0 === s && (s = 1);
                for (
                  var n =
                      t instanceof ArrayBuffer
                        ? e._binaryParser
                        : this._dataParser,
                    r = n.parseDragonBonesData(t, s);
                  ;

                ) {
                  var a = this._buildTextureAtlasData(null, null);
                  if (!n.parseTextureAtlasData(null, a, s)) {
                    a.returnToPool();
                    break;
                  }
                  this.addTextureAtlasData(a, i);
                }
                return null !== r && this.addDragonBonesData(r, i), r;
              }),
              (e.prototype.parseTextureAtlasData = function (t, e, i, s) {
                void 0 === i && (i = null), void 0 === s && (s = 1);
                var n = this._buildTextureAtlasData(null, null);
                return (
                  this._dataParser.parseTextureAtlasData(t, n, s),
                  this._buildTextureAtlasData(n, e || null),
                  this.addTextureAtlasData(n, i),
                  n
                );
              }),
              (e.prototype.updateTextureAtlasData = function (t, e) {
                var i = this.getTextureAtlasData(t);
                if (null !== i)
                  for (var s = 0, n = i.length; s < n; ++s)
                    s < e.length && this._buildTextureAtlasData(i[s], e[s]);
              }),
              (e.prototype.getDragonBonesData = function (t) {
                return t in this._dragonBonesDataMap
                  ? this._dragonBonesDataMap[t]
                  : null;
              }),
              (e.prototype.addDragonBonesData = function (t, e) {
                if (
                  (void 0 === e && (e = null),
                  (e = null !== e ? e : t.name) in this._dragonBonesDataMap)
                ) {
                  if (this._dragonBonesDataMap[e] === t) return;
                  console.warn("Can not add same name data: " + e);
                } else this._dragonBonesDataMap[e] = t;
              }),
              (e.prototype.removeDragonBonesData = function (t, e) {
                void 0 === e && (e = !0),
                  t in this._dragonBonesDataMap &&
                    (e &&
                      this._dragonBones.bufferObject(
                        this._dragonBonesDataMap[t]
                      ),
                    delete this._dragonBonesDataMap[t]);
              }),
              (e.prototype.getTextureAtlasData = function (t) {
                return t in this._textureAtlasDataMap
                  ? this._textureAtlasDataMap[t]
                  : null;
              }),
              (e.prototype.addTextureAtlasData = function (t, e) {
                void 0 === e && (e = null);
                var i =
                  (e = null !== e ? e : t.name) in this._textureAtlasDataMap
                    ? this._textureAtlasDataMap[e]
                    : (this._textureAtlasDataMap[e] = []);
                i.indexOf(t) < 0 && i.push(t);
              }),
              (e.prototype.removeTextureAtlasData = function (t, e) {
                if (
                  (void 0 === e && (e = !0), t in this._textureAtlasDataMap)
                ) {
                  var i = this._textureAtlasDataMap[t];
                  if (e)
                    for (var s = 0, n = i; s < n.length; s++) {
                      var r = n[s];
                      this._dragonBones.bufferObject(r);
                    }
                  delete this._textureAtlasDataMap[t];
                }
              }),
              (e.prototype.getArmatureData = function (t, e) {
                void 0 === e && (e = "");
                var s = new i();
                return this._fillBuildArmaturePackage(s, e, t, "", "")
                  ? s.armature
                  : null;
              }),
              (e.prototype.clear = function (t) {
                for (var e in (void 0 === t && (t = !0),
                this._dragonBonesDataMap))
                  t &&
                    this._dragonBones.bufferObject(this._dragonBonesDataMap[e]),
                    delete this._dragonBonesDataMap[e];
                for (var e in this._textureAtlasDataMap) {
                  if (t)
                    for (
                      var i = 0, s = this._textureAtlasDataMap[e];
                      i < s.length;
                      i++
                    ) {
                      var n = s[i];
                      this._dragonBones.bufferObject(n);
                    }
                  delete this._textureAtlasDataMap[e];
                }
              }),
              (e.prototype.buildArmature = function (t, e, s, n) {
                void 0 === e && (e = ""),
                  void 0 === s && (s = ""),
                  void 0 === n && (n = "");
                var r = new i();
                if (
                  !this._fillBuildArmaturePackage(
                    r,
                    e || "",
                    t,
                    s || "",
                    n || ""
                  )
                )
                  return (
                    console.warn(
                      "No armature data: " + t + ", " + (null !== e ? e : "")
                    ),
                    null
                  );
                var a = this._buildArmature(r);
                return (
                  this._buildBones(r, a),
                  this._buildSlots(r, a),
                  this._buildConstraints(r, a),
                  a.invalidUpdate(null, !0),
                  a.advanceTime(0),
                  a
                );
              }),
              (e.prototype.replaceDisplay = function (e, i, s) {
                void 0 === s && (s = -1),
                  s < 0 && (s = e.displayIndex),
                  s < 0 && (s = 0),
                  e.replaceDisplayData(i, s);
                var n = e.displayList;
                if (n.length <= s) {
                  n.length = s + 1;
                  for (var r = 0, a = n.length; r < a; ++r)
                    n[r] || (n[r] = null);
                }
                if (null !== i) {
                  var o = e.rawDisplayDatas,
                    h = null;
                  o &&
                    (t.DragonBones.webAssembly
                      ? s < o.size() && (h = o.get(s))
                      : s < o.length && (h = o[s])),
                    (n[s] = this._getSlotDisplay(null, i, h, e));
                } else n[s] = null;
                e.displayList = n;
              }),
              (e.prototype.replaceSlotDisplay = function (t, e, i, s, n, r) {
                void 0 === r && (r = -1);
                var a = this.getArmatureData(e, t || "");
                if (!a || !a.defaultSkin) return !1;
                var o = a.defaultSkin.getDisplay(i, s);
                return !!o && (this.replaceDisplay(n, o, r), !0);
              }),
              (e.prototype.replaceSlotDisplayList = function (e, i, s, n) {
                var r = this.getArmatureData(i, e || "");
                if (!r || !r.defaultSkin) return !1;
                var a = r.defaultSkin.getDisplays(s);
                if (!a) return !1;
                for (
                  var o = 0,
                    h = 0,
                    l = t.DragonBones.webAssembly ? a.size() : a.length;
                  h < l;
                  ++h
                ) {
                  var c = t.DragonBones.webAssembly ? a.get(h) : a[h];
                  this.replaceDisplay(n, c, o++);
                }
                return !0;
              }),
              (e.prototype.replaceSkin = function (e, i, s, n) {
                void 0 === s && (s = !1), void 0 === n && (n = null);
                for (
                  var r = !1, a = i.parent.defaultSkin, o = 0, h = e.getSlots();
                  o < h.length;
                  o++
                ) {
                  var l = h[o];
                  if (!(null !== n && n.indexOf(l.name) >= 0)) {
                    var c = i.getDisplays(l.name);
                    if (
                      c ||
                      (null !== a && i !== a && (c = a.getDisplays(l.name)), c)
                    ) {
                      var u = t.DragonBones.webAssembly ? c.size() : c.length,
                        _ = l.displayList;
                      _.length = u;
                      for (var d = 0, p = u; d < p; ++d) {
                        var m = t.DragonBones.webAssembly ? c.get(d) : c[d];
                        _[d] =
                          null !== m
                            ? this._getSlotDisplay(null, m, null, l)
                            : null;
                      }
                      (r = !0), (l.rawDisplayDatas = c), (l.displayList = _);
                    } else
                      s && ((l.rawDisplayDatas = null), (l.displayList = []));
                  }
                }
                return r;
              }),
              (e.prototype.replaceAnimation = function (e, i, s) {
                void 0 === s && (s = !0);
                var n = i.defaultSkin;
                if (null === n) return !1;
                if (s) e.animation.animations = i.animations;
                else {
                  var r = e.animation.animations,
                    a = {};
                  for (var o in r) a[o] = r[o];
                  for (var o in i.animations) a[o] = i.animations[o];
                  e.animation.animations = a;
                }
                for (var h = 0, l = e.getSlots(); h < l.length; h++)
                  for (
                    var c = l[h], u = 0, _ = 0, d = c.displayList;
                    _ < d.length;
                    _++
                  ) {
                    var p = d[_];
                    if (p instanceof t.Armature) {
                      var m = n.getDisplays(c.name);
                      if (
                        null !== m &&
                        u < (t.DragonBones.webAssembly ? m.size() : m.length)
                      ) {
                        var f = t.DragonBones.webAssembly ? m.get(u) : m[u];
                        if (null !== f && 1 === f.type) {
                          var g = this.getArmatureData(
                            f.path,
                            f.parent.parent.parent.name
                          );
                          g && this.replaceAnimation(p, g, s);
                        }
                      }
                    }
                    u++;
                  }
                return !0;
              }),
              (e.prototype.getAllDragonBonesData = function () {
                return this._dragonBonesDataMap;
              }),
              (e.prototype.getAllTextureAtlasData = function () {
                return this._textureAtlasDataMap;
              }),
              Object.defineProperty(e.prototype, "clock", {
                get: function () {
                  return this._dragonBones.clock;
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(e.prototype, "dragonBones", {
                get: function () {
                  return this._dragonBones;
                },
                enumerable: !0,
                configurable: !0,
              }),
              (e.prototype.changeSkin = function (t, e, i) {
                return (
                  void 0 === i && (i = null), this.replaceSkin(t, e, !1, i)
                );
              }),
              (e.prototype.copyAnimationsToArmature = function (t, e, i, s, n) {
                void 0 === s && (s = ""), void 0 === n && (n = !0);
                var r = this.getArmatureData(e, s);
                return !!r && this.replaceAnimation(t, r, n);
              }),
              (e._objectParser = null),
              (e._binaryParser = null),
              e
            );
          })();
          t.BaseFactory = e;
          var i = function () {
            (this.dataName = ""),
              (this.textureAtlasName = ""),
              (this.skin = null);
          };
          t.BuildArmaturePackage = i;
        })(Q2 || (Q2 = {})),
        (function (t) {
          (t.BinaryOffset = {
            WeigthBoneCount: 0,
            WeigthFloatOffset: 1,
            WeigthBoneIndices: 2,
            MeshVertexCount: 0,
            MeshTriangleCount: 1,
            MeshFloatOffset: 2,
            MeshWeightOffset: 3,
            MeshVertexIndices: 4,
            TimelineScale: 0,
            TimelineOffset: 1,
            TimelineKeyFrameCount: 2,
            TimelineFrameValueCount: 3,
            TimelineFrameValueOffset: 4,
            TimelineFrameOffset: 5,
            FramePosition: 0,
            FrameTweenType: 1,
            FrameTweenEasingOrCurveSampleCount: 2,
            FrameCurveSamples: 3,
            DeformMeshOffset: 0,
            DeformCount: 1,
            DeformValueCount: 2,
            DeformValueOffset: 3,
            DeformFloatOffset: 4,
          }),
            (t.ArmatureType = { Armature: 0, MovieClip: 1, Stage: 2 }),
            (t.BoneType = { Bone: 0, Surface: 1 }),
            (t.DisplayType = {
              Image: 0,
              Armature: 1,
              Mesh: 2,
              BoundingBox: 3,
            }),
            (t.BoundingBoxType = { Rectangle: 0, Ellipse: 1, Polygon: 2 }),
            (t.ActionType = {
              Play: 0,
              Stop: 1,
              GotoAndPlay: 2,
              GotoAndStop: 3,
              FadeIn: 4,
              FadeOut: 5,
              Frame: 10,
              Sound: 11,
            }),
            (t.BlendMode = {
              Normal: 0,
              Add: 1,
              Alpha: 2,
              Darken: 3,
              Difference: 4,
              Erase: 5,
              HardLight: 6,
              Invert: 7,
              Layer: 8,
              Lighten: 9,
              Multiply: 10,
              Overlay: 11,
              Screen: 12,
              Subtract: 13,
            }),
            (t.TweenType = {
              None: 0,
              Line: 1,
              Curve: 2,
              QuadIn: 3,
              QuadOut: 4,
              QuadInOut: 5,
            }),
            (t.TimelineType = {
              Action: 0,
              ZOrder: 1,
              BoneAll: 10,
              BoneTranslate: 11,
              BoneRotate: 12,
              BoneScale: 13,
              Surface: 50,
              SlotDisplay: 20,
              SlotColor: 21,
              SlotFFD: 22,
              IKConstraint: 30,
              AnimationTime: 40,
              AnimationWeight: 41,
            });
        })(Q2 || (Q2 = {}));
      const J2 = Q2.DragonBones,
        t3 = Q2.BaseObject,
        e3 = Q2.Matrix;
      Q2.Transform,
        Q2.ColorTransform,
        Q2.Point,
        Q2.Rectangle,
        Q2.UserData,
        Q2.ActionData,
        Q2.DragonBonesData,
        Q2.ArmatureData,
        Q2.BoneData,
        Q2.SurfaceData,
        Q2.SlotData,
        Q2.ConstraintData,
        Q2.IKConstraintData,
        Q2.PathConstraintData,
        Q2.CanvasData,
        Q2.SkinData,
        Q2.VerticesData;
      const i3 = Q2.DisplayData;
      Q2.ImageDisplayData,
        Q2.ArmatureDisplayData,
        Q2.MeshDisplayData,
        Q2.BoundingBoxDisplayData,
        Q2.PathDisplayData,
        Q2.WeightData,
        Q2.BoundingBoxData,
        Q2.RectangleBoundingBoxData,
        Q2.EllipseBoundingBoxData,
        Q2.PolygonBoundingBoxData,
        Q2.AnimationData,
        Q2.TimelineData,
        Q2.AnimationConfig;
      const s3 = Q2.TextureAtlasData,
        n3 = Q2.TextureData;
      Q2.DeformVertices;
      const r3 = Q2.Armature;
      Q2.TransformObject, Q2.Bone, Q2.Surface;
      const a3 = Q2.Slot;
      Q2.Constraint, Q2.IKConstraint, Q2.PathConstraint, Q2.WorldClock;
      const o3 = Q2.Animation;
      Q2.AnimationState,
        Q2.BonePose,
        Q2.BlendState,
        Q2.TimelineState,
        Q2.TweenTimelineState,
        Q2.BoneTimelineState,
        Q2.SlotTimelineState,
        Q2.ConstraintTimelineState,
        Q2.ActionTimelineState,
        Q2.ZOrderTimelineState,
        Q2.BoneAllTimelineState,
        Q2.BoneTranslateTimelineState,
        Q2.BoneRotateTimelineState,
        Q2.BoneScaleTimelineState,
        Q2.SurfaceTimelineState,
        Q2.SlotDislayTimelineState,
        Q2.SlotColorTimelineState,
        Q2.DeformTimelineState,
        Q2.IKConstraintTimelineState,
        Q2.AnimationTimelineState;
      const h3 = Q2.EventObject;
      Q2.DataParser, Q2.ObjectDataParser, Q2.ActionFrame, Q2.BinaryDataParser;
      const l3 = Q2.BaseFactory;
      Q2.BuildArmaturePackage;
      const c3 = Q2.BinaryOffset;
      Q2.ArmatureType;
      const u3 = Q2.BoneType;
      var _3, d3;
      Q2.DisplayType,
        Q2.BoundingBoxType,
        Q2.ActionType,
        Q2.BlendMode,
        Q2.TweenType,
        Q2.TimelineType;
      const { ccclass: p3 } = go;
      let m3 =
          p3("dragonBones.CCTextureAtlasData")(
            (_3 = class extends s3 {
              constructor(...t) {
                super(...t), (this._renderTexture = null);
              }
              get renderTexture() {
                return this._renderTexture;
              }
              set renderTexture(t) {
                if (((this._renderTexture = t), t))
                  for (const e in this.textures) {
                    const i = this.textures[e];
                    if (!i.spriteFrame) {
                      let e = null;
                      i.rotated
                        ? (e = new Ds(
                            i.region.x,
                            i.region.y,
                            i.region.height,
                            i.region.width
                          ))
                        : ((e = new Ds(
                            i.region.x,
                            i.region.y,
                            i.region.width,
                            i.region.height
                          )),
                          (i.spriteFrame = new uC()),
                          (i.spriteFrame.texture = t),
                          (i.spriteFrame.rect = e));
                    }
                  }
                else
                  for (const t in this.textures)
                    this.textures[t].spriteFrame = null;
              }
              static toString() {
                return "[class dragonBones.CCTextureAtlasData]";
              }
              createTexture() {
                return t3.borrowObject(f3);
              }
              _onClear() {
                super._onClear(), (this.renderTexture = null);
              }
            })
          ) || _3,
        f3 =
          p3("dragonBones.CCTextureData")(
            (d3 = class extends n3 {
              constructor(...t) {
                super(...t), (this.spriteFrame = null);
              }
              static toString() {
                return "[class dragonBones.CCTextureData]";
              }
              _onClear() {
                super._onClear(), (this.spriteFrame = null);
              }
            })
          ) || d3;
      var g3;
      const { ccclass: y3 } = go;
      let T3 =
        y3("dragonBones.CCSlot")(
          (g3 = class extends a3 {
            static toString() {
              return "[class dragonBones.CCSlot]";
            }
            constructor() {
              super(),
                (this._localVertices = void 0),
                (this._indices = void 0),
                (this._matrix = void 0),
                (this._worldMatrix = void 0),
                (this._worldMatrixDirty = void 0),
                (this._color = void 0),
                (this._localVertices = []),
                (this._indices = []),
                (this._matrix = new ms()),
                (this._worldMatrix = new ms()),
                (this._worldMatrixDirty = !0),
                (this._visible = !1),
                (this._color = new Qi());
            }
            getTexture() {
              return this._textureData
                ? this._textureData.spriteFrame.texture
                : null;
            }
            calculWorldMatrix() {
              const t = this._armature._parent;
              t
                ? this._mulMat(this._worldMatrix, t._worldMatrix, this._matrix)
                : ms.copy(this._worldMatrix, this._matrix),
                (this._worldMatrixDirty = !1);
            }
            _onClear() {
              super._onClear(),
                (this._localVertices.length = 0),
                (this._indices.length = 0),
                ms.identity(this._matrix),
                ms.identity(this._worldMatrix),
                (this._worldMatrixDirty = !0),
                (this._color = new Qi()),
                (this._visible = !1);
            }
            _onUpdateDisplay() {}
            _initDisplay(t) {}
            _addDisplay() {
              this._visible = !0;
            }
            _replaceDisplay(t) {}
            _removeDisplay() {
              this._visible = !1;
            }
            _disposeDisplay(t) {}
            _updateVisible() {
              this._visible = this.parent.visible;
            }
            _updateGlueMesh() {}
            _updateZOrder() {}
            _updateBlendMode() {
              if (this._childArmature) {
                const t = this._childArmature.getSlots();
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = t[e];
                  (i._blendMode = this._blendMode), i._updateBlendMode();
                }
              }
            }
            _updateColor() {
              const t = this._color;
              (t.r = 255 * this._colorTransform.redMultiplier),
                (t.g = 255 * this._colorTransform.greenMultiplier),
                (t.b = 255 * this._colorTransform.blueMultiplier),
                (t.a = 255 * this._colorTransform.alphaMultiplier);
            }
            _updateFrame() {
              this._indices.length = 0;
              const t = this._indices,
                e = this._localVertices;
              let i = 0,
                s = 0;
              const n = this._textureData;
              if (
                !this._display ||
                this._displayIndex < 0 ||
                !n ||
                !n.spriteFrame
              )
                return;
              const r = n.spriteFrame.texture,
                a = r.width,
                o = r.height,
                h = n.region;
              if (0 === a || 0 === o)
                return void console.error(
                  `SpriteFrame ${n.spriteFrame.name} incorrect size ${a} x ${o}`
                );
              const l =
                null !== this._deformVertices &&
                this._display === this._meshDisplay
                  ? this._deformVertices.verticesData
                  : null;
              if (l) {
                const n = l.data,
                  r = n.intArray,
                  c = n.floatArray,
                  u = r[l.offset + c3.MeshVertexCount],
                  _ = r[l.offset + c3.MeshTriangleCount];
                let d = r[l.offset + c3.MeshFloatOffset];
                d < 0 && (d += 65536);
                const p = d + 2 * u,
                  m = this._armature._armatureData.scale;
                for (let t = 0, i = 2 * u; t < i; t += 2)
                  (e[s++] = c[d + t] * m),
                    (e[s++] = -c[d + t + 1] * m),
                    l.rotated
                      ? ((e[s++] = (h.x + (1 - c[p + t]) * h.width) / a),
                        (e[s++] = (h.y + c[p + t + 1] * h.height) / o))
                      : ((e[s++] = (h.x + c[p + t] * h.width) / a),
                        (e[s++] = (h.y + c[p + t + 1] * h.height) / o));
                for (let e = 0; e < 3 * _; ++e)
                  t[i++] = r[l.offset + c3.MeshVertexIndices + e];
                (e.length = s),
                  (t.length = i),
                  l.weight && this._identityTransform();
              } else {
                const i = h.x / a,
                  n = (h.y + h.height) / o,
                  r = (h.x + h.width) / a,
                  l = h.y / o;
                (e[s++] = 0),
                  (e[s++] = 0),
                  (e[s++] = i),
                  (e[s++] = n),
                  (e[s++] = h.width),
                  (e[s++] = 0),
                  (e[s++] = r),
                  (e[s++] = n),
                  (e[s++] = 0),
                  (e[s++] = h.height),
                  (e[s++] = i),
                  (e[s++] = l),
                  (e[s++] = h.width),
                  (e[s++] = h.height),
                  (e[s++] = r),
                  (e[s++] = l),
                  (t[0] = 0),
                  (t[1] = 1),
                  (t[2] = 2),
                  (t[3] = 1),
                  (t[4] = 3),
                  (t[5] = 2),
                  (e.length = s),
                  (t.length = 6);
              }
              (this._visibleDirty = !0),
                (this._blendModeDirty = !0),
                (this._colorDirty = !0);
            }
            _updateMesh() {
              const t = this._armature._armatureData.scale,
                e = this._deformVertices.vertices,
                i = this._deformVertices.bones,
                s = this._deformVertices.verticesData,
                n = s.weight,
                r = e.length > 0 && s.inheritDeform,
                a = this._localVertices;
              if (n) {
                const o = s.data,
                  h = o.intArray,
                  l = o.floatArray,
                  c = h[s.offset + c3.MeshVertexCount];
                let u = h[n.offset + c3.WeigthFloatOffset];
                u < 0 && (u += 65536);
                for (
                  let s = 0,
                    o = n.offset + c3.WeigthBoneIndices + i.length,
                    _ = u,
                    d = 0,
                    p = 0;
                  s < c;
                  s++, p += 4
                ) {
                  const s = h[o++];
                  let n = 0,
                    c = 0;
                  for (let a = 0; a < s; ++a) {
                    const s = i[h[o++]];
                    if (null !== s) {
                      const i = s.globalTransformMatrix,
                        a = l[_++];
                      let o = l[_++] * t,
                        h = l[_++] * t;
                      r && ((o += e[d++]), (h += e[d++])),
                        (n += (i.a * o + i.c * h + i.tx) * a),
                        (c += (i.b * o + i.d * h + i.ty) * a);
                    }
                  }
                  (a[p] = n), (a[p + 1] = -c);
                }
              } else if (r) {
                const i = this._parent._boneData.type !== u3.Bone,
                  n = s.data,
                  r = n.intArray,
                  o = n.floatArray,
                  h = r[s.offset + c3.MeshVertexCount];
                let l = r[s.offset + c3.MeshFloatOffset];
                l < 0 && (l += 65536);
                for (let s = 0, n = h, r = 0; s < n; s++, r += 4) {
                  const n = o[l + 2 * s] * t + e[2 * s],
                    h = o[l + 2 * s + 1] * t + e[2 * s + 1];
                  if (i) {
                    const t = this._parent._getGlobalTransformMatrix(n, h);
                    (a[r] = t.a * n + t.c * h + t.tx),
                      (a[r + 1] = -t.b * n + t.d * h + t.ty);
                  } else (a[r] = n), (a[r + 1] = -h);
                }
              }
              n && this._identityTransform();
            }
            _identityTransform() {
              const t = this._matrix;
              (t.m00 = 1),
                (t.m01 = 0),
                (t.m04 = -0),
                (t.m05 = -1),
                (t.m12 = 0),
                (t.m13 = 0),
                (this._worldMatrixDirty = !0);
            }
            _updateTransform() {
              const t = this._matrix;
              (t.m00 = this.globalTransformMatrix.a),
                (t.m01 = this.globalTransformMatrix.b),
                (t.m04 = -this.globalTransformMatrix.c),
                (t.m05 = -this.globalTransformMatrix.d),
                this._childArmature
                  ? ((t.m12 = this.globalTransformMatrix.tx),
                    (t.m13 = this.globalTransformMatrix.ty))
                  : ((t.m12 =
                      this.globalTransformMatrix.tx -
                      (this.globalTransformMatrix.a * this._pivotX -
                        this.globalTransformMatrix.c * this._pivotY)),
                    (t.m13 =
                      this.globalTransformMatrix.ty -
                      (this.globalTransformMatrix.b * this._pivotX -
                        this.globalTransformMatrix.d * this._pivotY))),
                (this._worldMatrixDirty = !0);
            }
            updateWorldMatrix() {
              if (!this._armature) return;
              const t = this._armature._parent;
              if ((t && t.updateWorldMatrix(), this._worldMatrixDirty)) {
                this.calculWorldMatrix();
                const t = this.childArmature;
                if (!t) return;
                const e = t.getSlots();
                for (let t = 0, i = e.length; t < i; t++) {
                  const i = e[t];
                  i && (i._worldMatrixDirty = !0);
                }
              }
            }
            _mulMat(t, e, i) {
              const s = e.m00,
                n = e.m01,
                r = e.m04,
                a = e.m05,
                o = e.m12,
                h = e.m13,
                l = i.m00,
                c = i.m01,
                u = i.m04,
                _ = i.m05,
                d = i.m12,
                p = i.m13;
              0 !== n || 0 !== r
                ? ((t.m00 = l * s + c * r),
                  (t.m01 = l * n + c * a),
                  (t.m04 = u * s + _ * r),
                  (t.m05 = u * n + _ * a),
                  (t.m12 = s * d + r * p + o),
                  (t.m13 = n * d + a * p + h))
                : ((t.m00 = l * s),
                  (t.m01 = c * a),
                  (t.m04 = u * s),
                  (t.m05 = _ * a),
                  (t.m12 = s * d + o),
                  (t.m13 = a * p + h));
            }
          })
        ) || g3;
      var S3;
      const { ccclass: E3 } = go;
      let v3 =
        E3("dragonBones.CCArmatureDisplay")(
          (S3 = class extends i3 {
            get node() {
              return this;
            }
            constructor() {
              super(),
                (this.shouldAdvanced = !1),
                (this._ccNode = null),
                (this._ccComponent = null),
                (this._eventTarget = void 0),
                (this._armature = null),
                (this._eventTarget = new hr());
            }
            hasEvent(t) {
              return w("Method not implemented."), !1;
            }
            addEvent(t, e, i) {
              w("Method not implemented.");
            }
            removeEvent(t, e, i) {
              w("Method not implemented.");
            }
            setEventTarget(t) {
              this._eventTarget = t;
            }
            getRootDisplay() {
              let t,
                e = this._armature._parent;
              if (!e) return this;
              for (; e; ) (t = e), (e = e._armature._parent);
              return t._armature.display;
            }
            convertToRootSpace(t) {
              const e = this._armature._parent;
              if (!e) return t;
              e.updateWorldMatrix();
              const i = e._worldMatrix,
                s = new Yi(0, 0);
              return (
                (s.x = t.x * i.m00 + t.y * i.m04 + i.m12),
                (s.y = t.x * i.m01 + t.y * i.m05 + i.m13),
                s
              );
            }
            convertToWorldSpace(t) {
              var e;
              const i = this.convertToRootSpace(t),
                s = this.getRootNode();
              return null == s ||
                null === (e = s._uiProps.uiTransformComp) ||
                void 0 === e
                ? void 0
                : e.convertToWorldSpaceAR(i);
            }
            getRootNode() {
              const t = this.getRootDisplay();
              return t && t._ccNode;
            }
            dbInit(t) {
              this._armature = t;
            }
            dbClear() {
              this._armature = null;
            }
            dbUpdate() {
              this._ccComponent && this._ccComponent.markForUpdateRenderData();
            }
            advanceTimeBySelf(t) {
              this.shouldAdvanced = !!t;
            }
            hasDBEventListener(t) {
              return this._eventTarget.hasEventListener(t);
            }
            addDBEventListener(t, e, i) {
              this._eventTarget.on(t, e, i);
            }
            removeDBEventListener(t, e, i) {
              this._eventTarget.off(t, e, i);
            }
            dispatchDBEvent(t, e) {
              this._eventTarget.emit(t, e);
            }
          })
        ) || S3;
      var b3, A3;
      const { ccclass: C3 } = go;
      let O3 =
        C3("CCFactory")(
          (((A3 = class t extends l3 {
            static getInstance() {
              return t._factory || (t._factory = new t()), t._factory;
            }
            constructor() {
              super(),
                (this.id = void 0),
                (this.uuid = void 0),
                (this._slots = void 0);
              const t = new v3();
              (this._dragonBones = new J2(t)),
                Lv.getScheduler() &&
                  (YA.on(XA.EVENT_RESTART, this.onRestart, this),
                  this.initUpdate()),
                (this.id = this.uuid = "CCFactory");
            }
            onRestart() {
              t._factory = null;
            }
            initUpdate(t) {
              $l.enableForTarget(this),
                Lv.getScheduler().scheduleUpdate(this, jl.Priority.HIGH, !1);
            }
            update(t) {
              this._dragonBones.advanceTime(t);
            }
            getDragonBonesDataByRawData(t) {
              return (
                t instanceof ArrayBuffer ? l3._binaryParser : this._dataParser
              ).parseDragonBonesData(t, 1);
            }
            buildArmatureDisplay(t, e, i, s) {
              const n = this.buildArmature(t, e, i, s);
              return n ? n._display : null;
            }
            createArmatureNode(t, e, i) {
              let s = (i = i || new Pf()).getComponent(
                "dragonBones.ArmatureDisplay"
              );
              return (
                s || (s = i.addComponent("dragonBones.ArmatureDisplay")),
                (i.name = e),
                (s._armatureName = e),
                (s._dragonAsset = t.dragonAsset),
                (s._dragonAtlasAsset = t.dragonAtlasAsset),
                s._init(),
                s
              );
            }
            _buildTextureAtlasData(t, e) {
              return t ? (t.renderTexture = e) : (t = t3.borrowObject(m3)), t;
            }
            _sortSlots() {
              const t = this._slots,
                e = [];
              for (let i = 0, s = t.length; i < s; i++) {
                const s = t[i],
                  n = s._zOrder;
                let r = !1;
                for (let t = e.length - 1; t >= 0; t--)
                  if (n >= e[t]._zOrder) {
                    e.splice(t + 1, 0, s), (r = !0);
                    break;
                  }
                r || e.unshift(s);
              }
              this._slots = e;
            }
            _buildArmature(t) {
              const e = t3.borrowObject(r3);
              (e._skinData = t.skin),
                (e._animation = t3.borrowObject(o3)),
                (e._animation._armature = e),
                (e._animation.animations = t.armature.animations),
                (e._isChildArmature = !1);
              const i = new v3();
              return e.init(t.armature, i, i, this._dragonBones), e;
            }
            _buildSlot(t, e, i) {
              const s = t3.borrowObject(T3),
                n = s;
              return s.init(e, i, n, n), s;
            }
            getDragonBonesDataByUUID(t) {
              for (const e in this._dragonBonesDataMap)
                if (-1 !== e.indexOf(t)) return this._dragonBonesDataMap[e];
              return null;
            }
            removeDragonBonesDataByUUID(t, e) {
              void 0 === e && (e = !0);
              for (const i in this._dragonBonesDataMap)
                -1 !== i.indexOf(t) &&
                  (e &&
                    this._dragonBones.bufferObject(this._dragonBonesDataMap[i]),
                  delete this._dragonBonesDataMap[i]);
            }
          })._factory = null),
          (b3 = A3))
        ) || b3;
      var I3;
      const w3 = 1 / 60,
        R3 = [],
        D3 = [];
      let x3,
        M3,
        P3 = 0,
        N3 = 0,
        L3 = 0,
        B3 = null,
        F3 = null,
        U3 = 0,
        k3 = 0,
        z3 = 0,
        H3 = 0,
        G3 = 0;
      class V3 {
        constructor() {
          (this.maxVertexCount = 0),
            (this.maxIndexCount = 0),
            (this._privateMode = !1),
            (this._inited = !1),
            (this._invalid = !0),
            (this._enableCacheAttachedInfo = !1),
            (this.frames = []),
            (this.totalTime = 0),
            (this.isCompleted = !1),
            (this._frameIdx = -1),
            (this._armatureInfo = null),
            (this._animationName = null),
            (this._tempSegments = null),
            (this._tempColors = null),
            (this._tempBoneInfos = null);
        }
        init(t, e) {
          (this._inited = !0),
            (this._armatureInfo = t),
            (this._animationName = e);
        }
        clear() {
          this._inited = !1;
          for (let t = 0, e = this.frames.length; t < e; t++)
            this.frames[t].segments.length = 0;
          this.invalidAllFrame();
        }
        begin() {
          if (!this._invalid) return;
          const t = this._armatureInfo,
            e = t.curAnimationCache;
          e &&
            e !== this &&
            (this._privateMode ? e.invalidAllFrame() : e.updateToFrame()),
            t.armature.animation.play(this._animationName, 1),
            (t.curAnimationCache = this),
            (this._invalid = !1),
            (this._frameIdx = -1),
            (this.totalTime = 0),
            (this.isCompleted = !1);
        }
        end() {
          this._needToUpdate() ||
            ((this._armatureInfo.curAnimationCache = null),
            (this.frames.length = this._frameIdx + 1),
            (this.isCompleted = !0));
        }
        _needToUpdate(t) {
          return (
            !this._armatureInfo.armature.animation.isCompleted &&
            this.totalTime < 30 &&
            (void 0 === t || this._frameIdx < t)
          );
        }
        updateToFrame(t) {
          if (!this._inited) return;
          if ((this.begin(), !this._needToUpdate(t))) return;
          const e = this._armatureInfo.armature;
          do {
            e.advanceTime(w3),
              this._frameIdx++,
              this.updateFrame(e, this._frameIdx),
              (this.totalTime += w3);
          } while (this._needToUpdate(t));
          this.end();
        }
        isInited() {
          return this._inited;
        }
        isInvalid() {
          return this._invalid;
        }
        invalidAllFrame() {
          (this.isCompleted = !1), (this._invalid = !0);
        }
        updateAllFrame() {
          this.invalidAllFrame(), this.updateToFrame();
        }
        enableCacheAttachedInfo() {
          this._enableCacheAttachedInfo ||
            ((this._enableCacheAttachedInfo = !0), this.invalidAllFrame());
        }
        updateFrame(t, e) {
          (L3 = 0),
            (P3 = 0),
            (N3 = 0),
            (B3 = null),
            (F3 = null),
            (U3 = 0),
            (k3 = 0),
            (z3 = 0),
            (H3 = 0),
            (G3 = 0),
            (this.frames[e] = this.frames[e] || {
              segments: [],
              colors: [],
              boneInfos: [],
              vertices: new Float32Array(),
              uintVert: new Uint32Array(),
              indices: new Uint16Array(),
            });
          const i = this.frames[e],
            s = (this._tempSegments = i.segments),
            n = (this._tempColors = i.colors),
            r = (this._tempBoneInfos = i.boneInfos);
          this._traverseArmature(t, 1),
            H3 > 0 && (n[H3 - 1].vfOffset = L3),
            (n.length = H3),
            (r.length = P3);
          const a = z3 - 1;
          if (a >= 0)
            if (k3 > 0) {
              const t = s[a];
              (t.indexCount = k3),
                (t.vfCount = 9 * U3),
                (t.vertexCount = U3),
                (s.length = z3);
            } else s.length = z3 - 1;
          if (0 === s.length) return;
          let o = i.vertices;
          const h = L3 / 5,
            l = 9 * h;
          let c;
          (!o || o.length < L3) && (o = i.vertices = new Float32Array(l));
          for (let t = 0, e = 0; t < l; )
            (o[t] = R3[e++]),
              (o[t + 1] = R3[e++]),
              (o[t + 3] = R3[e++]),
              (o[t + 4] = R3[e++]),
              (c = R3[e++]),
              (o[t + 5] = (255 & c) / 255),
              (o[t + 6] = ((c >> 8) & 255) / 255),
              (o[t + 7] = ((c >> 16) & 255) / 255),
              (o[t + 8] = ((c >> 24) & 255) / 255),
              (t += 9);
          let u = i.indices;
          (!u || u.length < N3) && (u = i.indices = new Uint16Array(N3));
          for (let t = 0; t < N3; t++) u[t] = D3[t];
          (i.vertices = o),
            (i.indices = u),
            (this.maxVertexCount =
              h > this.maxVertexCount ? h : this.maxVertexCount),
            (this.maxIndexCount =
              u.length > this.maxIndexCount ? u.length : this.maxIndexCount);
        }
        _traverseArmature(t, e) {
          const i = this._tempColors,
            s = this._tempSegments,
            n = this._tempBoneInfos,
            r = t._slots;
          let a, o, h, l, c, u, _, d, p;
          const m = t._bones;
          if (this._enableCacheAttachedInfo)
            for (let t = 0, e = m.length; t < e; t++, P3++) {
              const e = m[t];
              let i = n[P3];
              i || (i = n[P3] = { globalTransformMatrix: new e3() });
              const s = e.globalTransformMatrix;
              i.globalTransformMatrix.copyFrom(s);
            }
          for (let t = 0, n = r.length; t < n; t++)
            if (((h = r[t]), h._visible && h._displayData))
              if ((h.updateWorldMatrix(), (c = h._color), h.childArmature))
                this._traverseArmature(h.childArmature, (e * c.a) / 255);
              else if (((_ = h.getTexture()), _)) {
                (B3 === _.nativeUrl && F3 === h._blendMode) ||
                  ((B3 = _.nativeUrl),
                  (F3 = h._blendMode),
                  (d = z3 - 1),
                  d >= 0 &&
                    (k3 > 0
                      ? ((p = s[d]),
                        (p.indexCount = k3),
                        (p.vertexCount = U3),
                        (p.vfCount = 9 * U3))
                      : z3--),
                  (s[z3] = {
                    tex: _,
                    blendMode: h._blendMode,
                    indexCount: 0,
                    vertexCount: 0,
                    vfCount: 0,
                  }),
                  z3++,
                  (k3 = 0),
                  (U3 = 0)),
                  (u =
                    (((c.a * e) << 24) >>> 0) + (c.b << 16) + (c.g << 8) + c.r),
                  G3 !== u &&
                    ((G3 = u),
                    H3 > 0 && (i[H3 - 1].vfOffset = L3),
                    (i[H3++] = {
                      r: c.r,
                      g: c.g,
                      b: c.b,
                      a: c.a * e,
                      vfOffset: 0,
                    })),
                  (a = h._localVertices),
                  (o = h._indices),
                  (l = h._worldMatrix);
                for (let t = 0, e = a.length; t < e; )
                  (x3 = a[t++]),
                    (M3 = a[t++]),
                    (R3[L3++] = x3 * l.m00 + M3 * l.m04 + l.m12),
                    (R3[L3++] = x3 * l.m01 + M3 * l.m05 + l.m13),
                    (R3[L3++] = a[t++]),
                    (R3[L3++] = a[t++]),
                    (R3[L3++] = u);
                for (let t = 0, e = o.length; t < e; t++) D3[N3++] = U3 + o[t];
                (k3 += o.length), (U3 += a.length / 4);
              }
        }
      }
      class j3 {
        constructor() {
          (this._privateMode = !1),
            (this._animationPool = {}),
            (this._armatureCache = {});
        }
        enablePrivateMode() {
          this._privateMode = !0;
        }
        dispose() {
          for (const t in this._armatureCache) {
            const e = this._armatureCache[t];
            if (e) {
              const t = e.armature;
              t && t.dispose();
            }
          }
          (this._armatureCache = {}), (this._animationPool = {});
        }
        _removeArmature(t) {
          const e = this._armatureCache[t],
            i = e.animationsCache;
          for (const e in i) {
            const s = i[e];
            s && ((this._animationPool[`${t}#${e}`] = s), s.clear());
          }
          const s = e.armature;
          s && s.dispose(), delete this._armatureCache[t];
        }
        resetArmature(t) {
          for (const e in this._armatureCache)
            -1 !== e.indexOf(t) && this._removeArmature(e);
        }
        getArmatureCache(t, e, i) {
          const s = this._armatureCache[e];
          let n;
          if (s) n = s.armature;
          else {
            const s = O3.getInstance().buildArmatureDisplay(t, e, "", i);
            if (!s || !s._armature) return null;
            if (((n = s._armature), !j3.canCache(n))) return n.dispose(), null;
            this._armatureCache[e] = {
              armature: n,
              animationsCache: {},
              curAnimationCache: null,
            };
          }
          return n;
        }
        getAnimationCache(t, e) {
          const i = this._armatureCache[t];
          return i ? i.animationsCache[e] : null;
        }
        initAnimationCache(t, e) {
          if (!e) return null;
          const i = this._armatureCache[t],
            s = i && i.armature;
          if (!s) return null;
          if (!s.animation.hasAnimation(e)) return null;
          const n = i.animationsCache;
          let r = n[e];
          if (!r) {
            const s = `${t}#${e}`;
            (r = this._animationPool[s]),
              r
                ? delete this._animationPool[s]
                : ((r = new V3()), (r._privateMode = this._privateMode)),
              r.init(i, e),
              (n[e] = r);
          }
          return r;
        }
        invalidAnimationCache(t) {
          const e = this._armatureCache[t];
          if (!e || !e.armature) return;
          const i = e.animationsCache;
          for (const t in i) i[t].invalidAllFrame();
        }
        updateAnimationCache(t, e) {
          if (e) {
            const i = this.initAnimationCache(t, e);
            if (!i) return;
            i.updateAllFrame();
          } else {
            const e = this._armatureCache[t];
            if (!e || !e.armature) return;
            const i = e.animationsCache;
            for (const t in i) i[t].updateAllFrame();
          }
        }
        static canCache(t) {
          const e = t._slots;
          for (let t = 0, i = e.length; t < i; t++)
            if (e[t].childArmature) return !1;
          return !0;
        }
      }
      var W3, X3, Y3;
      (I3 = j3), (j3.FrameTime = w3), (j3.sharedCache = new I3());
      const { ccclass: K3, serializable: q3 } = go;
      let $3 =
        K3("dragonBones.DragonBonesAsset")(
          ((X3 = class extends Ad {
            constructor(...t) {
              super(...t),
                (this._dragonBonesJson = Y3 && Y3()),
                (this._factory = null),
                (this._dragonBonesJsonData = void 0),
                (this._armaturesEnum = null);
            }
            get dragonBonesJson() {
              return this._dragonBonesJson;
            }
            set dragonBonesJson(t) {
              (this._dragonBonesJson = t),
                (this._dragonBonesJsonData = JSON.parse(t)),
                this.reset();
            }
            constructctor() {
              this.reset();
            }
            createNode(t) {
              const e = new Pf(this.name);
              return (
                (e.addComponent("dragonBones.ArmatureDisplay").dragonAsset =
                  this),
                t(null, e)
              );
            }
            reset() {
              this._clear();
            }
            init(t, e) {
              (this._factory = t || O3.getInstance()),
                !this._dragonBonesJsonData &&
                  this.dragonBonesJson &&
                  (this._dragonBonesJsonData = JSON.parse(
                    this.dragonBonesJson
                  ));
              let i = null;
              if (
                ((i = this._dragonBonesJsonData
                  ? this._dragonBonesJsonData
                  : this._nativeAsset),
                !this._uuid)
              ) {
                const t = this._factory.getDragonBonesDataByRawData(i);
                t ? (this._uuid = t.name) : w("dragonbones name is empty");
              }
              const s = `${this._uuid}#${e}`;
              return (
                this._factory.getDragonBonesData(s) ||
                  this._factory.parseDragonBonesData(
                    i instanceof ArrayBuffer
                      ? i
                      : i.buffer instanceof ArrayBuffer
                      ? i.buffer
                      : i,
                    s
                  ),
                s
              );
            }
            getArmatureEnum() {
              if (this._armaturesEnum) return this._armaturesEnum;
              this.init();
              const t = this._factory.getDragonBonesDataByUUID(this._uuid);
              if (t) {
                const e = t.armatureNames,
                  i = {};
                for (let t = 0; t < e.length; t++) i[e[t]] = t;
                return (this._armaturesEnum = ce(i));
              }
              return null;
            }
            getAnimsEnum(t) {
              this.init();
              const e = this._factory.getDragonBonesDataByUUID(this._uuid);
              if (e) {
                const i = e.getArmature(t);
                if (!i) return null;
                const s = { "<None>": 0 },
                  n = i.animations;
                let r = 0;
                for (const t in n) n.hasOwnProperty(t) && ((s[t] = r + 1), r++);
                return ce(s);
              }
              return null;
            }
            destroy() {
              return this._clear(), super.destroy();
            }
            _clear() {
              this._factory &&
                (j3.sharedCache.resetArmature(this._uuid),
                this._factory.removeDragonBonesDataByUUID(this._uuid, !0));
            }
          }),
          (Y3 = fa(X3.prototype, "_dragonBonesJson", [q3], function () {
            return "";
          })),
          (W3 = X3))
        ) || W3;
      var Z3, Q3, J3, t5, e5, i5, s5, n5;
      a.internal.DragonBonesAsset = $3;
      const { ccclass: r5, serializable: a5, type: o5 } = go;
      let h5 =
        ((Z3 = r5("dragonBones.DragonBonesAtlasAsset")),
        (Q3 = o5(sm)),
        Z3(
          ((t5 = class extends Ad {
            constructor() {
              super(),
                (this._atlasJson = e5 && e5()),
                (this._texture = i5 && i5()),
                (this._atlasJsonData = s5 && s5()),
                (this._factory = null),
                (this._textureAtlasData = n5 && n5()),
                this._clear();
            }
            get atlasJson() {
              return this._atlasJson;
            }
            set atlasJson(t) {
              (this._atlasJson = t),
                (this._atlasJsonData = JSON.parse(this.atlasJson)),
                this._clear();
            }
            get texture() {
              return this._texture;
            }
            set texture(t) {
              (this._texture = t), this._clear();
            }
            createNode(t) {
              const e = new Pf(this.name);
              return (
                (e.addComponent(
                  "dragonBones.ArmatureDisplay"
                ).dragonAtlasAsset = this),
                t(null, e)
              );
            }
            init(t) {
              (this._factory = t),
                this._atlasJsonData ||
                  (this._atlasJsonData = JSON.parse(this.atlasJson));
              const e = this._atlasJsonData;
              (this._uuid = this._uuid || e.name),
                this._textureAtlasData
                  ? t.addTextureAtlasData(this._textureAtlasData, this._uuid)
                  : (this._textureAtlasData = t.parseTextureAtlasData(
                      e,
                      this.texture,
                      this._uuid
                    ));
            }
            destroy() {
              return this._clear(), super.destroy();
            }
            _clear() {}
          }),
          (e5 = fa(t5.prototype, "_atlasJson", [a5], function () {
            return "";
          })),
          (i5 = fa(t5.prototype, "_texture", [a5, Q3], function () {
            return null;
          })),
          (s5 = fa(t5.prototype, "_atlasJsonData", [a5], function () {
            return {};
          })),
          (n5 = fa(t5.prototype, "_textureAtlasData", [a5], function () {
            return null;
          })),
          (J3 = t5))
        ) || J3);
      var l5;
      a.internal.DragonBonesAtlasAsset = h5;
      const c5 = new ms(),
        { ccclass: u5 } = go;
      let _5 =
        u5("dragonBones.AttachUtil")(
          (l5 = class {
            constructor() {
              (this._inited = !1),
                (this._armature = null),
                (this._armatureNode = null),
                (this._armatureDisplay = null);
            }
            init(t) {
              (this._inited = !0),
                (this._armature = t._armature),
                (this._armatureNode = t.node),
                (this._armatureDisplay = t);
            }
            reset() {
              (this._inited = !1),
                (this._armature = null),
                (this._armatureNode = null),
                (this._armatureDisplay = null);
            }
            _syncAttachedNode() {
              if (!this._inited) return;
              this._armatureNode.worldMatrix;
              let t = null;
              const e = this._armatureDisplay.isAnimationCached();
              if (
                e &&
                this._armatureDisplay &&
                ((t =
                  this._armatureDisplay._curFrame &&
                  this._armatureDisplay._curFrame.boneInfos),
                !t)
              )
                return;
              const i = this._armatureDisplay.sockets,
                s = this._armatureDisplay.socketNodes,
                n = (t, e) => {
                  const i = c5;
                  (i.m00 = e.a),
                    (i.m01 = e.b),
                    (i.m04 = -e.c),
                    (i.m05 = -e.d),
                    (i.m12 = e.tx),
                    (i.m13 = e.ty),
                    (t.matrix = c5);
                },
                r = this._armature.getBones();
              for (let a = i.length - 1; a >= 0; a--) {
                const o = i[a],
                  h = o.target;
                if (!h) continue;
                if (!h.isValid) {
                  s.delete(o.path), i.splice(a, 1);
                  continue;
                }
                const l = e ? t[o.boneIndex] : r[o.boneIndex];
                l && n(h, l.globalTransformMatrix);
              }
            }
          })
        ) || l5;
      class d5 extends jl {
        constructor() {
          super(), (this._armatures = new Set());
        }
        static getInstance() {
          return (
            d5._instance ||
              ((d5._instance = new d5()),
              Lv.registerSystem(d5.ID, d5._instance, jl.Priority.HIGH)),
            d5._instance
          );
        }
        add(t) {
          t && (this._armatures.has(t) || this._armatures.add(t));
        }
        remove(t) {
          t && this._armatures.has(t) && this._armatures.delete(t);
        }
        postUpdate(t) {
          this._armatures &&
            this._armatures.forEach((e) => {
              e.updateAnimation(t), e.syncAttachedNode();
            });
        }
        prepareRenderData() {
          this._armatures &&
            this._armatures.forEach((t) => {
              t.markForUpdateRenderData();
            });
        }
      }
      var p5,
        m5,
        f5,
        g5,
        y5,
        T5,
        S5,
        E5,
        v5,
        b5,
        A5,
        C5,
        O5,
        I5,
        w5,
        R5,
        D5,
        x5,
        M5,
        P5,
        N5,
        L5,
        B5,
        F5,
        U5,
        k5,
        z5,
        H5,
        G5,
        V5,
        j5,
        W5,
        X5;
      let Y5;
      (d5.ID = "ARMATURE"),
        (d5._instance = void 0),
        (a.internal.ArmatureSystem = d5),
        (function (t) {
          t[(t.default = -1)] = "default";
        })(j5 || (j5 = {})),
        de(j5),
        (function (t) {
          t[(t["<None>"] = 0)] = "<None>";
        })(W5 || (W5 = {})),
        de(W5),
        (function (t) {
          t[(t.REALTIME = 0)] = "REALTIME";
        })(X5 || (X5 = {})),
        de(W5),
        (function (t) {
          (t[(t.REALTIME = 0)] = "REALTIME"),
            (t[(t.SHARED_CACHE = 1)] = "SHARED_CACHE"),
            (t[(t.PRIVATE_CACHE = 2)] = "PRIVATE_CACHE");
        })(Y5 || (Y5 = {})),
        de(Y5);
      const {
        ccclass: K5,
        serializable: q5,
        editable: $5,
        type: Z5,
        help: Q5,
        menu: J5,
        tooltip: t4,
        visible: e4,
        displayName: i4,
        override: s4,
        displayOrder: n4,
        executeInEditMode: r4,
      } = go;
      let a4 =
        ((p5 = K5("dragonBones.ArmatureDisplay.DragonBoneSocket")),
        (m5 = Z5(Pf)),
        p5(
          ((g5 = class {
            constructor(t = "", e = null) {
              (this.path = y5 && y5()),
                (this.target = T5 && T5()),
                (this.boneIndex = null),
                (this.path = t),
                (this.target = e);
            }
          }),
          (y5 = fa(g5.prototype, "path", [q5], function () {
            return "";
          })),
          (T5 = fa(g5.prototype, "target", [m5, q5], function () {
            return null;
          })),
          (f5 = g5))
        ) || f5);
      Vt(a4, "dragonBones.ArmatureDisplay.DragonBoneSocket");
      let o4 =
        ((S5 = K5("dragonBones.ArmatureDisplay")),
        (E5 = Z5($3)),
        (v5 = Z5(h5)),
        (b5 = Z5(j5)),
        (A5 = Z5(W5)),
        (C5 = Z5([a4])),
        (O5 = Z5(ey)),
        S5(
          (((V5 = class t extends ew {
            get dragonAsset() {
              return this._dragonAsset;
            }
            set dragonAsset(t) {
              (this._dragonAsset = t),
                this.destroyRenderData(),
                this._refresh();
            }
            get dragonAtlasAsset() {
              return this._dragonAtlasAsset;
            }
            set dragonAtlasAsset(t) {
              (this._dragonAtlasAsset = t),
                this._parseDragonAtlasAsset(),
                this._refresh();
            }
            get armatureName() {
              return this._armatureName;
            }
            set armatureName(t) {
              this._armatureName = t;
              const e = this.getAnimationNames(this._armatureName);
              (!this.animationName || e.indexOf(this.animationName) < 0) &&
                (this.animationName = ""),
                this._armature &&
                  !this.isAnimationCached() &&
                  this._factory._dragonBones.clock.remove(this._armature),
                this._refresh(),
                this._armature &&
                  !this.isAnimationCached() &&
                  this._factory._dragonBones.clock.add(this._armature);
            }
            get animationName() {
              return this._animationName;
            }
            set animationName(t) {
              this._animationName = t;
            }
            get _defaultArmatureIndex() {
              return this._defaultArmatureIndexValue;
            }
            set _defaultArmatureIndex(t) {
              this._defaultArmatureIndexValue = t;
              let e = "";
              if (this.dragonAsset) {
                let t;
                if (
                  (this.dragonAsset && (t = this.dragonAsset.getArmatureEnum()),
                  !t)
                )
                  return void G(7400, this.name);
                e = t[this._defaultArmatureIndex];
              }
              void 0 !== e ? (this.armatureName = e) : G(7401, this.name),
                this.markForUpdateRenderData();
            }
            get _animationIndex() {
              return this._animationIndexValue;
            }
            set _animationIndex(t) {
              if (((this._animationIndexValue = t), 0 === this._animationIndex))
                return void (this.animationName = "");
              let e;
              if (
                (this.dragonAsset &&
                  (e = this.dragonAsset.getAnimsEnum(this.armatureName)),
                !e)
              )
                return;
              const i = e[this._animationIndex];
              void 0 !== i
                ? this.playAnimation(i, this.playTimes)
                : G(7402, this.name);
            }
            get _defaultCacheMode() {
              return this._defaultCacheModeValue;
            }
            set _defaultCacheMode(t) {
              if (
                ((this._defaultCacheModeValue = t),
                this._defaultCacheMode !== Y5.REALTIME &&
                  this._armature &&
                  !j3.canCache(this._armature))
              )
                return (
                  (this._defaultCacheMode = Y5.REALTIME),
                  void w(
                    "Animation cache mode doesn't support skeletal nesting"
                  )
                );
              this.setAnimationCacheMode(this._defaultCacheMode);
            }
            get timeScale() {
              return this._timeScale;
            }
            set timeScale(t) {
              (this._timeScale = t),
                this._armature &&
                  !this.isAnimationCached() &&
                  (this._armature.animation.timeScale = this.timeScale);
            }
            get debugBones() {
              return this._debugBones;
            }
            set debugBones(t) {
              (this._debugBones = t), this._updateDebugDraw();
            }
            get enableBatch() {
              return this._enableBatch;
            }
            set enableBatch(t) {
              t !== this._enableBatch &&
                ((this._enableBatch = t), this._updateBatch());
            }
            get sockets() {
              return this._sockets;
            }
            set sockets(t) {
              this._verifySockets(t),
                (this._sockets = t),
                this._updateSocketBindings(),
                t.length > 0 &&
                  this._frameCache &&
                  this._frameCache.enableCacheAttachedInfo();
            }
            get socketNodes() {
              return this._socketNodes;
            }
            get drawList() {
              return this._drawList;
            }
            requestDrawInfo(t) {
              return (
                this._drawInfoList[t] || (this._drawInfoList[t] = new rI()),
                this._drawInfoList[t]
              );
            }
            constructor() {
              super(),
                (this.playTimes = R5 && R5()),
                (this.premultipliedAlpha = D5 && D5()),
                (this._armature = null),
                (this.attachUtil = void 0),
                (this._defaultArmatureIndexValue = x5 && x5()),
                (this._dragonAsset = M5 && M5()),
                (this._dragonAtlasAsset = P5 && P5()),
                (this._armatureName = N5 && N5()),
                (this._animationName = L5 && L5()),
                (this._animationIndexValue = B5 && B5()),
                (this._preCacheMode = -1),
                (this._cacheMode = Y5.REALTIME),
                (this._defaultCacheModeValue = F5 && F5()),
                (this._timeScale = U5 && U5()),
                (this._playTimes = k5 && k5()),
                (this._debugBones = z5 && z5()),
                (this._enableBatch = H5 && H5()),
                (this._debugDraw = null),
                (this._armatureKey = ""),
                (this._accTime = 0),
                (this._playCount = 0),
                (this._frameCache = null),
                (this._curFrame = null),
                (this._playing = !1),
                (this._armatureCache = null),
                (this._eventTarget = void 0),
                (this._factory = null),
                (this._displayProxy = null),
                (this._drawIdx = 0),
                (this._drawList = new Xn(
                  () => ({
                    material: null,
                    texture: null,
                    indexOffset: 0,
                    indexCount: 0,
                  }),
                  1
                )),
                (this.maxVertexCount = 0),
                (this.maxIndexCount = 0),
                (this._materialCache = {}),
                (this._enumArmatures = ce({})),
                (this._enumAnimations = ce({})),
                (this._socketNodes = new Map()),
                (this._cachedSockets = new Map()),
                (this._sockets = G5 && G5()),
                (this._inited = void 0),
                (this._drawInfoList = []),
                (this._cacheModeEnum = void 0),
                (this._eventTarget = new hr()),
                (this._inited = !1),
                (this.attachUtil = new _5()),
                this.initFactory(),
                Je(this, "_animationIndex", this._enumAnimations),
                Je(this, "_defaultArmatureIndex", this._enumArmatures),
                (this._useVertexOpacity = !0);
            }
            initFactory() {
              this._factory = O3.getInstance();
            }
            onLoad() {
              super.onLoad();
            }
            _requestDrawData(t, e, i, s) {
              const n = this._drawList.add();
              return (
                (n.material = t),
                (n.texture = e),
                (n.indexOffset = i),
                (n.indexCount = s),
                n
              );
            }
            destroyRenderData() {
              this._drawList.reset(), super.destroyRenderData();
            }
            getMaterialTemplate() {
              return null !== this.customMaterial
                ? this.customMaterial
                : (this.material || this.updateMaterial(), this.material);
            }
            getMaterialForBlend(t, e) {
              const i = `${t}/${e}`;
              let s = this._materialCache[i];
              if (s) return s;
              const n = this.getMaterialTemplate();
              return (
                (s = new OI({ parent: n, subModelIdx: 0, owner: this })),
                s.recompileShaders({ TWO_COLORED: !1, USE_LOCAL: !1 }),
                (this._materialCache[i] = s),
                s.overridePipelineStates({
                  blendState: { targets: [{ blendSrc: t, blendDst: e }] },
                }),
                s
              );
            }
            _updateBuiltinMaterial() {
              return Pv.get("default-spine-material");
            }
            get customMaterial() {
              return this._customMaterial;
            }
            set customMaterial(t) {
              (this._customMaterial = t),
                this.updateMaterial(),
                this.markForUpdateRenderData();
            }
            updateMaterial() {
              let t;
              (t = this._customMaterial
                ? this._customMaterial
                : this._updateBuiltinMaterial()),
                this.setSharedMaterial(t, 0),
                this._cleanMaterialCache();
            }
            _render(t) {
              let e = 0;
              if (this.renderData && this._drawList) {
                const i = this.renderData,
                  s = i.chunk,
                  n = s.vertexAccessor,
                  r = i.getMeshBuffer(),
                  a = r.indexOffset;
                for (let i = 0; i < this._drawList.length; i++) {
                  this._drawIdx = i;
                  const s = this._drawList.data[i];
                  s.texture &&
                    t.commitMiddleware(
                      this,
                      r,
                      a + s.indexOffset,
                      s.indexCount,
                      s.texture,
                      s.material,
                      this._enableBatch
                    ),
                    (e += s.indexCount);
                }
                const o = i.indices.subarray(0, e);
                n.appendIndices(s.bufferId, o);
              }
            }
            __preload() {
              super.__preload(), this._init();
            }
            _init() {
              if (((this._cacheMode = this._defaultCacheMode), this._inited))
                return;
              (this._inited = !0),
                this._parseDragonAtlasAsset(),
                this._refresh();
              const t = this.node.children;
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e];
                i && "DEBUG_DRAW_NODE" === i.name && i.destroy();
              }
              this._updateDebugDraw(),
                this._indexBoneSockets(),
                this._updateSocketBindings();
            }
            getArmatureKey() {
              return this._armatureKey;
            }
            setAnimationCacheMode(t) {
              this._preCacheMode !== t &&
                ((this._cacheMode = t),
                this._buildArmature(),
                this._armature &&
                  !this.isAnimationCached() &&
                  this._factory._dragonBones.clock.add(this._armature),
                this._updateSocketBindings(),
                this.markForUpdateRenderData());
            }
            isAnimationCached() {
              return this._cacheMode !== Y5.REALTIME;
            }
            onEnable() {
              super.onEnable(),
                this._armature &&
                  !this.isAnimationCached() &&
                  this._factory._dragonBones.clock.add(this._armature),
                this._flushAssembler(),
                d5.getInstance().add(this);
            }
            onDisable() {
              super.onDisable(),
                this._armature &&
                  !this.isAnimationCached() &&
                  this._factory._dragonBones.clock.remove(this._armature),
                d5.getInstance().remove(this);
            }
            _emitCacheCompleteEvent() {
              this._eventTarget.emit(h3.LOOP_COMPLETE),
                this._eventTarget.emit(h3.COMPLETE);
            }
            updateAnimation(t) {
              if ((this.markForUpdateRenderData(), !this.isAnimationCached()))
                return;
              if (!this._frameCache) return;
              const e = this._frameCache;
              if (!e.isInited()) return;
              const i = e.frames;
              if (!this._playing)
                return void (
                  e.isInvalid() &&
                  (e.updateToFrame(),
                  (this._curFrame = i[i.length - 1]),
                  this.renderData &&
                    (this.renderData.vertexCount < e.maxVertexCount ||
                      this.renderData.indexCount < e.maxIndexCount) &&
                    ((this.maxVertexCount =
                      e.maxVertexCount > this.maxVertexCount
                        ? e.maxVertexCount
                        : this.maxVertexCount),
                    (this.maxIndexCount =
                      e.maxIndexCount > this.maxIndexCount
                        ? e.maxIndexCount
                        : this.maxIndexCount),
                    this.renderData.resize(
                      this.maxVertexCount,
                      this.maxIndexCount
                    ),
                    (!this.renderData.indices ||
                      this.maxIndexCount > this.renderData.indices.length) &&
                      (this.renderData.indices = new Uint16Array(
                        this.maxIndexCount
                      ))))
                );
              const s = j3.FrameTime;
              0 === this._accTime &&
                0 === this._playCount &&
                this._eventTarget.emit(h3.START),
                (this._accTime += t * this.timeScale * 1);
              let n = Math.floor(this._accTime / s);
              if (
                (e.isCompleted ||
                  (e.updateToFrame(n),
                  this.renderData &&
                    (this.renderData.vertexCount < e.maxVertexCount ||
                      this.renderData.indexCount < e.maxIndexCount) &&
                    ((this.maxVertexCount =
                      e.maxVertexCount > this.maxVertexCount
                        ? e.maxVertexCount
                        : this.maxVertexCount),
                    (this.maxIndexCount =
                      e.maxIndexCount > this.maxIndexCount
                        ? e.maxIndexCount
                        : this.maxIndexCount),
                    this.renderData.resize(
                      this.maxVertexCount,
                      this.maxIndexCount
                    ),
                    (!this.renderData.indices ||
                      this.maxIndexCount > this.renderData.indices.length) &&
                      (this.renderData.indices = new Uint16Array(
                        this.maxIndexCount
                      )))),
                e.isCompleted && n >= i.length)
              ) {
                if (
                  (this._playCount++,
                  this.playTimes > 0 && this._playCount >= this.playTimes)
                )
                  return (
                    (this._curFrame = i[i.length - 1]),
                    (this._accTime = 0),
                    (this._playing = !1),
                    (this._playCount = 0),
                    this._emitCacheCompleteEvent(),
                    void this.attachUtil._syncAttachedNode()
                  );
                (this._accTime = 0), (n = 0), this._emitCacheCompleteEvent();
              }
              (this._curFrame = i[n]), this.attachUtil._syncAttachedNode();
            }
            onDestroy() {
              (this._materialInstances = this._materialInstances.filter(
                (t) => !!t
              )),
                (this._inited = !1),
                this._cacheMode === Y5.PRIVATE_CACHE
                  ? (this._armatureCache.dispose(),
                    (this._armatureCache = null),
                    (this._armature = null))
                  : this._cacheMode === Y5.SHARED_CACHE
                  ? ((this._armatureCache = null), (this._armature = null))
                  : this._armature &&
                    (this._armature.dispose(), (this._armature = null)),
                this._drawList.destroy(),
                super.onDestroy();
            }
            _updateDebugDraw() {
              if (this.debugBones) {
                if (!this._debugDraw) {
                  const t = new Pf("DEBUG_DRAW_NODE");
                  t.hideFlags |= $n.Flags.DontSave | $n.Flags.HideInHierarchy;
                  const e = t.addComponent(ED);
                  (e.lineWidth = 1),
                    (e.strokeColor = new Qi(255, 0, 0, 255)),
                    (this._debugDraw = e);
                }
                this._debugDraw.node.parent = this.node;
              } else this._debugDraw && (this._debugDraw.node.parent = null);
              this.markForUpdateRenderData();
            }
            _updateBatch() {
              this._cleanMaterialCache(), this.markForUpdateRenderData();
            }
            _buildArmature() {
              if (
                !this.dragonAsset ||
                !this.dragonAtlasAsset ||
                !this.armatureName
              )
                return;
              this._armature &&
                (this._preCacheMode === Y5.PRIVATE_CACHE
                  ? this._armatureCache.dispose()
                  : this._preCacheMode === Y5.REALTIME &&
                    this._armature.dispose(),
                (this._armatureCache = null),
                (this._armature = null),
                (this._displayProxy = null),
                (this._frameCache = null),
                (this._curFrame = null),
                (this._playing = !1),
                (this._preCacheMode = -1)),
                this._cacheMode === Y5.SHARED_CACHE
                  ? (this._armatureCache = j3.sharedCache)
                  : this._cacheMode === Y5.PRIVATE_CACHE &&
                    ((this._armatureCache = new j3()),
                    this._armatureCache.enablePrivateMode());
              const t = this.dragonAtlasAsset._uuid;
              if (
                ((this._armatureKey = this.dragonAsset.init(this._factory, t)),
                this.isAnimationCached() &&
                  ((this._armature = this._armatureCache.getArmatureCache(
                    this.armatureName,
                    this._armatureKey,
                    t
                  )),
                  this._armature || (this._cacheMode = Y5.REALTIME)),
                (this._preCacheMode = this._cacheMode),
                this._cacheMode === Y5.REALTIME)
              ) {
                if (
                  ((this._displayProxy = this._factory.buildArmatureDisplay(
                    this.armatureName,
                    this._armatureKey,
                    "",
                    t
                  )),
                  !this._displayProxy)
                )
                  return;
                (this._displayProxy._ccNode = this.node),
                  (this._displayProxy._ccComponent = this),
                  this._displayProxy.setEventTarget(this._eventTarget),
                  (this._armature = this._displayProxy._armature),
                  (this._armature.animation.timeScale = this.timeScale);
              }
              if (
                (this._cacheMode !== Y5.REALTIME &&
                  this.debugBones &&
                  w("Debug bones is invalid in cached mode"),
                this._armature)
              ) {
                const t = this._armature.armatureData.aabb;
                this.node._uiProps.uiTransformComp.setContentSize(
                  t.width,
                  t.height
                );
              }
              this.attachUtil.init(this),
                this.animationName &&
                  this.playAnimation(this.animationName, this.playTimes),
                this._flushAssembler();
            }
            querySockets() {
              return this._armature
                ? (0 === this._cachedSockets.size && this._indexBoneSockets(),
                  Array.from(this._cachedSockets.keys()).sort())
                : [];
            }
            querySocketPathByName(t) {
              const e = [];
              for (const i of this._cachedSockets.keys())
                i.endsWith(t) && e.push(i);
              return e;
            }
            _parseDragonAtlasAsset() {
              this.dragonAtlasAsset &&
                this.dragonAtlasAsset.init(this._factory);
            }
            _refresh() {
              this._buildArmature(),
                this._indexBoneSockets(),
                this.markForUpdateRenderData();
            }
            _updateCacheModeEnum() {
              (this._cacheModeEnum = ce({})),
                this._armature
                  ? Object.assign(this._cacheModeEnum, Y5)
                  : Object.assign(this._cacheModeEnum, X5),
                Je(this, "_defaultCacheMode", this._cacheModeEnum);
            }
            _updateAnimEnum() {
              let t;
              (t = this.dragonAsset
                ? this.dragonAsset.getAnimsEnum(this.armatureName)
                : W5),
                (this._enumAnimations = ce({})),
                Object.assign(this._enumAnimations, t || W5),
                ce.update(this._enumAnimations),
                Je(this, "_animationIndex", this._enumAnimations);
            }
            _updateArmatureEnum() {
              let t;
              (t = this.dragonAsset ? this.dragonAsset.getArmatureEnum() : j5),
                (this._enumArmatures = ce({})),
                Object.assign(this._enumArmatures, t || j5),
                ce.update(this._enumArmatures),
                Je(this, "_defaultArmatureIndex", this._enumArmatures);
            }
            _indexBoneSockets() {
              if (!this._armature) return;
              this._cachedSockets.clear();
              const t = this._cachedSockets,
                e = (t, i, s) => {
                  if (s.has(t)) return s.get(t);
                  const n = i[t];
                  if (!n.parent)
                    return s.set(t, n.name), (n.path = n.name), n.name;
                  const r = `${e(n.parent._boneIndex, i, s)}/${n.name}`;
                  return s.set(t, r), (n.path = r), r;
                },
                i = (s, n) => {
                  const r = n.getBones(),
                    a = new Map();
                  for (let t = 0; t < r.length; t++) r[t]._boneIndex = t;
                  for (let t = 0; t < r.length; t++) e(t, r, a);
                  for (const e of a.keys()) t.set(`${s}${a.get(e)}`, e);
                  const o = n.getSlots();
                  for (let t = 0; t < o.length; t++)
                    o[t].childArmature && i(o[t].name, o[t].childArmature);
                };
              i("", this._armature);
            }
            playAnimation(t, e) {
              if (
                ((this.playTimes = void 0 === e ? -1 : e),
                (this.animationName = t),
                this.isAnimationCached())
              ) {
                let e = this._armatureCache.getAnimationCache(
                  this._armatureKey,
                  t
                );
                e ||
                  (e = this._armatureCache.initAnimationCache(
                    this._armatureKey,
                    t
                  )),
                  e &&
                    ((this._accTime = 0),
                    (this._playCount = 0),
                    (this._frameCache = e),
                    this._sockets.length > 0 &&
                      this._frameCache.enableCacheAttachedInfo(),
                    this._frameCache.updateToFrame(0),
                    (this._playing = !0),
                    (this._curFrame = this._frameCache.frames[0]));
              } else if (this._armature)
                return this._armature.animation.play(t, this.playTimes);
              return this.markForUpdateRenderData(), null;
            }
            updateAnimationCache(t) {
              this.isAnimationCached() &&
                this._armatureCache.updateAnimationCache(this._armatureKey, t);
            }
            invalidAnimationCache() {
              this.isAnimationCached() &&
                this._armatureCache.invalidAnimationCache(this._armatureKey);
            }
            getArmatureNames() {
              const t = this._factory.getDragonBonesData(this._armatureKey);
              return (t && t.armatureNames) || [];
            }
            getAnimationNames(t) {
              const e = [],
                i = this._factory.getDragonBonesData(this._armatureKey);
              if (i) {
                const s = i.getArmature(t);
                if (s)
                  for (const t in s.animations)
                    s.animations.hasOwnProperty(t) && e.push(t);
              }
              return e;
            }
            on(t, e, i) {
              this.addEventListener(t, e, i);
            }
            off(t, e, i) {
              this.removeEventListener(t, e, i);
            }
            once(t, e, i) {
              this._eventTarget.once(t, e, i);
            }
            addEventListener(t, e, i) {
              this._eventTarget.on(t, e, i);
            }
            removeEventListener(t, e, i) {
              this._eventTarget.off(t, e, i);
            }
            buildArmature(t, e) {
              return this._factory.createArmatureNode(this, t, e);
            }
            armature() {
              return this._armature;
            }
            _flushAssembler() {
              const e = t.Assembler.getAssembler(this);
              this._assembler !== e && (this._assembler = e),
                this._armature &&
                  this._assembler &&
                  ((this._renderData = this._assembler.createData(this)),
                  this._renderData &&
                    ((this.maxVertexCount = this._renderData.vertexCount),
                    (this.maxIndexCount = this._renderData.indexCount)),
                  this.markForUpdateRenderData(),
                  this._updateColor());
            }
            _updateSocketBindings() {
              if (this._armature) {
                this._socketNodes.clear();
                for (let t = 0, e = this._sockets.length; t < e; t++) {
                  const e = this._sockets[t];
                  if (e.path && e.target) {
                    const t = this._cachedSockets.get(e.path);
                    if (!t) {
                      console.error(
                        `Skeleton data does not contain path ${e.path}`
                      );
                      continue;
                    }
                    (e.boneIndex = t), this._socketNodes.set(e.path, e.target);
                  }
                }
              }
            }
            _verifySockets(t) {
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e].target;
                !i ||
                  (i.parent && i.parent === this.node) ||
                  console.error(
                    `Target node ${i.name} is expected to be a direct child of ${this.node.name}`
                  );
              }
            }
            _cleanMaterialCache() {
              for (const t in this._materialCache)
                this._materialCache[t].destroy();
              this._materialCache = {};
            }
            createRenderEntity() {
              const t = new oI(tI.DYNAMIC);
              return t.setUseLocal(!1), t;
            }
            markForUpdateRenderData(t = !0) {
              super.markForUpdateRenderData(t),
                this._debugDraw && this._debugDraw.markForUpdateRenderData(t);
            }
            syncAttachedNode() {
              this.attachUtil._syncAttachedNode();
            }
          }).AnimationCacheMode = Y5),
          s(
            (w5 = V5).prototype,
            "dragonAsset",
            [E5],
            Object.getOwnPropertyDescriptor(w5.prototype, "dragonAsset"),
            w5.prototype
          ),
          s(
            w5.prototype,
            "dragonAtlasAsset",
            [v5],
            Object.getOwnPropertyDescriptor(w5.prototype, "dragonAtlasAsset"),
            w5.prototype
          ),
          s(
            w5.prototype,
            "_defaultArmatureIndex",
            [b5],
            Object.getOwnPropertyDescriptor(
              w5.prototype,
              "_defaultArmatureIndex"
            ),
            w5.prototype
          ),
          s(
            w5.prototype,
            "_animationIndex",
            [A5],
            Object.getOwnPropertyDescriptor(w5.prototype, "_animationIndex"),
            w5.prototype
          ),
          s(
            w5.prototype,
            "timeScale",
            [q5],
            Object.getOwnPropertyDescriptor(w5.prototype, "timeScale"),
            w5.prototype
          ),
          (R5 = fa(w5.prototype, "playTimes", [q5], function () {
            return -1;
          })),
          (D5 = fa(w5.prototype, "premultipliedAlpha", [q5], function () {
            return !1;
          })),
          s(
            w5.prototype,
            "sockets",
            [C5],
            Object.getOwnPropertyDescriptor(w5.prototype, "sockets"),
            w5.prototype
          ),
          (x5 = fa(
            w5.prototype,
            "_defaultArmatureIndexValue",
            [q5],
            function () {
              return j5.default;
            }
          )),
          (M5 = fa(w5.prototype, "_dragonAsset", [q5], function () {
            return null;
          })),
          (P5 = fa(w5.prototype, "_dragonAtlasAsset", [q5], function () {
            return null;
          })),
          (N5 = fa(w5.prototype, "_armatureName", [q5], function () {
            return "";
          })),
          (L5 = fa(w5.prototype, "_animationName", [q5], function () {
            return "";
          })),
          (B5 = fa(w5.prototype, "_animationIndexValue", [q5], function () {
            return 0;
          })),
          (F5 = fa(w5.prototype, "_defaultCacheModeValue", [q5], function () {
            return Y5.REALTIME;
          })),
          (U5 = fa(w5.prototype, "_timeScale", [q5], function () {
            return 1;
          })),
          (k5 = fa(w5.prototype, "_playTimes", [q5], function () {
            return -1;
          })),
          (z5 = fa(w5.prototype, "_debugBones", [q5], function () {
            return !1;
          })),
          (H5 = fa(w5.prototype, "_enableBatch", [q5], function () {
            return !1;
          })),
          (G5 = fa(w5.prototype, "_sockets", [q5], function () {
            return [];
          })),
          s(
            w5.prototype,
            "customMaterial",
            [s4, O5],
            Object.getOwnPropertyDescriptor(w5.prototype, "customMaterial"),
            w5.prototype
          ),
          (I5 = w5))
        ) || I5);
      a.internal.ArmatureDisplay = o4;
      const h4 = new Qi(255, 0, 0, 255),
        l4 = new Qi(0, 0, 255, 255),
        c4 = new Qi(0, 255, 0, 255);
      let u4,
        _4,
        d4,
        p4,
        m4,
        f4,
        g4,
        y4,
        T4,
        S4,
        E4 = 0,
        v4 = 0,
        b4 = 0,
        A4 = 0,
        C4 = 0,
        O4 = 0,
        I4 = 0,
        w4 = 0,
        R4 = 0;
      const D4 = new Float32Array(4);
      let x4;
      const M4 = new Yi(0, 0, 0),
        P4 = new ms();
      let N4 = null,
        L4 = null;
      function B4(t, e) {
        if (!t) return null;
        let i, s;
        switch (e) {
          case 1:
            (i = m4 ? Pc.ONE : Pc.SRC_ALPHA), (s = Pc.ONE);
            break;
          case 10:
            (i = Pc.DST_COLOR), (s = Pc.ONE_MINUS_SRC_ALPHA);
            break;
          case 12:
            (i = Pc.ONE), (s = Pc.ONE_MINUS_SRC_COLOR);
            break;
          case 0:
          default:
            (i = m4 ? Pc.ONE : Pc.SRC_ALPHA), (s = Pc.ONE_MINUS_SRC_ALPHA);
        }
        return S4.getMaterialForBlend(i, s);
      }
      function F4(t, e) {
        const i = t.a * e * p4,
          s = m4 ? i / 255 : 1,
          n = (t.r * u4 * s) / 255,
          r = (t.g * _4 * s) / 255,
          a = (t.b * d4 * s) / 255;
        (D4[0] = n), (D4[1] = r), (D4[2] = a), (D4[3] = m4 ? 1 : i / 255);
      }
      let U4 = null;
      const k4 = {
        accessor: U4,
        vCount: 32767,
        ensureAccessor() {
          if (!U4) {
            const t = Lv.root.device,
              e = Lv.root.batcher2D,
              i = PO;
            (this.accessor = U4 = new YO(t, i, this.vCount)),
              e.registerBufferAccessor(Number.parseInt("DRAGONBONES", 36), U4);
          }
          return this.accessor;
        },
        createData(t) {
          let e = t.renderData;
          if (!e) {
            this.ensureAccessor();
            const i = t._armature._slots;
            let s = 0,
              n = 0;
            for (let t = 0; t < i.length; ++t) {
              const e = i[t],
                r = e._localVertices.length % 4;
              (s +=
                0 === r
                  ? e._localVertices.length / 4
                  : (e._localVertices.length - r) / 4 + 1),
                (n += e._indices.length);
            }
            (e = cI.add(PO, this.accessor)),
              e.resize(s, n),
              (e.indices && n === e.indices.length) ||
                (e.indices = new Uint16Array(n));
          }
          return e;
        },
        updateRenderData(t, e) {
          (S4 = t),
            t._armature &&
              (function (t) {
                const e = t._armature;
                if (!e || null === t.renderData) return;
                (f4 = !0),
                  (m4 = t.premultipliedAlpha),
                  t.drawList.reset(),
                  (S4 = t),
                  t.node,
                  (g4 = t.renderData),
                  (S4 = t),
                  (x4 = 0),
                  (N4 = null);
                const i = t.color;
                (u4 = i.r / 255),
                  (_4 = i.g / 255),
                  (d4 = i.b / 255),
                  (p4 = t.node._uiProps.opacity),
                  4294967295 !== Qi.toUint32(i) && (x4 |= 1);
                const s = t.node.getWorldMatrix();
                if (
                  ((E4 = 0),
                  (b4 = 0),
                  (A4 = 0),
                  (C4 = 0),
                  (O4 = 0),
                  (R4 = 0),
                  (I4 = S4.maxVertexCount),
                  (w4 = S4.maxIndexCount),
                  t.isAnimationCached())
                )
                  !(function (t, e) {
                    if (!t) return;
                    const i = t.segments;
                    if (0 === i.length) return;
                    let s = null;
                    const n = t.vertices,
                      r = t.indices;
                    let a = 0,
                      o = 0,
                      h = 0,
                      l = 0,
                      c = 0;
                    const u = t.colors;
                    let _ = u[c++],
                      d = _.vfOffset;
                    F4(_, 1);
                    const p = g4,
                      m = p.chunk.vb,
                      f = p.indices;
                    for (let t = 0, g = i.length; t < g; t++) {
                      const g = i[t];
                      if (((s = B4(g.tex, g.blendMode)), !s)) continue;
                      if (
                        (N4 || (N4 = s),
                        f4 || s.hash !== N4.hash || (g.tex && g.tex !== L4))
                      ) {
                        f4 = !1;
                        const t = O4 - R4;
                        t > 0 &&
                          (S4._requestDrawData(N4, L4, R4, t), (R4 = O4)),
                          (N4 = s),
                          (L4 = g.tex);
                      }
                      (v4 = g.vertexCount),
                        (C4 = g.indexCount),
                        (a = p.chunk.vertexOffset);
                      for (let t = O4, e = O4 + C4; t < e; t++)
                        f[t] = a + b4 + r[h++];
                      l = g.vfCount;
                      const y = n.subarray(o, l);
                      m.set(y, o);
                      let T = 0;
                      if (e)
                        for (let t = 0, i = v4; t < i; t++)
                          (M4.x = m[T]),
                            (M4.y = m[T + 1]),
                            (M4.z = 0),
                            M4.transformMat4(e),
                            (m[T] = M4.x),
                            (m[T + 1] = M4.y),
                            (m[T + 2] = M4.z),
                            (T += 9);
                      if (1 & x4) {
                        let t = (o / 9) * 5;
                        for (let e = o, i = o + l; e < i; e += 9, t += 5)
                          t >= d && ((_ = u[c++]), F4(_, 1), (d = _.vfOffset)),
                            m.set(D4, e + 5);
                      }
                      (o += l), (b4 += v4), (O4 += C4), (v4 = 0), (C4 = 0);
                    }
                    const g = O4 - R4;
                    L4 && g > 0 && S4._requestDrawData(N4, L4, R4, g);
                  })(t._curFrame, s);
                else {
                  z4(e, 1, s);
                  const i = t._debugDraw;
                  if (t.debugBones && i) {
                    i.clear(),
                      (i.lineWidth = 5),
                      (i.strokeColor = h4),
                      (i.fillColor = l4);
                    const t = e.getBones();
                    for (let e = 0, s = t.length; e < s; e++) {
                      const s = t[e],
                        n = Math.max(s.boneData.length, 5),
                        r = s.globalTransformMatrix.tx,
                        a = s.globalTransformMatrix.ty,
                        o = r + s.globalTransformMatrix.a * n,
                        h = a + s.globalTransformMatrix.b * n;
                      i.moveTo(r, a),
                        i.lineTo(o, h),
                        i.stroke(),
                        i.circle(r, a, 2 * Math.PI),
                        i.fill(),
                        0 === e && (i.fillColor = c4);
                    }
                  }
                }
                U4.getMeshBuffer(g4.chunk.bufferId).setDirty(), (S4 = void 0);
              })(t);
        },
        updateColor(t) {
          t && ((S4 = t), S4.markForUpdateRenderData());
        },
      };
      function z4(t, e, i) {
        const s = g4;
        (T4 = s.chunk.vb), (y4 = s.indices);
        const n = t._slots;
        let r,
          a,
          o,
          h,
          l,
          c = 0;
        for (let t = 0, c = n.length; t < c; t++) {
          if (((l = n[t]), (h = l._color), !l._visible || !l._displayData))
            continue;
          if (
            (i
              ? ms.multiply(l._worldMatrix, i, l._matrix)
              : ms.copy(l._worldMatrix, l._matrix),
            l.childArmature)
          ) {
            z4(l.childArmature, h.a / 255, l._worldMatrix);
            continue;
          }
          if (((r = B4(l.getTexture(), l._blendMode)), !r)) continue;
          N4 || (N4 = r);
          const c = l.getTexture();
          if (f4 || r.hash !== N4.hash || (c && L4 !== c)) {
            f4 = !1;
            const t = O4 - R4;
            t > 0 && (S4._requestDrawData(N4, L4, R4, t), (R4 = O4)),
              (L4 = c),
              (N4 = r);
          }
          F4(h, e),
            P4.set(l._worldMatrix),
            (a = l._localVertices),
            (v4 = a.length / 4),
            (E4 = 9 * v4),
            (o = l._indices),
            (C4 = o.length);
          let u = !1;
          if (
            (b4 + v4 > I4 && ((I4 = b4 + v4), (u = !0)),
            O4 + C4 > w4 && ((w4 = O4 + C4), (u = !0)),
            u)
          ) {
            const t = y4,
              e = s.chunk.vertexOffset;
            s.resizeAndCopy(I4, w4 > s.indexCount ? w4 : s.indexCount),
              (T4 = s.chunk.vb),
              w4 > y4.length && (y4 = s.indices = new Uint16Array(w4));
            const i = s.chunk.vertexOffset - e;
            for (let e = 0; e < O4; ++e) y4[e] = t[e] + i;
          }
          for (let t = 0, e = a.length, i = A4; t < e; i += 9)
            (M4.x = a[t++]),
              (M4.y = a[t++]),
              (M4.z = 0),
              M4.transformMat4(P4),
              (T4[i] = M4.x),
              (T4[i + 1] = M4.y),
              (T4[i + 2] = M4.z),
              (T4[i + 3] = a[t++]),
              (T4[i + 4] = a[t++]),
              T4.set(D4, i + 5);
          const _ = s.chunk.vertexOffset;
          for (let t = 0, e = o.length, i = O4; t < e; t++, i++)
            y4[i] = b4 + o[t] + _;
          (A4 += E4), (b4 += v4), (O4 += C4), (v4 = 0), (C4 = 0);
        }
        (c = O4 - R4),
          L4 && c > 0 && (S4._requestDrawData(N4, L4, R4, c), (R4 = O4)),
          S4.maxIndexCount < w4 && (S4.maxIndexCount = w4),
          S4.maxVertexCount < I4 && (S4.maxVertexCount = I4);
      }
      a.internal.DragonBonesAssembler = k4;
      const H4 = { getAssembler: () => k4 };
      let G4, V4, j4;
      (o4.Assembler = H4),
        (function (t) {
          (t[(t.FFD = 0)] = "FFD"),
            (t[(t.AdjustColor = 10)] = "AdjustColor"),
            (t[(t.BevelFilter = 11)] = "BevelFilter"),
            (t[(t.BlurFilter = 12)] = "BlurFilter"),
            (t[(t.DropShadowFilter = 13)] = "DropShadowFilter"),
            (t[(t.GlowFilter = 14)] = "GlowFilter"),
            (t[(t.GradientBevelFilter = 15)] = "GradientBevelFilter"),
            (t[(t.GradientGlowFilter = 16)] = "GradientGlowFilter");
        })(G4 || (G4 = {})),
        (function (t) {
          (t[(t.Frame = 0)] = "Frame"), (t[(t.Sound = 1)] = "Sound");
        })(V4 || (V4 = {})),
        (function (t) {
          (t[(t.None = 0)] = "None"),
            (t[(t.SameLayer = 1)] = "SameLayer"),
            (t[(t.SameGroup = 2)] = "SameGroup"),
            (t[(t.SameLayerAndGroup = 3)] = "SameLayerAndGroup"),
            (t[(t.All = 4)] = "All");
        })(j4 || (j4 = {}));
      const W4 = globalThis.dragonBones,
        X4 = W4.Slot,
        Y4 = W4.Matrix,
        K4 = W4.BaseObject,
        q4 = W4.BoundingBoxData,
        $4 = W4.PolygonBoundingBoxData,
        Z4 = W4.Transform,
        Q4 = W4.Animation,
        J4 = W4.TextureData,
        t6 = W4.CCTextureData,
        e6 = W4.BaseFactory,
        i6 = W4.CCFactory,
        s6 = W4.WorldClock,
        n6 = W4.TextureAtlasData,
        r6 = W4.CCArmatureDisplay,
        a6 = W4.AnimationState,
        o6 = W4.BoneData,
        h6 = W4.EllipseBoundingBoxData,
        l6 = W4.ArmatureData,
        c6 = W4.CCTextureAtlasData,
        u6 = W4.TransformObject,
        _6 = W4.CCSlot,
        d6 = W4.Armature,
        p6 = W4.Bone,
        m6 = W4.RectangleBoundingBoxData,
        f6 = W4.ArmatureCacheMgr,
        g6 = W4.SkinData,
        y6 = W4.EventObject,
        T6 = W4.SlotData,
        S6 = W4.DragonBonesData,
        E6 = W4.AnimationData,
        v6 = W4.CCArmatureCacheDisplay;
      var b6, A6, C6, O6, I6, w6, R6, D6, x6, M6, P6, N6;
      function L6() {
        const t = new B6();
        return t.initialize({ flows: [] }), t;
      }
      t(
        "dragonBones",
        Object.freeze({
          __proto__: null,
          DragonBonesAsset: $3,
          DragonBonesAtlasAsset: h5,
          timeScale: 1,
          get AnimationCacheMode() {
            return Y5;
          },
          DragonBoneSocket: a4,
          ArmatureDisplay: o4,
          AttachUtil: _5,
          simpleDragonBoneAssembler: H4,
          get ExtensionType() {
            return G4;
          },
          get EventType() {
            return V4;
          },
          get AnimationFadeOutMode() {
            return j4;
          },
          Slot: X4,
          Matrix: Y4,
          BaseObject: K4,
          BoundingBoxData: q4,
          PolygonBoundingBoxData: $4,
          Transform: Z4,
          Animation: Q4,
          TextureData: J4,
          CCTextureData: t6,
          BaseFactory: e6,
          CCFactory: i6,
          WorldClock: s6,
          TextureAtlasData: n6,
          CCArmatureDisplay: r6,
          AnimationState: a6,
          BoneData: o6,
          EllipseBoundingBoxData: h6,
          ArmatureData: l6,
          CCTextureAtlasData: c6,
          TransformObject: u6,
          CCSlot: _6,
          Armature: d6,
          Bone: p6,
          RectangleBoundingBoxData: m6,
          ArmatureCacheMgr: f6,
          SkinData: g6,
          EventObject: y6,
          SlotData: T6,
          DragonBonesData: S6,
          AnimationData: E6,
          CCArmatureCacheDisplay: v6,
        })
      );
      const B6 = t("ForwardPipeline", nr.ForwardPipeline),
        F6 = t("ForwardFlow", nr.ForwardFlow),
        U6 = t("ShadowFlow", nr.ShadowFlow),
        k6 = t("ForwardStage", nr.ForwardStage),
        z6 = t("ShadowStage", nr.ShadowStage),
        H6 = t("DeferredPipeline", nr.DeferredPipeline),
        G6 = t("MainFlow", nr.MainFlow),
        V6 = t("LightingStage", nr.LightingStage),
        j6 = t("PostProcessStage", nr.PostProcessStage),
        W6 = t("GbufferStage", nr.GbufferStage),
        X6 = t("BloomStage", nr.BloomStage),
        Y6 = t("ReflectionProbeFlow", nr.ReflectionProbeFlow),
        K6 = t("ReflectionProbeStage", nr.ReflectionProbeStage),
        q6 = t("RenderPipeline", nr.RenderPipeline),
        $6 = t("RenderFlow", nr.RenderFlow),
        Z6 = t("RenderStage", nr.RenderStage);
      (a.RenderFlow = $6), (a.RenderStage = Z6), (a.RenderPipeline = q6);
      const Q6 = B6.prototype;
      (Q6._ctor = function () {
        (this._tag = 0), (this._flows = []);
      }),
        (Q6.init = function () {
          for (let t = 0; t < this._flows.length; t++)
            this._flows[t].init(this);
          const t = { tag: this._tag, flows: this._flows };
          this.initialize(t);
        });
      const J6 = Q6.onLoaded;
      Q6.onLoaded = function () {
        J6 && J6.call(this);
        for (let t = 0; t < this._flows.length; t++) this._flows[t].init(this);
        const t = { tag: this._tag, flows: this._flows };
        this.initialize(t);
      };
      const t8 = F6.prototype;
      (t8._ctor = function () {
        (this._name = 0),
          (this._priority = 0),
          (this._tag = 0),
          (this._stages = []);
      }),
        (t8.init = function (t) {
          for (let e = 0; e < this._stages.length; e++) this._stages[e].init(t);
          const e = {
            name: this._name,
            priority: this._priority,
            tag: this._tag,
            stages: this._stages,
          };
          this.initialize(e);
        });
      const e8 = U6.prototype;
      (e8._ctor = function () {
        (this._name = 0),
          (this._priority = 0),
          (this._tag = 0),
          (this._stages = []);
      }),
        (e8.init = function (t) {
          for (let e = 0; e < this._stages.length; e++) this._stages[e].init(t);
          const e = {
            name: this._name,
            priority: this._priority,
            tag: this._tag,
            stages: this._stages,
          };
          this.initialize(e);
        });
      const i8 = k6.prototype;
      (i8._ctor = function () {
        (this._name = 0),
          (this._priority = 0),
          (this._tag = 0),
          (this.renderQueues = []);
      }),
        (i8.init = function () {
          const t = [];
          for (let e = 0; e < this.renderQueues.length; e++)
            t.push(this.renderQueues[e].init());
          const e = {
            name: this._name,
            priority: this._priority,
            tag: this._tag,
            renderQueues: t,
          };
          this.initialize(e);
        });
      const s8 = z6.prototype;
      (s8._ctor = function () {
        (this._name = 0), (this._priority = 0), (this._tag = 0);
      }),
        (s8.init = function () {
          const t = {
            name: this._name,
            priority: this._priority,
            tag: this._tag,
            renderQueues: [],
          };
          this.initialize(t);
        });
      const n8 = H6.prototype;
      n8._ctor = function () {
        (this._tag = 0),
          (this._flows = []),
          (this.renderTextures = []),
          (this.materials = []);
      };
      const r8 = n8.onLoaded;
      n8.onLoaded = function () {
        r8 && r8.call(this);
        for (let t = 0; t < this._flows.length; t++) this._flows[t].init(this);
        let t = { tag: this._tag, flows: this._flows };
        this.initialize(t);
      };
      const a8 = G6.prototype;
      (a8._ctor = function () {
        (this._name = 0),
          (this._priority = 0),
          (this._tag = 0),
          (this._stages = []);
      }),
        (a8.init = function (t) {
          for (let e = 0; e < this._stages.length; e++) this._stages[e].init(t);
          const e = {
            name: this._name,
            priority: this._priority,
            tag: this._tag,
            stages: this._stages,
          };
          this.initialize(e);
        });
      const o8 = W6.prototype;
      (o8._ctor = function () {
        (this._name = 0),
          (this._priority = 0),
          (this._tag = 0),
          (this.renderQueues = []);
      }),
        (o8.init = function () {
          const t = [];
          for (let e = 0; e < this.renderQueues.length; e++)
            t.push(this.renderQueues[e].init());
          const e = {
            name: this._name,
            priority: this._priority,
            tag: this._tag,
            renderQueues: t,
          };
          this.initialize(e);
        });
      const h8 = V6.prototype;
      (h8._ctor = function () {
        (this._name = 0),
          (this._priority = 0),
          (this._tag = 0),
          (this.renderQueues = []),
          (this._deferredMaterial = null);
      }),
        (h8.init = function (t) {
          const e = [];
          for (let t = 0; t < this.renderQueues.length; t++)
            e.push(this.renderQueues[t].init());
          t.pipelineSceneData.deferredLightingMaterial = this._deferredMaterial;
          const i = {
            name: this._name,
            priority: this._priority,
            tag: this._tag,
            renderQueues: e,
          };
          this.initialize(i);
        });
      const l8 = X6.prototype;
      (l8._ctor = function () {
        (this._name = 0),
          (this._priority = 0),
          (this._tag = 0),
          (this.renderQueues = []),
          (this._bloomMaterial = null);
      }),
        (l8.init = function (t) {
          const e = [];
          for (let t = 0; t < this.renderQueues.length; t++)
            e.push(this.renderQueues[t].init());
          t.pipelineSceneData.bloomMaterial = this._bloomMaterial;
          const i = {
            name: this._name,
            priority: this._priority,
            tag: this._tag,
            renderQueues: e,
          };
          this.initialize(i);
        });
      const c8 = j6.prototype;
      (c8._ctor = function () {
        (this._name = 0),
          (this._priority = 0),
          (this._tag = 0),
          (this.renderQueues = []),
          (this._postProcessMaterial = null);
      }),
        (c8.init = function (t) {
          const e = [];
          for (let t = 0; t < this.renderQueues.length; t++)
            e.push(this.renderQueues[t].init());
          t.pipelineSceneData.postProcessMaterial = this._postProcessMaterial;
          const i = {
            name: this._name,
            priority: this._priority,
            tag: this._tag,
            renderQueues: e,
          };
          this.initialize(i);
        });
      const u8 = Y6.prototype;
      (u8._ctor = function () {
        (this._name = 0),
          (this._priority = 0),
          (this._tag = 0),
          (this._stages = []);
      }),
        (u8.init = function (t) {
          for (let e = 0; e < this._stages.length; e++) this._stages[e].init(t);
          const e = {
            name: this._name,
            priority: this._priority,
            tag: this._tag,
            stages: this._stages,
          };
          this.initialize(e);
        });
      const _8 = K6.prototype;
      (_8._ctor = function () {
        (this._name = 0),
          (this._priority = 0),
          (this._tag = 0),
          (this.renderQueues = []);
      }),
        (_8.init = function () {
          const t = [];
          for (let e = 0; e < this.renderQueues.length; e++)
            t.push(this.renderQueues[e].init());
          const e = {
            name: this._name,
            priority: this._priority,
            tag: this._tag,
            renderQueues: t,
          };
          this.initialize(e);
        });
      let d8,
        p8 =
          ((b6 = Ca("RenderTextureConfig")),
          (A6 = ao(pC)),
          b6(
            ((O6 = class {
              constructor() {
                (this.name = I6 && I6()), (this.texture = w6 && w6());
              }
            }),
            (I6 = fa(O6.prototype, "name", [Na], function () {
              return "";
            })),
            (w6 = fa(O6.prototype, "texture", [A6], function () {
              return null;
            })),
            (C6 = O6))
          ) || C6);
      t("RenderQueueSortMode", d8),
        (function (t) {
          (t[(t.FRONT_TO_BACK = 0)] = "FRONT_TO_BACK"),
            (t[(t.BACK_TO_FRONT = 1)] = "BACK_TO_FRONT");
        })(d8 || t("RenderQueueSortMode", (d8 = {}))),
        de(d8);
      let m8 = t(
          "RenderQueueDesc",
          ((R6 = ao(d8)),
          (D6 = ao([Ge])),
          (x6 = class {
            constructor() {
              (this.isTransparent = M6 && M6()),
                (this.sortMode = P6 && P6()),
                (this.stages = N6 && N6()),
                (this.stages = []);
            }
            init() {
              return new nr.RenderQueueDesc(
                this.isTransparent,
                this.sortMode,
                this.stages
              );
            }
          }),
          (M6 = fa(x6.prototype, "isTransparent", [Na], function () {
            return !1;
          })),
          (P6 = fa(x6.prototype, "sortMode", [R6], function () {
            return d8.FRONT_TO_BACK;
          })),
          (N6 = fa(x6.prototype, "stages", [D6], function () {
            return [];
          })),
          x6)
        ),
        f8 = function (t, e) {
          const i = `_${e}_target`;
          Object.defineProperty(t, e, {
            configurable: !0,
            enumerable: !0,
            get: function () {
              return (
                this[i] || (this[i] = []),
                (t = this),
                (e = i),
                new Proxy(t[e], {
                  get: (t, e, i) => Reflect.get(t, e, i),
                  set(i, s, n) {
                    const r = Reflect.set(i, s, n);
                    return (t[e] = i), r;
                  },
                })
              );
              var t, e;
            },
            set: function (t) {
              this[i] = t;
            },
          });
        };
      f8($6.prototype, "_stages"), f8(q6.prototype, "_flows");
      const g8 = jsb.Material;
      !(function (t, e = vd) {
        const { GbufferStage: i, RenderQueueDesc: s } = { ...t };
        e(
          () => {
            to()(i.prototype, "renderQueues", () => []);
          },
          "displayOrder",
          "renderQueues"
        ),
          e(
            () => {
              Na(i.prototype, "renderQueues", () => []);
            },
            "serializable",
            "renderQueues"
          ),
          e(
            () => {
              ao([s])(i.prototype, "renderQueues", () => []);
            },
            "type",
            "renderQueues"
          ),
          e(
            () => {
              Ca("GbufferStage")(i);
            },
            "ccclass",
            null
          );
      })({ GbufferStage: W6, RenderQueueDesc: m8 }),
        (function (t, e = vd) {
          const {
            LightingStage: i,
            Material: s,
            RenderQueueDesc: n,
          } = { ...t };
          e(
            () => {
              to()(i.prototype, "_deferredMaterial", () => null);
            },
            "displayOrder",
            "_deferredMaterial"
          ),
            e(
              () => {
                Na(i.prototype, "_deferredMaterial", () => null);
              },
              "serializable",
              "_deferredMaterial"
            ),
            e(
              () => {
                ao(s)(i.prototype, "_deferredMaterial", () => null);
              },
              "type",
              "_deferredMaterial"
            ),
            e(
              () => {
                to()(i.prototype, "renderQueues", () => []);
              },
              "displayOrder",
              "renderQueues"
            ),
            e(
              () => {
                Na(i.prototype, "renderQueues", () => []);
              },
              "serializable",
              "renderQueues"
            ),
            e(
              () => {
                ao([n])(i.prototype, "renderQueues", () => []);
              },
              "type",
              "renderQueues"
            ),
            e(
              () => {
                Ca("LightingStage")(i);
              },
              "ccclass",
              null
            );
        })({ LightingStage: V6, RenderQueueDesc: m8, Material: g8 }),
        (function (t, e = vd) {
          const { BloomStage: i, Material: s } = { ...t };
          e(
            () => {
              to()(i.prototype, "_bloomMaterial", () => null);
            },
            "displayOrder",
            "_bloomMaterial"
          ),
            e(
              () => {
                Na(i.prototype, "_bloomMaterial", () => null);
              },
              "serializable",
              "_bloomMaterial"
            ),
            e(
              () => {
                ao(s)(i.prototype, "_bloomMaterial", () => null);
              },
              "type",
              "_bloomMaterial"
            ),
            e(
              () => {
                Ca("BloomStage")(i);
              },
              "ccclass",
              null
            );
        })({ BloomStage: X6, Material: g8 }),
        (function (t, e = vd) {
          const {
            PostProcessStage: i,
            Material: s,
            RenderQueueDesc: n,
          } = { ...t };
          e(
            () => {
              to()(i.prototype, "_postProcessMaterial", () => null);
            },
            "displayOrder",
            "_postProcessMaterial"
          ),
            e(
              () => {
                Na(i.prototype, "_postProcessMaterial", () => null);
              },
              "serializable",
              "_postProcessMaterial"
            ),
            e(
              () => {
                ao(s)(i.prototype, "_postProcessMaterial", () => null);
              },
              "type",
              "_postProcessMaterial"
            ),
            e(
              () => {
                to()(i.prototype, "renderQueues", () => []);
              },
              "displayOrder",
              "renderQueues"
            ),
            e(
              () => {
                Na(i.prototype, "renderQueues", () => []);
              },
              "serializable",
              "renderQueues"
            ),
            e(
              () => {
                ao([n])(i.prototype, "renderQueues", () => []);
              },
              "type",
              "renderQueues"
            ),
            e(
              () => {
                Ca("PostProcessStage")(i);
              },
              "ccclass",
              null
            );
        })({ PostProcessStage: j6, Material: g8, RenderQueueDesc: m8 }),
        (function (t, e = vd) {
          const { ForwardStage: i, RenderQueueDesc: s } = { ...t };
          e(
            () => {
              to()(i.prototype, "renderQueues", () => []);
            },
            "displayOrder",
            "renderQueues"
          ),
            e(
              () => {
                Na(i.prototype, "renderQueues", () => []);
              },
              "serializable",
              "renderQueues"
            ),
            e(
              () => {
                ao([s])(i.prototype, "renderQueues", () => []);
              },
              "type",
              "renderQueues"
            ),
            e(
              () => {
                Ca("ForwardStage")(i);
              },
              "ccclass",
              null
            );
        })({ ForwardStage: k6, RenderQueueDesc: m8 }),
        (function (t, e = vd) {
          const { ShadowStage: i } = { ...t };
          e(
            () => {
              Ca("ShadowStage")(i);
            },
            "ccclass",
            null
          );
        })({ ShadowStage: z6 }),
        (function (t, e = vd) {
          const { ReflectionProbeStage: i } = { ...t };
          e(
            () => {
              Ca("ReflectionProbeStage")(i);
            },
            "ccclass",
            null
          );
        })({ ReflectionProbeStage: K6 }),
        (function (t, e = vd) {
          const { MainFlow: i } = { ...t };
          e(
            () => {
              Ca("MainFlow")(i);
            },
            "ccclass",
            null
          );
        })({ MainFlow: G6 }),
        (function (t, e = vd) {
          const { ForwardFlow: i } = { ...t };
          e(
            () => {
              Ca("ForwardFlow")(i);
            },
            "ccclass",
            null
          );
        })({ ForwardFlow: F6 }),
        (function (t, e = vd) {
          const { ShadowFlow: i } = { ...t };
          e(
            () => {
              Ca("ShadowFlow")(i);
            },
            "ccclass",
            null
          );
        })({ ShadowFlow: U6 }),
        (function (t, e = vd) {
          const { ReflectionProbeFlow: i } = { ...t };
          e(
            () => {
              Ca("ReflectionProbeFlow")(i);
            },
            "ccclass",
            null
          );
        })({ ReflectionProbeFlow: Y6 }),
        (function (t, e = vd) {
          const { ForwardPipeline: i, RenderTextureConfig: s } = { ...t };
          e(
            () => {
              to()(i.prototype, "renderTextures", () => []);
            },
            "displayOrder",
            "renderTextures"
          ),
            e(
              () => {
                Na(i.prototype, "renderTextures", () => []);
              },
              "serializable",
              "renderTextures"
            ),
            e(
              () => {
                ao([s])(i.prototype, "renderTextures", () => []);
              },
              "type",
              "renderTextures"
            ),
            e(
              () => {
                Ca("ForwardPipeline")(i);
              },
              "ccclass",
              null
            );
        })({ ForwardPipeline: B6, RenderTextureConfig: p8 }),
        (function (t, e = vd) {
          const { DeferredPipeline: i, RenderTextureConfig: s } = { ...t };
          e(
            () => {
              to()(i.prototype, "renderTextures", () => []);
            },
            "displayOrder",
            "renderTextures"
          ),
            e(
              () => {
                Na(i.prototype, "renderTextures", () => []);
              },
              "serializable",
              "renderTextures"
            ),
            e(
              () => {
                ao([s])(i.prototype, "renderTextures", () => []);
              },
              "type",
              "renderTextures"
            ),
            e(
              () => {
                Ca("DeferredPipeline")(i);
              },
              "ccclass",
              null
            );
        })({ DeferredPipeline: H6, RenderTextureConfig: p8 }),
        (function (t, e = vd) {
          const {
            RenderQueueDesc: i,
            RenderQueueSortMode: s,
            CCString: n,
          } = { ...t };
          e(
            () => {
              Wa(i.prototype);
            },
            "editable",
            "isTransparent"
          ),
            e(
              () => {
                Na(i.prototype, "isTransparent", () => !1);
              },
              "serializable",
              "isTransparent"
            ),
            e(
              () => {
                ao(s)(i.prototype, "sortMode", () => s.FRONT_TO_BACK);
              },
              "type",
              "sortMode"
            ),
            e(
              () => {
                ao([n])(i.prototype, "stages", () => []);
              },
              "type",
              "stages"
            ),
            e(
              () => {
                Ca("RenderQueueDesc")(i);
              },
              "ccclass",
              null
            );
        })({ RenderQueueDesc: m8, RenderQueueSortMode: d8, CCString: Ge }),
        (function (t, e = vd) {
          const { RenderStage: i } = { ...t };
          e(
            () => {
              Na(i.prototype, "_name", () => "");
            },
            "serializable",
            "_name"
          ),
            e(
              () => {
                to()(i.prototype, "_name", () => "");
              },
              "displayOrder",
              "_name"
            ),
            e(
              () => {
                Na(i.prototype, "_priority", () => 0);
              },
              "serializable",
              "_priority"
            ),
            e(
              () => {
                to()(i.prototype, "_priority", () => 0);
              },
              "displayOrder",
              "_priority"
            ),
            e(
              () => {
                Na(i.prototype, "_tag", () => 0);
              },
              "serializable",
              "_tag"
            ),
            e(
              () => {
                to()(i.prototype, "_tag", () => 0);
              },
              "displayOrder",
              "_tag"
            ),
            e(
              () => {
                Ca("RenderStage")(i);
              },
              "ccclass",
              null
            );
        })({ RenderStage: Z6 }),
        (function (t, e = vd) {
          const { RenderFlow: i, RenderStage: s } = { ...t };
          e(
            () => {
              Na(i.prototype, "_name", () => "");
            },
            "serializable",
            "_name"
          ),
            e(
              () => {
                to()(i.prototype, "_name", () => "");
              },
              "displayOrder",
              "_name"
            ),
            e(
              () => {
                Na(i.prototype, "_priority", () => 0);
              },
              "serializable",
              "_priority"
            ),
            e(
              () => {
                to()(i.prototype, "_priority", () => 0);
              },
              "displayOrder",
              "_priority"
            ),
            e(
              () => {
                Na(i.prototype, "_tag", () => 0);
              },
              "serializable",
              "_tag"
            ),
            e(
              () => {
                to()(i.prototype, "_tag", () => 0);
              },
              "displayOrder",
              "_tag"
            ),
            e(
              () => {
                Na(i.prototype, "_stages", () => []);
              },
              "serializable",
              "_stages"
            ),
            e(
              () => {
                ao([s])(i.prototype, "_stages", () => []);
              },
              "type",
              "_stages"
            ),
            e(
              () => {
                to()(i.prototype, "_stages", () => []);
              },
              "displayOrder",
              "_stages"
            ),
            e(
              () => {
                Ca("RenderFlow")(i);
              },
              "ccclass",
              null
            );
        })({ RenderFlow: $6, RenderStage: Z6 }),
        (function (t, e = vd) {
          const { RenderPipeline: i, RenderFlow: s } = { ...t };
          e(
            () => {
              Na(i.prototype, "_tag", () => 0);
            },
            "serializable",
            "_tag"
          ),
            e(
              () => {
                to()(i.prototype, "_tag", () => 0);
              },
              "displayOrder",
              "_tag"
            ),
            e(
              () => {
                Na(i.prototype, "_flows", () => []);
              },
              "serializable",
              "_flows"
            ),
            e(
              () => {
                ao([s])(i.prototype, "_flows", () => []);
              },
              "type",
              "_flows"
            ),
            e(
              () => {
                to()(i.prototype, "_flows", () => []);
              },
              "displayOrder",
              "_flows"
            ),
            e(
              () => {
                Ca("cc.RenderPipeline")(i);
              },
              "ccclass",
              null
            );
        })({ RenderPipeline: q6, RenderFlow: $6 });
      var y8,
        T8,
        S8,
        E8,
        v8,
        b8,
        A8,
        C8,
        O8,
        I8,
        w8 = Object.freeze({
          __proto__: null,
          createDefaultPipeline: L6,
          ForwardPipeline: B6,
          ForwardFlow: F6,
          ShadowFlow: U6,
          ForwardStage: k6,
          ShadowStage: z6,
          DeferredPipeline: H6,
          MainFlow: G6,
          LightingStage: V6,
          PostProcessStage: j6,
          GbufferStage: W6,
          BloomStage: X6,
          ReflectionProbeFlow: Y6,
          ReflectionProbeStage: K6,
          RenderPipeline: q6,
          RenderFlow: $6,
          RenderStage: Z6,
          get RenderQueueSortMode() {
            return d8;
          },
          RenderQueueDesc: m8,
        });
      a.legacy_rendering = w8;
      let R8 =
        ((y8 = Ca("cc.Billboard")),
        (T8 = ao(sm)),
        (S8 = ao(sm)),
        y8(
          ((v8 = class extends np {
            get texture() {
              return this._texture;
            }
            set texture(t) {
              (this._texture = t), this.updateTexture();
            }
            updateTexture() {
              this._material &&
                this._material.setProperty("mainTexture", this._texture);
            }
            get height() {
              return this._height;
            }
            set height(t) {
              (this._height = t), this.updateHeight();
            }
            updateHeight() {
              this._material &&
                ((this._uniform.y = this._height),
                this._material.setProperty("cc_size_rotation", this._uniform));
            }
            get width() {
              return this._width;
            }
            set width(t) {
              (this._width = t), this.updateWidth();
            }
            updateWidth() {
              this._material &&
                ((this._uniform.x = this._width),
                this._material.setProperty("cc_size_rotation", this._uniform));
            }
            get rotation() {
              return Math.round(100 * Ai(this._rotation)) / 100;
            }
            set rotation(t) {
              (this._rotation = bi(t)), this.updateRotation();
            }
            updateRotation() {
              this._material &&
                ((this._uniform.z = this._rotation),
                this._material.setProperty("cc_size_rotation", this._uniform));
            }
            get technique() {
              return this._techIndex;
            }
            set technique(t) {
              var e, i;
              t = Math.floor(t);
              const s =
                null === (e = this._material) ||
                void 0 === e ||
                null === (i = e.effectAsset) ||
                void 0 === i
                  ? void 0
                  : i.techniques;
              s && t >= s.length && (t = s.length - 1),
                t < 0 && (t = 0),
                (this._techIndex = t),
                this.updateTechnique();
            }
            updateTechnique() {
              this._model &&
                this._mesh &&
                this._material &&
                this._material.technique !== this._techIndex &&
                (this.detachFromScene(),
                this._model.destroy(),
                (this._model = null),
                this._material.destroy(),
                (this._material = null),
                this._mesh.destroy(),
                (this._mesh = null),
                this.createModel(),
                this.updateWidth(),
                this.updateHeight(),
                this.updateRotation(),
                this.updateTexture(),
                this.enabled
                  ? (this.attachToScene(), (this._model.enabled = !0))
                  : (this._model.enabled = !1));
            }
            constructor() {
              super(),
                (this._texture = b8 && b8()),
                (this._height = A8 && A8()),
                (this._width = C8 && C8()),
                (this._rotation = O8 && O8()),
                (this._techIndex = I8 && I8()),
                (this._model = null),
                (this._mesh = null),
                (this._material = null),
                (this._uniform = new Wi(1, 1, 0, 0));
            }
            onLoad() {
              this.createModel();
            }
            onEnable() {
              this.attachToScene(),
                (this._model.enabled = !0),
                this.updateWidth(),
                this.updateHeight(),
                this.updateRotation(),
                this.updateTexture(),
                this.updateTechnique();
            }
            onDisable() {
              this.detachFromScene();
            }
            attachToScene() {
              this._model &&
                this.node &&
                this.node.scene &&
                (this._model.scene && this.detachFromScene(),
                this._getRenderScene().addModel(this._model));
            }
            detachFromScene() {
              this._model &&
                this._model.scene &&
                this._model.scene.removeModel(this._model);
            }
            createModel() {
              this._mesh = sC(
                {
                  primitiveMode: Gc.TRIANGLE_LIST,
                  positions: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  uvs: [0, 0, 1, 0, 0, 1, 1, 1],
                  colors: [
                    Qi.WHITE.r,
                    Qi.WHITE.g,
                    Qi.WHITE.b,
                    Qi.WHITE.a,
                    Qi.WHITE.r,
                    Qi.WHITE.g,
                    Qi.WHITE.b,
                    Qi.WHITE.a,
                    Qi.WHITE.r,
                    Qi.WHITE.g,
                    Qi.WHITE.b,
                    Qi.WHITE.a,
                    Qi.WHITE.r,
                    Qi.WHITE.g,
                    Qi.WHITE.b,
                    Qi.WHITE.a,
                  ],
                  attributes: [
                    new Lu(eu.ATTR_POSITION, fc.RGB32F),
                    new Lu(eu.ATTR_TEX_COORD, fc.RG32F),
                    new Lu(eu.ATTR_COLOR, fc.RGBA8UI, !0),
                  ],
                  indices: [0, 1, 2, 1, 2, 3],
                },
                void 0,
                { calculateBounds: !1 }
              );
              const t = (this._model = a.director.root.createModel(
                tg,
                this.node
              ));
              (t.node = t.transform = this.node),
                null == this._material &&
                  ((this._material = new ey()),
                  this._material.copy(Pv.get("default-billboard-material"), {
                    technique: this._techIndex,
                  })),
                t.initSubModel(
                  0,
                  this._mesh.renderingSubMeshes[0],
                  this._material
                );
            }
          }),
          (b8 = fa(v8.prototype, "_texture", [T8], function () {
            return null;
          })),
          s(
            v8.prototype,
            "texture",
            [S8],
            Object.getOwnPropertyDescriptor(v8.prototype, "texture"),
            v8.prototype
          ),
          (A8 = fa(v8.prototype, "_height", [Na], function () {
            return 0;
          })),
          (C8 = fa(v8.prototype, "_width", [Na], function () {
            return 0;
          })),
          (O8 = fa(v8.prototype, "_rotation", [Na], function () {
            return 0;
          })),
          (I8 = fa(v8.prototype, "_techIndex", [Na], function () {
            return 0;
          })),
          (E8 = v8))
        ) || E8);
      t({ Billboard: R8, BillboardComponent: R8 });
      const D8 = [
          new Lu(eu.ATTR_POSITION, fc.RGB32F),
          new Lu(eu.ATTR_TEX_COORD, fc.RGBA32F),
          new Lu(eu.ATTR_TEX_COORD1, fc.RGB32F),
          new Lu(eu.ATTR_COLOR, fc.RGBA8, !0),
        ],
        x8 = new Yi(),
        M8 = new Yi();
      class P8 extends tg {
        constructor() {
          super(),
            (this._capacity = void 0),
            (this._vertSize = 0),
            (this._vBuffer = null),
            (this._vertAttrsFloatCount = 0),
            (this._vdataF32 = null),
            (this._vdataUint32 = null),
            (this._subMeshData = null),
            (this._vertCount = 0),
            (this._indexCount = 0),
            (this._material = null),
            (this._iaVertCount = 0),
            (this._iaIndexCount = 0),
            this._registerListeners(),
            (this.type = Jf.LINE),
            (this._capacity = 100);
        }
        setCapacity(t) {
          (this._capacity = t), this.createBuffer();
        }
        createBuffer() {
          this._vertSize = 0;
          for (const t of D8)
            (t.offset = this._vertSize), (this._vertSize += a_[t.format].size);
          (this._vertAttrsFloatCount = this._vertSize / 4),
            (this._vBuffer = this.createSubMeshData()),
            (this._vdataF32 = new Float32Array(this._vBuffer)),
            (this._vdataUint32 = new Uint32Array(this._vBuffer));
        }
        updateMaterial(t) {
          (this._material = t), super.setSubModelMaterial(0, t);
        }
        createSubMeshData() {
          this._subMeshData && this.destroySubMeshData(),
            (this._vertCount = 2),
            (this._indexCount = 6);
          const t = this._device.createBuffer(
              new yu(
                Tc.VERTEX | Tc.TRANSFER_DST,
                vc.DEVICE,
                this._vertSize * this._capacity * this._vertCount,
                this._vertSize
              )
            ),
            e = new ArrayBuffer(
              this._vertSize * this._capacity * this._vertCount
            );
          t.update(e);
          const i = new Uint16Array((this._capacity - 1) * this._indexCount);
          let s = 0;
          for (let t = 0; t < this._capacity - 1; ++t) {
            const e = 2 * t;
            (i[s++] = e),
              (i[s++] = e + 1),
              (i[s++] = e + 2),
              (i[s++] = e + 3),
              (i[s++] = e + 2),
              (i[s++] = e + 1);
          }
          const n = this._device.createBuffer(
            new yu(
              Tc.INDEX | Tc.TRANSFER_DST,
              vc.DEVICE,
              (this._capacity - 1) *
                this._indexCount *
                Uint16Array.BYTES_PER_ELEMENT,
              Uint16Array.BYTES_PER_ELEMENT
            )
          );
          return (
            n.update(i),
            (this._iaVertCount = this._capacity * this._vertCount),
            (this._iaIndexCount = (this._capacity - 1) * this._indexCount),
            (this._subMeshData = new fC([t], D8, Gc.TRIANGLE_LIST, n)),
            this.initSubModel(0, this._subMeshData, this._material),
            e
          );
        }
        addLineVertexData(t, e, i) {
          if (t.length > 1) {
            let s = 0;
            Yi.subtract(x8, t[1], t[0]),
              (this._vdataF32[s++] = t[0].x),
              (this._vdataF32[s++] = t[0].y),
              (this._vdataF32[s++] = t[0].z),
              (this._vdataF32[s++] = 0),
              (this._vdataF32[s++] = e.evaluate(0, 1)),
              (this._vdataF32[s++] = 0),
              (this._vdataF32[s++] = 0),
              (this._vdataF32[s++] = x8.x),
              (this._vdataF32[s++] = x8.y),
              (this._vdataF32[s++] = x8.z),
              (this._vdataUint32[s++] = Qi.toUint32(i.evaluate(0, 1))),
              (this._vdataF32[s++] = t[0].x),
              (this._vdataF32[s++] = t[0].y),
              (this._vdataF32[s++] = t[0].z),
              (this._vdataF32[s++] = 1),
              (this._vdataF32[s++] = e.evaluate(0, 1)),
              (this._vdataF32[s++] = 0),
              (this._vdataF32[s++] = 1),
              (this._vdataF32[s++] = x8.x),
              (this._vdataF32[s++] = x8.y),
              (this._vdataF32[s++] = x8.z),
              (this._vdataUint32[s++] = Qi.toUint32(i.evaluate(0, 1)));
            for (let n = 1; n < t.length - 1; n++) {
              Yi.subtract(x8, t[n - 1], t[n]),
                Yi.subtract(M8, t[n + 1], t[n]),
                Yi.subtract(M8, M8, x8);
              const r = n / t.length;
              (this._vdataF32[s++] = t[n].x),
                (this._vdataF32[s++] = t[n].y),
                (this._vdataF32[s++] = t[n].z),
                (this._vdataF32[s++] = 0),
                (this._vdataF32[s++] = e.evaluate(r, 1)),
                (this._vdataF32[s++] = r),
                (this._vdataF32[s++] = 0),
                (this._vdataF32[s++] = M8.x),
                (this._vdataF32[s++] = M8.y),
                (this._vdataF32[s++] = M8.z),
                (this._vdataUint32[s++] = Qi.toUint32(i.evaluate(r, 1))),
                (this._vdataF32[s++] = t[n].x),
                (this._vdataF32[s++] = t[n].y),
                (this._vdataF32[s++] = t[n].z),
                (this._vdataF32[s++] = 1),
                (this._vdataF32[s++] = e.evaluate(r, 1)),
                (this._vdataF32[s++] = r),
                (this._vdataF32[s++] = 1),
                (this._vdataF32[s++] = M8.x),
                (this._vdataF32[s++] = M8.y),
                (this._vdataF32[s++] = M8.z),
                (this._vdataUint32[s++] = Qi.toUint32(i.evaluate(r, 1)));
            }
            Yi.subtract(x8, t[t.length - 1], t[t.length - 2]),
              (this._vdataF32[s++] = t[t.length - 1].x),
              (this._vdataF32[s++] = t[t.length - 1].y),
              (this._vdataF32[s++] = t[t.length - 1].z),
              (this._vdataF32[s++] = 0),
              (this._vdataF32[s++] = e.evaluate(1, 1)),
              (this._vdataF32[s++] = 1),
              (this._vdataF32[s++] = 0),
              (this._vdataF32[s++] = x8.x),
              (this._vdataF32[s++] = x8.y),
              (this._vdataF32[s++] = x8.z),
              (this._vdataUint32[s++] = Qi.toUint32(i.evaluate(1, 1))),
              (this._vdataF32[s++] = t[t.length - 1].x),
              (this._vdataF32[s++] = t[t.length - 1].y),
              (this._vdataF32[s++] = t[t.length - 1].z),
              (this._vdataF32[s++] = 1),
              (this._vdataF32[s++] = e.evaluate(1, 1)),
              (this._vdataF32[s++] = 1),
              (this._vdataF32[s++] = 1),
              (this._vdataF32[s++] = x8.x),
              (this._vdataF32[s++] = x8.y),
              (this._vdataF32[s++] = x8.z),
              (this._vdataUint32[s++] = Qi.toUint32(i.evaluate(1, 1)));
          }
          this.updateIA(Math.max(0, t.length - 1));
        }
        updateIA(t) {
          const e = this._subModels[0].inputAssembler;
          e.vertexBuffers[0].update(this._vdataF32),
            (e.firstIndex = 0),
            (e.indexCount = this._indexCount * t),
            (e.vertexCount = this._iaVertCount);
        }
        destroySubMeshData() {
          this._subMeshData &&
            (this._subMeshData.destroy(), (this._subMeshData = null));
        }
      }
      var N8, L8;
      const B8 = hi.Attr.setClassAttr,
        F8 = [
          ["mode", "constant", "multiplier"],
          ["mode", "spline", "multiplier"],
          ["mode", "splineMin", "splineMax", "multiplier"],
          ["mode", "constantMin", "constantMax", "multiplier"],
        ],
        U8 = ce({ Constant: 0, Curve: 1, TwoCurves: 2, TwoConstants: 3 });
      let k8 = t(
        "CurveRange",
        Ca("cc.CurveRange")(
          (((L8 = class {
            set mode(t) {
              switch (((this._mode = t), t)) {
                case U8.Constant:
                case U8.TwoConstants:
                  break;
                case U8.Curve:
                  this.spline || (this.spline = Ll());
                  break;
                case U8.TwoCurves:
                  this.splineMax || (this.splineMax = Ll()),
                    this.splineMin || (this.splineMin = Ll());
              }
            }
            get mode() {
              return this._mode;
            }
            get curve() {
              var t;
              return null !== (t = this._curve) && void 0 !== t
                ? t
                : (this._curve = new Dl(this.spline));
            }
            set curve(t) {
              (this._curve = t), (this.spline = t._internalCurve);
            }
            get curveMin() {
              var t;
              return null !== (t = this._curveMin) && void 0 !== t
                ? t
                : (this._curveMin = new Dl(this.splineMin));
            }
            set curveMin(t) {
              (this._curveMin = t), (this.splineMin = t._internalCurve);
            }
            get curveMax() {
              var t;
              return null !== (t = this._curveMax) && void 0 !== t
                ? t
                : (this._curveMax = new Dl(this.splineMax));
            }
            set curveMax(t) {
              (this._curveMax = t), (this.splineMax = t._internalCurve);
            }
            constructor() {
              (this.constant = 0),
                (this.constantMin = 0),
                (this.constantMax = 0),
                (this.multiplier = 1),
                (this._mode = U8.Constant);
            }
            evaluate(t, e) {
              switch (this._mode) {
                default:
                case U8.Constant:
                  return this.constant;
                case U8.Curve:
                  return this.spline.evaluate(t) * this.multiplier;
                case U8.TwoCurves:
                  return (
                    vi(
                      this.splineMin.evaluate(t),
                      this.splineMax.evaluate(t),
                      e
                    ) * this.multiplier
                  );
                case U8.TwoConstants:
                  return vi(this.constantMin, this.constantMax, e);
              }
            }
            getMax() {
              switch (this._mode) {
                default:
                case U8.Constant:
                  return this.constant;
                case U8.Curve:
                  return this.multiplier;
                case U8.TwoConstants:
                  return this.constantMax;
                case U8.TwoCurves:
                  return this.multiplier;
              }
            }
            isZero() {
              switch (this._mode) {
                default:
                case U8.Constant:
                  return Ti(this.constant, 0, gi);
                case U8.Curve:
                  return Ti(this.multiplier, 0, gi);
                case U8.TwoConstants:
                  return Ti(
                    Math.max(
                      Math.abs(this.constantMax),
                      Math.abs(this.constantMin)
                    ),
                    0,
                    gi
                  );
                case U8.TwoCurves:
                  return Ti(this.multiplier, 0, gi);
              }
            }
            _onBeforeSerialize(t) {
              return F8[this._mode];
            }
          }).Mode = U8),
          (N8 = L8))
        ) || N8
      );
      function z8(t, e, i) {
        switch (t.mode) {
          case U8.Constant:
            return t.constant;
          case U8.Curve:
            return t.spline.evaluate(e) * t.multiplier;
          case U8.TwoCurves:
            return 0 === i
              ? t.splineMin.evaluate(e) * t.multiplier
              : t.splineMax.evaluate(e) * t.multiplier;
          case U8.TwoConstants:
            return 0 === i ? t.constantMin : t.constantMax;
          default:
            return 0;
        }
      }
      function H8(t) {
        switch (t.mode) {
          case U8.TwoConstants:
          case U8.TwoCurves:
            return 2;
          default:
            return 1;
        }
      }
      function G8(t, e, i, s) {
        return (
          null === t || i !== t.width || s !== t.height
            ? (t && t.destroy(),
              (t = (function (t, e, i) {
                const s = new wd({
                    width: e,
                    height: i,
                    _data: t,
                    _compressed: !1,
                    format: Cd.RGBA32F,
                  }),
                  n = new sm();
                return (
                  n.setFilters(Id.NEAREST, Id.NEAREST),
                  n.setMipFilter(Id.NONE),
                  n.setWrapMode(
                    Od.CLAMP_TO_EDGE,
                    Od.CLAMP_TO_EDGE,
                    Od.CLAMP_TO_EDGE
                  ),
                  (n.image = s),
                  n
                );
              })(e, i, s)))
            : t.uploadData(e),
          t
        );
      }
      function V8(t, e, i, s, n, r, a) {
        const o = Math.max(H8(s), H8(n), H8(r)),
          h = i * o * 4;
        (null !== e && e.length === h) || (e = new Float32Array(i * o * 4));
        const l = [s, n, r],
          c = 1 / (i - 1);
        for (let t = 0; t < o; t++)
          for (let s = 0; s < 3; s++) {
            const n = l[s];
            let r = 0,
              o = 0;
            for (let h = 0; h < i; h++) {
              const l = z8(n, c * h, t);
              a ? (o = l) : ((r += l), (o = r / (h + 1))),
                (e[4 * (t * i + h) + s] = o);
            }
          }
        return { texture: G8(t, e, i, o), texdata: e };
      }
      var j8, W8, X8, Y8, K8, q8, $8, Z8, Q8, J8, t7, e7, i7, s7, n7, r7;
      hi.fastDefine("cc.CurveRange", k8, {
        multiplier: 1,
        constantMax: 0,
        constantMin: 0,
        constant: 0,
        mode: U8.Constant,
        splineMax: Object.freeze(Ll()),
        splineMin: Object.freeze(Ll()),
        spline: Object.freeze(Ll()),
      }),
        B8(k8, "multiplier", "visible", !0),
        B8(k8, "constantMax", "visible", !0),
        B8(k8, "constantMin", "visible", !0),
        B8(k8, "constant", "visible", !0),
        Je(k8, "mode", U8),
        B8(k8, "mode", "visible", !0),
        B8(k8, "splineMax", "type", "Object"),
        B8(k8, "splineMax", "ctor", wh),
        B8(k8, "splineMax", "visible", !0),
        B8(k8, "splineMin", "type", "Object"),
        B8(k8, "splineMin", "ctor", wh),
        B8(k8, "splineMin", "visible", !0),
        B8(k8, "spline", "type", "Object"),
        B8(k8, "spline", "ctor", wh),
        B8(k8, "spline", "visible", !0);
      const a7 = ce({
          Color: 0,
          Gradient: 1,
          TwoColors: 2,
          TwoGradients: 3,
          RandomColor: 4,
        }),
        o7 = new Qi(),
        h7 = new Qi();
      let l7 = t(
        "GradientRange",
        ((j8 = Ca("cc.GradientRange")),
        (W8 = ao(a7)),
        (X8 = ao(Ol)),
        (Y8 = ao(Ol)),
        (K8 = ao(Ol)),
        (q8 = ao(a7)),
        j8(
          (((r7 = class {
            constructor() {
              (this.color = Q8 && Q8()),
                (this.colorMin = J8 && J8()),
                (this.colorMax = t7 && t7()),
                (this.gradient = e7 && e7()),
                (this.gradientMin = i7 && i7()),
                (this.gradientMax = s7 && s7()),
                (this._mode = n7 && n7()),
                (this._color = Qi.WHITE.clone());
            }
            get mode() {
              return this._mode;
            }
            set mode(t) {
              this._mode = t;
            }
            evaluate(t, e) {
              switch (this._mode) {
                case a7.Color:
                  return this.color;
                case a7.TwoColors:
                  return (
                    Qi.lerp(this._color, this.colorMin, this.colorMax, e),
                    this._color
                  );
                case a7.RandomColor:
                  return this.gradient.getRandomColor(this._color);
                case a7.Gradient:
                  return this.gradient.evaluateFast(this._color, t);
                case a7.TwoGradients:
                  return (
                    Qi.lerp(
                      this._color,
                      this.gradientMin.evaluateFast(o7, t),
                      this.gradientMax.evaluateFast(h7, t),
                      e
                    ),
                    this._color
                  );
                default:
                  return this.color;
              }
            }
            _onBeforeSerialize(t) {
              return (!1)[this._mode];
            }
          }).Mode = a7),
          s(
            (Z8 = r7).prototype,
            "mode",
            [W8],
            Object.getOwnPropertyDescriptor(Z8.prototype, "mode"),
            Z8.prototype
          ),
          (Q8 = fa(Z8.prototype, "color", [Na], function () {
            return Qi.WHITE.clone();
          })),
          (J8 = fa(Z8.prototype, "colorMin", [Na], function () {
            return Qi.WHITE.clone();
          })),
          (t7 = fa(Z8.prototype, "colorMax", [Na], function () {
            return Qi.WHITE.clone();
          })),
          (e7 = fa(Z8.prototype, "gradient", [X8], function () {
            return new Ol();
          })),
          (i7 = fa(Z8.prototype, "gradientMin", [Y8], function () {
            return new Ol();
          })),
          (s7 = fa(Z8.prototype, "gradientMax", [K8], function () {
            return new Ol();
          })),
          (n7 = fa(Z8.prototype, "_mode", [q8], function () {
            return a7.Color;
          })),
          ($8 = Z8))
        ) || $8)
      );
      function c7(t, e, i) {
        switch (t.mode) {
          case a7.Color:
            return t.color;
          case a7.TwoColors:
            return 0 === i ? t.colorMin : t.colorMax;
          case a7.RandomColor:
            return t.gradient.getRandomColor(o7);
          case a7.Gradient:
            return t.gradient.evaluateFast(o7, e);
          case a7.TwoGradients:
            return 0 === i
              ? t.gradientMin.evaluateFast(o7, e)
              : t.gradientMax.evaluateFast(o7, e);
          default:
            return t.color;
        }
      }
      var u7,
        _7,
        d7,
        p7,
        m7,
        f7,
        g7,
        y7,
        T7,
        S7,
        E7,
        v7,
        b7,
        A7,
        C7,
        O7,
        I7,
        w7,
        R7,
        D7;
      const x7 = { CC_USE_WORLD_SPACE: !1, CC_USE_WORLD_SCALE: !0 };
      let M7 =
        ((u7 = Ca("cc.Line")),
        (_7 = ao(sm)),
        (d7 = ao(sm)),
        (p7 = ao(ey)),
        (m7 = ao([Yi])),
        (f7 = ao([Yi])),
        (g7 = ao(k8)),
        (y7 = ao(l7)),
        (T7 = ao(Ss)),
        (S7 = ao(Ss)),
        u7(
          ((v7 = class extends MM {
            get texture() {
              return this._texture;
            }
            set texture(t) {
              (this._texture = t),
                this.material && this.material.setProperty("mainTexture", t);
            }
            get lineMaterial() {
              return this.getSharedMaterial(0);
            }
            set lineMaterial(t) {
              this.setSharedMaterial(t, 0);
            }
            get sharedMaterials() {
              return super.sharedMaterials;
            }
            set sharedMaterials(t) {
              super.sharedMaterials = t;
            }
            get worldSpace() {
              return this._worldSpace;
            }
            set worldSpace(t) {
              this._worldSpace = t;
              const e = this.getMaterialInstance(0);
              e &&
                ((x7.CC_USE_WORLD_SPACE = this.worldSpace),
                e.recompileShaders(x7),
                this._models[0] && this._models[0].setSubModelMaterial(0, e));
            }
            get positions() {
              return this._positions;
            }
            set positions(t) {
              (this._positions = t),
                this._models[0] &&
                  this._models[0].addLineVertexData(
                    this._positions,
                    this.width,
                    this.color
                  );
            }
            get width() {
              return this._width;
            }
            set width(t) {
              (this._width = t),
                this._models[0] &&
                  this._models[0].addLineVertexData(
                    this._positions,
                    this._width,
                    this._color
                  );
            }
            get color() {
              return this._color;
            }
            set color(t) {
              (this._color = t),
                this._models[0] &&
                  this._models[0].addLineVertexData(
                    this._positions,
                    this._width,
                    this._color
                  );
            }
            get tile() {
              return this._tile;
            }
            set tile(t) {
              this._tile.set(t),
                this.material &&
                  ((this._tile_offset.x = this._tile.x),
                  (this._tile_offset.y = this._tile.y),
                  this.material.setProperty(
                    "mainTiling_Offset",
                    this._tile_offset
                  ));
            }
            get offset() {
              return this._offset;
            }
            set offset(t) {
              this._offset.set(t),
                this.material &&
                  ((this._tile_offset.z = this._offset.x),
                  (this._tile_offset.w = this._offset.y),
                  this.material.setProperty(
                    "mainTiling_Offset",
                    this._tile_offset
                  ));
            }
            constructor() {
              super(),
                (this._texture = b7 && b7()),
                (this._material = A7 && A7()),
                (this._worldSpace = C7 && C7()),
                (this._positions = O7 && O7()),
                (this._width = I7 && I7()),
                (this._color = w7 && w7()),
                (this._tile = R7 && R7()),
                (this._tile_offset = new Wi()),
                (this._offset = D7 && D7());
            }
            onLoad() {
              const t = a.director.root.createModel(P8);
              if (
                (0 === this._models.length
                  ? this._models.push(t)
                  : (this._models[0] = t),
                (t.node = t.transform = this.node),
                this._material &&
                  ((this.lineMaterial = this._material),
                  (this._material = null)),
                null === this.lineMaterial)
              ) {
                const t = Pv.get("default-trail-material");
                this.material = t;
              }
              const e = this.getMaterialInstance(0);
              e &&
                ((x7.CC_USE_WORLD_SPACE = this.worldSpace),
                e.recompileShaders(x7),
                t.updateMaterial(e)),
                t.setCapacity(100);
            }
            onEnable() {
              super.onEnable(),
                0 !== this._models.length &&
                  this._models[0] &&
                  (this._attachToScene(),
                  (this.texture = this._texture),
                  (this.tile = this._tile),
                  (this.offset = this._offset),
                  this._models[0].addLineVertexData(
                    this._positions,
                    this.width,
                    this.color
                  ));
            }
            onDisable() {
              this._models.length > 0 &&
                this._models[0] &&
                this._detachFromScene();
            }
            _attachToScene() {
              if (
                (super._attachToScene(),
                this._models.length > 0 &&
                  this._models[0] &&
                  this.node &&
                  this.node.scene)
              ) {
                const t = this._models[0];
                t.scene && this._detachFromScene(),
                  this._getRenderScene().addModel(t);
              }
            }
            _detachFromScene() {
              if (
                (super._detachFromScene(),
                this._models.length > 0 && this._models[0])
              ) {
                const t = this._models[0];
                t.scene && t.scene.removeModel(t);
              }
            }
            _onMaterialModified(t, e) {
              super._onMaterialModified(t, e);
              const i = this.getMaterialInstance(0);
              i &&
                ((x7.CC_USE_WORLD_SPACE = this.worldSpace),
                i.recompileShaders(x7),
                this._models[0]) &&
                this._models[0].updateMaterial(i);
            }
          }),
          (b7 = fa(v7.prototype, "_texture", [_7], function () {
            return null;
          })),
          s(
            v7.prototype,
            "texture",
            [d7],
            Object.getOwnPropertyDescriptor(v7.prototype, "texture"),
            v7.prototype
          ),
          (A7 = fa(v7.prototype, "_material", [Na], function () {
            return null;
          })),
          s(
            v7.prototype,
            "lineMaterial",
            [p7],
            Object.getOwnPropertyDescriptor(v7.prototype, "lineMaterial"),
            v7.prototype
          ),
          s(
            v7.prototype,
            "sharedMaterials",
            [oo, Na],
            Object.getOwnPropertyDescriptor(v7.prototype, "sharedMaterials"),
            v7.prototype
          ),
          (C7 = fa(v7.prototype, "_worldSpace", [Na], function () {
            return !1;
          })),
          (O7 = fa(v7.prototype, "_positions", [m7], function () {
            return [];
          })),
          s(
            v7.prototype,
            "positions",
            [f7],
            Object.getOwnPropertyDescriptor(v7.prototype, "positions"),
            v7.prototype
          ),
          s(
            v7.prototype,
            "width",
            [g7],
            Object.getOwnPropertyDescriptor(v7.prototype, "width"),
            v7.prototype
          ),
          (I7 = fa(v7.prototype, "_width", [Na], function () {
            return new k8();
          })),
          s(
            v7.prototype,
            "color",
            [y7],
            Object.getOwnPropertyDescriptor(v7.prototype, "color"),
            v7.prototype
          ),
          (w7 = fa(v7.prototype, "_color", [Na], function () {
            return new l7();
          })),
          (R7 = fa(v7.prototype, "_tile", [Na], function () {
            return new Ss(1, 1);
          })),
          s(
            v7.prototype,
            "tile",
            [T7],
            Object.getOwnPropertyDescriptor(v7.prototype, "tile"),
            v7.prototype
          ),
          (D7 = fa(v7.prototype, "_offset", [Na], function () {
            return new Ss(0, 0);
          })),
          s(
            v7.prototype,
            "offset",
            [S7],
            Object.getOwnPropertyDescriptor(v7.prototype, "offset"),
            v7.prototype
          ),
          (E7 = v7))
        ) || E7);
      t({ Line: M7, LineComponent: M7 });
      class P7 {
        constructor(t) {
          (this.particleSystem = void 0),
            (this.position = void 0),
            (this.velocity = void 0),
            (this.animatedVelocity = void 0),
            (this.ultimateVelocity = void 0),
            (this.angularVelocity = void 0),
            (this.axisOfRotation = void 0),
            (this.rotation = void 0),
            (this.startEuler = void 0),
            (this.startRotation = void 0),
            (this.startRotated = void 0),
            (this.deltaQuat = void 0),
            (this.deltaMat = void 0),
            (this.localMat = void 0),
            (this.startSize = void 0),
            (this.size = void 0),
            (this.startColor = void 0),
            (this.color = void 0),
            (this.randomSeed = void 0),
            (this.remainingLifetime = void 0),
            (this.loopCount = void 0),
            (this.lastLoop = void 0),
            (this.trailDelay = void 0),
            (this.startLifetime = void 0),
            (this.emitAccumulator0 = void 0),
            (this.emitAccumulator1 = void 0),
            (this.frameIndex = void 0),
            (this.startRow = void 0),
            (this.particleSystem = t),
            (this.position = new Yi(0, 0, 0)),
            (this.velocity = new Yi(0, 0, 0)),
            (this.animatedVelocity = new Yi(0, 0, 0)),
            (this.ultimateVelocity = new Yi(0, 0, 0)),
            (this.angularVelocity = new Yi(0, 0, 0)),
            (this.axisOfRotation = new Yi(0, 0, 0)),
            (this.rotation = new Yi(0, 0, 0)),
            (this.startEuler = new Yi(0, 0, 0)),
            (this.startRotation = new as()),
            (this.startRotated = !1),
            (this.deltaQuat = new as()),
            (this.deltaMat = new ms()),
            (this.localMat = new ms()),
            (this.startSize = new Yi(0, 0, 0)),
            (this.size = new Yi(0, 0, 0)),
            (this.startColor = Qi.WHITE.clone()),
            (this.color = Qi.WHITE.clone()),
            (this.randomSeed = 0),
            (this.remainingLifetime = 0),
            (this.loopCount = 0),
            (this.lastLoop = 0),
            (this.trailDelay = 0),
            (this.startLifetime = 0),
            (this.emitAccumulator0 = 0),
            (this.emitAccumulator1 = 0),
            (this.frameIndex = 0),
            (this.startRow = 0);
        }
        reset() {
          this.rotation.set(0, 0, 0),
            this.startEuler.set(0, 0, 0),
            this.startRotation.set(0, 0, 0, 1),
            (this.startRotated = !1),
            this.deltaQuat.set(0, 0, 0, 1),
            this.deltaMat.identity(),
            this.localMat.identity();
        }
      }
      (P7.INDENTIFY_NEG_QUAT = 10), (P7.R2D = 180 / Math.PI);
      const N7 = "noiseModule",
        L7 = [
          "sizeModule",
          "colorModule",
          "forceModule",
          "velocityModule",
          "limitModule",
          "rotationModule",
          "textureModule",
          "noiseModule",
        ],
        B7 = [
          "_colorOverLifetimeModule",
          "_shapeModule",
          "_sizeOvertimeModule",
          "_velocityOvertimeModule",
          "_forceOvertimeModule",
          "_limitVelocityOvertimeModule",
          "_rotationOvertimeModule",
          "_textureAnimationModule",
          "_noiseModule",
          "_trailModule",
        ];
      class F7 {
        constructor() {
          (this.target = null),
            (this.needUpdate = !1),
            (this.needAnimate = !0),
            (this.name = void 0);
        }
        bindTarget(t) {
          this.target = t;
        }
        update(t, e) {}
      }
      const U7 = ce({ World: 0, Local: 1, Custom: 2 }),
        k7 = ce({ Pause: 0, PauseAndCatchup: 1, AlwaysSimulate: 2 }),
        z7 = ce({ World: 0, Local: 1, View: 2 }),
        H7 = ce({
          Billboard: 0,
          StrecthedBillboard: 1,
          HorizontalBillboard: 2,
          VerticalBillboard: 3,
          Mesh: 4,
        }),
        G7 = ce({ Box: 0, Circle: 1, Cone: 2, Sphere: 3, Hemisphere: 4 }),
        V7 = ce({ Base: 0, Edge: 1, Shell: 2, Volume: 3 }),
        j7 = ce({ Random: 0, Loop: 1, PingPong: 2 }),
        W7 = ce({ Particles: 0 }),
        X7 = ce({ Stretch: 0 }),
        Y7 = new Yi(0, 0, -1);
      function K7(t, e, i, s) {
        return e !== t
          ? (t === U7.World || ms.invert(i, i), ms.getRotation(s, i), !0)
          : (as.set(s, 0, 0, 0, 1), !1);
      }
      function q7(t, e) {
        Ss.set(t, Math.cos(e), Math.sin(e));
      }
      function $7(t) {
        const e = Ii(-1, 1),
          i = Ii(0, 2 * Math.PI),
          s = Math.sqrt(1 - e * e),
          n = s * Math.cos(i),
          r = s * Math.sin(i);
        Yi.set(t, n, r, e);
      }
      function Z7(t, e, i) {
        $7(t), Yi.multiplyScalar(t, t, e + (i - e) * Ci());
      }
      function Q7(t, e, i, s) {
        q7(t, s), (t.z = 0), Yi.multiplyScalar(t, t, e + (i - e) * Ci());
      }
      function J7(t) {
        for (let e = 0; e < t.length; e++) {
          const i = e + wi(0, t.length - e),
            s = t[i];
          (t[i] = t[e]), (t[e] = s);
        }
      }
      function t9() {
        let t = Ii(-1, 1);
        return 0 === t && t++, c(t);
      }
      function e9(t) {
        const e = k8.Mode;
        switch (t.mode) {
          case e.TwoCurves:
          case e.TwoConstants:
            return !0;
          default:
            return !1;
        }
      }
      var i9, s9, n9, r9, a9, o9;
      let h9 =
        ((i9 = Ca("cc.ColorOvertimeModule")),
        (s9 = ao(l7)),
        i9(
          ((r9 = class extends F7 {
            constructor(...t) {
              super(...t),
                (this._enable = a9 && a9()),
                (this.color = o9 && o9()),
                (this.name = "colorModule");
            }
            get enable() {
              return this._enable;
            }
            set enable(t) {
              this._enable !== t &&
                ((this._enable = t),
                this.target && this.target.enableModule(this.name, t, this));
            }
            animate(t) {
              t.color.set(t.startColor);
              const e = (function (t) {
                const e = l7.Mode;
                switch (t.mode) {
                  case e.TwoGradients:
                  case e.TwoColors:
                    return !0;
                  default:
                    return !1;
                }
              })(this.color)
                ? Ri(t.randomSeed + 91041)
                : 0;
              t.color.multiply(
                this.color.evaluate(
                  1 - t.remainingLifetime / t.startLifetime,
                  e
                )
              );
            }
          }),
          (a9 = fa(r9.prototype, "_enable", [Na], function () {
            return !1;
          })),
          (o9 = fa(r9.prototype, "color", [s9, Na], function () {
            return new l7();
          })),
          (n9 = r9))
        ) || n9);
      var l9, c9, u9, _9, d9, p9, m9, f9, g9, y9, T9, S9;
      const E9 = 212165,
        v9 = new Yi();
      let b9 =
        ((l9 = Ca("cc.ForceOvertimeModule")),
        (c9 = ao(k8)),
        (u9 = ao(k8)),
        (_9 = ao(k8)),
        (d9 = ao(U7)),
        l9(
          ((m9 = class extends F7 {
            get enable() {
              return this._enable;
            }
            set enable(t) {
              this._enable !== t &&
                ((this._enable = t),
                this.target && this.target.enableModule(this.name, t, this));
            }
            constructor() {
              super(),
                (this._enable = f9 && f9()),
                (this.x = g9 && g9()),
                (this.y = y9 && y9()),
                (this.z = T9 && T9()),
                (this.space = S9 && S9()),
                (this.randomized = !1),
                (this.rotation = void 0),
                (this.needTransform = void 0),
                (this.name = "forceModule"),
                (this.rotation = new as()),
                (this.needTransform = !1),
                (this.needUpdate = !0);
            }
            update(t, e) {
              this.needTransform = K7(t, this.space, e, this.rotation);
            }
            animate(t, e) {
              const i = 1 - t.remainingLifetime / t.startLifetime,
                s = e9(this.x) ? Ri(t.randomSeed + E9) : 0,
                n = e9(this.y) ? Ri(t.randomSeed + E9) : 0,
                r = e9(this.z) ? Ri(t.randomSeed + E9) : 0,
                a = Yi.set(
                  v9,
                  this.x.evaluate(i, s),
                  this.y.evaluate(i, n),
                  this.z.evaluate(i, r)
                );
              this.needTransform && Yi.transformQuat(a, a, this.rotation),
                Yi.scaleAndAdd(t.velocity, t.velocity, a, e),
                Yi.copy(t.ultimateVelocity, t.velocity);
            }
          }),
          (f9 = fa(m9.prototype, "_enable", [Na], function () {
            return !1;
          })),
          (g9 = fa(m9.prototype, "x", [c9, Na], function () {
            return new k8();
          })),
          (y9 = fa(m9.prototype, "y", [u9, Na], function () {
            return new k8();
          })),
          (T9 = fa(m9.prototype, "z", [_9, Na], function () {
            return new k8();
          })),
          (S9 = fa(m9.prototype, "space", [d9, Na], function () {
            return U7.Local;
          })),
          (p9 = m9))
        ) || p9);
      var A9, C9, O9, I9, w9, R9, D9, x9, M9, P9, N9, L9, B9, F9, U9, k9;
      const z9 = 23541,
        H9 = new Yi(),
        G9 = new Yi();
      let V9 =
        ((A9 = Ca("cc.LimitVelocityOvertimeModule")),
        (C9 = ao(k8)),
        (O9 = ao(k8)),
        (I9 = ao(k8)),
        (w9 = ao(k8)),
        (R9 = ao(U7)),
        A9(
          ((x9 = class extends F7 {
            get enable() {
              return this._enable;
            }
            set enable(t) {
              this._enable !== t &&
                ((this._enable = t),
                this.target && this.target.enableModule(this.name, t, this));
            }
            constructor() {
              super(),
                (this._enable = M9 && M9()),
                (this.limitX = P9 && P9()),
                (this.limitY = N9 && N9()),
                (this.limitZ = L9 && L9()),
                (this.limit = B9 && B9()),
                (this.dampen = F9 && F9()),
                (this.separateAxes = U9 && U9()),
                (this.space = k9 && k9()),
                (this.drag = null),
                (this.multiplyDragByParticleSize = !1),
                (this.multiplyDragByParticleVelocity = !1),
                (this.name = "limitModule"),
                (this.rotation = void 0),
                (this.needTransform = void 0),
                (this.rotation = new as()),
                (this.needTransform = !1),
                (this.needUpdate = !0);
            }
            update(t, e) {
              this.needTransform = K7(t, this.space, e, this.rotation);
            }
            animate(t, e) {
              const i = 1 - t.remainingLifetime / t.startLifetime,
                s = H9;
              if (this.separateAxes) {
                const e = e9(this.limitX) ? Ri(t.randomSeed + z9) : 0,
                  n = e9(this.limitY) ? Ri(t.randomSeed + z9) : 0,
                  r = e9(this.limitZ) ? Ri(t.randomSeed + z9) : 0;
                Yi.set(
                  G9,
                  this.limitX.evaluate(i, e),
                  this.limitY.evaluate(i, n),
                  this.limitZ.evaluate(i, r)
                ),
                  this.needTransform && Yi.transformQuat(G9, G9, this.rotation),
                  Yi.set(
                    s,
                    j9(t.ultimateVelocity.x, G9.x, this.dampen),
                    j9(t.ultimateVelocity.y, G9.y, this.dampen),
                    j9(t.ultimateVelocity.z, G9.z, this.dampen)
                  );
              } else {
                Yi.normalize(s, t.ultimateVelocity);
                const e = e9(this.limit) ? Ri(t.randomSeed + z9) : 0;
                Yi.multiplyScalar(
                  s,
                  s,
                  j9(
                    t.ultimateVelocity.length(),
                    this.limit.evaluate(i, e),
                    this.dampen
                  )
                );
              }
              Yi.copy(t.ultimateVelocity, s),
                Yi.copy(t.velocity, t.ultimateVelocity);
            }
          }),
          (M9 = fa(x9.prototype, "_enable", [Na], function () {
            return !1;
          })),
          (P9 = fa(x9.prototype, "limitX", [C9, Na], function () {
            return new k8();
          })),
          (N9 = fa(x9.prototype, "limitY", [O9, Na], function () {
            return new k8();
          })),
          (L9 = fa(x9.prototype, "limitZ", [I9, Na], function () {
            return new k8();
          })),
          (B9 = fa(x9.prototype, "limit", [w9, Na], function () {
            return new k8();
          })),
          (F9 = fa(x9.prototype, "dampen", [Na], function () {
            return 3;
          })),
          (U9 = fa(x9.prototype, "separateAxes", [Na], function () {
            return !1;
          })),
          (k9 = fa(x9.prototype, "space", [R9, Na], function () {
            return U7.Local;
          })),
          (D9 = x9))
        ) || D9);
      function j9(t, e, i) {
        const s = Math.sign(t);
        let n = Math.abs(t);
        if (n > e) {
          const t = n - n * i;
          n = t > e ? t : e;
        }
        return n * s;
      }
      var W9, X9, Y9, K9, q9, $9, Z9, Q9, J9, ttt, ett;
      const itt = 125292;
      let stt =
        ((W9 = Ca("cc.RotationOvertimeModule")),
        (X9 = ao(k8)),
        (Y9 = ao(k8)),
        (K9 = ao(k8)),
        W9(
          (($9 = class extends F7 {
            constructor(...t) {
              super(...t),
                (this._enable = Z9 && Z9()),
                (this._separateAxes = Q9 && Q9()),
                (this.x = J9 && J9()),
                (this.y = ttt && ttt()),
                (this.z = ett && ett()),
                (this.name = "rotationModule"),
                (this._startMat = new ms()),
                (this._matRot = new ms()),
                (this._quatRot = new as()),
                (this._otherEuler = new Yi());
            }
            get enable() {
              return this._enable;
            }
            set enable(t) {
              this._enable !== t &&
                ((this._enable = t),
                this.target && this.target.enableModule(this.name, t, this));
            }
            get separateAxes() {
              return this._separateAxes;
            }
            set separateAxes(t) {
              this._separateAxes = t;
            }
            _processRotation(t, e) {
              const i = t.particleSystem.processor.getInfo().renderMode;
              i !== H7.Mesh &&
                i === H7.StrecthedBillboard &&
                this._quatRot.set(0, 0, 0, 1),
                as.normalize(this._quatRot, this._quatRot),
                this._quatRot.w < 0 &&
                  (this._quatRot.x += P7.INDENTIFY_NEG_QUAT);
            }
            animate(t, e) {
              const i = 1 - t.remainingLifetime / t.startLifetime,
                s = e9(this.z) ? Ri(t.randomSeed + itt) : 0,
                n = t.particleSystem.processor.getInfo().renderMode;
              if (
                this._separateAxes &&
                n !== H7.VerticalBillboard &&
                n !== H7.HorizontalBillboard
              ) {
                const n = e9(this.x) ? Ri(t.randomSeed + itt) : 0,
                  r = e9(this.y) ? Ri(t.randomSeed + itt) : 0;
                as.fromEuler(
                  t.deltaQuat,
                  this.x.evaluate(i, n) * e * P7.R2D,
                  this.y.evaluate(i, r) * e * P7.R2D,
                  this.z.evaluate(i, s) * e * P7.R2D
                );
              } else
                as.fromEuler(
                  t.deltaQuat,
                  0,
                  0,
                  this.z.evaluate(i, s) * e * P7.R2D
                );
              (t.deltaMat = ms.fromQuat(t.deltaMat, t.deltaQuat)),
                (t.localMat = t.localMat.multiply(t.deltaMat)),
                t.startRotated ||
                  (n !== H7.Mesh &&
                    (n === H7.StrecthedBillboard
                      ? t.startEuler.set(0, 0, 0)
                      : n !== H7.Billboard &&
                        t.startEuler.set(0, 0, t.startEuler.z)),
                  as.fromEuler(
                    t.startRotation,
                    t.startEuler.x * P7.R2D,
                    t.startEuler.y * P7.R2D,
                    t.startEuler.z * P7.R2D
                  ),
                  (t.startRotated = !0)),
                (this._startMat = ms.fromQuat(this._startMat, t.startRotation)),
                (this._matRot = this._startMat.multiply(t.localMat)),
                ms.getRotation(this._quatRot, this._matRot),
                this._processRotation(t, P7.R2D),
                t.rotation.set(
                  this._quatRot.x,
                  this._quatRot.y,
                  this._quatRot.z
                );
            }
          }),
          (Z9 = fa($9.prototype, "_enable", [Na], function () {
            return !1;
          })),
          (Q9 = fa($9.prototype, "_separateAxes", [Na], function () {
            return !1;
          })),
          (J9 = fa($9.prototype, "x", [X9, Na], function () {
            return new k8();
          })),
          (ttt = fa($9.prototype, "y", [Y9, Na], function () {
            return new k8();
          })),
          (ett = fa($9.prototype, "z", [K9, Na], function () {
            return new k8();
          })),
          (q9 = $9))
        ) || q9);
      var ntt, rtt, att, ott, htt, ltt, ctt, utt, _tt, dtt, ptt, mtt, ftt;
      const gtt = 39825;
      let ytt =
        ((ntt = Ca("cc.SizeOvertimeModule")),
        (rtt = ao(k8)),
        (att = ao(k8)),
        (ott = ao(k8)),
        (htt = ao(k8)),
        ntt(
          ((ctt = class extends F7 {
            constructor(...t) {
              super(...t),
                (this._enable = utt && utt()),
                (this.separateAxes = _tt && _tt()),
                (this.size = dtt && dtt()),
                (this.x = ptt && ptt()),
                (this.y = mtt && mtt()),
                (this.z = ftt && ftt()),
                (this.name = "sizeModule");
            }
            get enable() {
              return this._enable;
            }
            set enable(t) {
              this._enable !== t &&
                ((this._enable = t),
                this.target && this.target.enableModule(this.name, t, this));
            }
            animate(t, e) {
              if (this.separateAxes) {
                const e = 1 - t.remainingLifetime / t.startLifetime,
                  i = e9(this.x) ? Ri(t.randomSeed + gtt) : 0,
                  s = e9(this.y) ? Ri(t.randomSeed + gtt) : 0,
                  n = e9(this.z) ? Ri(t.randomSeed + gtt) : 0;
                (t.size.x = t.startSize.x * this.x.evaluate(e, i)),
                  (t.size.y = t.startSize.y * this.y.evaluate(e, s)),
                  (t.size.z = t.startSize.z * this.z.evaluate(e, n));
              } else {
                const e = e9(this.size) ? Ri(t.randomSeed + gtt) : 0;
                Yi.multiplyScalar(
                  t.size,
                  t.startSize,
                  this.size.evaluate(
                    1 - t.remainingLifetime / t.startLifetime,
                    e
                  )
                );
              }
            }
          }),
          (utt = fa(ctt.prototype, "_enable", [Na], function () {
            return !1;
          })),
          (_tt = fa(ctt.prototype, "separateAxes", [Na], function () {
            return !1;
          })),
          (dtt = fa(ctt.prototype, "size", [rtt, Na], function () {
            return new k8();
          })),
          (ptt = fa(ctt.prototype, "x", [att, Na], function () {
            return new k8();
          })),
          (mtt = fa(ctt.prototype, "y", [ott, Na], function () {
            return new k8();
          })),
          (ftt = fa(ctt.prototype, "z", [htt, Na], function () {
            return new k8();
          })),
          (ltt = ctt))
        ) || ltt);
      var Ttt,
        Stt,
        Ett,
        vtt,
        btt,
        Att,
        Ctt,
        Ott,
        Itt,
        wtt,
        Rtt,
        Dtt,
        xtt,
        Mtt,
        Ptt,
        Ntt,
        Ltt,
        Btt,
        Ftt,
        Utt,
        ktt,
        ztt,
        Htt;
      const Gtt = ce({ Grid: 0 }),
        Vtt = ce({ WholeSheet: 0, SingleRow: 1 });
      let jtt =
        ((Ttt = Ca("cc.TextureAnimationModule")),
        (Stt = La("numTilesX")),
        (Ett = La("numTilesY")),
        (vtt = ao(Gtt)),
        (btt = ao(Gtt)),
        (Att = ao(Vtt)),
        (Ctt = ao(k8)),
        (Ott = ao(k8)),
        Ttt(
          ((wtt = class extends F7 {
            constructor(...t) {
              super(...t),
                (this._enable = Rtt && Rtt()),
                (this._numTilesX = Dtt && Dtt()),
                (this._numTilesY = xtt && xtt()),
                (this._mode = Mtt && Mtt()),
                (this.animation = Ptt && Ptt()),
                (this.frameOverTime = Ntt && Ntt()),
                (this.startFrame = Ltt && Ltt()),
                (this.cycleCount = Btt && Btt()),
                (this._flipU = Ftt && Ftt()),
                (this._flipV = Utt && Utt()),
                (this._uvChannelMask = ktt && ktt()),
                (this.randomRow = ztt && ztt()),
                (this.rowIndex = Htt && Htt()),
                (this.name = "textureModule");
            }
            get enable() {
              return this._enable;
            }
            set enable(t) {
              this._enable !== t &&
                ((this._enable = t),
                this.target &&
                  (this.target.updateMaterialParams(),
                  this.target.enableModule(this.name, t, this)));
            }
            get mode() {
              return this._mode;
            }
            set mode(t) {
              t !== Gtt.Grid &&
                R("particle texture animation's sprites is not supported!");
            }
            get numTilesX() {
              return this._numTilesX;
            }
            set numTilesX(t) {
              this._numTilesX !== t &&
                ((this._numTilesX = t), this.target.updateMaterialParams());
            }
            get numTilesY() {
              return this._numTilesY;
            }
            set numTilesY(t) {
              this._numTilesY !== t &&
                ((this._numTilesY = t), this.target.updateMaterialParams());
            }
            get flipU() {
              return this._flipU;
            }
            set flipU(t) {
              R("particle texture animation's flipU is not supported!");
            }
            get flipV() {
              return this._flipV;
            }
            set flipV(t) {
              R("particle texture animation's flipV is not supported!");
            }
            get uvChannelMask() {
              return this._uvChannelMask;
            }
            set uvChannelMask(t) {
              R("particle texture animation's uvChannelMask is not supported!");
            }
            init(t) {
              t.startRow = Math.floor(Ci() * this.numTilesY);
            }
            animate(t, e) {
              const i = 1 - t.remainingLifetime / t.startLifetime,
                s = e9(this.startFrame) ? Ri(t.randomSeed + 90794) : 0,
                n = e9(this.frameOverTime) ? Ri(t.randomSeed + 90794) : 0,
                r =
                  this.startFrame.evaluate(i, s) /
                  (this.numTilesX * this.numTilesY);
              if (this.animation === Vtt.WholeSheet)
                t.frameIndex = Pi(
                  this.cycleCount * (this.frameOverTime.evaluate(i, n) + r),
                  1
                );
              else if (this.animation === Vtt.SingleRow) {
                const e = 1 / this.numTilesY;
                if (this.randomRow) {
                  const s = Pi(
                      this.cycleCount * (this.frameOverTime.evaluate(i, n) + r),
                      1
                    ),
                    a = t.startRow * e,
                    o = a + e;
                  t.frameIndex = vi(a, o, s);
                } else {
                  const s = this.rowIndex * e,
                    a = s + e;
                  t.frameIndex = vi(
                    s,
                    a,
                    Pi(
                      this.cycleCount * (this.frameOverTime.evaluate(i, n) + r),
                      1
                    )
                  );
                }
              }
            }
          }),
          (Rtt = fa(wtt.prototype, "_enable", [Na], function () {
            return !1;
          })),
          (Dtt = fa(wtt.prototype, "_numTilesX", [Stt], function () {
            return 0;
          })),
          (xtt = fa(wtt.prototype, "_numTilesY", [Ett], function () {
            return 0;
          })),
          (Mtt = fa(wtt.prototype, "_mode", [vtt], function () {
            return Gtt.Grid;
          })),
          s(
            wtt.prototype,
            "mode",
            [btt],
            Object.getOwnPropertyDescriptor(wtt.prototype, "mode"),
            wtt.prototype
          ),
          (Ptt = fa(wtt.prototype, "animation", [Att, Na], function () {
            return Vtt.WholeSheet;
          })),
          (Ntt = fa(wtt.prototype, "frameOverTime", [Ctt, Na], function () {
            return new k8();
          })),
          (Ltt = fa(wtt.prototype, "startFrame", [Ott, Na], function () {
            return new k8();
          })),
          (Btt = fa(wtt.prototype, "cycleCount", [Na], function () {
            return 0;
          })),
          (Ftt = fa(wtt.prototype, "_flipU", [Na], function () {
            return 0;
          })),
          (Utt = fa(wtt.prototype, "_flipV", [Na], function () {
            return 0;
          })),
          (ktt = fa(wtt.prototype, "_uvChannelMask", [Na], function () {
            return -1;
          })),
          (ztt = fa(wtt.prototype, "randomRow", [Na], function () {
            return !1;
          })),
          (Htt = fa(wtt.prototype, "rowIndex", [Na], function () {
            return 0;
          })),
          (Itt = wtt))
        ) || Itt);
      var Wtt, Xtt, Ytt, Ktt, qtt, $tt, Ztt, Qtt, Jtt, tet, eet, iet, set, net;
      const ret = 197866,
        aet = new Yi();
      let oet =
        ((Wtt = Ca("cc.VelocityOvertimeModule")),
        (Xtt = ao(k8)),
        (Ytt = ao(k8)),
        (Ktt = ao(k8)),
        (qtt = ao(k8)),
        ($tt = ao(U7)),
        Wtt(
          ((Qtt = class extends F7 {
            get enable() {
              return this._enable;
            }
            set enable(t) {
              this._enable !== t &&
                ((this._enable = t),
                this.target && this.target.enableModule(this.name, t, this));
            }
            constructor() {
              super(),
                (this._enable = Jtt && Jtt()),
                (this.x = tet && tet()),
                (this.y = eet && eet()),
                (this.z = iet && iet()),
                (this.speedModifier = set && set()),
                (this.space = net && net()),
                (this.rotation = void 0),
                (this.needTransform = void 0),
                (this.name = "velocityModule"),
                (this.rotation = new as()),
                (this.speedModifier.constant = 1),
                (this.needTransform = !1),
                (this.needUpdate = !0);
            }
            update(t, e) {
              this.needTransform = K7(t, this.space, e, this.rotation);
            }
            animate(t, e) {
              const i = 1 - t.remainingLifetime / t.startLifetime,
                s = e9(this.x) ? Ri(t.randomSeed ^ ret) : 0,
                n = e9(this.y) ? Ri(156497 ^ t.randomSeed) : 0,
                r = e9(this.z) ? Ri(984136 ^ t.randomSeed) : 0,
                a = e9(this.speedModifier) ? Ri(t.randomSeed + ret) : 0,
                o = Yi.set(
                  aet,
                  this.x.evaluate(i, s),
                  this.y.evaluate(i, n),
                  this.z.evaluate(i, r)
                );
              this.needTransform && Yi.transformQuat(o, o, this.rotation),
                Yi.add(t.animatedVelocity, t.animatedVelocity, o),
                Yi.add(t.ultimateVelocity, t.velocity, t.animatedVelocity),
                Yi.multiplyScalar(
                  t.ultimateVelocity,
                  t.ultimateVelocity,
                  this.speedModifier.evaluate(
                    1 - t.remainingLifetime / t.startLifetime,
                    a
                  )
                );
            }
          }),
          (Jtt = fa(Qtt.prototype, "_enable", [Na], function () {
            return !1;
          })),
          (tet = fa(Qtt.prototype, "x", [Xtt, Na], function () {
            return new k8();
          })),
          (eet = fa(Qtt.prototype, "y", [Ytt, Na], function () {
            return new k8();
          })),
          (iet = fa(Qtt.prototype, "z", [Ktt, Na], function () {
            return new k8();
          })),
          (set = fa(Qtt.prototype, "speedModifier", [qtt, Na], function () {
            return new k8();
          })),
          (net = fa(Qtt.prototype, "space", [$tt, Na], function () {
            return U7.Local;
          })),
          (Ztt = Qtt))
        ) || Ztt);
      var het, cet, uet, _et, det, pet, met, fet;
      let get = t(
        "Burst",
        ((het = Ca("cc.Burst")),
        (cet = ao(k8)),
        het(
          ((_et = class {
            get time() {
              return this._time;
            }
            set time(t) {
              (this._time = t), (this._curTime = t);
            }
            get repeatCount() {
              return this._repeatCount;
            }
            set repeatCount(t) {
              (this._repeatCount = t), (this._remainingCount = t);
            }
            constructor() {
              (this._time = det && det()),
                (this._repeatCount = pet && pet()),
                (this.repeatInterval = met && met()),
                (this.count = fet && fet()),
                (this._remainingCount = void 0),
                (this._curTime = void 0),
                (this._remainingCount = 0),
                (this._curTime = 0);
            }
            update(t, e) {
              if (
                (0 === this._remainingCount &&
                  ((this._remainingCount = this._repeatCount),
                  (this._curTime = this._time)),
                this._remainingCount > 0)
              ) {
                let i =
                  Pi(t.time - t.startDelay.evaluate(0, 1), t.duration) - e;
                i = i > 0 ? i : 0;
                const s = Pi(t.time - t.startDelay.evaluate(0, 1), t.duration);
                this._curTime >= i &&
                  this._curTime < s &&
                  (t.emit(
                    this.count.evaluate(this._curTime / t.duration, 1),
                    e - (s - this._curTime)
                  ),
                  (this._curTime += this.repeatInterval),
                  --this._remainingCount);
              }
            }
            reset() {
              (this._remainingCount = 0), (this._curTime = 0);
            }
            getMaxCount(t) {
              return (
                this.count.getMax() *
                Math.min(
                  Math.ceil(t.duration / this.repeatInterval),
                  this.repeatCount
                )
              );
            }
          }),
          (det = fa(_et.prototype, "_time", [Na], function () {
            return 0;
          })),
          (pet = fa(_et.prototype, "_repeatCount", [Na], function () {
            return 1;
          })),
          (met = fa(_et.prototype, "repeatInterval", [Na], function () {
            return 1;
          })),
          (fet = fa(_et.prototype, "count", [cet, Na], function () {
            return new k8();
          })),
          (uet = _et))
        ) || uet)
      );
      var yet,
        Tet,
        Eet,
        vet,
        bet,
        Aet,
        Cet,
        Oet,
        Iet,
        wet,
        Ret,
        Det,
        xet,
        Met,
        Pet,
        Net,
        Let,
        Bet,
        Fet,
        Uet,
        ket,
        zet,
        Het,
        Get,
        Vet,
        jet,
        Wet,
        Xet;
      const Yet = new Yi(0, 0, 0),
        Ket = [0, 0, 0],
        qet = new Yi(0.5, 0.5, 0.5);
      let $et =
        ((yet = Ca("cc.ShapeModule")),
        (Tet = ao(G7)),
        (Eet = La("shapeType")),
        (vet = ao(G7)),
        (bet = ao(V7)),
        (Aet = ao(j7)),
        (Cet = ao(k8)),
        yet(
          ((Iet = class {
            get position() {
              return this._position;
            }
            set position(t) {
              (this._position = t), this.constructMat();
            }
            get rotation() {
              return this._rotation;
            }
            set rotation(t) {
              (this._rotation = t), this.constructMat();
            }
            get scale() {
              return this._scale;
            }
            set scale(t) {
              (this._scale = t), this.constructMat();
            }
            get arc() {
              return Ai(this._arc);
            }
            set arc(t) {
              this._arc = bi(t);
            }
            get angle() {
              return Math.round(100 * Ai(this._angle)) / 100;
            }
            set angle(t) {
              this._angle = bi(t);
            }
            get enable() {
              return this._enable;
            }
            set enable(t) {
              this._enable = t;
            }
            get shapeType() {
              return this._shapeType;
            }
            set shapeType(t) {
              switch (((this._shapeType = t), this._shapeType)) {
                case G7.Box:
                  this.emitFrom === V7.Base && (this.emitFrom = V7.Volume);
                  break;
                case G7.Cone:
                  this.emitFrom === V7.Edge && (this.emitFrom = V7.Base);
                  break;
                case G7.Sphere:
                case G7.Hemisphere:
                  (this.emitFrom !== V7.Base && this.emitFrom !== V7.Edge) ||
                    (this.emitFrom = V7.Volume);
              }
            }
            constructor() {
              (this._enable = wet && wet()),
                (this._shapeType = Ret && Ret()),
                (this.emitFrom = Det && Det()),
                (this.alignToDirection = xet && xet()),
                (this.randomDirectionAmount = Met && Met()),
                (this.sphericalDirectionAmount = Pet && Pet()),
                (this.randomPositionAmount = Net && Net()),
                (this.radius = Let && Let()),
                (this.radiusThickness = Bet && Bet()),
                (this.arcMode = Fet && Fet()),
                (this.arcSpread = Uet && Uet()),
                (this.arcSpeed = ket && ket()),
                (this.length = zet && zet()),
                (this.boxThickness = Het && Het()),
                (this._position = Get && Get()),
                (this._rotation = Vet && Vet()),
                (this._scale = jet && jet()),
                (this._arc = Wet && Wet()),
                (this._angle = Xet && Xet()),
                (this.mat = new ms()),
                (this.quat = new as()),
                (this.particleSystem = null),
                (this.lastTime = 0),
                (this.totalAngle = 0);
            }
            onInit(t) {
              (this.particleSystem = t),
                this.constructMat(),
                (this.lastTime = this.particleSystem.time);
            }
            emit(t) {
              switch (this.shapeType) {
                case G7.Box:
                  !(function (t, e, i, s) {
                    switch (t) {
                      case V7.Volume:
                        (n = i),
                          (r = qet),
                          Yi.set(
                            n,
                            Ii(-r.x, r.x),
                            Ii(-r.y, r.y),
                            Ii(-r.z, r.z)
                          );
                        break;
                      case V7.Shell:
                        (Ket[0] = Ii(-0.5, 0.5)),
                          (Ket[1] = Ii(-0.5, 0.5)),
                          (Ket[2] = 0.5 * t9()),
                          J7(Ket),
                          Zet(Ket, e),
                          Yi.set(i, Ket[0], Ket[1], Ket[2]);
                        break;
                      case V7.Edge:
                        (Ket[0] = Ii(-0.5, 0.5)),
                          (Ket[1] = 0.5 * t9()),
                          (Ket[2] = 0.5 * t9()),
                          J7(Ket),
                          Zet(Ket, e),
                          Yi.set(i, Ket[0], Ket[1], Ket[2]);
                        break;
                      default:
                        w(`${t} is not supported for box emitter.`);
                    }
                    var n, r;
                    Yi.copy(s, Y7);
                  })(this.emitFrom, this.boxThickness, t.position, t.velocity);
                  break;
                case G7.Circle:
                  !(function (t, e, i, s, n) {
                    Q7(s, t * (1 - e), t, i), Yi.normalize(n, s);
                  })(
                    this.radius,
                    this.radiusThickness,
                    this.generateArcAngle(),
                    t.position,
                    t.velocity
                  );
                  break;
                case G7.Cone:
                  !(function (t, e, i, s, n, r, a, o) {
                    switch (t) {
                      case V7.Base:
                        Q7(a, e * (1 - i), e, s),
                          Ss.multiplyScalar(o, a, Math.sin(n)),
                          (o.z = -Math.cos(n) * e),
                          Yi.normalize(o, o),
                          (a.z = 0);
                        break;
                      case V7.Shell:
                        q7(a, s),
                          Ss.multiplyScalar(o, a, Math.sin(n)),
                          (o.z = -Math.cos(n)),
                          Yi.normalize(o, o),
                          Ss.multiplyScalar(a, a, e),
                          (a.z = 0);
                        break;
                      case V7.Volume:
                        Q7(a, e * (1 - i), e, s),
                          Ss.multiplyScalar(o, a, Math.sin(n)),
                          (o.z = -Math.cos(n) * e),
                          Yi.normalize(o, o),
                          (a.z = 0),
                          Yi.add(
                            a,
                            a,
                            Yi.multiplyScalar(Yet, o, (r * Ci()) / -o.z)
                          );
                        break;
                      default:
                        w(`${t} is not supported for cone emitter.`);
                    }
                  })(
                    this.emitFrom,
                    this.radius,
                    this.radiusThickness,
                    this.generateArcAngle(),
                    this._angle,
                    this.length,
                    t.position,
                    t.velocity
                  );
                  break;
                case G7.Sphere:
                  !(function (t, e, i, s, n) {
                    switch (t) {
                      case V7.Volume:
                        Z7(s, e * (1 - i), e), Yi.normalize(n, s);
                        break;
                      case V7.Shell:
                        $7(s), Yi.multiplyScalar(s, s, e), Yi.normalize(n, s);
                        break;
                      default:
                        w(`${t} is not supported for sphere emitter.`);
                    }
                  })(
                    this.emitFrom,
                    this.radius,
                    this.radiusThickness,
                    t.position,
                    t.velocity
                  );
                  break;
                case G7.Hemisphere:
                  !(function (t, e, i, s, n) {
                    switch (t) {
                      case V7.Volume:
                        Z7(s, e * (1 - i), e),
                          s.z > 0 && (s.z *= -1),
                          Yi.normalize(n, s);
                        break;
                      case V7.Shell:
                        $7(s),
                          Yi.multiplyScalar(s, s, e),
                          s.z > 0 && (s.z *= -1),
                          Yi.normalize(n, s);
                        break;
                      default:
                        w(`${t} is not supported for hemisphere emitter.`);
                    }
                  })(
                    this.emitFrom,
                    this.radius,
                    this.radiusThickness,
                    t.position,
                    t.velocity
                  );
                  break;
                default:
                  w(
                    `${this.shapeType} shapeType is not supported by ShapeModule.`
                  );
              }
              if (
                (this.randomPositionAmount > 0 &&
                  ((t.position.x += Ii(
                    -this.randomPositionAmount,
                    this.randomPositionAmount
                  )),
                  (t.position.y += Ii(
                    -this.randomPositionAmount,
                    this.randomPositionAmount
                  )),
                  (t.position.z += Ii(
                    -this.randomPositionAmount,
                    this.randomPositionAmount
                  ))),
                Yi.transformQuat(t.velocity, t.velocity, this.quat),
                Yi.transformMat4(t.position, t.position, this.mat),
                this.sphericalDirectionAmount > 0)
              ) {
                const e = Yi.normalize(Yet, t.position);
                Yi.lerp(
                  t.velocity,
                  t.velocity,
                  e,
                  this.sphericalDirectionAmount
                );
              }
              this.lastTime = this.particleSystem.time;
            }
            constructMat() {
              as.fromEuler(
                this.quat,
                this._rotation.x,
                this._rotation.y,
                this._rotation.z
              ),
                ms.fromRTS(this.mat, this.quat, this._position, this._scale);
            }
            generateArcAngle() {
              if (this.arcMode === j7.Random) return Ii(0, this._arc);
              let t =
                this.totalAngle +
                2 *
                  Math.PI *
                  this.arcSpeed.evaluate(this.particleSystem.time, 1) *
                  (this.particleSystem.time - this.lastTime);
              switch (
                ((this.totalAngle = t),
                0 !== this.arcSpread &&
                  (t =
                    Math.floor(t / (this._arc * this.arcSpread)) *
                    this._arc *
                    this.arcSpread),
                this.arcMode)
              ) {
                case j7.Loop:
                  return Pi(t, this._arc);
                case j7.PingPong:
                  return Ni(t, this._arc);
                default:
                  return Pi(t, this._arc);
              }
            }
          }),
          (wet = fa(Iet.prototype, "_enable", [Na], function () {
            return !1;
          })),
          (Ret = fa(Iet.prototype, "_shapeType", [Tet, Eet], function () {
            return G7.Cone;
          })),
          s(
            Iet.prototype,
            "shapeType",
            [vet],
            Object.getOwnPropertyDescriptor(Iet.prototype, "shapeType"),
            Iet.prototype
          ),
          (Det = fa(Iet.prototype, "emitFrom", [bet, Na], function () {
            return V7.Volume;
          })),
          (xet = fa(Iet.prototype, "alignToDirection", [Na], function () {
            return !1;
          })),
          (Met = fa(Iet.prototype, "randomDirectionAmount", [Na], function () {
            return 0;
          })),
          (Pet = fa(
            Iet.prototype,
            "sphericalDirectionAmount",
            [Na],
            function () {
              return 0;
            }
          )),
          (Net = fa(Iet.prototype, "randomPositionAmount", [Na], function () {
            return 0;
          })),
          (Let = fa(Iet.prototype, "radius", [Na], function () {
            return 1;
          })),
          (Bet = fa(Iet.prototype, "radiusThickness", [Na], function () {
            return 1;
          })),
          (Fet = fa(Iet.prototype, "arcMode", [Aet, Na], function () {
            return j7.Random;
          })),
          (Uet = fa(Iet.prototype, "arcSpread", [Na], function () {
            return 0;
          })),
          (ket = fa(Iet.prototype, "arcSpeed", [Cet, Na], function () {
            return new k8();
          })),
          (zet = fa(Iet.prototype, "length", [Na], function () {
            return 5;
          })),
          (Het = fa(Iet.prototype, "boxThickness", [Na], function () {
            return new Yi(0, 0, 0);
          })),
          (Get = fa(Iet.prototype, "_position", [Na], function () {
            return new Yi(0, 0, 0);
          })),
          (Vet = fa(Iet.prototype, "_rotation", [Na], function () {
            return new Yi(0, 0, 0);
          })),
          (jet = fa(Iet.prototype, "_scale", [Na], function () {
            return new Yi(1, 1, 1);
          })),
          (Wet = fa(Iet.prototype, "_arc", [Na], function () {
            return bi(360);
          })),
          (Xet = fa(Iet.prototype, "_angle", [Na], function () {
            return bi(25);
          })),
          (Oet = Iet))
        ) || Oet);
      function Zet(t, e) {
        e.x > 0 &&
          ((t[0] += 0.5 * Ii(-e.x, e.x)), (t[0] = Si(t[0], -0.5, 0.5))),
          e.y > 0 &&
            ((t[1] += 0.5 * Ii(-e.y, e.y)), (t[1] = Si(t[1], -0.5, 0.5))),
          e.z > 0 &&
            ((t[2] += 0.5 * Ii(-e.z, e.z)), (t[2] = Si(t[2], -0.5, 0.5)));
      }
      const Qet = [0, 0, 1, 0, 0, 1, 1, 1],
        Jet = [0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0];
      class tit extends tg {
        constructor() {
          super(),
            (this._capacity = void 0),
            (this._bufferSize = void 0),
            (this._vertAttrs = void 0),
            (this._vertAttribSize = void 0),
            (this._vBuffer = void 0),
            (this._vertAttrsFloatCount = void 0),
            (this._vdataF32 = void 0),
            (this._vdataUint32 = void 0),
            (this._subMeshData = void 0),
            (this._mesh = void 0),
            (this._vertCount = 0),
            (this._indexCount = 0),
            (this._startTimeOffset = 0),
            (this._lifeTimeOffset = 0),
            (this._material = null),
            (this._vertAttribSizeStatic = void 0),
            (this._vertStaticAttrsFloatCount = void 0),
            (this._insBuffers = void 0),
            (this._insIndices = void 0),
            (this._useInstance = void 0),
            (this._iaVertCount = 0),
            (this._iaIndexCount = 0),
            this._registerListeners(),
            (this.type = Jf.PARTICLE_BATCH),
            (this._capacity = 0),
            (this._bufferSize = 16),
            (this._vertAttrs = null),
            (this._vertAttribSize = 0),
            (this._vBuffer = null),
            (this._vertAttrsFloatCount = 0),
            (this._vdataF32 = null),
            (this._vdataUint32 = null),
            (this._vertAttribSizeStatic = 0),
            (this._vertStaticAttrsFloatCount = 0),
            (this._insBuffers = []),
            (this._insIndices = null),
            I_.gfxDevice.hasFeature(mc.INSTANCED_ARRAYS)
              ? (this._useInstance = !0)
              : (this._useInstance = !1),
            (this._subMeshData = null),
            (this._mesh = null);
        }
        setCapacity(t) {
          const e = this._capacity !== t;
          (this._capacity = t),
            (this._bufferSize = Math.max(this._capacity, 16)),
            this._subMeshData && e && this.rebuild();
        }
        setVertexAttributes(t, e) {
          if (this._useInstance) this.setVertexAttributesIns(t, e);
          else {
            if (this._mesh === t && this._vertAttrs === e) return;
            (this._mesh = t), (this._vertAttrs = e), (this._vertAttribSize = 0);
            for (const t of this._vertAttrs)
              (t.offset = this._vertAttribSize),
                (this._vertAttribSize += a_[t.format].size);
            (this._vertAttrsFloatCount = this._vertAttribSize / 4),
              this.rebuild();
          }
        }
        setVertexAttributesIns(t, e) {
          if (this._mesh !== t || this._vertAttrs !== e) {
            (this._mesh = t),
              (this._vertAttrs = e),
              (this._vertAttribSize = 0),
              (this._vertAttribSizeStatic = 0);
            for (const t of this._vertAttrs)
              0 === t.stream
                ? ((t.offset = this._vertAttribSize),
                  (this._vertAttribSize += a_[t.format].size))
                : 1 === t.stream &&
                  ((t.offset = this._vertAttribSizeStatic),
                  (this._vertAttribSizeStatic += a_[t.format].size));
            (this._vertAttrsFloatCount = this._vertAttribSize / 4),
              (this._vertStaticAttrsFloatCount =
                this._vertAttribSizeStatic / 4),
              this.rebuild();
          }
        }
        createSubMeshData() {
          this.destroySubMeshData(),
            (this._vertCount = 4),
            (this._indexCount = 6),
            this._mesh &&
              ((this._vertCount =
                this._mesh.struct.vertexBundles[
                  this._mesh.struct.primitives[0].vertexBundelIndices[0]
                ].view.count),
              (this._indexCount =
                this._mesh.struct.primitives[0].indexView.count));
          const t = this._device.createBuffer(
              new yu(
                Tc.VERTEX | Tc.TRANSFER_DST,
                vc.HOST | vc.DEVICE,
                this._vertAttribSize * this._bufferSize * this._vertCount,
                this._vertAttribSize
              )
            ),
            e = new ArrayBuffer(
              this._vertAttribSize * this._bufferSize * this._vertCount
            );
          if (this._mesh && this._capacity > 0) {
            let t =
              this._vertAttrs[
                this._vertAttrs.findIndex((t) => t.name === eu.ATTR_TEX_COORD)
              ].offset;
            this._mesh.copyAttribute(
              0,
              eu.ATTR_TEX_COORD,
              e,
              this._vertAttribSize,
              t
            );
            let i = this._vertAttrs.findIndex(
              (t) => t.name === eu.ATTR_TEX_COORD3
            );
            if (
              ((t = this._vertAttrs[i++].offset),
              this._mesh.copyAttribute(
                0,
                eu.ATTR_POSITION,
                e,
                this._vertAttribSize,
                t
              ),
              (t = this._vertAttrs[i++].offset),
              this._mesh.copyAttribute(
                0,
                eu.ATTR_NORMAL,
                e,
                this._vertAttribSize,
                t
              ),
              (t = this._vertAttrs[i++].offset),
              !this._mesh.copyAttribute(
                0,
                eu.ATTR_COLOR,
                e,
                this._vertAttribSize,
                t
              ))
            ) {
              const i = new Uint32Array(e);
              for (let e = 0; e < this._vertCount; ++e)
                i[e * this._vertAttrsFloatCount + t / 4] = Qi.toUint32(
                  Qi.WHITE
                );
            }
            const s = new Float32Array(e);
            for (let t = 1; t < this._capacity; t++)
              s.copyWithin(
                (t * this._vertAttribSize * this._vertCount) / 4,
                0,
                (this._vertAttribSize * this._vertCount) / 4
              );
          }
          t.update(e);
          const i = new Uint16Array(this._bufferSize * this._indexCount);
          if (this._mesh && this._capacity > 0) {
            this._mesh.copyIndices(0, i);
            for (let t = 1; t < this._capacity; t++)
              for (let e = 0; e < this._indexCount; e++)
                i[t * this._indexCount + e] = i[e] + t * this._vertCount;
          } else {
            let t = 0;
            for (let e = 0; e < this._capacity; ++e) {
              const s = 4 * e;
              (i[t++] = s),
                (i[t++] = s + 1),
                (i[t++] = s + 2),
                (i[t++] = s + 3),
                (i[t++] = s + 2),
                (i[t++] = s + 1);
            }
          }
          const s = this._device.createBuffer(
            new yu(
              Tc.INDEX | Tc.TRANSFER_DST,
              vc.DEVICE,
              this._bufferSize *
                this._indexCount *
                Uint16Array.BYTES_PER_ELEMENT,
              Uint16Array.BYTES_PER_ELEMENT
            )
          );
          return (
            s.update(i),
            (this._iaVertCount = this._capacity * this._vertCount),
            (this._iaIndexCount = this._capacity * this._indexCount),
            (this._subMeshData = new fC(
              [t],
              this._vertAttrs,
              Gc.TRIANGLE_LIST,
              s
            )),
            this.initSubModel(0, this._subMeshData, this._material),
            e
          );
        }
        createSubMeshDataInsDynamic() {
          (this._insBuffers.length = 0), this.destroySubMeshData();
          const t = this._device.createBuffer(
              new yu(
                Tc.VERTEX | Tc.TRANSFER_DST,
                vc.HOST | vc.DEVICE,
                this._vertAttribSize * this._bufferSize,
                this._vertAttribSize
              )
            ),
            e = new ArrayBuffer(this._vertAttribSize * this._bufferSize);
          return t.update(e), this._insBuffers.push(t), e;
        }
        createSubMeshDataInsStatic() {
          (this._vertCount = 4),
            (this._indexCount = 6),
            this._mesh &&
              ((this._vertCount =
                this._mesh.struct.vertexBundles[
                  this._mesh.struct.primitives[0].vertexBundelIndices[0]
                ].view.count),
              (this._indexCount =
                this._mesh.struct.primitives[0].indexView.count));
          const t = this._device.createBuffer(
              new yu(
                Tc.VERTEX | Tc.TRANSFER_DST,
                vc.HOST | vc.DEVICE,
                this._vertAttribSizeStatic * this._vertCount,
                this._vertAttribSizeStatic
              )
            ),
            e = new ArrayBuffer(this._vertAttribSizeStatic * this._vertCount);
          if (this._mesh) {
            let t = this._vertAttrs.findIndex(
                (t) => t.name === eu.ATTR_TEX_COORD
              ),
              i = this._vertAttrs[t].offset;
            if (
              (this._mesh.copyAttribute(
                0,
                eu.ATTR_TEX_COORD,
                e,
                this._vertAttribSizeStatic,
                i
              ),
              (t = this._vertAttrs.findIndex(
                (t) => t.name === eu.ATTR_TEX_COORD3
              )),
              (i = this._vertAttrs[t++].offset),
              this._mesh.copyAttribute(
                0,
                eu.ATTR_POSITION,
                e,
                this._vertAttribSizeStatic,
                i
              ),
              (i = this._vertAttrs[t++].offset),
              this._mesh.copyAttribute(
                0,
                eu.ATTR_NORMAL,
                e,
                this._vertAttribSizeStatic,
                i
              ),
              (i = this._vertAttrs[t++].offset),
              !this._mesh.copyAttribute(
                0,
                eu.ATTR_COLOR,
                e,
                this._vertAttribSizeStatic,
                i
              ))
            ) {
              const t = new Uint32Array(e);
              for (let e = 0; e < this._vertCount; ++e)
                t[e * this._vertStaticAttrsFloatCount + i / 4] = Qi.toUint32(
                  Qi.WHITE
                );
            }
          } else {
            const t = new Float32Array(e);
            for (let e = 0; e < Jet.length; ++e) t[e] = Jet[e];
          }
          t.update(e);
          const i = new Uint16Array(this._indexCount);
          this._mesh
            ? this._mesh.copyIndices(0, i)
            : ((i[0] = 0),
              (i[1] = 1),
              (i[2] = 2),
              (i[3] = 3),
              (i[4] = 2),
              (i[5] = 1));
          const s = this._device.createBuffer(
            new yu(
              Tc.INDEX | Tc.TRANSFER_DST,
              vc.DEVICE,
              this._indexCount * Uint16Array.BYTES_PER_ELEMENT,
              Uint16Array.BYTES_PER_ELEMENT
            )
          );
          s.update(i),
            (this._insIndices = s),
            (this._iaVertCount = this._vertCount),
            (this._iaIndexCount = this._indexCount),
            this._insBuffers.push(t);
        }
        createInsSubmesh() {
          (this._subMeshData = new fC(
            this._insBuffers,
            this._vertAttrs,
            Gc.TRIANGLE_LIST,
            this._insIndices
          )),
            this.initSubModel(0, this._subMeshData, this._material);
        }
        updateMaterial(t) {
          (this._material = t), this.setSubModelMaterial(0, t);
        }
        addParticleVertexData(t, e) {
          if (this._useInstance) this.addParticleVertexDataIns(t, e);
          else if (this._mesh)
            for (let i = 0; i < this._vertCount; i++) {
              let s = (t * this._vertCount + i) * this._vertAttrsFloatCount;
              (this._vdataF32[s++] = e.position.x),
                (this._vdataF32[s++] = e.position.y),
                (this._vdataF32[s++] = e.position.z),
                (s += 2),
                (this._vdataF32[s++] = e.texcoord.z),
                (this._vdataF32[s++] = e.size.x),
                (this._vdataF32[s++] = e.size.y),
                (this._vdataF32[s++] = e.size.z),
                (this._vdataF32[s++] = e.rotation.x),
                (this._vdataF32[s++] = e.rotation.y),
                (this._vdataF32[s++] = e.rotation.z),
                (this._vdataUint32[s++] = e.color);
            }
          else {
            let i = t * this._vertAttrsFloatCount;
            (this._vdataF32[i++] = e.position.x),
              (this._vdataF32[i++] = e.position.y),
              (this._vdataF32[i++] = e.position.z),
              (this._vdataF32[i++] = e.texcoord.x),
              (this._vdataF32[i++] = e.texcoord.y),
              (this._vdataF32[i++] = e.texcoord.z),
              (this._vdataF32[i++] = e.size.x),
              (this._vdataF32[i++] = e.size.y),
              (this._vdataF32[i++] = e.size.z),
              (this._vdataF32[i++] = e.rotation.x),
              (this._vdataF32[i++] = e.rotation.y),
              (this._vdataF32[i++] = e.rotation.z),
              (this._vdataUint32[i++] = e.color),
              e.velocity &&
                ((this._vdataF32[i++] = e.velocity.x),
                (this._vdataF32[i++] = e.velocity.y),
                (this._vdataF32[i++] = e.velocity.z));
          }
        }
        addParticleVertexDataIns(t, e) {
          let i = t * this._vertAttrsFloatCount;
          this._mesh
            ? ((this._vdataF32[i++] = e.position.x),
              (this._vdataF32[i++] = e.position.y),
              (this._vdataF32[i++] = e.position.z),
              (this._vdataF32[i++] = e.texcoord.z),
              (this._vdataF32[i++] = e.size.x),
              (this._vdataF32[i++] = e.size.y),
              (this._vdataF32[i++] = e.size.z),
              (this._vdataF32[i++] = e.rotation.x),
              (this._vdataF32[i++] = e.rotation.y),
              (this._vdataF32[i++] = e.rotation.z),
              (this._vdataUint32[i++] = e.color))
            : ((this._vdataF32[i++] = e.position.x),
              (this._vdataF32[i++] = e.position.y),
              (this._vdataF32[i++] = e.position.z),
              (this._vdataF32[i++] = e.texcoord.z),
              (this._vdataF32[i++] = e.size.x),
              (this._vdataF32[i++] = e.size.y),
              (this._vdataF32[i++] = e.size.z),
              (this._vdataF32[i++] = e.rotation.x),
              (this._vdataF32[i++] = e.rotation.y),
              (this._vdataF32[i++] = e.rotation.z),
              (this._vdataUint32[i++] = e.color),
              e.velocity &&
                ((this._vdataF32[i++] = e.velocity.x),
                (this._vdataF32[i++] = e.velocity.y),
                (this._vdataF32[i++] = e.velocity.z)));
        }
        addGPUParticleVertexData(t, e, i) {
          if (this._useInstance) this.addGPUParticleVertexDataIns(t, e, i);
          else {
            let s = e * this._vertAttrsFloatCount * this._vertCount;
            for (let e = 0; e < this._vertCount; e++) {
              let n = s;
              (this._vdataF32[n++] = t.position.x),
                (this._vdataF32[n++] = t.position.y),
                (this._vdataF32[n++] = t.position.z),
                (this._vdataF32[n++] = i),
                (this._vdataF32[n++] = t.startSize.x),
                (this._vdataF32[n++] = t.startSize.y),
                (this._vdataF32[n++] = t.startSize.z),
                (this._vdataF32[n++] = Qet[2 * e]),
                (this._vdataF32[n++] = t.rotation.x),
                (this._vdataF32[n++] = t.rotation.y),
                (this._vdataF32[n++] = t.rotation.z),
                (this._vdataF32[n++] = Qet[2 * e + 1]),
                (this._vdataF32[n++] = t.startColor.r / 255),
                (this._vdataF32[n++] = t.startColor.g / 255),
                (this._vdataF32[n++] = t.startColor.b / 255),
                (this._vdataF32[n++] = t.startColor.a / 255),
                (this._vdataF32[n++] = t.velocity.x),
                (this._vdataF32[n++] = t.velocity.y),
                (this._vdataF32[n++] = t.velocity.z),
                (this._vdataF32[n++] = t.startLifetime),
                (this._vdataF32[n++] = t.randomSeed),
                (s += this._vertAttrsFloatCount);
            }
          }
        }
        addGPUParticleVertexDataIns(t, e, i) {
          let s = e * this._vertAttrsFloatCount,
            n = s;
          (this._vdataF32[n++] = t.position.x),
            (this._vdataF32[n++] = t.position.y),
            (this._vdataF32[n++] = t.position.z),
            (this._vdataF32[n++] = i),
            (this._vdataF32[n++] = t.startSize.x),
            (this._vdataF32[n++] = t.startSize.y),
            (this._vdataF32[n++] = t.startSize.z),
            (this._vdataF32[n++] = t.frameIndex),
            (this._vdataF32[n++] = t.rotation.x),
            (this._vdataF32[n++] = t.rotation.y),
            (this._vdataF32[n++] = t.rotation.z),
            (this._vdataF32[n++] = t.startColor.r / 255),
            (this._vdataF32[n++] = t.startColor.g / 255),
            (this._vdataF32[n++] = t.startColor.b / 255),
            (this._vdataF32[n++] = t.startColor.a / 255),
            (this._vdataF32[n++] = t.velocity.x),
            (this._vdataF32[n++] = t.velocity.y),
            (this._vdataF32[n++] = t.velocity.z),
            (this._vdataF32[n++] = t.startLifetime),
            (this._vdataF32[n++] = t.randomSeed),
            (s += this._vertAttrsFloatCount);
        }
        updateGPUParticles(t, e, i) {
          if (this._useInstance) return this.updateGPUParticlesIns(t, e, i);
          {
            const s = this._vertAttrsFloatCount * this._vertCount;
            let n = 0,
              r = 0,
              a = 0,
              o = 0,
              h = 0;
            for (let l = 0; l < t; ++l)
              (n = l * s),
                (r = this._vdataF32[n + this._startTimeOffset]),
                (a = this._vdataF32[n + this._lifeTimeOffset]),
                (h = e - r),
                a - h < i &&
                  ((o = --t * s), this._vdataF32.copyWithin(n, o, o + s), l--);
            return t;
          }
        }
        updateGPUParticlesIns(t, e, i) {
          const s = this._vertAttrsFloatCount;
          let n = 0,
            r = 0,
            a = 0,
            o = 0,
            h = 0;
          for (let l = 0; l < t; ++l)
            (n = l * s),
              (r = this._vdataF32[n + this._startTimeOffset]),
              (a = this._vdataF32[n + this._lifeTimeOffset]),
              (h = e - r),
              a - h < i &&
                ((o = --t * s), this._vdataF32.copyWithin(n, o, o + s), l--);
          return t;
        }
        constructAttributeIndex() {
          if (!this._vertAttrs) return;
          let t = this._vertAttrs.findIndex(
              (t) => "a_position_starttime" === t.name
            ),
            e = this._vertAttrs[t].offset;
          (this._startTimeOffset = e / 4 + 3),
            (t = this._vertAttrs.findIndex((t) => "a_dir_life" === t.name)),
            (e = this._vertAttrs[t].offset),
            (this._lifeTimeOffset = e / 4 + 3);
        }
        updateIA(t) {
          if (this._useInstance) this.updateIAIns(t);
          else {
            if (t <= 0) return;
            const e = this._subModels[0].inputAssembler;
            e.vertexBuffers[0].update(this._vdataF32),
              (e.firstIndex = 0),
              (e.indexCount = this._indexCount * t),
              (e.vertexCount = this._iaVertCount);
          }
        }
        updateIAIns(t) {
          if (t <= 0) return;
          const e = this._subModels[0].inputAssembler;
          e.vertexBuffers[0].update(this._vdataF32),
            (e.instanceCount = t),
            (e.firstIndex = 0),
            (e.indexCount = this._indexCount),
            (e.instanceCount = t),
            (e.vertexCount = this._iaVertCount);
        }
        clear() {
          this._useInstance
            ? this.clearIns()
            : (this._subModels[0].inputAssembler.indexCount = 0);
        }
        clearIns() {
          this._subModels[0].inputAssembler.instanceCount = 0;
        }
        destroy() {
          super.destroy(), this.doDestroy();
        }
        doDestroy() {
          (this._vBuffer = null),
            (this._vdataF32 = null),
            (this._vdataUint32 = null),
            (this._insBuffers = []),
            (this._insIndices = null),
            (this._vertAttrs = null),
            (this._material = null),
            (this._mesh = null),
            this.destroySubMeshData();
        }
        rebuild() {
          this._useInstance
            ? this.rebuildIns()
            : ((this._vBuffer = this.createSubMeshData()),
              (this._vdataF32 = new Float32Array(this._vBuffer)),
              (this._vdataUint32 = new Uint32Array(this._vBuffer)));
        }
        rebuildIns() {
          (this._vBuffer = this.createSubMeshDataInsDynamic()),
            (this._vdataF32 = new Float32Array(this._vBuffer)),
            (this._vdataUint32 = new Uint32Array(this._vBuffer)),
            this.createSubMeshDataInsStatic(),
            this.createInsSubmesh();
        }
        destroySubMeshData() {
          this._subMeshData &&
            (this._subMeshData.destroy(), (this._subMeshData = null));
        }
        set useInstance(t) {
          this._useInstance !== t && (this._useInstance = t);
        }
        get useInstance() {
          return this._useInstance;
        }
      }
      class eit {
        get model() {
          return this._model;
        }
        constructor(t) {
          (this._particleSystem = null),
            (this._model = null),
            (this._renderInfo = null),
            (this._vertAttrs = []),
            (this._useInstance = void 0),
            (this._renderInfo = t),
            I_.gfxDevice.hasFeature(mc.INSTANCED_ARRAYS)
              ? (this._useInstance = !0)
              : (this._useInstance = !1);
        }
        getUseInstance() {
          return this._useInstance;
        }
        getInfo() {
          return this._renderInfo;
        }
        onInit(t) {
          this._particleSystem = t;
        }
        onEnable() {
          if (!this._particleSystem) return;
          this.attachToScene();
          const t = this._model;
          t && (t.node = t.transform = this._particleSystem.node);
        }
        onDisable() {
          this.detachFromScene();
        }
        onDestroy() {
          this._model &&
            (a.director.root.destroyModel(this._model), (this._model = null));
        }
        attachToScene() {
          var t;
          this._model &&
            (this._model.scene && this.detachFromScene(),
            null === (t = this._particleSystem) ||
              void 0 === t ||
              t._getRenderScene().addModel(this._model));
        }
        detachFromScene() {
          this._model &&
            this._model.scene &&
            this._model.scene.removeModel(this._model);
        }
        setVertexAttributes() {
          this._model &&
            (this.updateVertexAttrib(),
            this._model.setVertexAttributes(
              this._renderInfo.renderMode === H7.Mesh
                ? this._renderInfo.mesh
                : null,
              this._vertAttrs
            ));
        }
        clear() {
          this._model && (this._model.enabled = !1);
        }
        getModel() {
          return this._model;
        }
        _initModel() {
          !this._model &&
            this._particleSystem &&
            ((this._model = a.director.root.createModel(tit)),
            this._model.setCapacity(this._particleSystem.capacity),
            (this._model.visFlags = this._particleSystem.visibility));
        }
        updateTrailMaterial() {}
        getDefaultTrailMaterial() {
          return null;
        }
      }
      class iit {
        constructor(t) {
          (this.permutation = [
            151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7,
            225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6,
            148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35,
            11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171,
            168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231,
            83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245,
            40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76,
            132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
            164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5,
            202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16,
            58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,
            154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253,
            19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246,
            97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241,
            81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199,
            106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
            138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78,
            66, 215, 61, 156, 180,
          ]),
            (this.accSpeed = new Yi()),
            (this.noiseSpeed = new Yi()),
            (this.noiseFrequency = 0),
            (this.noiseAbs = new Yi()),
            (this.noiseAmplitude = new Yi()),
            (this.octaves = new Yi()),
            (this.dt = 0),
            (this.point = new Yi()),
            (this.result = new Yi()),
            (this.mixOut = new Ss()),
            t && (this.permutation = t);
        }
        noise(t, e, i, s = 0, n = 1) {
          const r = new Array(512);
          for (let t = 0; t < 256; t++) r[256 + t] = r[t] = this.permutation[t];
          const a = 255 & Math.floor(t),
            o = 255 & Math.floor(e),
            h = 255 & Math.floor(i);
          (t -= Math.floor(t)), (e -= Math.floor(e)), (i -= Math.floor(i));
          const l = this.fade(t),
            c = this.fade(e),
            u = this.fade(i),
            _ = r[a] + o,
            d = r[_] + h,
            p = r[_ + 1] + h,
            m = r[a + 1] + o,
            f = r[m] + h,
            g = r[m + 1] + h;
          return (
            s +
            this.scale(
              this.lerp(
                u,
                this.lerp(
                  c,
                  this.lerp(
                    l,
                    this.grad(r[d], t, e, i),
                    this.grad(r[f], t - 1, e, i)
                  ),
                  this.lerp(
                    l,
                    this.grad(r[p], t, e - 1, i),
                    this.grad(r[g], t - 1, e - 1, i)
                  )
                ),
                this.lerp(
                  c,
                  this.lerp(
                    l,
                    this.grad(r[d + 1], t, e, i - 1),
                    this.grad(r[f + 1], t - 1, e, i - 1)
                  ),
                  this.lerp(
                    l,
                    this.grad(r[p + 1], t, e - 1, i - 1),
                    this.grad(r[g + 1], t - 1, e - 1, i - 1)
                  )
                )
              )
            ) *
              (n - s)
          );
        }
        fade(t) {
          return t * t * t * (t * (6 * t - 15) + 10);
        }
        lerp(t, e, i) {
          return e + t * (i - e);
        }
        grad(t, e, i, s) {
          const n = 15 & t,
            r = n < 8 ? e : i,
            a = n < 4 ? i : 12 === n || 14 === n ? e : s;
          return (0 == (1 & n) ? r : -r) + (0 == (2 & n) ? a : -a);
        }
        scale(t) {
          return (1 + t) / 2;
        }
        setSpeed(t, e, i) {
          this.noiseSpeed.set(t, e, i);
        }
        setFrequency(t) {
          this.noiseFrequency = t;
        }
        setAbs(t, e, i) {
          this.noiseAbs.set(t, e, i);
        }
        setAmplititude(t, e, i) {
          this.noiseAmplitude.set(t, e, i);
        }
        setOctaves(t, e, i) {
          this.octaves.set(t, e, i);
        }
        setTime(t) {
          this.dt = t;
        }
        setSamplePoint(t) {
          this.point.set(t);
        }
        getResult() {
          return this.result;
        }
        getNoise(t, e, i, s, n, r, a) {
          let o = r,
            h = 0;
          if (((h += this.noise(t * o, e * o, i * o, -1, 1)), 1 === a.x))
            return h;
          let l = 1,
            c = 1;
          for (let s = 1; s < a.x; ++s)
            (l *= a.y),
              (o *= a.z),
              (c += l),
              (h += this.noise(t * o, e * o, i * o, -1, 1) * l);
          return h / c;
        }
        getNoiseMix(t, e, i, s, n, r) {
          (t.x = this.getNoise(e.x, e.y, e.z, i, s, n, r)),
            (t.y = this.getNoise(e.y, e.z, e.x, i, s, n, r));
        }
        getNoiseParticle() {
          this.accSpeed.set(
            this.noiseSpeed.x * this.dt,
            this.noiseSpeed.y * this.dt,
            this.noiseSpeed.z * this.dt
          );
          const t = this.getNoise(
              this.point.z + this.accSpeed.x,
              this.point.y,
              this.point.x,
              this.dt,
              this.accSpeed,
              this.noiseFrequency,
              this.octaves
            ),
            e = this.getNoise(
              this.point.x + 1e3,
              this.point.z + this.accSpeed.y,
              this.point.y,
              this.dt,
              this.accSpeed,
              this.noiseFrequency,
              this.octaves
            ),
            i = this.getNoise(
              this.point.y,
              this.point.x + 1e3,
              this.point.z + this.accSpeed.z,
              this.dt,
              this.accSpeed,
              this.noiseFrequency,
              this.octaves
            );
          this.result.set(
            t * this.noiseAmplitude.x,
            e * this.noiseAmplitude.y,
            i * this.noiseAmplitude.z
          );
        }
        getPreview(t, e, i) {
          for (let s = 0; s < i; ++s)
            for (let n = 0; n < e; ++n) {
              const r = (n - 0.5 * e) / e + this.noiseSpeed.x * this.dt,
                a = (s - 0.5 * i) / i + this.noiseSpeed.y * this.dt,
                o = this.getNoise(
                  r,
                  a,
                  0,
                  this.dt,
                  this.accSpeed,
                  this.noiseFrequency,
                  this.octaves
                );
              t[s * e + n] = 0.5 * (o + 1);
            }
        }
      }
      const sit = new Wi(),
        nit = new Yi(),
        rit = new ms(),
        ait = new ms(),
        oit = new as();
      new Yi();
      const hit = [
          "_colorOverLifetimeModule",
          "_sizeOvertimeModule",
          "_velocityOvertimeModule",
          "_forceOvertimeModule",
          "_limitVelocityOvertimeModule",
          "_rotationOvertimeModule",
          "_textureAnimationModule",
          "_noiseModule",
        ],
        lit = [0, 0, 1, 0, 0, 1, 1, 1],
        cit = [
          new Lu(eu.ATTR_POSITION, fc.RGB32F),
          new Lu(eu.ATTR_TEX_COORD, fc.RGB32F),
          new Lu(eu.ATTR_TEX_COORD1, fc.RGB32F),
          new Lu(eu.ATTR_TEX_COORD2, fc.RGB32F),
          new Lu(eu.ATTR_COLOR, fc.RGBA8, !0),
        ],
        uit = [
          new Lu(eu.ATTR_POSITION, fc.RGB32F),
          new Lu(eu.ATTR_TEX_COORD, fc.RGB32F),
          new Lu(eu.ATTR_TEX_COORD1, fc.RGB32F),
          new Lu(eu.ATTR_TEX_COORD2, fc.RGB32F),
          new Lu(eu.ATTR_COLOR, fc.RGBA8, !0),
          new Lu(eu.ATTR_COLOR1, fc.RGB32F),
        ],
        _it = [
          new Lu(eu.ATTR_POSITION, fc.RGB32F),
          new Lu(eu.ATTR_TEX_COORD, fc.RGB32F),
          new Lu(eu.ATTR_TEX_COORD1, fc.RGB32F),
          new Lu(eu.ATTR_TEX_COORD2, fc.RGB32F),
          new Lu(eu.ATTR_COLOR, fc.RGBA8, !0),
          new Lu(eu.ATTR_TEX_COORD3, fc.RGB32F),
          new Lu(eu.ATTR_NORMAL, fc.RGB32F),
          new Lu(eu.ATTR_COLOR1, fc.RGBA8, !0),
        ],
        dit = [
          new Lu(eu.ATTR_TEX_COORD4, fc.RGBA32F, !1, 0, !0),
          new Lu(eu.ATTR_TEX_COORD1, fc.RGB32F, !1, 0, !0),
          new Lu(eu.ATTR_TEX_COORD2, fc.RGB32F, !1, 0, !0),
          new Lu(eu.ATTR_COLOR, fc.RGBA8, !0, 0, !0),
          new Lu(eu.ATTR_TEX_COORD, fc.RGB32F, !1, 1),
        ],
        pit = [
          new Lu(eu.ATTR_TEX_COORD4, fc.RGBA32F, !1, 0, !0),
          new Lu(eu.ATTR_TEX_COORD1, fc.RGB32F, !1, 0, !0),
          new Lu(eu.ATTR_TEX_COORD2, fc.RGB32F, !1, 0, !0),
          new Lu(eu.ATTR_COLOR, fc.RGBA8, !0, 0, !0),
          new Lu(eu.ATTR_COLOR1, fc.RGB32F, !1, 0, !0),
          new Lu(eu.ATTR_TEX_COORD, fc.RGB32F, !1, 1),
        ],
        mit = [
          new Lu(eu.ATTR_TEX_COORD4, fc.RGBA32F, !1, 0, !0),
          new Lu(eu.ATTR_TEX_COORD1, fc.RGB32F, !1, 0, !0),
          new Lu(eu.ATTR_TEX_COORD2, fc.RGB32F, !1, 0, !0),
          new Lu(eu.ATTR_COLOR, fc.RGBA8, !0, 0, !0),
          new Lu(eu.ATTR_TEX_COORD, fc.RGB32F, !1, 1),
          new Lu(eu.ATTR_TEX_COORD3, fc.RGB32F, !1, 1),
          new Lu(eu.ATTR_NORMAL, fc.RGB32F, !1, 1),
          new Lu(eu.ATTR_COLOR1, fc.RGBA8, !0, 1),
        ],
        fit = { parent: null, owner: null, subModelIdx: 0 };
      class git {
        constructor() {
          (this.position = void 0),
            (this.texcoord = void 0),
            (this.size = void 0),
            (this.rotation = void 0),
            (this.color = void 0),
            (this.velocity = void 0),
            (this.position = new Yi()),
            (this.texcoord = new Yi()),
            (this.size = new Yi()),
            (this.rotation = new Yi()),
            (this.color = 0),
            (this.velocity = null);
        }
      }
      class yit extends eit {
        constructor(t) {
          super(t),
            (this._defines = void 0),
            (this._trailDefines = void 0),
            (this._frameTile_velLenScale = void 0),
            (this._tmp_velLenScale = void 0),
            (this._defaultMat = null),
            (this._node_scale = void 0),
            (this._particleVertexData = void 0),
            (this._particles = null),
            (this._defaultTrailMat = null),
            (this._updateList = new Map()),
            (this._animateList = new Map()),
            (this._runAnimateList = new Array()),
            (this._fillDataFunc = null),
            (this._uScaleHandle = 0),
            (this._uLenHandle = 0),
            (this._uNodeRotHandle = 0),
            (this._alignSpace = z7.View),
            (this._inited = !1),
            (this._localMat = new ms()),
            (this._gravity = new Wi()),
            (this.noise = new iit()),
            (this._model = null),
            (this._frameTile_velLenScale = new Wi(1, 1, 0, 0)),
            (this._tmp_velLenScale = this._frameTile_velLenScale.clone()),
            (this._node_scale = new Yi()),
            (this._particleVertexData = new git()),
            (this._defines = {
              CC_USE_WORLD_SPACE: !0,
              CC_USE_BILLBOARD: !0,
              CC_USE_STRETCHED_BILLBOARD: !1,
              CC_USE_HORIZONTAL_BILLBOARD: !1,
              CC_USE_VERTICAL_BILLBOARD: !1,
            }),
            (this._trailDefines = { CC_USE_WORLD_SPACE: !0 });
        }
        onInit(t) {
          super.onInit(t),
            (this._particles = new Xn(() => new P7(this), 16)),
            this._setVertexAttrib(),
            this._setFillFunc(),
            this._initModuleList(),
            this._initModel(),
            this.updateMaterialParams(),
            this.updateTrailMaterial(),
            this.setVertexAttributes(),
            (this._inited = !0);
        }
        clear() {
          super.clear(),
            this._particles.reset(),
            this._particleSystem &&
              this._particleSystem._trailModule &&
              this._particleSystem._trailModule.clear(),
            this.updateRenderData(),
            (this._model.enabled = !1);
        }
        updateRenderMode() {
          this._setVertexAttrib(),
            this._setFillFunc(),
            this.updateMaterialParams(),
            this.setVertexAttributes();
        }
        onDestroy() {
          var t;
          null === (t = this._particles) || void 0 === t || t.destroy(),
            super.onDestroy();
        }
        getFreeParticle() {
          return this._particleSystem &&
            this._particles.length >= this._particleSystem.capacity
            ? null
            : this._particles.add();
        }
        getDefaultTrailMaterial() {
          return this._defaultTrailMat;
        }
        setNewParticle(t) {}
        _initModuleList() {
          hit.forEach((t) => {
            if (!this._particleSystem) return;
            const e = this._particleSystem[t];
            e &&
              e.enable &&
              (e.needUpdate && this._updateList.set(e.name, e),
              e.needAnimate && this._animateList.set(e.name, e));
          }),
            (this._runAnimateList.length = 0);
          for (let t = 0, e = L7.length; t < e; t++) {
            const e = this._animateList.get(L7[t]);
            e && this._runAnimateList.push(e);
          }
        }
        enableModule(t, e, i) {
          e
            ? (i.needUpdate && this._updateList.set(i.name, i),
              i.needAnimate && this._animateList.set(i.name, i))
            : (this._animateList.delete(t), this._updateList.delete(t)),
            (this._runAnimateList.length = 0);
          for (let t = 0, e = L7.length; t < e; t++) {
            const e = this._animateList.get(L7[t]);
            e && this._runAnimateList.push(e);
          }
          this.updateMaterialParams();
        }
        updateAlignSpace(t) {
          this._alignSpace = t;
        }
        getDefaultMaterial() {
          return this._defaultMat;
        }
        updateRotation(t) {
          t && this.doUpdateRotation(t);
        }
        doUpdateRotation(t) {
          if (
            this._renderInfo.renderMode === H7.Mesh ||
            this._alignSpace !== z7.View
          ) {
            var e;
            if (this._alignSpace === z7.Local)
              null === (e = this._particleSystem) ||
                void 0 === e ||
                e.node.getRotation(oit);
            else if (this._alignSpace === z7.World) {
              var i;
              null === (i = this._particleSystem) ||
                void 0 === i ||
                i.node.getWorldRotation(oit);
            } else if (this._alignSpace === z7.View) {
              var s, n;
              oit.set(0, 0, 0, 1);
              const t =
                null === (s = this._particleSystem) ||
                void 0 === s ||
                null === (n = s.node.scene.renderScene) ||
                void 0 === n
                  ? void 0
                  : n.cameras;
              if (void 0 !== t)
                for (let e = 0; e < (null == t ? void 0 : t.length); ++e) {
                  const i = t[e];
                  if (
                    (i.visibility & this._particleSystem.node.layer) ===
                    this._particleSystem.node.layer
                  ) {
                    as.fromViewUp(oit, i.forward);
                    break;
                  }
                }
            } else oit.set(0, 0, 0, 1);
            t.setUniform(this._uNodeRotHandle, oit);
          }
        }
        updateScale(t) {
          t && this.doUpdateScale(t);
        }
        doUpdateScale(t) {
          var e, i, s;
          const n = this._node_scale;
          switch (
            null === (e = this._particleSystem) || void 0 === e
              ? void 0
              : e.scaleSpace
          ) {
            case U7.Local:
              null === (i = this._particleSystem) ||
                void 0 === i ||
                i.node.getScale(n);
              break;
            case U7.World:
              null === (s = this._particleSystem) ||
                void 0 === s ||
                s.node.getWorldScale(n);
          }
          t.setUniform(this._uScaleHandle, sit.set(n.x, n.y, n.z));
        }
        updateParticles(t) {
          const e = this._particleSystem;
          if (!e) return this._particles.length;
          e.node.getWorldMatrix(rit);
          const i = (e.getMaterialInstance(0) || this._defaultMat).passes[0];
          this.doUpdateScale(i),
            this.doUpdateRotation(i),
            this._updateList.forEach(() => {});
          const s = e._trailModule,
            n = s && s.enable;
          n && s.update();
          const r = !e.gravityModifier.isZero();
          if (r) {
            if (e.simulationSpace === U7.Local) {
              const t = e.node.getRotation();
              ms.fromQuat(this._localMat, t), this._localMat.transpose();
            }
            if (e.node.parent) {
              const t = e.node.parent.getWorldRotation();
              ms.fromQuat(ait, t), ait.transpose();
            }
          }
          for (let i = 0; i < this._particles.length; ++i) {
            const a = this._particles.data[i];
            if (
              ((a.remainingLifetime -= t),
              Yi.set(a.animatedVelocity, 0, 0, 0),
              a.remainingLifetime < 0)
            )
              n && s.removeParticle(a), this._particles.removeAt(i), --i;
            else {
              if (r) {
                const i = e9(e.gravityModifier) ? Ri(a.randomSeed) : 0;
                if (e.simulationSpace === U7.Local) {
                  const s = 1 - a.remainingLifetime / a.startLifetime,
                    n = 9.8 * -e.gravityModifier.evaluate(s, i) * t;
                  (this._gravity.x = 0),
                    (this._gravity.y = n),
                    (this._gravity.z = 0),
                    (this._gravity.w = 1),
                    Ti(n, 0, gi) ||
                      (e.node.parent &&
                        (this._gravity = this._gravity.transformMat4(ait)),
                      (this._gravity = this._gravity.transformMat4(
                        this._localMat
                      )),
                      (a.velocity.x += this._gravity.x),
                      (a.velocity.y += this._gravity.y),
                      (a.velocity.z += this._gravity.z));
                } else
                  a.velocity.y -=
                    9.8 *
                    e.gravityModifier.evaluate(
                      1 - a.remainingLifetime / a.startLifetime,
                      i
                    ) *
                    t;
              }
              Yi.copy(a.ultimateVelocity, a.velocity),
                this._runAnimateList.forEach((e) => {
                  e.animate(a, t);
                }),
                Yi.scaleAndAdd(a.position, a.position, a.ultimateVelocity, t),
                n && s.animate(a, t);
            }
          }
          return (
            (this._model.enabled = this._particles.length > 0),
            this._particles.length
          );
        }
        getNoisePreview(t, e, i) {
          this._runAnimateList.forEach((s) => {
            s.name === N7 && s.getNoisePreview(t, this._particleSystem, e, i);
          });
        }
        updateRenderData() {
          let t = 0;
          for (let e = 0; e < this._particles.length; ++e) {
            const i = this._particles.data[e];
            let s = 0;
            const n = this._particleSystem._textureAnimationModule;
            n && n.enable && (s = i.frameIndex),
              (t = 4 * e),
              this._fillDataFunc(i, t, s);
          }
        }
        beforeRender() {
          this._model.updateIA(this._particles.length);
        }
        getParticleCount() {
          return this._particles.length;
        }
        onMaterialModified(t, e) {
          this._inited &&
            (0 === t
              ? this.updateMaterialParams()
              : this.updateTrailMaterial());
        }
        onRebuildPSO(t, e) {
          this._model && 0 === t && this._model.setSubModelMaterial(0, e);
          const i = this._particleSystem._trailModule,
            s = null == i ? void 0 : i.getModel();
          s && 1 === t && s.setSubModelMaterial(0, e);
        }
        _setFillFunc() {
          this._renderInfo.renderMode === H7.Mesh
            ? (this._fillDataFunc = this._fillMeshData)
            : this._renderInfo.renderMode === H7.StrecthedBillboard
            ? (this._fillDataFunc = this._fillStrecthedData)
            : (this._fillDataFunc = this._fillNormalData);
        }
        _fillMeshData(t, e, i) {
          const s = e / 4;
          Yi.copy(this._particleVertexData.position, t.position),
            (nit.z = i),
            Yi.copy(this._particleVertexData.texcoord, nit),
            Yi.copy(this._particleVertexData.size, t.size),
            Yi.copy(this._particleVertexData.rotation, t.rotation),
            (this._particleVertexData.color = Qi.toUint32(t.color)),
            this._model.addParticleVertexData(s, this._particleVertexData);
        }
        _fillStrecthedData(t, e, i) {
          if (this._useInstance) this._fillStrecthedDataIns(t, e, i);
          else
            for (let s = 0; s < 4; ++s)
              Yi.copy(this._particleVertexData.position, t.position),
                (nit.x = lit[2 * s]),
                (nit.y = lit[2 * s + 1]),
                (nit.z = i),
                Yi.copy(this._particleVertexData.texcoord, nit),
                Yi.copy(this._particleVertexData.size, t.size),
                Yi.copy(this._particleVertexData.rotation, t.rotation),
                (this._particleVertexData.color = Qi.toUint32(t.color)),
                (this._particleVertexData.velocity = t.ultimateVelocity),
                this._model.addParticleVertexData(
                  e++,
                  this._particleVertexData
                );
        }
        _fillStrecthedDataIns(t, e, i) {
          const s = e / 4;
          Yi.copy(this._particleVertexData.position, t.position),
            (nit.z = i),
            Yi.copy(this._particleVertexData.texcoord, nit),
            Yi.copy(this._particleVertexData.size, t.size),
            Yi.copy(this._particleVertexData.rotation, t.rotation),
            (this._particleVertexData.color = Qi.toUint32(t.color)),
            (this._particleVertexData.velocity = t.ultimateVelocity),
            this._model.addParticleVertexData(s, this._particleVertexData);
        }
        _fillNormalData(t, e, i) {
          if (this._useInstance) this._fillNormalDataIns(t, e, i);
          else
            for (let s = 0; s < 4; ++s)
              Yi.copy(this._particleVertexData.position, t.position),
                (nit.x = lit[2 * s]),
                (nit.y = lit[2 * s + 1]),
                (nit.z = i),
                Yi.copy(this._particleVertexData.texcoord, nit),
                Yi.copy(this._particleVertexData.size, t.size),
                Yi.copy(this._particleVertexData.rotation, t.rotation),
                (this._particleVertexData.color = Qi.toUint32(t.color)),
                this._model.addParticleVertexData(
                  e++,
                  this._particleVertexData
                );
        }
        _fillNormalDataIns(t, e, i) {
          const s = e / 4;
          Yi.copy(this._particleVertexData.position, t.position),
            (nit.z = i),
            Yi.copy(this._particleVertexData.texcoord, nit),
            Yi.copy(this._particleVertexData.size, t.size),
            Yi.copy(this._particleVertexData.rotation, t.rotation),
            (this._particleVertexData.color = Qi.toUint32(t.color)),
            this._model.addParticleVertexData(s, this._particleVertexData);
        }
        updateVertexAttrib() {
          if (
            this._renderInfo.renderMode === H7.Mesh &&
            this._renderInfo.mesh
          ) {
            const t = this._renderInfo.mesh.readAttributeFormat(
              0,
              eu.ATTR_COLOR
            );
            if (t) {
              let e = fc.RGBA8;
              for (let i = 0; i < a_.length; ++i)
                if (a_[i].name === t.name) {
                  e = i;
                  break;
                }
              this._vertAttrs[7] = new Lu(
                eu.ATTR_COLOR1,
                e,
                !0,
                this._useInstance ? 1 : 0
              );
            } else {
              const t = fc.RGBA8;
              this._vertAttrs[7] = new Lu(
                eu.ATTR_COLOR1,
                t,
                !0,
                this._useInstance ? 1 : 0
              );
            }
          }
        }
        _setVertexAttrib() {
          if (this._useInstance) this._setVertexAttribIns();
          else
            switch (this._renderInfo.renderMode) {
              case H7.StrecthedBillboard:
                this._vertAttrs = uit.slice();
                break;
              case H7.Mesh:
                this._vertAttrs = _it.slice();
                break;
              default:
                this._vertAttrs = cit.slice();
            }
        }
        _setVertexAttribIns() {
          switch (this._renderInfo.renderMode) {
            case H7.StrecthedBillboard:
              this._vertAttrs = pit.slice();
              break;
            case H7.Mesh:
              this._vertAttrs = mit.slice();
              break;
            default:
              this._vertAttrs = dit.slice();
          }
        }
        updateMaterialParams() {
          if (!this._particleSystem) return;
          const t = this._particleSystem,
            e = t.sharedMaterial;
          null != e &&
            (this._renderInfo.mainTexture = e.getProperty("mainTexture", 0)),
            null == t.sharedMaterial &&
              null == this._defaultMat &&
              ((fit.parent = Pv.get("default-particle-material")),
              (fit.owner = this._particleSystem),
              (fit.subModelIdx = 0),
              (this._defaultMat = new OI(fit)),
              (fit.parent = null),
              (fit.owner = null),
              (fit.subModelIdx = 0),
              null !== this._renderInfo.mainTexture &&
                this._defaultMat.setProperty(
                  "mainTexture",
                  this._renderInfo.mainTexture
                ));
          const i = t.getMaterialInstance(0) || this._defaultMat;
          t.simulationSpace === U7.World
            ? (this._defines.CC_USE_WORLD_SPACE = !0)
            : (this._defines.CC_USE_WORLD_SPACE = !1);
          const s = i.passes[0];
          (this._uScaleHandle = s.getHandle("scale")),
            (this._uLenHandle = s.getHandle("frameTile_velLenScale")),
            (this._uNodeRotHandle = s.getHandle("nodeRotation"));
          const n = this._renderInfo.renderMode,
            r = this._frameTile_velLenScale;
          n === H7.Billboard
            ? (this._defines.CC_RENDER_MODE = 0)
            : n === H7.StrecthedBillboard
            ? ((this._defines.CC_RENDER_MODE = 1),
              (r.z = this._renderInfo.velocityScale),
              (r.w = this._renderInfo.lengthScale))
            : n === H7.HorizontalBillboard
            ? (this._defines.CC_RENDER_MODE = 2)
            : n === H7.VerticalBillboard
            ? (this._defines.CC_RENDER_MODE = 3)
            : n === H7.Mesh
            ? (this._defines.CC_RENDER_MODE = 4)
            : w(`particle system renderMode ${n} not support.`);
          const a = t._textureAnimationModule;
          a && a.enable
            ? (Wi.copy(this._tmp_velLenScale, r),
              Ss.set(this._tmp_velLenScale, a.numTilesX, a.numTilesY),
              s.setUniform(this._uLenHandle, this._tmp_velLenScale))
            : s.setUniform(this._uLenHandle, r);
          let o = !1;
          const h = this._particleSystem._rotationOvertimeModule;
          (o = !!h && h.enable),
            (this._defines.ROTATION_OVER_TIME_MODULE_ENABLE = o),
            (this._defines.CC_INSTANCE_PARTICLE = this._useInstance),
            i.recompileShaders(this._defines),
            this._model && this._model.updateMaterial(i);
        }
        updateTrailMaterial() {
          if (!this._particleSystem) return;
          const t = this._particleSystem,
            e = t._trailModule;
          if (e && e.enable) {
            t.simulationSpace === U7.World || e.space === U7.World
              ? (this._trailDefines.CC_USE_WORLD_SPACE = !0)
              : (this._trailDefines.CC_USE_WORLD_SPACE = !1);
            let i = t.getMaterialInstance(1);
            null === i &&
              null === this._defaultTrailMat &&
              ((fit.parent = Pv.get("default-trail-material")),
              (fit.owner = this._particleSystem),
              (fit.subModelIdx = 1),
              (this._defaultTrailMat = new OI(fit)),
              (fit.parent = null),
              (fit.owner = null),
              (fit.subModelIdx = 0)),
              (i = i || this._defaultTrailMat),
              i.recompileShaders(this._trailDefines),
              e.updateMaterial();
          }
        }
        setUseInstance(t) {
          this._useInstance !== t &&
            ((this._useInstance = t),
            this._model &&
              ((this._model.useInstance = t), this._model.doDestroy()),
            this.updateRenderMode());
        }
      }
      const Tit = new Wi(),
        Sit = new ms(),
        Eit = new Wi(),
        vit = new as(),
        bit = new as();
      new Yi();
      const Ait = 32,
        Cit = "a_position_starttime",
        Oit = "a_size_uv",
        Iit = "a_rotation_uv",
        wit = "a_color",
        Rit = "a_dir_life",
        Dit = "a_rndSeed",
        xit = "a_size_fid",
        Mit = "a_rotation",
        Pit = [
          new Lu(Cit, fc.RGBA32F),
          new Lu(Oit, fc.RGBA32F),
          new Lu(Iit, fc.RGBA32F),
          new Lu(wit, fc.RGBA32F),
          new Lu(Rit, fc.RGBA32F),
          new Lu(Dit, fc.R32F),
        ],
        Nit = [
          new Lu(Cit, fc.RGBA32F),
          new Lu(Oit, fc.RGBA32F),
          new Lu(Iit, fc.RGBA32F),
          new Lu(wit, fc.RGBA32F),
          new Lu(Rit, fc.RGBA32F),
          new Lu(Dit, fc.R32F),
          new Lu(eu.ATTR_TEX_COORD, fc.RGB32F),
          new Lu(eu.ATTR_TEX_COORD3, fc.RGB32F),
          new Lu(eu.ATTR_NORMAL, fc.RGB32F),
          new Lu(eu.ATTR_COLOR1, fc.RGBA8, !0),
        ],
        Lit = [
          new Lu(Cit, fc.RGBA32F, !1, 0, !0),
          new Lu(xit, fc.RGBA32F, !1, 0, !0),
          new Lu(Mit, fc.RGB32F, !1, 0, !0),
          new Lu(wit, fc.RGBA32F, !1, 0, !0),
          new Lu(Rit, fc.RGBA32F, !1, 0, !0),
          new Lu(Dit, fc.R32F, !1, 0, !0),
          new Lu("a_uv", fc.RGB32F, !1, 1),
        ],
        Bit = [
          new Lu(Cit, fc.RGBA32F, !1, 0, !0),
          new Lu(xit, fc.RGBA32F, !1, 0, !0),
          new Lu(Mit, fc.RGB32F, !1, 0, !0),
          new Lu(wit, fc.RGBA32F, !1, 0, !0),
          new Lu(Rit, fc.RGBA32F, !1, 0, !0),
          new Lu(Dit, fc.R32F, !1, 0, !0),
          new Lu(eu.ATTR_TEX_COORD, fc.RGB32F, !1, 1),
          new Lu(eu.ATTR_TEX_COORD3, fc.RGB32F, !1, 1),
          new Lu(eu.ATTR_NORMAL, fc.RGB32F, !1, 1),
          new Lu(eu.ATTR_COLOR1, fc.RGBA8, !0, 1),
        ],
        Fit = { parent: null, owner: null, subModelIdx: 0 };
      class Uit extends eit {
        constructor(t) {
          super(t),
            (this._defines = void 0),
            (this._frameTile_velLenScale = void 0),
            (this._unifrom_velLenScale = void 0),
            (this._tmp_velLenScale = void 0),
            (this._node_scale = void 0),
            (this._vertAttrs = []),
            (this._defaultMat = null),
            (this._particleNum = 0),
            (this._tempParticle = null),
            (this._colorTexture = null),
            (this._forceTexture = null),
            (this._velocityTexture = null),
            (this._rotationTexture = null),
            (this._sizeTexture = null),
            (this._animTexture = null),
            (this._colorData = null),
            (this._forceData = null),
            (this._velocityData = null),
            (this._rotationData = null),
            (this._sizeData = null),
            (this._animData = null),
            (this._uTimeHandle = 0),
            (this._uRotHandle = 0),
            (this._uNodeRotHandle = 0),
            (this._alignSpace = z7.View),
            (this._inited = !1),
            (this._frameTile_velLenScale = new Wi(1, 1, 0, 0)),
            (this._unifrom_velLenScale = this._frameTile_velLenScale.clone()),
            (this._tmp_velLenScale = this._frameTile_velLenScale.clone()),
            (this._node_scale = new Yi()),
            (this._defines = {
              CC_USE_WORLD_SPACE: !0,
              CC_USE_BILLBOARD: !0,
              CC_USE_STRETCHED_BILLBOARD: !1,
              CC_USE_HORIZONTAL_BILLBOARD: !1,
              CC_USE_VERTICAL_BILLBOARD: !1,
              COLOR_OVER_TIME_MODULE_ENABLE: !1,
            }),
            (this._tempParticle = new P7(null)),
            (this._particleNum = 0);
        }
        onInit(t) {
          super.onInit(t),
            this._setVertexAttrib(),
            this._initModel(),
            this.updateMaterialParams(),
            this.setVertexAttributes(),
            (this._inited = !0);
        }
        updateRenderMode() {
          this._setVertexAttrib(),
            this.updateMaterialParams(),
            this.setVertexAttributes();
        }
        setVertexAttributes() {
          super.setVertexAttributes(), this._model.constructAttributeIndex();
        }
        clear() {
          super.clear(), (this._particleNum = 0), this.updateRenderData();
        }
        onDestroy() {
          super.onDestroy(),
            this._forceTexture && this._forceTexture.destroy(),
            this._velocityTexture && this._velocityTexture.destroy(),
            this._colorTexture && this._colorTexture.destroy(),
            this._sizeTexture && this._sizeTexture.destroy(),
            this._rotationTexture && this._rotationTexture.destroy(),
            this._animTexture && this._animTexture.destroy(),
            (this._forceData = null),
            (this._velocityData = null),
            (this._colorData = null),
            (this._sizeData = null),
            (this._rotationData = null),
            (this._animData = null);
        }
        enableModule(t, e, i) {
          var s;
          const n =
            (null === (s = this._particleSystem) || void 0 === s
              ? void 0
              : s.getMaterialInstance(0)) || this._defaultMat;
          n &&
            (this.initShaderUniform(n),
            n.recompileShaders(this._defines),
            this._model && this._model.setSubModelMaterial(0, n));
        }
        getFreeParticle() {
          var t;
          return this._particleSystem &&
            this._particleNum >=
              (null === (t = this._particleSystem) || void 0 === t
                ? void 0
                : t.capacity)
            ? null
            : this._tempParticle;
        }
        setNewParticle(t) {
          this._particleSystem &&
            (this._model.addGPUParticleVertexData(
              t,
              this._particleNum,
              this._particleSystem.time
            ),
            this._particleNum++);
        }
        getDefaultMaterial() {
          return this._defaultMat;
        }
        updateRotation(t) {
          t && this.doUpdateRotation(t);
        }
        doUpdateRotation(t) {
          if (
            this._renderInfo.renderMode === H7.Mesh ||
            this._alignSpace !== z7.View
          ) {
            var e;
            if (this._alignSpace === z7.Local)
              null === (e = this._particleSystem) ||
                void 0 === e ||
                e.node.getRotation(bit);
            else if (this._alignSpace === z7.World) {
              var i;
              null === (i = this._particleSystem) ||
                void 0 === i ||
                i.node.getWorldRotation(bit);
            } else if (this._alignSpace === z7.View) {
              var s, n;
              bit.set(0, 0, 0, 1);
              const t =
                null === (s = this._particleSystem) ||
                void 0 === s ||
                null === (n = s.node.scene.renderScene) ||
                void 0 === n
                  ? void 0
                  : n.cameras;
              if (void 0 !== t && this._particleSystem)
                for (let e = 0; e < (null == t ? void 0 : t.length); ++e) {
                  const i = t[e];
                  if (
                    (i.visibility & this._particleSystem.node.layer) ===
                    this._particleSystem.node.layer
                  ) {
                    as.fromViewUp(bit, i.forward);
                    break;
                  }
                }
            } else bit.set(0, 0, 0, 1);
            t.setUniform(this._uNodeRotHandle, bit);
          }
        }
        updateScale(t) {
          t && this.doUpdateScale(t);
        }
        doUpdateScale(t) {
          var e;
          const i = this._node_scale;
          switch (
            null === (e = this._particleSystem) || void 0 === e
              ? void 0
              : e.scaleSpace
          ) {
            case U7.Local:
              this._particleSystem.node.getScale(i);
              break;
            case U7.World:
              this._particleSystem.node.getWorldScale(i);
          }
          t.setUniform(t.getHandle("scale"), Tit.set(i.x, i.y, i.z));
        }
        updateParticles(t) {
          return this._particleSystem
            ? ((this._particleNum = this._model.updateGPUParticles(
                this._particleNum,
                this._particleSystem.time,
                t
              )),
              this.updateShaderUniform(t),
              (this._model.enabled = this._particleNum > 0),
              this._particleNum)
            : this._particleNum;
        }
        updateRenderData() {}
        beforeRender() {
          this._model.updateIA(this._particleNum);
        }
        updateAlignSpace(t) {
          this._alignSpace = t;
        }
        updateShaderUniform(t) {
          if (!this._particleSystem) return;
          const e =
            this._particleSystem.getMaterialInstance(0) || this._defaultMat;
          if (!e) return;
          const i = e.passes[0];
          (Eit.x = this._particleSystem.time),
            (Eit.y = t),
            i.setUniform(this._uTimeHandle, Eit),
            this._particleSystem.node.getWorldRotation(vit),
            i.setUniform(this._uRotHandle, vit),
            this.doUpdateRotation(i);
        }
        initShaderUniform(t) {
          var e, i, s, n, r, a;
          const o = t.passes[0];
          (this._uTimeHandle = o.getHandle("u_timeDelta")),
            (this._uRotHandle = o.getHandle("u_worldRot")),
            (this._uNodeRotHandle = o.getHandle("nodeRotation")),
            this.doUpdateScale(o),
            o.setUniform(
              o.getHandle("frameTile_velLenScale"),
              this._unifrom_velLenScale
            ),
            (Eit.x = Ait),
            (Eit.y = 0.03125),
            o.setUniform(o.getHandle("u_sampleInfo"), Eit);
          let h = !1;
          const l =
            null === (e = this._particleSystem) || void 0 === e
              ? void 0
              : e._forceOvertimeModule;
          if (
            ((h = !!l && l.enable),
            (this._defines.FORCE_OVER_TIME_MODULE_ENABLE = h),
            h)
          ) {
            const t = V8(
              this._forceTexture,
              this._forceData,
              Ait,
              l.x,
              l.y,
              l.z
            );
            (this._forceTexture = t.texture), (this._forceData = t.texdata);
            const e = o.getHandle("force_over_time_tex0"),
              i = hR.getBindingFromHandle(e);
            o.bindSampler(i, this._forceTexture.getGFXSampler()),
              o.bindTexture(i, this._forceTexture.getGFXTexture());
            const s = o.getHandle("u_force_space");
            o.setUniform(s, l.space);
            const n = o.getHandle("u_force_mode");
            o.setUniform(n, this._forceTexture.height);
          }
          const c =
            null === (i = this._particleSystem) || void 0 === i
              ? void 0
              : i._velocityOvertimeModule;
          if (
            ((h = !!c && c.enable),
            (this._defines.VELOCITY_OVER_TIME_MODULE_ENABLE = h),
            h)
          ) {
            const t = (function (t, e, i, s, n, r, a) {
              const o = Math.max(H8(s), H8(n), H8(r), H8(a)),
                h = i * o * 4;
              (null !== e && e.length === h) ||
                (e = new Float32Array(i * o * 4));
              const l = [s, n, r, a];
              for (let t = 0; t < o; t++)
                for (let s = 0; s < 4; s++) {
                  const n = l[s];
                  let r = 0,
                    a = 0;
                  for (let o = 0; o < i; o++) {
                    const h = z8(n, 0.03225806451612903 * o, t);
                    (r += h), (a = r / (o + 1)), (e[4 * (t * i + o) + s] = a);
                  }
                }
              return { texture: G8(t, e, i, o), texdata: e };
            })(
              this._velocityTexture,
              this._velocityData,
              Ait,
              c.x,
              c.y,
              c.z,
              c.speedModifier
            );
            (this._velocityTexture = t.texture),
              (this._velocityData = t.texdata);
            const e = o.getHandle("velocity_over_time_tex0"),
              i = hR.getBindingFromHandle(e);
            o.bindSampler(i, this._velocityTexture.getGFXSampler()),
              o.bindTexture(i, this._velocityTexture.getGFXTexture());
            const s = o.getHandle("u_velocity_space");
            o.setUniform(s, c.space);
            const n = o.getHandle("u_velocity_mode");
            o.setUniform(n, this._velocityTexture.height);
          }
          const u =
            null === (s = this._particleSystem) || void 0 === s
              ? void 0
              : s._colorOverLifetimeModule;
          if (
            ((h = !!u && u.enable),
            (this._defines.COLOR_OVER_TIME_MODULE_ENABLE = h),
            h)
          ) {
            const t = (function (t, e, i, s) {
              const n = (function (t) {
                  switch (t.mode) {
                    case a7.TwoColors:
                    case a7.TwoGradients:
                      return 2;
                    default:
                      return 1;
                  }
                })(s),
                r = i * n * 4;
              (null !== e && e.length === r) || (e = new Uint8Array(i * n * 4));
              const a = 1 / (i - 1);
              let o = 0;
              for (let t = 0; t < n; t++)
                for (let n = 0; n < i; n++) {
                  const i = c7(s, a * n, t);
                  (e[o] = i.r),
                    (e[o + 1] = i.g),
                    (e[o + 2] = i.b),
                    (e[o + 3] = i.a),
                    (o += 4);
                }
              return (
                (null !== t && i === t.width && n === t.height) ||
                  (t && t.destroy(),
                  (t = new sm()).create(i, n, Cd.RGBA8888),
                  t.setFilters(Id.LINEAR, Id.LINEAR),
                  t.setWrapMode(Od.CLAMP_TO_EDGE, Od.CLAMP_TO_EDGE)),
                t.uploadData(e),
                { texture: t, texdata: e }
              );
            })(this._colorTexture, this._colorData, Ait, u.color);
            (this._colorTexture = t.texture), (this._colorData = t.texdata);
            const e = o.getHandle("color_over_time_tex0"),
              i = hR.getBindingFromHandle(e);
            o.bindSampler(i, this._colorTexture.getGFXSampler()),
              o.bindTexture(i, this._colorTexture.getGFXTexture());
            const s = o.getHandle("u_color_mode");
            o.setUniform(s, this._colorTexture.height);
          }
          const _ =
            null === (n = this._particleSystem) || void 0 === n
              ? void 0
              : n._rotationOvertimeModule;
          if (
            ((h = !!_ && _.enable),
            (this._defines.ROTATION_OVER_TIME_MODULE_ENABLE = h),
            h)
          ) {
            let t;
            if (
              ((t = _.separateAxes
                ? V8(
                    this._rotationTexture,
                    this._rotationData,
                    Ait,
                    _.x,
                    _.y,
                    _.z
                  )
                : (function (t, e, i, s) {
                    const n = H8(s),
                      r = 128 * n;
                    (null !== e && e.length === r) ||
                      (e = new Float32Array(128 * n));
                    let a = 0;
                    for (let t = 0; t < n; t++)
                      for (let i = 0; i < 32; i++) {
                        const n = z8(s, 0.03225806451612903 * i, t);
                        (e[a + 2] = n), (a += 4);
                      }
                    return { texture: G8(t, e, 32, n), texdata: e };
                  })(this._rotationTexture, this._rotationData, 0, _.z)),
              (this._rotationTexture = t.texture),
              (this._rotationData = t.texdata),
              this._rotationTexture)
            ) {
              const t = o.getHandle("rotation_over_time_tex0"),
                e = hR.getBindingFromHandle(t);
              o.bindSampler(e, this._rotationTexture.getGFXSampler()),
                o.bindTexture(e, this._rotationTexture.getGFXTexture());
              const i = o.getHandle("u_rotation_mode");
              o.setUniform(i, this._rotationTexture.height);
            }
          }
          const d =
            null === (r = this._particleSystem) || void 0 === r
              ? void 0
              : r._sizeOvertimeModule;
          if (
            ((h = !!d && d.enable),
            (this._defines.SIZE_OVER_TIME_MODULE_ENABLE = h),
            h)
          ) {
            let t;
            if (
              ((t = d.separateAxes
                ? V8(this._sizeTexture, this._sizeData, Ait, d.x, d.y, d.z, !0)
                : (function (t, e, i, s) {
                    const n = H8(s),
                      r = 128 * n;
                    (null !== e && e.length === r) ||
                      (e = new Float32Array(128 * n));
                    let a = 0,
                      o = 0,
                      h = 0;
                    for (let t = 0; t < n; t++) {
                      a = 0;
                      for (let i = 0; i < 32; i++) {
                        const n = z8(s, 0.03225806451612903 * i, t);
                        (o = n),
                          (e[h] = o),
                          (e[h + 1] = o),
                          (e[h + 2] = o),
                          (h += 4);
                      }
                    }
                    return { texture: G8(t, e, 32, n), texdata: e };
                  })(this._sizeTexture, this._sizeData, 0, d.size)),
              (this._sizeTexture = t.texture),
              (this._sizeData = t.texdata),
              this._sizeTexture)
            ) {
              const t = o.getHandle("size_over_time_tex0"),
                e = hR.getBindingFromHandle(t);
              o.bindSampler(e, this._sizeTexture.getGFXSampler()),
                o.bindTexture(e, this._sizeTexture.getGFXTexture());
              const i = o.getHandle("u_size_mode");
              o.setUniform(i, this._sizeTexture.height);
            }
          }
          const p =
            null === (a = this._particleSystem) || void 0 === a
              ? void 0
              : a._textureAnimationModule;
          if (
            ((h = !!p && p.enable),
            (this._defines.TEXTURE_ANIMATION_MODULE_ENABLE = h),
            h)
          ) {
            const t = (function (t, e, i, s, n) {
              const r = Math.max(H8(s), H8(n)),
                a = i * r * 4;
              (null !== e && e.length === a) ||
                (e = new Float32Array(i * r * 4));
              const o = [s, n];
              for (let t = 0; t < r; t++)
                for (let s = 0; s < 2; s++) {
                  const n = o[s];
                  let r = 0;
                  for (let a = 0; a < i; a++) {
                    const o = z8(n, 0.03225806451612903 * a, t);
                    (r = o), (e[4 * (t * i + a) + s] = r);
                  }
                }
              return { texture: G8(t, e, i, r), texdata: e };
            })(
              this._animTexture,
              this._animData,
              Ait,
              p.startFrame,
              p.frameOverTime
            );
            (this._animTexture = t.texture), (this._animData = t.texdata);
            const e = o.getHandle("texture_animation_tex0"),
              i = hR.getBindingFromHandle(e);
            o.bindSampler(i, this._animTexture.getGFXSampler()),
              o.bindTexture(i, this._animTexture.getGFXTexture());
            const s = o.getHandle("u_anim_info");
            (Eit.x = this._animTexture.height),
              (Eit.y = p.numTilesX * p.numTilesY),
              (Eit.z = p.cycleCount),
              o.setUniform(s, Eit);
          }
          (this._defines.USE_VK_SHADER = I_.gfxDevice.gfxAPI === dc.VULKAN),
            (this._defines.CC_INSTANCE_PARTICLE = this._useInstance);
        }
        getParticleCount() {
          return this._particleNum;
        }
        onMaterialModified(t, e) {
          this._inited && this.updateMaterialParams();
        }
        onRebuildPSO(t, e) {
          this._model && 0 === t && this._model.setSubModelMaterial(0, e);
        }
        updateVertexAttrib() {
          if (
            this._renderInfo.renderMode === H7.Mesh &&
            this._renderInfo.mesh
          ) {
            const t = this._renderInfo.mesh.readAttributeFormat(
              0,
              eu.ATTR_COLOR
            );
            if (t) {
              let e = fc.RGBA8;
              for (let i = 0; i < a_.length; ++i)
                if (a_[i].name === t.name) {
                  e = i;
                  break;
                }
              this._vertAttrs[9] = new Lu(
                eu.ATTR_COLOR1,
                e,
                !0,
                this._useInstance ? 1 : 0
              );
            } else {
              const t = fc.RGBA8;
              this._vertAttrs[9] = new Lu(
                eu.ATTR_COLOR1,
                t,
                !0,
                this._useInstance ? 1 : 0
              );
            }
          }
        }
        _setVertexAttrib() {
          if (this._useInstance) this._setVertexAttribIns();
          else
            switch (this._renderInfo.renderMode) {
              case H7.StrecthedBillboard:
                this._vertAttrs = Pit.slice();
                break;
              case H7.Mesh:
                this._vertAttrs = Nit.slice();
                break;
              default:
                this._vertAttrs = Pit.slice();
            }
        }
        _setVertexAttribIns() {
          switch (this._renderInfo.renderMode) {
            case H7.StrecthedBillboard:
              this._vertAttrs = Lit.slice();
              break;
            case H7.Mesh:
              this._vertAttrs = Bit.slice();
              break;
            default:
              this._vertAttrs = Lit.slice();
          }
        }
        updateMaterialParams() {
          if (!this._particleSystem) return;
          const t = this._particleSystem,
            e = t.sharedMaterial;
          null !== e &&
            (this._renderInfo.mainTexture = e.getProperty("mainTexture", 0)),
            null == t.sharedMaterial &&
              null == this._defaultMat &&
              ((Fit.parent = Pv.get("default-particle-gpu-material")),
              (Fit.owner = t),
              (Fit.subModelIdx = 0),
              (this._defaultMat = new OI(Fit)),
              (Fit.parent = null),
              (Fit.owner = null),
              (Fit.subModelIdx = 0),
              null !== this._renderInfo.mainTexture &&
                this._defaultMat.setProperty(
                  "mainTexture",
                  this._renderInfo.mainTexture
                ));
          const i = t.getMaterialInstance(0) || this._defaultMat;
          t.node.getWorldMatrix(Sit),
            t.simulationSpace === U7.World
              ? (this._defines.CC_USE_WORLD_SPACE = !0)
              : (this._defines.CC_USE_WORLD_SPACE = !1);
          const s = this._renderInfo.renderMode;
          s === H7.Billboard
            ? (this._defines.CC_RENDER_MODE = 0)
            : s === H7.StrecthedBillboard
            ? ((this._defines.CC_RENDER_MODE = 1),
              (this._frameTile_velLenScale.z = this._renderInfo.velocityScale),
              (this._frameTile_velLenScale.w = this._renderInfo.lengthScale))
            : s === H7.HorizontalBillboard
            ? (this._defines.CC_RENDER_MODE = 2)
            : s === H7.VerticalBillboard
            ? (this._defines.CC_RENDER_MODE = 3)
            : s === H7.Mesh
            ? (this._defines.CC_RENDER_MODE = 4)
            : w(`particle system renderMode ${s} not support.`);
          const n = t._textureAnimationModule;
          n && n.enable
            ? (Ss.set(this._frameTile_velLenScale, n.numTilesX, n.numTilesY),
              Wi.copy(this._unifrom_velLenScale, this._frameTile_velLenScale))
            : ((this._tmp_velLenScale.z = this._frameTile_velLenScale.z),
              (this._tmp_velLenScale.w = this._frameTile_velLenScale.w),
              Wi.copy(this._unifrom_velLenScale, this._tmp_velLenScale)),
            this.initShaderUniform(i),
            i.recompileShaders(this._defines),
            this._model && this._model.updateMaterial(i);
        }
        setUseInstance(t) {
          this._useInstance !== t &&
            ((this._useInstance = t),
            this._model &&
              ((this._model.useInstance = t), this._model.doDestroy()),
            this.updateRenderMode());
        }
        getNoisePreview(t, e, i) {}
      }
      var kit,
        zit,
        Hit,
        Git,
        Vit,
        jit,
        Wit,
        Xit,
        Yit,
        Kit,
        qit,
        $it,
        Zit,
        Qit,
        Jit,
        tst,
        est,
        ist,
        sst,
        nst,
        rst;
      function ast() {
        const t = Lv.root.device;
        return (
          !!(
            t.capabilities.maxVertexTextureUnits >= 8 &&
            t.getFormatFeatures(fc.RGBA32F) &
              (Oc.RENDER_TARGET | Oc.SAMPLED_TEXTURE)
          ) ||
          (a.warn(
            "Maybe the device has restrictions on vertex textures or does not support float textures."
          ),
          !1)
        );
      }
      let ost =
        ((kit = Ca("cc.ParticleSystemRenderer")),
        (zit = ao(H7)),
        (Hit = ao(H7)),
        (Git = ao(sB)),
        (Vit = ao(ey)),
        (jit = ao(ey)),
        (Wit = ao(ey)),
        (Xit = ao(ey)),
        (Yit = ao(z7)),
        kit(
          (((rst = class {
            constructor() {
              (this._renderMode = $it && $it()),
                (this._velocityScale = Zit && Zit()),
                (this._lengthScale = Qit && Qit()),
                (this._mesh = Jit && Jit()),
                (this._cpuMaterial = tst && tst()),
                (this._gpuMaterial = est && est()),
                (this._mainTexture = ist && ist()),
                (this._useGPU = sst && sst()),
                (this._alignSpace = nst && nst()),
                (this._particleSystem = null);
            }
            get renderMode() {
              return this._renderMode;
            }
            set renderMode(t) {
              this._renderMode !== t &&
                ((this._renderMode = t),
                this._particleSystem &&
                  this._particleSystem.processor.updateRenderMode());
            }
            get velocityScale() {
              return this._velocityScale;
            }
            set velocityScale(t) {
              (this._velocityScale = t),
                this._particleSystem &&
                  this._particleSystem.processor.updateMaterialParams();
            }
            get lengthScale() {
              return this._lengthScale;
            }
            set lengthScale(t) {
              (this._lengthScale = t),
                this._particleSystem &&
                  this._particleSystem.processor.updateMaterialParams();
            }
            get mesh() {
              return this._mesh;
            }
            set mesh(t) {
              (this._mesh = t),
                this._particleSystem &&
                  this._particleSystem.processor.setVertexAttributes();
            }
            get particleMaterial() {
              return this._particleSystem
                ? this._particleSystem.getSharedMaterial(0)
                : null;
            }
            set particleMaterial(t) {
              this._particleSystem &&
                this._particleSystem.setSharedMaterial(t, 0);
            }
            get cpuMaterial() {
              return this._cpuMaterial;
            }
            set cpuMaterial(t) {
              if (null !== t) {
                {
                  const e = t.effectName;
                  if (
                    -1 === e.indexOf("particle") ||
                    -1 !== e.indexOf("particle-gpu")
                  )
                    return void z(6035);
                }
                (this._cpuMaterial = t),
                  (this.particleMaterial = this._cpuMaterial);
              }
            }
            get gpuMaterial() {
              return this._gpuMaterial;
            }
            set gpuMaterial(t) {
              if (null !== t) {
                if (-1 === t.effectName.indexOf("particle-gpu"))
                  return void z(6035);
                (this._gpuMaterial = t),
                  (this.particleMaterial = this._gpuMaterial);
              }
            }
            get trailMaterial() {
              return this._particleSystem
                ? this._particleSystem.getSharedMaterial(1)
                : null;
            }
            set trailMaterial(t) {
              this._particleSystem &&
                this._particleSystem.setSharedMaterial(t, 1);
            }
            get mainTexture() {
              return this._mainTexture;
            }
            set mainTexture(t) {
              this._mainTexture = t;
            }
            get useGPU() {
              return this._useGPU;
            }
            set useGPU(t) {
              this._useGPU !== t &&
                (ast() ? (this._useGPU = t) : (this._useGPU = !1),
                this._switchProcessor());
            }
            get alignSpace() {
              return this._alignSpace;
            }
            set alignSpace(t) {
              (this._alignSpace = t),
                this._particleSystem.processor.updateAlignSpace(
                  this._alignSpace
                );
            }
            create(t) {
              null === this._particleSystem
                ? (this._particleSystem = t)
                : this._particleSystem !== t && G(6033);
            }
            onInit(t) {
              this.create(t);
              const e = this._useGPU && ast();
              this._particleSystem.processor
                ? G(6034)
                : ((this._particleSystem.processor = e
                    ? new Uit(this)
                    : new yit(this)),
                  this._particleSystem.processor.updateAlignSpace(
                    this.alignSpace
                  ),
                  this._particleSystem.processor.onInit(t)),
                e
                  ? (this.gpuMaterial = this.particleMaterial)
                  : (this.particleMaterial &&
                      -1 !==
                        this.particleMaterial.effectName.indexOf(
                          "particle-gpu"
                        ) &&
                      ((this.particleMaterial = null), z(6035)),
                    (this.cpuMaterial = this.particleMaterial));
            }
            _switchProcessor() {
              if (!this._particleSystem) return;
              this._particleSystem.processor &&
                (this._particleSystem.processor.detachFromScene(),
                this._particleSystem.processor.clear(),
                (this._particleSystem.processor = null));
              const t = this._useGPU && ast();
              !t &&
                this.cpuMaterial &&
                (this.particleMaterial = this.cpuMaterial),
                t &&
                  this.gpuMaterial &&
                  (this.particleMaterial = this.gpuMaterial),
                (this._particleSystem.processor = t
                  ? new Uit(this)
                  : new yit(this)),
                this._particleSystem.processor.updateAlignSpace(
                  this.alignSpace
                ),
                this._particleSystem.processor.onInit(this._particleSystem),
                this._particleSystem.processor.onEnable(),
                this._particleSystem.bindModule();
            }
          }).AlignmentSpace = z7),
          s(
            (qit = rst).prototype,
            "renderMode",
            [zit],
            Object.getOwnPropertyDescriptor(qit.prototype, "renderMode"),
            qit.prototype
          ),
          ($it = fa(qit.prototype, "_renderMode", [Hit, Na], function () {
            return H7.Billboard;
          })),
          (Zit = fa(qit.prototype, "_velocityScale", [Na], function () {
            return 1;
          })),
          (Qit = fa(qit.prototype, "_lengthScale", [Na], function () {
            return 1;
          })),
          (Jit = fa(qit.prototype, "_mesh", [Na], function () {
            return null;
          })),
          s(
            qit.prototype,
            "mesh",
            [Git],
            Object.getOwnPropertyDescriptor(qit.prototype, "mesh"),
            qit.prototype
          ),
          s(
            qit.prototype,
            "particleMaterial",
            [Vit],
            Object.getOwnPropertyDescriptor(qit.prototype, "particleMaterial"),
            qit.prototype
          ),
          s(
            qit.prototype,
            "cpuMaterial",
            [jit],
            Object.getOwnPropertyDescriptor(qit.prototype, "cpuMaterial"),
            qit.prototype
          ),
          (tst = fa(qit.prototype, "_cpuMaterial", [Na], function () {
            return null;
          })),
          s(
            qit.prototype,
            "gpuMaterial",
            [Wit],
            Object.getOwnPropertyDescriptor(qit.prototype, "gpuMaterial"),
            qit.prototype
          ),
          (est = fa(qit.prototype, "_gpuMaterial", [Na], function () {
            return null;
          })),
          s(
            qit.prototype,
            "trailMaterial",
            [Xit],
            Object.getOwnPropertyDescriptor(qit.prototype, "trailMaterial"),
            qit.prototype
          ),
          (ist = fa(qit.prototype, "_mainTexture", [Na], function () {
            return null;
          })),
          (sst = fa(qit.prototype, "_useGPU", [Na], function () {
            return !1;
          })),
          s(
            qit.prototype,
            "alignSpace",
            [Yit],
            Object.getOwnPropertyDescriptor(qit.prototype, "alignSpace"),
            qit.prototype
          ),
          (nst = fa(qit.prototype, "_alignSpace", [Na], function () {
            return z7.View;
          })),
          (Kit = qit))
        ) || Kit);
      var hst,
        lst,
        cst,
        ust,
        _st,
        dst,
        pst,
        mst,
        fst,
        gst,
        yst,
        Tst,
        Sst,
        Est,
        vst,
        bst,
        Ast,
        Cst,
        Ost,
        Ist,
        wst,
        Rst,
        Dst,
        xst;
      const Mst = Math.cos(bi(100)),
        Pst = { position: new Yi(), velocity: new Yi() },
        Nst = new as(),
        Lst = new Yi(),
        Bst = new Yi(),
        Fst = new Qi();
      class Ust {
        constructor(t) {
          for (
            this.start = void 0,
              this.end = void 0,
              this.trailElements = void 0,
              this.start = -1,
              this.end = -1,
              this.trailElements = [];
            t--;

          )
            this.trailElements.push({
              position: new Yi(),
              lifetime: 0,
              width: 0,
              velocity: new Yi(),
              direction: 0,
              color: new Qi(),
            });
        }
        getElement(t) {
          return -1 === this.start
            ? null
            : (t < 0 &&
                (t =
                  (t + this.trailElements.length) % this.trailElements.length),
              t >= this.trailElements.length &&
                (t %= this.trailElements.length),
              this.trailElements[t]);
        }
        addElement() {
          if (0 === this.trailElements.length) return null;
          if (-1 === this.start)
            return (this.start = 0), (this.end = 1), this.trailElements[0];
          this.start === this.end &&
            (this.trailElements.splice(this.end, 0, {
              position: new Yi(),
              lifetime: 0,
              width: 0,
              velocity: new Yi(),
              direction: 0,
              color: new Qi(),
            }),
            this.start++,
            (this.start %= this.trailElements.length));
          const t = this.end++;
          return (this.end %= this.trailElements.length), this.trailElements[t];
        }
        iterateElement(t, e, i, s) {
          const n =
            this.start >= this.end
              ? this.end + this.trailElements.length
              : this.end;
          for (let r = this.start; r < n; r++)
            e(t, this.trailElements[r % this.trailElements.length], i, s) &&
              (this.start++, (this.start %= this.trailElements.length));
          this.start === n && ((this.start = -1), (this.end = -1));
        }
        count() {
          return this.start < this.end
            ? this.end - this.start
            : this.trailElements.length + this.end - this.start;
        }
        clear() {
          (this.start = -1), (this.end = -1);
        }
      }
      let kst =
        ((hst = Ca("cc.TrailModule")),
        (lst = ao(W7)),
        (cst = ao(k8)),
        (ust = ao(U7)),
        (_st = ao(X7)),
        (dst = ao(k8)),
        (pst = ao(l7)),
        (mst = ao(l7)),
        (fst = ao(U7)),
        hst(
          ((yst = class {
            get enable() {
              return this._enable;
            }
            set enable(t) {
              (t === this._enable && this._trailModel) ||
                (t &&
                  !this._enable &&
                  ((this._enable = t),
                  this._particleSystem.processor &&
                    this._particleSystem.processor.updateTrailMaterial()),
                t && !this._trailModel && (this._createModel(), this.rebuild()),
                (this._enable = t),
                this._trailModel && (this._trailModel.enabled = t),
                t ? this.onEnable() : this.onDisable());
            }
            get minParticleDistance() {
              return this._minParticleDistance;
            }
            set minParticleDistance(t) {
              (this._minParticleDistance = t),
                (this._minSquaredDistance = t * t);
            }
            get space() {
              return this._space;
            }
            set space(t) {
              this._space = t;
              const e = this._particleSystem;
              e && e.processor && e.processor.updateTrailMaterial();
            }
            getModel() {
              return this._trailModel;
            }
            get inited() {
              return this._inited;
            }
            constructor() {
              (this._enable = Tst && Tst()),
                (this.mode = Sst && Sst()),
                (this.lifeTime = Est && Est()),
                (this._minParticleDistance = vst && vst()),
                (this.existWithParticles = bst && bst()),
                (this.textureMode = Ast && Ast()),
                (this.widthFromParticle = Cst && Cst()),
                (this.widthRatio = Ost && Ost()),
                (this.colorFromParticle = Ist && Ist()),
                (this.colorOverTrail = wst && wst()),
                (this.colorOvertime = Rst && Rst()),
                (this._space = Dst && Dst()),
                (this._particleSystem = xst && xst()),
                (this._minSquaredDistance = 0),
                (this._vertSize = void 0),
                (this._trailNum = 0),
                (this._trailLifetime = 0),
                (this.vbOffset = 0),
                (this.ibOffset = 0),
                (this._trailSegments = null),
                (this._particleTrail = void 0),
                (this._trailModel = null),
                (this._subMeshData = null),
                (this._vertAttrs = void 0),
                (this._vbF32 = null),
                (this._vbUint32 = null),
                (this._iBuffer = null),
                (this._needTransform = !1),
                (this._material = null),
                (this._psTransform = new ms()),
                (this._iaVertCount = 0),
                (this._iaIndexCount = 0),
                (this._inited = void 0),
                (this._vertAttrs = [
                  new Lu(eu.ATTR_POSITION, fc.RGB32F),
                  new Lu(eu.ATTR_TEX_COORD, fc.RGBA32F),
                  new Lu(eu.ATTR_TEX_COORD1, fc.RGB32F),
                  new Lu(eu.ATTR_COLOR, fc.RGBA8, !0),
                ]),
                (this._vertSize = 0);
              for (const t of this._vertAttrs)
                this._vertSize += a_[t.format].size;
              (this._particleTrail = new Map()), (this._inited = !1);
            }
            onInit(t) {
              (this._particleSystem = t),
                (this.minParticleDistance = this._minParticleDistance);
              let e = 0;
              const i = t.startLifetime.getMax(),
                s = t.rateOverTime.getMax(),
                n = t.duration;
              for (let s = 0, r = t.bursts.length; s < r; s++)
                e += t.bursts[s].getMaxCount(t) * Math.ceil(i / n);
              this.lifeTime.getMax() < 1 && z(6036),
                (this._trailNum = Math.ceil(
                  i * Math.ceil(this.lifeTime.getMax()) * 60 * (s * n + e)
                )),
                (this._trailSegments = new Wn(
                  () => new Ust(10),
                  Math.ceil(s * n),
                  (t) => {
                    t.trailElements.length = 0;
                  }
                )),
                this._enable && (this.enable = this._enable),
                (this._inited = !0);
            }
            onEnable() {
              this._attachToScene();
            }
            onDisable() {
              this._particleTrail.clear(), this._detachFromScene();
            }
            _attachToScene() {
              this._trailModel &&
                (this._trailModel.scene && this._detachFromScene(),
                this._particleSystem
                  ._getRenderScene()
                  .addModel(this._trailModel));
            }
            _detachFromScene() {
              this._trailModel &&
                this._trailModel.scene &&
                this._trailModel.scene.removeModel(this._trailModel);
            }
            destroy() {
              this.destroySubMeshData(),
                this._trailModel &&
                  (Lv.root.destroyModel(this._trailModel),
                  (this._trailModel = null)),
                this._trailSegments &&
                  (this._trailSegments.destroy(), (this._trailSegments = null));
            }
            play() {
              this._trailModel &&
                this._enable &&
                (this._trailModel.enabled = !0);
            }
            clear() {
              if (this.enable) {
                const t = this._particleTrail.values();
                let e = t.next();
                for (; !e.done; ) e.value.clear(), (e = t.next());
                this._particleTrail.clear(),
                  this.updateRenderData(),
                  this._trailModel && (this._trailModel.enabled = !1);
              }
            }
            updateMaterial() {
              this._particleSystem &&
                ((this._material =
                  this._particleSystem.getMaterialInstance(1) ||
                  this._particleSystem.processor._defaultTrailMat),
                this._trailModel &&
                  this._trailModel.setSubModelMaterial(0, this._material));
            }
            update() {
              (this._trailLifetime = this.lifeTime.evaluate(
                this._particleSystem.time,
                1
              )),
                this.space === U7.World &&
                this._particleSystem.simulationSpace === U7.Local
                  ? ((this._needTransform = !0),
                    this._particleSystem.node.getWorldMatrix(this._psTransform),
                    this._particleSystem.node.getWorldRotation(Nst))
                  : (this._needTransform = !1);
            }
            animate(t, e) {
              if (!this._trailSegments) return;
              if (t.loopCount > t.lastLoop)
                return void (t.trailDelay > 1
                  ? ((t.lastLoop = t.loopCount), (t.trailDelay = 0))
                  : t.trailDelay++);
              let i = this._particleTrail.get(t);
              if (!i)
                return (
                  (i = this._trailSegments.alloc()),
                  void this._particleTrail.set(t, i)
                );
              let s = i.getElement(i.end - 1);
              if (
                (this._needTransform
                  ? Yi.transformMat4(Lst, t.position, this._psTransform)
                  : Yi.copy(Lst, t.position),
                s &&
                  (i.iterateElement(this, this._updateTrailElement, t, e),
                  Yi.squaredDistance(s.position, Lst) <
                    this._minSquaredDistance))
              )
                return;
              if (((s = i.addElement()), !s)) return;
              Yi.copy(s.position, Lst),
                (s.lifetime = 0),
                this.widthFromParticle
                  ? (s.width = t.size.x * this.widthRatio.evaluate(0, 1))
                  : (s.width = this.widthRatio.evaluate(0, 1));
              const n = i.count();
              if (2 === n) {
                const t = i.getElement(i.end - 2);
                Yi.subtract(t.velocity, s.position, t.position);
              } else if (n > 2) {
                const t = i.getElement(i.end - 2),
                  e = i.getElement(i.end - 3);
                Yi.subtract(Lst, e.position, t.position),
                  Yi.subtract(Bst, s.position, t.position),
                  Yi.subtract(t.velocity, Bst, Lst),
                  Yi.equals(Yi.ZERO, t.velocity) && Yi.copy(t.velocity, Lst),
                  Yi.normalize(t.velocity, t.velocity),
                  this._checkDirectionReverse(t, e);
              }
              this.colorFromParticle
                ? s.color.set(t.color)
                : s.color.set(this.colorOvertime.evaluate(0, 1));
            }
            removeParticle(t) {
              const e = this._particleTrail.get(t);
              e &&
                this._trailSegments &&
                (e.clear(),
                this._trailSegments.free(e),
                this._particleTrail.delete(t));
            }
            updateRenderData() {
              (this.vbOffset = 0), (this.ibOffset = 0);
              for (const t of this._particleTrail.keys()) {
                const e = this._particleTrail.get(t);
                if (-1 === e.start) continue;
                const i = (4 * this.vbOffset) / this._vertSize,
                  s = e.start >= e.end ? e.end + e.trailElements.length : e.end,
                  n = s - e.start,
                  r = 1 / n,
                  a = e.trailElements[e.start];
                this._fillVertexBuffer(
                  a,
                  this.colorOverTrail.evaluate(1, 1),
                  i,
                  1,
                  0,
                  4
                );
                for (let t = e.start + 1; t < s; t++) {
                  const s = e.trailElements[t % e.trailElements.length],
                    a = t - e.start;
                  this._fillVertexBuffer(
                    s,
                    this.colorOverTrail.evaluate(1 - a / n, 1),
                    i,
                    1 - a * r,
                    a,
                    5
                  );
                }
                this._needTransform
                  ? Yi.transformMat4(
                      Pst.position,
                      t.position,
                      this._psTransform
                    )
                  : Yi.copy(Pst.position, t.position);
                const o = this._trailModel;
                if (
                  (o && o.node.invalidateChildren(Cf.POSITION),
                  1 === n || 2 === n)
                ) {
                  const t = e.getElement(e.end - 1);
                  Yi.subtract(t.velocity, Pst.position, t.position),
                    (this._vbF32[this.vbOffset - this._vertSize / 4 - 4] =
                      t.velocity.x),
                    (this._vbF32[this.vbOffset - this._vertSize / 4 - 3] =
                      t.velocity.y),
                    (this._vbF32[this.vbOffset - this._vertSize / 4 - 2] =
                      t.velocity.z),
                    (this._vbF32[this.vbOffset - 4] = t.velocity.x),
                    (this._vbF32[this.vbOffset - 3] = t.velocity.y),
                    (this._vbF32[this.vbOffset - 2] = t.velocity.z),
                    Yi.subtract(Pst.velocity, Pst.position, t.position),
                    this._checkDirectionReverse(Pst, t);
                } else if (n > 2) {
                  const t = e.getElement(e.end - 1),
                    s = e.getElement(e.end - 2);
                  Yi.subtract(Lst, s.position, t.position),
                    Yi.subtract(Bst, Pst.position, t.position),
                    Yi.normalize(Lst, Lst),
                    Yi.normalize(Bst, Bst),
                    Yi.subtract(t.velocity, Bst, Lst),
                    Yi.normalize(t.velocity, t.velocity),
                    this._checkDirectionReverse(t, s),
                    (this.vbOffset -= (this._vertSize / 4) * 2),
                    (this.ibOffset -= 6),
                    this._fillVertexBuffer(
                      t,
                      this.colorOverTrail.evaluate(r, 1),
                      i,
                      r,
                      n - 1,
                      5
                    ),
                    Yi.subtract(Pst.velocity, Pst.position, t.position),
                    Yi.normalize(Pst.velocity, Pst.velocity),
                    this._checkDirectionReverse(Pst, t);
                }
                this.widthFromParticle
                  ? (Pst.width = t.size.x * this.widthRatio.evaluate(0, 1))
                  : (Pst.width = this.widthRatio.evaluate(0, 1)),
                  (Pst.color = t.color),
                  Yi.equals(Pst.velocity, Yi.ZERO)
                    ? (this.ibOffset -= 3)
                    : this._fillVertexBuffer(
                        Pst,
                        this.colorOverTrail.evaluate(0, 1),
                        i,
                        0,
                        n,
                        1
                      );
              }
              this._trailModel &&
                (this._trailModel.enabled = this.ibOffset > 0);
            }
            updateIA(t) {
              const e = this._trailModel && this._trailModel.subModels;
              if (e && e.length > 0) {
                const i = e[0];
                i.inputAssembler.vertexBuffers[0].update(this._vbF32),
                  i.inputAssembler.indexBuffer.update(this._iBuffer),
                  (i.inputAssembler.firstIndex = 0),
                  (i.inputAssembler.indexCount = t),
                  (i.inputAssembler.vertexCount = this._iaVertCount);
              }
            }
            beforeRender() {
              this.updateIA(this.ibOffset);
            }
            _createModel() {
              this._trailModel ||
                (this._trailModel = a.director.root.createModel(tg));
            }
            rebuild() {
              const t = Lv.root.device,
                e = t.createBuffer(
                  new yu(
                    Tc.VERTEX | Tc.TRANSFER_DST,
                    vc.HOST | vc.DEVICE,
                    this._vertSize * (this._trailNum + 1) * 2,
                    this._vertSize
                  )
                ),
                i = new ArrayBuffer(this._vertSize * (this._trailNum + 1) * 2);
              (this._vbF32 = new Float32Array(i)),
                (this._vbUint32 = new Uint32Array(i)),
                e.update(i);
              const s = t.createBuffer(
                new yu(
                  Tc.INDEX | Tc.TRANSFER_DST,
                  vc.HOST | vc.DEVICE,
                  6 *
                    Math.max(1, this._trailNum) *
                    Uint16Array.BYTES_PER_ELEMENT,
                  Uint16Array.BYTES_PER_ELEMENT
                )
              );
              (this._iBuffer = new Uint16Array(
                6 * Math.max(1, this._trailNum)
              )),
                s.update(this._iBuffer),
                (this._iaVertCount = 2 * (this._trailNum + 1)),
                (this._iaIndexCount = 6 * this._trailNum),
                (this._subMeshData = new fC(
                  [e],
                  this._vertAttrs,
                  Gc.TRIANGLE_LIST,
                  s
                ));
              const n = this._trailModel;
              n &&
                this._material &&
                ((n.node = n.transform = this._particleSystem.node),
                (n.visFlags = this._particleSystem.visibility),
                n.initSubModel(0, this._subMeshData, this._material),
                (n.enabled = !0));
            }
            _updateTrailElement(t, e, i, s) {
              return (
                (e.lifetime += s),
                t.colorFromParticle
                  ? (e.color.set(i.color),
                    e.color.multiply(
                      t.colorOvertime.evaluate(
                        1 - i.remainingLifetime / i.startLifetime,
                        1
                      )
                    ))
                  : e.color.set(
                      t.colorOvertime.evaluate(
                        1 - i.remainingLifetime / i.startLifetime,
                        1
                      )
                    ),
                t.widthFromParticle
                  ? (e.width =
                      i.size.x *
                      t.widthRatio.evaluate(e.lifetime / t._trailLifetime, 1))
                  : (e.width = t.widthRatio.evaluate(
                      e.lifetime / t._trailLifetime,
                      1
                    )),
                e.lifetime > t._trailLifetime
              );
            }
            _fillVertexBuffer(t, e, i, s, n, r) {
              (this._vbF32[this.vbOffset++] = t.position.x),
                (this._vbF32[this.vbOffset++] = t.position.y),
                (this._vbF32[this.vbOffset++] = t.position.z),
                (this._vbF32[this.vbOffset++] = t.direction),
                (this._vbF32[this.vbOffset++] = t.width),
                (this._vbF32[this.vbOffset++] = s),
                (this._vbF32[this.vbOffset++] = 0),
                (this._vbF32[this.vbOffset++] = t.velocity.x),
                (this._vbF32[this.vbOffset++] = t.velocity.y),
                (this._vbF32[this.vbOffset++] = t.velocity.z),
                Fst.set(t.color),
                Fst.multiply(e),
                (this._vbUint32[this.vbOffset++] = Qi.toUint32(Fst)),
                (this._vbF32[this.vbOffset++] = t.position.x),
                (this._vbF32[this.vbOffset++] = t.position.y),
                (this._vbF32[this.vbOffset++] = t.position.z),
                (this._vbF32[this.vbOffset++] = 1 - t.direction),
                (this._vbF32[this.vbOffset++] = t.width),
                (this._vbF32[this.vbOffset++] = s),
                (this._vbF32[this.vbOffset++] = 1),
                (this._vbF32[this.vbOffset++] = t.velocity.x),
                (this._vbF32[this.vbOffset++] = t.velocity.y),
                (this._vbF32[this.vbOffset++] = t.velocity.z),
                (this._vbUint32[this.vbOffset++] = Qi.toUint32(Fst)),
                1 & r &&
                  ((this._iBuffer[this.ibOffset++] = i + 2 * n),
                  (this._iBuffer[this.ibOffset++] = i + 2 * n - 1),
                  (this._iBuffer[this.ibOffset++] = i + 2 * n + 1)),
                4 & r &&
                  ((this._iBuffer[this.ibOffset++] = i + 2 * n),
                  (this._iBuffer[this.ibOffset++] = i + 2 * n + 1),
                  (this._iBuffer[this.ibOffset++] = i + 2 * n + 2));
            }
            _checkDirectionReverse(t, e) {
              Yi.dot(t.velocity, e.velocity) < Mst
                ? (t.direction = 1 - e.direction)
                : (t.direction = e.direction);
            }
            destroySubMeshData() {
              this._subMeshData &&
                (this._subMeshData.destroy(), (this._subMeshData = null));
            }
          }),
          (Tst = fa(yst.prototype, "_enable", [Na], function () {
            return !1;
          })),
          (Sst = fa(yst.prototype, "mode", [lst, Na], function () {
            return W7.Particles;
          })),
          (Est = fa(yst.prototype, "lifeTime", [cst, Na], function () {
            return new k8();
          })),
          (vst = fa(yst.prototype, "_minParticleDistance", [Na], function () {
            return 0.1;
          })),
          s(
            yst.prototype,
            "space",
            [ust],
            Object.getOwnPropertyDescriptor(yst.prototype, "space"),
            yst.prototype
          ),
          (bst = fa(yst.prototype, "existWithParticles", [Na], function () {
            return !0;
          })),
          (Ast = fa(yst.prototype, "textureMode", [_st, Na], function () {
            return X7.Stretch;
          })),
          (Cst = fa(yst.prototype, "widthFromParticle", [Na], function () {
            return !0;
          })),
          (Ost = fa(yst.prototype, "widthRatio", [dst, Na], function () {
            return new k8();
          })),
          (Ist = fa(yst.prototype, "colorFromParticle", [Na], function () {
            return !1;
          })),
          (wst = fa(yst.prototype, "colorOverTrail", [pst, Na], function () {
            return new l7();
          })),
          (Rst = fa(yst.prototype, "colorOvertime", [mst, Na], function () {
            return new l7();
          })),
          (Dst = fa(yst.prototype, "_space", [fst], function () {
            return U7.World;
          })),
          (xst = fa(yst.prototype, "_particleSystem", [Na], function () {
            return null;
          })),
          (gst = yst))
        ) || gst);
      const zst = new ms(),
        Hst = new ms(),
        Gst = new as(),
        Vst = new Yi(),
        jst = [
          "_colorOverLifetimeModule",
          "_sizeOvertimeModule",
          "_velocityOvertimeModule",
          "_forceOvertimeModule",
          "_limitVelocityOvertimeModule",
          "_rotationOvertimeModule",
          "_textureAnimationModule",
        ];
      class Wst {
        constructor(t) {
          (this._particleSystem = void 0),
            (this._processor = void 0),
            (this._node = void 0),
            (this._particlesAll = void 0),
            (this._updateList = new Map()),
            (this._animateList = new Map()),
            (this._runAnimateList = new Array()),
            (this._localMat = new ms()),
            (this._gravity = new Wi()),
            (this.minPos = new Yi()),
            (this.maxPos = new Yi()),
            (this._nodePos = new Yi()),
            (this._nodeSize = new Yi()),
            (this._particleSystem = t),
            (this._processor = this._particleSystem.processor),
            (this._node = t.node),
            (this._particlesAll = []),
            this._initModuleList();
        }
        _updateBoundingNode() {
          this._nodeSize.set(
            this.maxPos.x - this.minPos.x,
            this.maxPos.y - this.minPos.y,
            this.maxPos.z - this.minPos.z
          ),
            this._nodePos.set(
              this.minPos.x + 0.5 * this._nodeSize.x,
              this.minPos.y + 0.5 * this._nodeSize.y,
              this.minPos.z + 0.5 * this._nodeSize.z
            );
        }
        setBoundingBoxSize(t) {
          (this.maxPos.x = this._nodePos.x + t.x),
            (this.maxPos.y = this._nodePos.y + t.y),
            (this.maxPos.z = this._nodePos.z + t.z),
            (this.minPos.x = this._nodePos.x - t.x),
            (this.minPos.y = this._nodePos.y - t.y),
            (this.minPos.z = this._nodePos.z - t.z),
            this._updateBoundingNode();
        }
        setBoundingBoxCenter(t, e, i) {
          (this.maxPos.x = t + 0.5 * this._nodeSize.x),
            (this.maxPos.y = e + 0.5 * this._nodeSize.y),
            (this.maxPos.z = i + 0.5 * this._nodeSize.z),
            (this.minPos.x = t - 0.5 * this._nodeSize.x),
            (this.minPos.y = e - 0.5 * this._nodeSize.y),
            (this.minPos.z = i - 0.5 * this._nodeSize.z),
            this._updateBoundingNode();
        }
        _initModuleList() {
          jst.forEach((t) => {
            const e = this._particleSystem[t];
            e &&
              e.enable &&
              (e.needUpdate && this._updateList.set(e.name, e),
              e.needAnimate && this._animateList.set(e.name, e));
          }),
            (this._runAnimateList.length = 0);
          for (let t = 0, e = L7.length; t < e; t++) {
            const e = this._animateList.get(L7[t]);
            e && this._runAnimateList.push(e);
          }
        }
        _emit(t, e, i) {
          const s = this._particleSystem,
            n = this._node,
            r = (s.time % s.duration) / s.duration;
          n.invalidateChildren(Cf.POSITION),
            s.simulationSpace === U7.World &&
              (n.getWorldMatrix(zst), n.getWorldRotation(Gst));
          for (let n = 0; n < t; ++n) {
            const t = new P7(s);
            (t.particleSystem = s), t.reset();
            const n = Ri(wi(0, l));
            s._shapeModule && s._shapeModule.enable
              ? s._shapeModule.emit(t)
              : (Yi.set(t.position, 0, 0, 0), Yi.copy(t.velocity, Y7)),
              s._textureAnimationModule &&
                s._textureAnimationModule.enable &&
                s._textureAnimationModule.init(t);
            const a = s.startSpeed.evaluate(r, n);
            Yi.multiplyScalar(t.velocity, t.velocity, a),
              s.simulationSpace === U7.World &&
                (Yi.transformMat4(t.position, t.position, zst),
                Yi.transformQuat(t.velocity, t.velocity, Gst)),
              Yi.copy(t.ultimateVelocity, t.velocity),
              Yi.set(t.rotation, 0, 0, 0),
              s.startSize3D
                ? Yi.set(
                    t.startSize,
                    s.startSizeX.evaluate(r, n),
                    s.startSizeY.evaluate(r, n),
                    s.startSizeZ.evaluate(r, n)
                  )
                : (Yi.set(t.startSize, s.startSizeX.evaluate(r, n), 1, 1),
                  (t.startSize.y = t.startSize.x)),
              Yi.copy(t.size, t.startSize),
              (t.startLifetime = s.startLifetime.evaluate(r, n) + e),
              (t.remainingLifetime = t.startLifetime),
              i.push(t);
          }
        }
        _updateParticles(t, e) {
          const i = this._particleSystem;
          switch ((i.node.getWorldMatrix(zst), i.scaleSpace)) {
            case U7.Local:
              i.node.getScale(Vst);
              break;
            case U7.World:
              i.node.getWorldScale(Vst);
          }
          if (
            (this._updateList.forEach(() => {}), i.simulationSpace === U7.Local)
          ) {
            const t = i.node.getRotation();
            ms.fromQuat(this._localMat, t), this._localMat.transpose();
          }
          i.node.parent && (i.node.parent.getWorldMatrix(Hst), Hst.invert());
          for (let s = 0; s < e.length; ++s) {
            const n = e[s];
            if (
              ((n.remainingLifetime -= t),
              Yi.set(n.animatedVelocity, 0, 0, 0),
              i.gravityModifier.mode !== U8.Constant ||
                0 !== i.gravityModifier.constant)
            ) {
              const e = e9(i.gravityModifier) ? Ri(n.randomSeed) : 0;
              if (i.simulationSpace === U7.Local) {
                const s =
                  9.8 *
                  -i.gravityModifier.evaluate(
                    1 - n.remainingLifetime / n.startLifetime,
                    e
                  ) *
                  t;
                (this._gravity.x = 0),
                  (this._gravity.y = s),
                  (this._gravity.z = 0),
                  (this._gravity.w = 1),
                  Ti(s, 0, gi) ||
                    (i.node.parent &&
                      (this._gravity = this._gravity.transformMat4(Hst)),
                    (this._gravity = this._gravity.transformMat4(
                      this._localMat
                    )),
                    (n.velocity.x += this._gravity.x),
                    (n.velocity.y += this._gravity.y),
                    (n.velocity.z += this._gravity.z));
              } else
                n.velocity.y -=
                  9.8 *
                  i.gravityModifier.evaluate(
                    1 - n.remainingLifetime / n.startLifetime,
                    e
                  ) *
                  t;
            }
            Yi.copy(n.ultimateVelocity, n.velocity),
              this._runAnimateList.forEach((e) => {
                e.animate(n, t);
              }),
              Yi.scaleAndAdd(n.position, n.position, n.ultimateVelocity, t);
          }
        }
        _calculateBounding(t) {
          const e = new Yi(),
            i = new Yi(),
            s = new Yi(),
            n = new Yi(),
            r = new Yi(1, 1, 1);
          if (this._processor.getInfo().renderMode === H7.Mesh) {
            const t = this._processor.getInfo().mesh;
            if (t && t.struct.minPosition && t.struct.maxPosition) {
              const e = new Kr();
              Kr.fromPoints(e, t.struct.minPosition, t.struct.maxPosition);
              const i = Math.max(
                e.halfExtents.x,
                e.halfExtents.y,
                e.halfExtents.z
              );
              r.set(i, i, i);
            }
          }
          const a = this._particleSystem.node.worldMatrix;
          for (let o = 0; o < this._particlesAll.length; ++o) {
            const h = this._particlesAll[o];
            Yi.multiply(e, Vst, h.size),
              Yi.multiply(e, e, r),
              i.set(h.position),
              this._particleSystem.simulationSpace !== U7.World &&
                Yi.transformMat4(i, i, a),
              t && 0 === o
                ? (Yi.subtract(this.minPos, i, e), Yi.add(this.maxPos, i, e))
                : (Yi.subtract(s, i, e),
                  Yi.add(n, i, e),
                  Yi.min(this.minPos, this.minPos, s),
                  Yi.max(this.maxPos, this.maxPos, n));
          }
        }
        calculatePositions() {
          this._emit(this._particleSystem.capacity, 0, this._particlesAll);
          const t = e9(this._particleSystem.startLifetime) ? Ri(wi(0, l)) : 0;
          this._updateParticles(0, this._particlesAll),
            this._calculateBounding(!0),
            this._updateParticles(
              this._particleSystem.startLifetime.evaluate(0, t),
              this._particlesAll
            ),
            this._calculateBounding(!1),
            this._updateBoundingNode();
        }
        clear() {
          this._particlesAll.length = 0;
        }
        destroy() {}
      }
      var Xst,
        Yst,
        Kst,
        qst,
        $st,
        Zst,
        Qst,
        Jst,
        tnt,
        ent,
        int,
        snt,
        nnt,
        rnt,
        ant,
        ont,
        hnt,
        lnt,
        cnt,
        unt,
        _nt,
        dnt,
        pnt,
        mnt,
        fnt,
        gnt,
        ynt,
        Tnt,
        Snt,
        Ent;
      const {
        ccclass: vnt,
        serializable: bnt,
        displayOrder: Ant,
        type: Cnt,
        range: Ont,
        slide: Int,
        visible: wnt,
      } = go;
      let Rnt =
        ((Xst = vnt("cc.NoiseModule")),
        (Yst = Cnt(ze)),
        (Kst = Cnt(ze)),
        (qst = Cnt(ze)),
        ($st = Cnt(ze)),
        (Zst = Cnt(ze)),
        (Qst = Cnt(ze)),
        (Jst = Cnt(ze)),
        (tnt = Cnt(ze)),
        (ent = Cnt(ze)),
        (int = Cnt(ze)),
        (snt = Cnt(ke)),
        (nnt = Cnt(ze)),
        (rnt = Cnt(ze)),
        Xst(
          ((ont = class extends F7 {
            constructor(...t) {
              super(...t),
                (this._enable = hnt && hnt()),
                (this._strengthX = lnt && lnt()),
                (this._strengthY = cnt && cnt()),
                (this._strengthZ = unt && unt()),
                (this._noiseSpeedX = _nt && _nt()),
                (this._noiseSpeedY = dnt && dnt()),
                (this._noiseSpeedZ = pnt && pnt()),
                (this._noiseFrequency = mnt && mnt()),
                (this._remapX = fnt && fnt()),
                (this._remapY = gnt && gnt()),
                (this._remapZ = ynt && ynt()),
                (this._octaves = Tnt && Tnt()),
                (this._octaveMultiplier = Snt && Snt()),
                (this._octaveScale = Ent && Ent()),
                (this.name = N7),
                (this.noise = new iit()),
                (this.samplePosition = new Yi());
            }
            get enable() {
              return this._enable;
            }
            set enable(t) {
              this._enable !== t &&
                ((this._enable = t),
                this.target && this.target.enableModule(this.name, t, this));
            }
            get strengthX() {
              return this._strengthX;
            }
            set strengthX(t) {
              this._strengthX = t;
            }
            get strengthY() {
              return this._strengthY;
            }
            set strengthY(t) {
              this._strengthY = t;
            }
            get strengthZ() {
              return this._strengthZ;
            }
            set strengthZ(t) {
              this._strengthZ = t;
            }
            get noiseSpeedX() {
              return this._noiseSpeedX;
            }
            set noiseSpeedX(t) {
              this._noiseSpeedX = t;
            }
            get noiseSpeedY() {
              return this._noiseSpeedY;
            }
            set noiseSpeedY(t) {
              this._noiseSpeedY = t;
            }
            get noiseSpeedZ() {
              return this._noiseSpeedZ;
            }
            set noiseSpeedZ(t) {
              this._noiseSpeedZ = t;
            }
            get noiseFrequency() {
              return this._noiseFrequency;
            }
            set noiseFrequency(t) {
              this._noiseFrequency = t;
            }
            get remapX() {
              return this._remapX;
            }
            set remapX(t) {
              this._remapX = t;
            }
            get remapY() {
              return this._remapY;
            }
            set remapY(t) {
              this._remapY = t;
            }
            get remapZ() {
              return this._remapZ;
            }
            set remapZ(t) {
              this._remapZ = t;
            }
            get octaves() {
              return this._octaves;
            }
            set octaves(t) {
              this._octaves = t;
            }
            get octaveMultiplier() {
              return this._octaveMultiplier;
            }
            set octaveMultiplier(t) {
              this._octaveMultiplier = t;
            }
            get octaveScale() {
              return this._octaveScale;
            }
            set octaveScale(t) {
              this._octaveScale = t;
            }
            animate(t, e) {
              this.noise.setTime(t.particleSystem.time),
                this.noise.setSpeed(
                  this.noiseSpeedX,
                  this.noiseSpeedY,
                  this.noiseSpeedZ
                ),
                this.noise.setFrequency(this.noiseFrequency),
                this.noise.setAbs(this.remapX, this.remapY, this.remapZ),
                this.noise.setAmplititude(
                  this.strengthX,
                  this.strengthY,
                  this.strengthZ
                ),
                this.noise.setOctaves(
                  this.octaves,
                  this.octaveMultiplier,
                  this.octaveScale
                ),
                this.samplePosition.set(t.position),
                this.samplePosition.add3f(1 * Ci(), 1 * Ci(), 1 * Ci()),
                this.noise.setSamplePoint(this.samplePosition),
                this.noise.getNoiseParticle();
              const i = this.noise.getResult();
              i.multiply3f(Ci(), Ci(), Ci()),
                Yi.add(t.position, t.position, i.multiplyScalar(e));
            }
            getNoisePreview(t, e, i, s) {
              this.noise.setTime(e.time),
                this.noise.setSpeed(
                  this.noiseSpeedX,
                  this.noiseSpeedY,
                  this.noiseSpeedZ
                ),
                this.noise.setFrequency(this.noiseFrequency),
                this.noise.setAbs(this.remapX, this.remapY, this.remapZ),
                this.noise.setAmplititude(
                  this.strengthX,
                  this.strengthY,
                  this.strengthZ
                ),
                this.noise.setOctaves(
                  this.octaves,
                  this.octaveMultiplier,
                  this.octaveScale
                ),
                this.noise.getNoiseParticle(),
                this.noise.getPreview(t, i, s);
            }
          }),
          (hnt = fa(ont.prototype, "_enable", [bnt], function () {
            return !1;
          })),
          s(
            ont.prototype,
            "strengthX",
            [Yst],
            Object.getOwnPropertyDescriptor(ont.prototype, "strengthX"),
            ont.prototype
          ),
          (lnt = fa(ont.prototype, "_strengthX", [bnt], function () {
            return 10;
          })),
          s(
            ont.prototype,
            "strengthY",
            [Kst],
            Object.getOwnPropertyDescriptor(ont.prototype, "strengthY"),
            ont.prototype
          ),
          (cnt = fa(ont.prototype, "_strengthY", [bnt], function () {
            return 10;
          })),
          s(
            ont.prototype,
            "strengthZ",
            [qst],
            Object.getOwnPropertyDescriptor(ont.prototype, "strengthZ"),
            ont.prototype
          ),
          (unt = fa(ont.prototype, "_strengthZ", [bnt], function () {
            return 10;
          })),
          s(
            ont.prototype,
            "noiseSpeedX",
            [$st],
            Object.getOwnPropertyDescriptor(ont.prototype, "noiseSpeedX"),
            ont.prototype
          ),
          (_nt = fa(ont.prototype, "_noiseSpeedX", [bnt], function () {
            return 0;
          })),
          s(
            ont.prototype,
            "noiseSpeedY",
            [Zst],
            Object.getOwnPropertyDescriptor(ont.prototype, "noiseSpeedY"),
            ont.prototype
          ),
          (dnt = fa(ont.prototype, "_noiseSpeedY", [bnt], function () {
            return 0;
          })),
          s(
            ont.prototype,
            "noiseSpeedZ",
            [Qst],
            Object.getOwnPropertyDescriptor(ont.prototype, "noiseSpeedZ"),
            ont.prototype
          ),
          (pnt = fa(ont.prototype, "_noiseSpeedZ", [bnt], function () {
            return 0;
          })),
          s(
            ont.prototype,
            "noiseFrequency",
            [Jst],
            Object.getOwnPropertyDescriptor(ont.prototype, "noiseFrequency"),
            ont.prototype
          ),
          (mnt = fa(ont.prototype, "_noiseFrequency", [bnt], function () {
            return 1;
          })),
          s(
            ont.prototype,
            "remapX",
            [tnt],
            Object.getOwnPropertyDescriptor(ont.prototype, "remapX"),
            ont.prototype
          ),
          (fnt = fa(ont.prototype, "_remapX", [bnt], function () {
            return 0;
          })),
          s(
            ont.prototype,
            "remapY",
            [ent],
            Object.getOwnPropertyDescriptor(ont.prototype, "remapY"),
            ont.prototype
          ),
          (gnt = fa(ont.prototype, "_remapY", [bnt], function () {
            return 0;
          })),
          s(
            ont.prototype,
            "remapZ",
            [int],
            Object.getOwnPropertyDescriptor(ont.prototype, "remapZ"),
            ont.prototype
          ),
          (ynt = fa(ont.prototype, "_remapZ", [bnt], function () {
            return 0;
          })),
          s(
            ont.prototype,
            "octaves",
            [snt],
            Object.getOwnPropertyDescriptor(ont.prototype, "octaves"),
            ont.prototype
          ),
          (Tnt = fa(ont.prototype, "_octaves", [bnt], function () {
            return 1;
          })),
          s(
            ont.prototype,
            "octaveMultiplier",
            [nnt],
            Object.getOwnPropertyDescriptor(ont.prototype, "octaveMultiplier"),
            ont.prototype
          ),
          (Snt = fa(ont.prototype, "_octaveMultiplier", [bnt], function () {
            return 0.5;
          })),
          s(
            ont.prototype,
            "octaveScale",
            [rnt],
            Object.getOwnPropertyDescriptor(ont.prototype, "octaveScale"),
            ont.prototype
          ),
          (Ent = fa(ont.prototype, "_octaveScale", [bnt], function () {
            return 2;
          })),
          (ant = ont))
        ) || ant);
      var Dnt,
        xnt,
        Mnt,
        Pnt,
        Nnt,
        Lnt,
        Bnt,
        Fnt,
        Unt,
        knt,
        znt,
        Hnt,
        Gnt,
        Vnt,
        jnt,
        Wnt,
        Xnt,
        Ynt,
        Knt,
        qnt,
        $nt,
        Znt,
        Qnt,
        Jnt,
        trt,
        ert,
        irt,
        srt,
        nrt,
        rrt,
        art,
        ort,
        hrt,
        lrt,
        crt,
        urt,
        _rt,
        drt,
        prt,
        mrt,
        frt,
        grt,
        yrt,
        Trt,
        Srt,
        Ert,
        vrt,
        brt,
        Art,
        Crt,
        Ort,
        Irt,
        wrt,
        Rrt,
        Drt,
        xrt,
        Mrt,
        Prt,
        Nrt,
        Lrt,
        Brt,
        Frt,
        Urt,
        krt,
        zrt,
        Hrt,
        Grt,
        Vrt,
        jrt,
        Wrt,
        Xrt,
        Yrt,
        Krt,
        qrt,
        $rt,
        Zrt,
        Qrt,
        Jrt,
        tat,
        eat,
        iat,
        sat,
        nat,
        rat,
        aat,
        oat,
        hat,
        lat,
        cat,
        uat,
        _at;
      const dat = new ms(),
        pat = new as(),
        mat = Object.getOwnPropertyDescriptor(HI.prototype, "sharedMaterials");
      let fat =
        ((Dnt = Ca("cc.ParticleSystem")),
        (xnt = Ia(99)),
        (Mnt = ao(l7)),
        (Pnt = ao(U7)),
        (Nnt = La("startSize")),
        (Lnt = ao(k8)),
        (Bnt = ao(k8)),
        (Fnt = ao(k8)),
        (Unt = ao(k8)),
        (knt = ao(k8)),
        (znt = ao(k8)),
        (Hnt = ao(k8)),
        (Gnt = La("startRotation")),
        (Vnt = ao(k8)),
        (jnt = ao(k8)),
        (Wnt = ao(U7)),
        (Xnt = ao(k8)),
        (Ynt = ao(k8)),
        (Knt = ao(k8)),
        (qnt = ao([get])),
        ($nt = ao(He)),
        (Znt = ao(k7)),
        (Qnt = ao(ze)),
        (Jnt = ao(ze)),
        (trt = ao(ze)),
        (ert = La("enableCulling")),
        (irt = ao(h9)),
        (srt = ao(h9)),
        (nrt = ao($et)),
        (rrt = ao($et)),
        (art = ao(ytt)),
        (ort = ao(ytt)),
        (hrt = ao(oet)),
        (lrt = ao(oet)),
        (crt = ao(b9)),
        (urt = ao(b9)),
        (_rt = ao(V9)),
        (drt = ao(V9)),
        (prt = ao(stt)),
        (mrt = ao(stt)),
        (frt = ao(jtt)),
        (grt = ao(jtt)),
        (yrt = ao(Rnt)),
        (Trt = ao(Rnt)),
        (Srt = ao(kst)),
        (Ert = ao(kst)),
        (vrt = ao(ost)),
        Dnt(
          (brt =
            xnt(
              (((_at = class extends MM {
                get capacity() {
                  return this._capacity;
                }
                set capacity(t) {
                  (this._capacity = Math.floor(t > 0 ? t : 0)),
                    this.processor &&
                      this.processor.model &&
                      this.processor.model.setCapacity(this._capacity);
                }
                get prewarm() {
                  return this._prewarm;
                }
                set prewarm(t) {
                  !0 === t && this.loop, (this._prewarm = t);
                }
                get simulationSpace() {
                  return this._simulationSpace;
                }
                set simulationSpace(t) {
                  t !== this._simulationSpace &&
                    ((this._simulationSpace = t),
                    this.processor &&
                      (this.processor.updateMaterialParams(),
                      this.processor.updateTrailMaterial()));
                }
                set renderCulling(t) {
                  (this._renderCulling = t),
                    t &&
                      (this._boundingBox ||
                        ((this._boundingBox = new Kr()),
                        this._calculateBounding(!1)));
                }
                get renderCulling() {
                  return this._renderCulling;
                }
                get cullingMode() {
                  return this._cullingMode;
                }
                set cullingMode(t) {
                  this._cullingMode = t;
                }
                get aabbHalfX() {
                  return this.getBoundingX() || 0;
                }
                set aabbHalfX(t) {
                  this.setBoundingX(t);
                }
                get aabbHalfY() {
                  return this.getBoundingY() || 0;
                }
                set aabbHalfY(t) {
                  this.setBoundingY(t);
                }
                get aabbHalfZ() {
                  return this.getBoundingZ() || 0;
                }
                set aabbHalfZ(t) {
                  this.setBoundingZ(t);
                }
                get dataCulling() {
                  return this._dataCulling;
                }
                set dataCulling(t) {
                  this._dataCulling = t;
                }
                get sharedMaterials() {
                  return mat.get.call(this);
                }
                set sharedMaterials(t) {
                  mat.set.call(this, t);
                }
                get colorOverLifetimeModule() {
                  return this._colorOverLifetimeModule;
                }
                set colorOverLifetimeModule(t) {
                  t && (this._colorOverLifetimeModule = t);
                }
                get shapeModule() {
                  return this._shapeModule;
                }
                set shapeModule(t) {
                  t && (this._shapeModule = t);
                }
                get sizeOvertimeModule() {
                  return this._sizeOvertimeModule;
                }
                set sizeOvertimeModule(t) {
                  t && (this._sizeOvertimeModule = t);
                }
                get velocityOvertimeModule() {
                  return this._velocityOvertimeModule;
                }
                set velocityOvertimeModule(t) {
                  t && (this._velocityOvertimeModule = t);
                }
                get forceOvertimeModule() {
                  return this._forceOvertimeModule;
                }
                set forceOvertimeModule(t) {
                  t && (this._forceOvertimeModule = t);
                }
                get limitVelocityOvertimeModule() {
                  return this._limitVelocityOvertimeModule;
                }
                set limitVelocityOvertimeModule(t) {
                  t && (this._limitVelocityOvertimeModule = t);
                }
                get rotationOvertimeModule() {
                  return this._rotationOvertimeModule;
                }
                set rotationOvertimeModule(t) {
                  t && (this._rotationOvertimeModule = t);
                }
                get textureAnimationModule() {
                  return this._textureAnimationModule;
                }
                set textureAnimationModule(t) {
                  t && (this._textureAnimationModule = t);
                }
                get noiseModule() {
                  return this._noiseModule;
                }
                set noiseModule(t) {
                  t && (this._noiseModule = t);
                }
                get trailModule() {
                  return this._trailModule;
                }
                set trailModule(t) {
                  t && (this._trailModule = t);
                }
                constructor() {
                  super(),
                    (this.startColor = Crt && Crt()),
                    (this.scaleSpace = Ort && Ort()),
                    (this.startSize3D = Irt && Irt()),
                    (this.startSizeX = wrt && wrt()),
                    (this.startSizeY = Rrt && Rrt()),
                    (this.startSizeZ = Drt && Drt()),
                    (this.startSpeed = xrt && xrt()),
                    (this.startRotation3D = Mrt && Mrt()),
                    (this.startRotationX = Prt && Prt()),
                    (this.startRotationY = Nrt && Nrt()),
                    (this.startRotationZ = Lrt && Lrt()),
                    (this.startDelay = Brt && Brt()),
                    (this.startLifetime = Frt && Frt()),
                    (this.duration = Urt && Urt()),
                    (this.loop = krt && krt()),
                    (this.simulationSpeed = zrt && zrt()),
                    (this.playOnAwake = Hrt && Hrt()),
                    (this.gravityModifier = Grt && Grt()),
                    (this.rateOverTime = Vrt && Vrt()),
                    (this.rateOverDistance = jrt && jrt()),
                    (this.bursts = Wrt && Wrt()),
                    (this._renderCulling = Xrt && Xrt()),
                    (this._cullingMode = Yrt && Yrt()),
                    (this._aabbHalfX = Krt && Krt()),
                    (this._aabbHalfY = qrt && qrt()),
                    (this._aabbHalfZ = $rt && $rt()),
                    (this._dataCulling = Zrt && Zrt()),
                    (this._colorOverLifetimeModule = Qrt && Qrt()),
                    (this._shapeModule = Jrt && Jrt()),
                    (this._sizeOvertimeModule = tat && tat()),
                    (this._velocityOvertimeModule = eat && eat()),
                    (this._forceOvertimeModule = iat && iat()),
                    (this._limitVelocityOvertimeModule = sat && sat()),
                    (this._rotationOvertimeModule = nat && nat()),
                    (this._textureAnimationModule = rat && rat()),
                    (this._noiseModule = aat && aat()),
                    (this._trailModule = oat && oat()),
                    (this.renderer = hat && hat()),
                    (this._isPlaying = void 0),
                    (this._isPaused = void 0),
                    (this._isStopped = void 0),
                    (this._isEmitting = void 0),
                    (this._needToRestart = void 0),
                    (this._needRefresh = void 0),
                    (this._time = void 0),
                    (this._emitRateTimeCounter = void 0),
                    (this._emitRateDistanceCounter = void 0),
                    (this._oldWPos = void 0),
                    (this._curWPos = void 0),
                    (this._boundingBox = void 0),
                    (this._culler = void 0),
                    (this._oldPos = void 0),
                    (this._curPos = void 0),
                    (this._isCulled = void 0),
                    (this._isSimulating = void 0),
                    (this._customData1 = void 0),
                    (this._customData2 = void 0),
                    (this._subEmitters = void 0),
                    (this._needAttach = void 0),
                    (this._prewarm = lat && lat()),
                    (this._capacity = cat && cat()),
                    (this._simulationSpace = uat && uat()),
                    (this.processor = null),
                    (this.rateOverTime.constant = 10),
                    (this.startLifetime.constant = 5),
                    (this.startSizeX.constant = 1),
                    (this.startSpeed.constant = 5),
                    (this._isPlaying = !1),
                    (this._isPaused = !1),
                    (this._isStopped = !0),
                    (this._isEmitting = !1),
                    (this._needToRestart = !1),
                    (this._needRefresh = !0),
                    (this._needAttach = !1),
                    (this._time = 0),
                    (this._emitRateTimeCounter = 0),
                    (this._emitRateDistanceCounter = 0),
                    (this._oldWPos = new Yi()),
                    (this._curWPos = new Yi()),
                    (this._boundingBox = null),
                    (this._culler = null),
                    (this._oldPos = null),
                    (this._curPos = null),
                    (this._isCulled = !1),
                    (this._isSimulating = !0),
                    (this._customData1 = new Ss()),
                    (this._customData2 = new Ss()),
                    (this._subEmitters = []);
                }
                onFocusInEditor() {
                  this.renderer.create(this);
                }
                onLoad() {
                  this.renderer.onInit(this),
                    this._shapeModule && this._shapeModule.onInit(this),
                    this._trailModule &&
                      !this.renderer.useGPU &&
                      this._trailModule.enable &&
                      this._trailModule.onInit(this),
                    this.bindModule(),
                    this._resetPosition();
                }
                _onMaterialModified(t, e) {
                  null !== this.processor &&
                    this.processor.onMaterialModified(t, e);
                }
                _onRebuildPSO(t, e) {
                  this.processor.onRebuildPSO(t, e);
                }
                _collectModels() {
                  return (
                    (this._models.length = 0),
                    this._models.push(this.processor.model),
                    this._trailModule &&
                      this._trailModule.enable &&
                      this._trailModule.getModel() &&
                      this._models.push(this._trailModule.getModel()),
                    this._models
                  );
                }
                _attachToScene() {
                  this.processor.attachToScene(),
                    this._trailModule &&
                      this._trailModule.enable &&
                      this._trailModule._attachToScene();
                }
                _detachFromScene() {
                  this.processor.detachFromScene(),
                    this._trailModule &&
                      this._trailModule.enable &&
                      this._trailModule._detachFromScene(),
                    this._boundingBox && (this._boundingBox = null),
                    this._culler &&
                      (this._culler.clear(),
                      this._culler.destroy(),
                      (this._culler = null));
                }
                bindModule() {
                  this._colorOverLifetimeModule &&
                    this._colorOverLifetimeModule.bindTarget(this.processor),
                    this._sizeOvertimeModule &&
                      this._sizeOvertimeModule.bindTarget(this.processor),
                    this._rotationOvertimeModule &&
                      this._rotationOvertimeModule.bindTarget(this.processor),
                    this._forceOvertimeModule &&
                      this._forceOvertimeModule.bindTarget(this.processor),
                    this._limitVelocityOvertimeModule &&
                      this._limitVelocityOvertimeModule.bindTarget(
                        this.processor
                      ),
                    this._velocityOvertimeModule &&
                      this._velocityOvertimeModule.bindTarget(this.processor),
                    this._textureAnimationModule &&
                      this._textureAnimationModule.bindTarget(this.processor),
                    this._noiseModule &&
                      this._noiseModule.bindTarget(this.processor);
                }
                play() {
                  if (
                    (this._needToRestart &&
                      (this.reset(), (this._needToRestart = !1)),
                    this._isPaused && (this._isPaused = !1),
                    this._isStopped && (this._isStopped = !1),
                    (this._isPlaying = !0),
                    (this._isEmitting = !0),
                    this._resetPosition(),
                    this._prewarm && this._prewarmSystem(),
                    this._trailModule && this._trailModule.play(),
                    this.processor)
                  ) {
                    const t = this.processor.getModel();
                    t && (t.enabled = this.enabledInHierarchy);
                  }
                }
                pause() {
                  this._isStopped
                    ? w("pause(): particle system is already stopped.")
                    : (this._isPlaying && (this._isPlaying = !1),
                      (this._isPaused = !0));
                }
                stopEmitting() {
                  (this._isEmitting = !1), (this._needToRestart = !0);
                }
                stop() {
                  (this._isPlaying || this._isPaused) && this.clear(),
                    this._isPlaying && (this._isPlaying = !1),
                    this._isPaused && (this._isPaused = !1),
                    this._isEmitting && (this._isEmitting = !1),
                    (this._isStopped = !0),
                    (this._needRefresh = !0),
                    this.reset();
                }
                reset() {
                  (this._time = 0),
                    (this._emitRateTimeCounter = 0),
                    (this._emitRateDistanceCounter = 0),
                    this._resetPosition();
                  for (const t of this.bursts) t.reset();
                }
                clear() {
                  this.enabledInHierarchy &&
                    (this.processor.clear(),
                    this._trailModule && this._trailModule.clear()),
                    this._calculateBounding(!1);
                }
                getParticleCount() {
                  return this.processor ? this.processor.getParticleCount() : 0;
                }
                setCustomData1(t, e) {
                  Ss.set(this._customData1, t, e);
                }
                setCustomData2(t, e) {
                  Ss.set(this._customData2, t, e);
                }
                onDestroy() {
                  var t;
                  this.stop(),
                    null !== (t = this.processor.getModel()) &&
                      void 0 !== t &&
                      t.scene &&
                      (this.processor.detachFromScene(),
                      this._trailModule &&
                        this._trailModule.enable &&
                        this._trailModule._detachFromScene()),
                    a.director.off(
                      a.Director.EVENT_BEFORE_COMMIT,
                      this.beforeRender,
                      this
                    ),
                    this.processor.onDestroy(),
                    this._trailModule && this._trailModule.destroy(),
                    this._culler &&
                      (this._culler.clear(),
                      this._culler.destroy(),
                      (this._culler = null));
                }
                onEnable() {
                  super.onEnable(),
                    a.director.on(
                      a.Director.EVENT_BEFORE_COMMIT,
                      this.beforeRender,
                      this
                    ),
                    this.playOnAwake && this.play(),
                    this.processor.onEnable(),
                    this._trailModule && this._trailModule.onEnable();
                }
                onDisable() {
                  a.director.off(
                    a.Director.EVENT_BEFORE_COMMIT,
                    this.beforeRender,
                    this
                  ),
                    this.processor.onDisable(),
                    this._trailModule && this._trailModule.onDisable(),
                    this._boundingBox && (this._boundingBox = null),
                    (this._oldPos = null),
                    this._culler &&
                      (this._culler.clear(),
                      this._culler.destroy(),
                      (this._culler = null));
                }
                _calculateBounding(t) {
                  this._boundingBox &&
                    (this._culler || (this._culler = new Wst(this)),
                    this._culler.calculatePositions(),
                    Kr.fromPoints(
                      this._boundingBox,
                      this._culler.minPos,
                      this._culler.maxPos
                    ),
                    t
                      ? ((this.aabbHalfX = this._boundingBox.halfExtents.x),
                        (this.aabbHalfY = this._boundingBox.halfExtents.y),
                        (this.aabbHalfZ = this._boundingBox.halfExtents.z))
                      : (this.aabbHalfX
                          ? this.setBoundingX(this.aabbHalfX)
                          : (this.aabbHalfX = this._boundingBox.halfExtents.x),
                        this.aabbHalfY
                          ? this.setBoundingY(this.aabbHalfY)
                          : (this.aabbHalfY = this._boundingBox.halfExtents.y),
                        this.aabbHalfZ
                          ? this.setBoundingZ(this.aabbHalfZ)
                          : (this.aabbHalfZ = this._boundingBox.halfExtents.z)),
                    this._culler.clear());
                }
                update(t) {
                  const e = t * this.simulationSpeed;
                  if (this.renderCulling) {
                    var i;
                    if (
                      (this._boundingBox ||
                        ((this._boundingBox = new Kr()),
                        this._calculateBounding(!1)),
                      this._curPos || (this._curPos = new Yi()),
                      this.node.getWorldPosition(this._curPos),
                      this._oldPos ||
                        ((this._oldPos = new Yi()),
                        this._oldPos.set(this._curPos)),
                      !this._curPos.equals(this._oldPos) &&
                        this._boundingBox &&
                        this._culler)
                    ) {
                      const t = this._curPos.x - this._oldPos.x,
                        e = this._curPos.y - this._oldPos.y,
                        i = this._curPos.z - this._oldPos.z,
                        s = this._boundingBox.center;
                      (s.x += t),
                        (s.y += e),
                        (s.z += i),
                        this._culler.setBoundingBoxCenter(s.x, s.y, s.z),
                        this._oldPos.set(this._curPos);
                    }
                    const t =
                      null === (i = this.node.scene.renderScene) || void 0 === i
                        ? void 0
                        : i.cameras;
                    let s = !0;
                    if (void 0 !== t && this._boundingBox)
                      for (let e = 0; e < t.length; ++e) {
                        const i = t[e];
                        if (
                          (i.visibility & this.node.layer) ===
                            this.node.layer &&
                          Bn.aabbFrustum(this._boundingBox, i.frustum)
                        ) {
                          s = !1;
                          break;
                        }
                      }
                    if (s) {
                      if (
                        (this._cullingMode !== k7.AlwaysSimulate &&
                          (this._isSimulating = !1),
                        this._isCulled ||
                          (this.processor.detachFromScene(),
                          (this._isCulled = !0)),
                        this._trailModule &&
                          this._trailModule.enable &&
                          this._trailModule._detachFromScene(),
                        this._cullingMode === k7.PauseAndCatchup &&
                          (this._time += e),
                        this._cullingMode !== k7.AlwaysSimulate)
                      )
                        return;
                    } else
                      this._isCulled &&
                        (this._attachToScene(), (this._isCulled = !1)),
                        this._isSimulating || (this._isSimulating = !0);
                    if (!this._isSimulating) return;
                  } else
                    this._boundingBox && (this._boundingBox = null),
                      this._culler &&
                        (this._culler.clear(),
                        this._culler.destroy(),
                        (this._culler = null)),
                      (this._isSimulating = !0);
                  if (this._isPlaying)
                    (this._time += e),
                      this._emit(e),
                      0 !== this.processor.updateParticles(e) ||
                        this._isEmitting ||
                        this.stop();
                  else {
                    const t = (
                      this.getMaterialInstance(0) ||
                      this.processor.getDefaultMaterial()
                    ).passes[0];
                    this.processor.updateRotation(t),
                      this.processor.updateScale(t);
                  }
                  var s, n;
                  this._needAttach &&
                    this.getParticleCount() > 0 &&
                    !this._isCulled &&
                    ((null !== (s = this.processor.getModel()) &&
                      void 0 !== s &&
                      s.scene) ||
                      this.processor.attachToScene(),
                    this._trailModule &&
                      this._trailModule.enable &&
                      ((null !== (n = this._trailModule.getModel()) &&
                        void 0 !== n &&
                        n.scene) ||
                        this._trailModule._attachToScene()),
                    (this._needAttach = !1));
                  !this.renderer.useGPU &&
                    this._trailModule &&
                    this._trailModule.enable &&
                    (this._trailModule.inited ||
                      (this._trailModule.clear(),
                      this._trailModule.destroy(),
                      this._trailModule.onInit(this),
                      (this._trailModule.enable = !1),
                      (this._trailModule.enable = !0)));
                }
                beforeRender() {
                  var t, e;
                  this.getParticleCount() <= 0
                    ? null !== (e = this.processor.getModel()) &&
                      void 0 !== e &&
                      e.scene &&
                      (this.processor.detachFromScene(),
                      this._trailModule &&
                        this._trailModule.enable &&
                        this._trailModule._detachFromScene(),
                      (this._needAttach = !1))
                    : (null !== (t = this.processor.getModel()) &&
                        void 0 !== t &&
                        t.scene) ||
                      (this._needAttach = !0),
                    this._isPlaying &&
                      (this.processor.updateRenderData(),
                      this.processor.beforeRender(),
                      this._trailModule &&
                        this._trailModule.enable &&
                        (this._trailModule.updateRenderData(),
                        this._trailModule.beforeRender()));
                }
                _onVisibilityChange(t) {
                  this.processor.model && (this.processor.model.visFlags = t);
                }
                emit(t, e) {
                  const i = (this._time % this.duration) / this.duration;
                  this._needRefresh &&
                    (this.node.invalidateChildren(Cf.POSITION),
                    (this._needRefresh = !1)),
                    this._simulationSpace === U7.World &&
                      (this.node.getWorldMatrix(dat),
                      this.node.getWorldRotation(pat));
                  for (let s = 0; s < t; ++s) {
                    const t = this.processor.getFreeParticle();
                    if (null === t) return;
                    (t.particleSystem = this), t.reset();
                    const s = Ri(wi(0, l));
                    this._shapeModule && this._shapeModule.enable
                      ? this._shapeModule.emit(t)
                      : (Yi.set(t.position, 0, 0, 0), Yi.copy(t.velocity, Y7)),
                      this._textureAnimationModule &&
                        this._textureAnimationModule.enable &&
                        this._textureAnimationModule.init(t);
                    const n = this.startSpeed.evaluate(i, s);
                    Yi.multiplyScalar(t.velocity, t.velocity, n),
                      this._simulationSpace === U7.World &&
                        (Yi.transformMat4(t.position, t.position, dat),
                        Yi.transformQuat(t.velocity, t.velocity, pat)),
                      Yi.copy(t.ultimateVelocity, t.velocity),
                      this.startRotation3D
                        ? t.startEuler.set(
                            this.startRotationX.evaluate(i, s),
                            this.startRotationY.evaluate(i, s),
                            this.startRotationZ.evaluate(i, s)
                          )
                        : t.startEuler.set(
                            0,
                            0,
                            this.startRotationZ.evaluate(i, s)
                          ),
                      t.rotation.set(t.startEuler),
                      this.startSize3D
                        ? Yi.set(
                            t.startSize,
                            this.startSizeX.evaluate(i, s),
                            this.startSizeY.evaluate(i, s),
                            this.startSizeZ.evaluate(i, s)
                          )
                        : (Yi.set(
                            t.startSize,
                            this.startSizeX.evaluate(i, s),
                            1,
                            1
                          ),
                          (t.startSize.y = t.startSize.x)),
                      Yi.copy(t.size, t.startSize),
                      t.startColor.set(this.startColor.evaluate(i, s)),
                      t.color.set(t.startColor),
                      (t.startLifetime = this.startLifetime.evaluate(i, s) + e),
                      (t.remainingLifetime = t.startLifetime),
                      (t.randomSeed = wi(0, 233280)),
                      t.loopCount++,
                      this.processor.setNewParticle(t);
                  }
                }
                _prewarmSystem() {
                  (this.startDelay.mode = U8.Constant),
                    (this.startDelay.constant = 0);
                  const t = this.duration / 1;
                  for (let e = 0; e < t; ++e)
                    (this._time += 1),
                      this._emit(1),
                      this.processor.updateParticles(1);
                }
                _emit(t) {
                  const e = this.startDelay.evaluate(0, 1);
                  if (this._time > e) {
                    if (
                      (this._time > this.duration + e &&
                        (this.loop || (this._isEmitting = !1)),
                      !this._isEmitting)
                    )
                      return;
                    if (
                      ((this._emitRateTimeCounter +=
                        this.rateOverTime.evaluate(
                          this._time / this.duration,
                          1
                        ) * t),
                      this._emitRateTimeCounter > 1)
                    ) {
                      const e = Math.floor(this._emitRateTimeCounter);
                      (this._emitRateTimeCounter -= e), this.emit(e, t);
                    }
                    const i = this.rateOverDistance.evaluate(
                      this._time / this.duration,
                      1
                    );
                    if (i > 0) {
                      Yi.copy(this._oldWPos, this._curWPos),
                        this.node.getWorldPosition(this._curWPos);
                      const t = Yi.distance(this._curWPos, this._oldWPos);
                      this._emitRateDistanceCounter += t * i;
                    }
                    if (this._emitRateDistanceCounter > 1) {
                      const e = Math.floor(this._emitRateDistanceCounter);
                      (this._emitRateDistanceCounter -= e), this.emit(e, t);
                    }
                    for (const e of this.bursts) e.update(this, t);
                  }
                }
                _resetPosition() {
                  this.node.getWorldPosition(this._oldWPos),
                    Yi.copy(this._curWPos, this._oldWPos);
                }
                addSubEmitter(t) {
                  this._subEmitters.push(t);
                }
                removeSubEmitter(t) {
                  this._subEmitters.splice(this._subEmitters.indexOf(t), 1);
                }
                addBurst(t) {
                  this.bursts.push(t);
                }
                removeBurst(t) {
                  const e = this.bursts.indexOf(t);
                  e > -1 && this.bursts.splice(e, 1);
                }
                getBoundingX() {
                  return this._aabbHalfX;
                }
                getBoundingY() {
                  return this._aabbHalfY;
                }
                getBoundingZ() {
                  return this._aabbHalfZ;
                }
                setBoundingX(t) {
                  this._boundingBox &&
                    this._culler &&
                    ((this._boundingBox.halfExtents.x = t),
                    this._culler.setBoundingBoxSize(
                      this._boundingBox.halfExtents
                    ),
                    (this._aabbHalfX = t));
                }
                setBoundingY(t) {
                  this._boundingBox &&
                    this._culler &&
                    ((this._boundingBox.halfExtents.y = t),
                    this._culler.setBoundingBoxSize(
                      this._boundingBox.halfExtents
                    ),
                    (this._aabbHalfY = t));
                }
                setBoundingZ(t) {
                  this._boundingBox &&
                    this._culler &&
                    ((this._boundingBox.halfExtents.z = t),
                    this._culler.setBoundingBoxSize(
                      this._boundingBox.halfExtents
                    ),
                    (this._aabbHalfZ = t));
                }
                get isPlaying() {
                  return this._isPlaying;
                }
                get isPaused() {
                  return this._isPaused;
                }
                get isStopped() {
                  return this._isStopped;
                }
                get isEmitting() {
                  return this._isEmitting;
                }
                get time() {
                  return this._time;
                }
                _onBeforeSerialize(t) {
                  return this.dataCulling
                    ? t.filter(
                        (t) => !B7.includes(t) || (this[t] && this[t].enable)
                      )
                    : t;
                }
                getNoisePreview(t, e) {
                  const i = [];
                  return (
                    this.processor && this.processor.getNoisePreview(i, t, e), i
                  );
                }
              }).CullingMode = k7),
              (Crt = fa(
                (Art = _at).prototype,
                "startColor",
                [Mnt, Na],
                function () {
                  return new l7();
                }
              )),
              (Ort = fa(Art.prototype, "scaleSpace", [Pnt, Na], function () {
                return U7.Local;
              })),
              (Irt = fa(Art.prototype, "startSize3D", [Na], function () {
                return !1;
              })),
              (wrt = fa(Art.prototype, "startSizeX", [Nnt, Lnt], function () {
                return new k8();
              })),
              (Rrt = fa(Art.prototype, "startSizeY", [Bnt, Na], function () {
                return new k8();
              })),
              (Drt = fa(Art.prototype, "startSizeZ", [Fnt, Na], function () {
                return new k8();
              })),
              (xrt = fa(Art.prototype, "startSpeed", [Unt, Na], function () {
                return new k8();
              })),
              (Mrt = fa(Art.prototype, "startRotation3D", [Na], function () {
                return !1;
              })),
              (Prt = fa(
                Art.prototype,
                "startRotationX",
                [knt, Na],
                function () {
                  return new k8();
                }
              )),
              (Nrt = fa(
                Art.prototype,
                "startRotationY",
                [znt, Na],
                function () {
                  return new k8();
                }
              )),
              (Lrt = fa(
                Art.prototype,
                "startRotationZ",
                [Hnt, Gnt],
                function () {
                  return new k8();
                }
              )),
              (Brt = fa(Art.prototype, "startDelay", [Vnt, Na], function () {
                return new k8();
              })),
              (Frt = fa(Art.prototype, "startLifetime", [jnt, Na], function () {
                return new k8();
              })),
              (Urt = fa(Art.prototype, "duration", [Na], function () {
                return 5;
              })),
              (krt = fa(Art.prototype, "loop", [Na], function () {
                return !0;
              })),
              s(
                Art.prototype,
                "simulationSpace",
                [Wnt, Na],
                Object.getOwnPropertyDescriptor(
                  Art.prototype,
                  "simulationSpace"
                ),
                Art.prototype
              ),
              (zrt = fa(Art.prototype, "simulationSpeed", [Na], function () {
                return 1;
              })),
              (Hrt = fa(Art.prototype, "playOnAwake", [Na], function () {
                return !0;
              })),
              (Grt = fa(
                Art.prototype,
                "gravityModifier",
                [Xnt, Na],
                function () {
                  return new k8();
                }
              )),
              (Vrt = fa(Art.prototype, "rateOverTime", [Ynt, Na], function () {
                return new k8();
              })),
              (jrt = fa(
                Art.prototype,
                "rateOverDistance",
                [Knt, Na],
                function () {
                  return new k8();
                }
              )),
              (Wrt = fa(Art.prototype, "bursts", [qnt, Na], function () {
                return [];
              })),
              s(
                Art.prototype,
                "renderCulling",
                [$nt],
                Object.getOwnPropertyDescriptor(Art.prototype, "renderCulling"),
                Art.prototype
              ),
              (Xrt = fa(Art.prototype, "_renderCulling", [Na], function () {
                return !1;
              })),
              s(
                Art.prototype,
                "cullingMode",
                [Znt],
                Object.getOwnPropertyDescriptor(Art.prototype, "cullingMode"),
                Art.prototype
              ),
              (Yrt = fa(Art.prototype, "_cullingMode", [Na], function () {
                return k7.Pause;
              })),
              s(
                Art.prototype,
                "aabbHalfX",
                [Qnt],
                Object.getOwnPropertyDescriptor(Art.prototype, "aabbHalfX"),
                Art.prototype
              ),
              (Krt = fa(Art.prototype, "_aabbHalfX", [Na], function () {
                return 0;
              })),
              s(
                Art.prototype,
                "aabbHalfY",
                [Jnt],
                Object.getOwnPropertyDescriptor(Art.prototype, "aabbHalfY"),
                Art.prototype
              ),
              (qrt = fa(Art.prototype, "_aabbHalfY", [Na], function () {
                return 0;
              })),
              s(
                Art.prototype,
                "aabbHalfZ",
                [trt],
                Object.getOwnPropertyDescriptor(Art.prototype, "aabbHalfZ"),
                Art.prototype
              ),
              ($rt = fa(Art.prototype, "_aabbHalfZ", [Na], function () {
                return 0;
              })),
              (Zrt = fa(Art.prototype, "_dataCulling", [Na, ert], function () {
                return !1;
              })),
              s(
                Art.prototype,
                "sharedMaterials",
                [oo, Na],
                Object.getOwnPropertyDescriptor(
                  Art.prototype,
                  "sharedMaterials"
                ),
                Art.prototype
              ),
              (Qrt = fa(
                Art.prototype,
                "_colorOverLifetimeModule",
                [irt],
                function () {
                  return null;
                }
              )),
              s(
                Art.prototype,
                "colorOverLifetimeModule",
                [srt],
                Object.getOwnPropertyDescriptor(
                  Art.prototype,
                  "colorOverLifetimeModule"
                ),
                Art.prototype
              ),
              (Jrt = fa(Art.prototype, "_shapeModule", [nrt], function () {
                return null;
              })),
              s(
                Art.prototype,
                "shapeModule",
                [rrt],
                Object.getOwnPropertyDescriptor(Art.prototype, "shapeModule"),
                Art.prototype
              ),
              (tat = fa(
                Art.prototype,
                "_sizeOvertimeModule",
                [art],
                function () {
                  return null;
                }
              )),
              s(
                Art.prototype,
                "sizeOvertimeModule",
                [ort],
                Object.getOwnPropertyDescriptor(
                  Art.prototype,
                  "sizeOvertimeModule"
                ),
                Art.prototype
              ),
              (eat = fa(
                Art.prototype,
                "_velocityOvertimeModule",
                [hrt],
                function () {
                  return null;
                }
              )),
              s(
                Art.prototype,
                "velocityOvertimeModule",
                [lrt],
                Object.getOwnPropertyDescriptor(
                  Art.prototype,
                  "velocityOvertimeModule"
                ),
                Art.prototype
              ),
              (iat = fa(
                Art.prototype,
                "_forceOvertimeModule",
                [crt],
                function () {
                  return null;
                }
              )),
              s(
                Art.prototype,
                "forceOvertimeModule",
                [urt],
                Object.getOwnPropertyDescriptor(
                  Art.prototype,
                  "forceOvertimeModule"
                ),
                Art.prototype
              ),
              (sat = fa(
                Art.prototype,
                "_limitVelocityOvertimeModule",
                [_rt],
                function () {
                  return null;
                }
              )),
              s(
                Art.prototype,
                "limitVelocityOvertimeModule",
                [drt],
                Object.getOwnPropertyDescriptor(
                  Art.prototype,
                  "limitVelocityOvertimeModule"
                ),
                Art.prototype
              ),
              (nat = fa(
                Art.prototype,
                "_rotationOvertimeModule",
                [prt],
                function () {
                  return null;
                }
              )),
              s(
                Art.prototype,
                "rotationOvertimeModule",
                [mrt],
                Object.getOwnPropertyDescriptor(
                  Art.prototype,
                  "rotationOvertimeModule"
                ),
                Art.prototype
              ),
              (rat = fa(
                Art.prototype,
                "_textureAnimationModule",
                [frt],
                function () {
                  return null;
                }
              )),
              s(
                Art.prototype,
                "textureAnimationModule",
                [grt],
                Object.getOwnPropertyDescriptor(
                  Art.prototype,
                  "textureAnimationModule"
                ),
                Art.prototype
              ),
              (aat = fa(Art.prototype, "_noiseModule", [yrt], function () {
                return null;
              })),
              s(
                Art.prototype,
                "noiseModule",
                [Trt],
                Object.getOwnPropertyDescriptor(Art.prototype, "noiseModule"),
                Art.prototype
              ),
              (oat = fa(Art.prototype, "_trailModule", [Srt], function () {
                return null;
              })),
              s(
                Art.prototype,
                "trailModule",
                [Ert],
                Object.getOwnPropertyDescriptor(Art.prototype, "trailModule"),
                Art.prototype
              ),
              (hat = fa(Art.prototype, "renderer", [vrt, Na], function () {
                return new ost();
              })),
              (lat = fa(Art.prototype, "_prewarm", [Na], function () {
                return !1;
              })),
              (cat = fa(Art.prototype, "_capacity", [Na], function () {
                return 100;
              })),
              (uat = fa(Art.prototype, "_simulationSpace", [Na], function () {
                return U7.Local;
              })),
              (brt = Art))
            ) || brt)
        ) || brt);
      t({ ParticleSystem: fat, ParticleSystemComponent: fat });
      class gat {
        static instantiate(t) {
          this.registeredSceneEvent ||
            (Lv.on(Nv.EVENT_BEFORE_SCENE_LAUNCH, this.onSceneUnload, this),
            (this.registeredSceneEvent = !0));
          const e = t._uuid;
          if (!this.particleSystemPool.has(e)) {
            const i = new Wn(
              () => Jj(t) || new Pf(),
              1,
              (t) => t.destroy()
            );
            this.particleSystemPool.set(e, i);
          }
          return this.particleSystemPool.get(e).alloc();
        }
        static destroy(t) {
          var e, i;
          const s =
            null === (e = t.prefab) ||
            void 0 === e ||
            null === (i = e.asset) ||
            void 0 === i
              ? void 0
              : i.uuid;
          s &&
            this.particleSystemPool.has(s) &&
            (this.stop(t), this.particleSystemPool.get(s).free(t));
        }
        static play(t) {
          for (const e of t.getComponentsInChildren(fat)) e.play();
        }
        static stop(t) {
          for (const e of t.getComponentsInChildren(fat)) e.stop();
        }
        static onSceneUnload() {
          this.particleSystemPool.forEach((t) => t.destroy()),
            this.particleSystemPool.clear();
        }
      }
      t("ParticleUtils", gat),
        (gat.particleSystemPool = new Map()),
        (gat.registeredSceneEvent = !1),
        Z(get.prototype, "Burst.prototype", [
          { name: "minCount" },
          { name: "maxCount" },
        ]),
        $(fat.prototype, "ParticleSystem.prototype", [
          { name: "enableCulling", newName: "dataCulling" },
        ]),
        (a.ParticleSystemComponent = fat),
        Vt(fat, "cc.ParticleSystemComponent"),
        (a.BillboardComponent = R8),
        Vt(R8, "cc.BillboardComponent"),
        (a.LineComponent = M7),
        Vt(M7, "cc.LineComponent"),
        (a.ParticleUtils = gat);
      const yat = ce({ GRAVITY: 0, RADIUS: 1 }),
        Tat = ce({ FREE: 0, RELATIVE: 1, GROUPED: 2 }),
        Sat = new Ss(0, 0),
        Eat = new Ss(),
        vat = new Ss(),
        bat = new Ss(),
        Aat = new Ss(),
        Cat = new Wi(),
        Oat = FO(PO);
      class Iat {
        constructor() {
          (this.pos = new Ss(0, 0)),
            (this.startPos = new Ss(0, 0)),
            (this.color = new Qi(0, 0, 0, 255)),
            (this.deltaColor = { r: 0, g: 0, b: 0, a: 255 }),
            (this.size = 0),
            (this.deltaSize = 0),
            (this.rotation = 0),
            (this.deltaRotation = 0),
            (this.timeToLive = 0),
            (this.drawPos = new Ss(0, 0)),
            (this.aspectRatio = 1),
            (this.dir = new Ss(0, 0)),
            (this.radialAccel = 0),
            (this.tangentialAccel = 0),
            (this.angle = 0),
            (this.degreesPerSecond = 0),
            (this.radius = 0),
            (this.deltaRadius = 0);
        }
      }
      const wat = new (class extends $t {
        get() {
          return this._get() || new Iat();
        }
      })((t) => {
        t.pos.set(Sat),
          t.startPos.set(Sat),
          t.color.set(0, 0, 0, 255),
          (t.deltaColor.r = t.deltaColor.g = t.deltaColor.b = 0),
          (t.deltaColor.a = 255),
          (t.size = 0),
          (t.deltaSize = 0),
          (t.rotation = 0),
          (t.deltaRotation = 0),
          (t.timeToLive = 0),
          t.drawPos.set(Sat),
          (t.aspectRatio = 1),
          t.dir.set(Sat),
          (t.radialAccel = 0),
          (t.tangentialAccel = 0),
          (t.angle = 0),
          (t.degreesPerSecond = 0),
          (t.radius = 0),
          (t.deltaRadius = 0);
      }, 1024);
      class Rat {
        constructor(t) {
          (this.particles = []),
            (this.active = !1),
            (this.uvFilled = 0),
            (this.finished = !1),
            (this.readyToPlay = !0),
            (this.elapsed = 0),
            (this.emitCounter = 0),
            (this._worldRotation = 0),
            (this.sys = t),
            (this.particles = []),
            (this.active = !1),
            (this.readyToPlay = !0),
            (this.finished = !1),
            (this.elapsed = 0),
            (this.emitCounter = 0),
            (this.uvFilled = 0),
            (this._worldRotation = 0);
        }
        stop() {
          (this.active = !1),
            (this.readyToPlay = !1),
            (this.elapsed = this.sys.duration),
            (this.emitCounter = 0);
        }
        reset() {
          (this.active = !0),
            (this.readyToPlay = !0),
            (this.elapsed = 0),
            (this.emitCounter = 0),
            (this.finished = !1);
          const t = this.particles;
          for (let e = 0; e < t.length; ++e) wat.put(t[e]);
          (t.length = 0), this.renderData && this.renderData.resize(0, 0);
        }
        emitParticle(t) {
          const e = this.sys,
            i = wat.get();
          this.particles.push(i),
            (i.timeToLive = e.life + e.lifeVar * (Ci() - 0.5) * 2);
          const s = (i.timeToLive = Math.max(0, i.timeToLive));
          (i.pos.x = e.sourcePos.x + e.posVar.x * (Ci() - 0.5) * 2),
            (i.pos.y = e.sourcePos.y + e.posVar.y * (Ci() - 0.5) * 2);
          let n = 0,
            r = 0,
            a = 0,
            o = 0;
          const h = e.startColor,
            l = e.startColorVar,
            c = e.endColor,
            u = e.endColorVar;
          (i.color.r = n = Re(h.r + l.r * (Ci() - 0.5) * 2, 0, 255)),
            (i.color.g = r = Re(h.g + l.g * (Ci() - 0.5) * 2, 0, 255)),
            (i.color.b = a = Re(h.b + l.b * (Ci() - 0.5) * 2, 0, 255)),
            (i.color.a = o = Re(h.a + l.a * (Ci() - 0.5) * 2, 0, 255)),
            (i.deltaColor.r =
              (Re(c.r + u.r * (Ci() - 0.5) * 2, 0, 255) - n) / s),
            (i.deltaColor.g =
              (Re(c.g + u.g * (Ci() - 0.5) * 2, 0, 255) - r) / s),
            (i.deltaColor.b =
              (Re(c.b + u.b * (Ci() - 0.5) * 2, 0, 255) - a) / s),
            (i.deltaColor.a =
              (Re(c.a + u.a * (Ci() - 0.5) * 2, 0, 255) - o) / s);
          let _ = e.startSize + e.startSizeVar * (Ci() - 0.5) * 2;
          if (((_ = Math.max(0, _)), (i.size = _), -1 === e.endSize))
            i.deltaSize = 0;
          else {
            let t = e.endSize + e.endSizeVar * (Ci() - 0.5) * 2;
            (t = Math.max(0, t)), (i.deltaSize = (t - _) / s);
          }
          const d = e.startSpin + e.startSpinVar * (Ci() - 0.5) * 2,
            p = e.endSpin + e.endSpinVar * (Ci() - 0.5) * 2;
          (i.rotation = d),
            (i.deltaRotation = (p - d) / s),
            (i.startPos.x = t.x),
            (i.startPos.y = t.y),
            (i.aspectRatio = e.aspectRatio || 1);
          const m = De(
            e.angle + this._worldRotation + e.angleVar * (Ci() - 0.5) * 2
          );
          if (e.emitterMode === yat.GRAVITY) {
            const t = e.speed + e.speedVar * (Ci() - 0.5) * 2;
            (i.dir.x = Math.cos(m)),
              (i.dir.y = Math.sin(m)),
              i.dir.multiplyScalar(t),
              (i.radialAccel =
                e.radialAccel + e.radialAccelVar * (Ci() - 0.5) * 2),
              (i.tangentialAccel =
                e.tangentialAccel + e.tangentialAccelVar * (Ci() - 0.5) * 2),
              e.rotationIsDir &&
                (i.rotation = -xe(Math.atan2(i.dir.y, i.dir.x)));
          } else {
            const t = e.startRadius + e.startRadiusVar * (Ci() - 0.5) * 2,
              n = e.endRadius + e.endRadiusVar * (Ci() - 0.5) * 2;
            (i.radius = t),
              (i.deltaRadius = -1 === e.endRadius ? 0 : (n - t) / s),
              (i.angle = m),
              (i.degreesPerSecond = De(
                e.rotatePerS + e.rotatePerSVar * (Ci() - 0.5) * 2
              ));
          }
        }
        updateUVs(t) {
          const e = this.renderData;
          if (e && this.sys._renderSpriteFrame) {
            const i = e.vData,
              s = this.sys._renderSpriteFrame.uv,
              n = t ? 0 : this.uvFilled,
              r = this.particles.length;
            for (let t = n; t < r; t++) {
              const e = t * Oat * 4;
              (i[e + 3] = s[0]),
                (i[e + 4] = s[1]),
                (i[e + 12] = s[2]),
                (i[e + 13] = s[3]),
                (i[e + 21] = s[4]),
                (i[e + 22] = s[5]),
                (i[e + 30] = s[6]),
                (i[e + 31] = s[7]);
            }
            this.uvFilled = r;
          }
        }
        updateParticleBuffer(t, e, i, s) {
          const n = i.vData,
            r = e.x,
            a = e.y;
          let o = t.size,
            h = o;
          const l = t.aspectRatio;
          l > 1 ? (h = o / l) : (o = h * l);
          const c = o / 2,
            u = h / 2;
          if (t.rotation) {
            const e = -c,
              i = -u,
              o = c,
              h = u,
              l = -De(t.rotation),
              _ = Math.cos(l),
              d = Math.sin(l);
            (n[s] = e * _ - i * d + r),
              (n[s + 1] = e * d + i * _ + a),
              (n[s + 2] = 0),
              (n[s + 9] = o * _ - i * d + r),
              (n[s + 10] = o * d + i * _ + a),
              (n[s + 11] = 0),
              (n[s + 18] = e * _ - h * d + r),
              (n[s + 19] = e * d + h * _ + a),
              (n[s + 20] = 0),
              (n[s + 27] = o * _ - h * d + r),
              (n[s + 28] = o * d + h * _ + a),
              (n[s + 29] = 0);
          } else
            (n[s] = r - c),
              (n[s + 1] = a - u),
              (n[s + 2] = 0),
              (n[s + 9] = r + c),
              (n[s + 10] = a - u),
              (n[s + 11] = 0),
              (n[s + 18] = r - c),
              (n[s + 19] = a + u),
              (n[s + 20] = 0),
              (n[s + 27] = r + c),
              (n[s + 28] = a + u),
              (n[s + 29] = 0);
          const _ = t.color;
          (Cat.x = _.r / 255),
            (Cat.y = _.g / 255),
            (Cat.z = _.b / 255),
            (Cat.w = _.a / 255),
            Wi.toArray(n, Cat, s + 5),
            Wi.toArray(n, Cat, s + 14),
            Wi.toArray(n, Cat, s + 23),
            Wi.toArray(n, Cat, s + 32);
        }
        step(t) {
          const e = this.sys.assembler,
            i = this.sys,
            s = i.node,
            n = this.particles;
          if (
            ((t = t > e.maxParticleDeltaTime ? e.maxParticleDeltaTime : t),
            s.updateWorldTransform(),
            i.positionType === Tat.FREE)
          ) {
            this._worldRotation = (function (t) {
              let e = 0,
                i = t;
              for (; i; ) (e += i.eulerAngles.z), (i = i.parent);
              return e;
            })(s);
            const t = s.worldMatrix;
            (Eat.x = t.m12), (Eat.y = t.m13);
          } else
            i.positionType === Tat.RELATIVE
              ? ((this._worldRotation = s.eulerAngles.z),
                (Eat.x = s.position.x),
                (Eat.y = s.position.y))
              : (this._worldRotation = 0);
          if (this.active && i.emissionRate) {
            const e = 1 / i.emissionRate;
            for (
              n.length < i.totalParticles && (this.emitCounter += t);
              n.length < i.totalParticles && this.emitCounter > e;

            )
              this.emitParticle(Eat), (this.emitCounter -= e);
            (this.elapsed += t),
              -1 !== i.duration && i.duration < this.elapsed && i.stopSystem();
          }
          const r = this.renderData,
            a = n.length;
          r.reset(),
            this.requestData(4 * a, 6 * a),
            a > this.uvFilled && this.updateUVs();
          let o = 0;
          for (; o < n.length; ) {
            vat.x = vat.y = bat.x = bat.y = Aat.x = Aat.y = 0;
            const e = n[o];
            if (((e.timeToLive -= t), e.timeToLive > 0)) {
              if (i.emitterMode === yat.GRAVITY) {
                const s = Aat,
                  n = vat,
                  r = bat;
                (e.pos.x || e.pos.y) && (n.set(e.pos), n.normalize()),
                  r.set(n),
                  n.multiplyScalar(e.radialAccel);
                const a = r.x;
                (r.x = -r.y),
                  (r.y = a),
                  r.multiplyScalar(e.tangentialAccel),
                  s.set(n),
                  s.add(r),
                  s.add(i.gravity),
                  s.multiplyScalar(t),
                  e.dir.add(s),
                  s.set(e.dir),
                  s.multiplyScalar(t),
                  e.pos.add(s);
              } else
                (e.angle += e.degreesPerSecond * t),
                  (e.radius += e.deltaRadius * t),
                  (e.pos.x = -Math.cos(e.angle) * e.radius),
                  (e.pos.y = -Math.sin(e.angle) * e.radius);
              (e.color.r += e.deltaColor.r * t),
                (e.color.g += e.deltaColor.g * t),
                (e.color.b += e.deltaColor.b * t),
                (e.color.a += e.deltaColor.a * t),
                (e.size += e.deltaSize * t),
                e.size < 0 && (e.size = 0),
                (e.rotation += e.deltaRotation * t);
              const s = vat;
              s.set(e.pos), i.positionType !== Tat.GROUPED && s.add(e.startPos);
              const n = Oat * o * 4;
              this.updateParticleBuffer(e, s, r, n), ++o;
            } else {
              const t = n[o];
              o !== n.length - 1 && (n[o] = n[n.length - 1]),
                wat.put(t),
                n.length--,
                r.resize(r.vertexCount - 4, r.indexCount - 6);
            }
          }
          (this.renderData.material = this.sys.getRenderMaterial(0)),
            (this.renderData.frame = this.sys._renderSpriteFrame),
            r.setRenderDrawInfoAttributes(),
            0 !== n.length ||
              this.active ||
              this.readyToPlay ||
              ((this.finished = !0), i._finishedSimulation());
        }
        requestData(t, e) {
          let i = this.renderData.indexCount;
          this.renderData.request(t, e);
          const s = this.renderData.indexCount / 6,
            n = this.renderData.iData;
          for (let t = i; t < s; t++) {
            const e = 4 * t;
            (n[i++] = e),
              (n[i++] = e + 1),
              (n[i++] = e + 2),
              (n[i++] = e + 1),
              (n[i++] = e + 3),
              (n[i++] = e + 2);
          }
        }
        initDrawInfo() {
          this.renderData.setRenderDrawInfoAttributes();
        }
      }
      var Dat, xat, Mat;
      const { ccclass: Pat, serializable: Nat, editable: Lat } = go;
      let Bat = t(
        "ParticleAsset",
        Pat("cc.ParticleAsset")(
          ((xat = class extends Ad {
            constructor(...t) {
              super(...t), (this.spriteFrame = Mat && Mat());
            }
          }),
          (Mat = fa(xat.prototype, "spriteFrame", [Nat], function () {
            return null;
          })),
          (Dat = xat))
        ) || Dat
      );
      a.ParticleAsset = Bat;
      /** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
      var Fat = {};
      (function () {
        function t(t) {
          throw t;
        }
        var e = void 0,
          i = !0,
          s = this;
        function n(t, i) {
          var n,
            r = t.split("."),
            a = s;
          !(r[0] in a) && a.execScript && a.execScript("var " + r[0]);
          for (; r.length && (n = r.shift()); )
            r.length || i === e ? (a = a[n] ? a[n] : (a[n] = {})) : (a[n] = i);
        }
        var r =
          "undefined" != typeof Uint8Array &&
          "undefined" != typeof Uint16Array &&
          "undefined" != typeof Uint32Array;
        function a(t) {
          if ("string" == typeof t) {
            var e,
              i,
              s = t.split("");
            for (e = 0, i = s.length; e < i; e++)
              s[e] = (255 & s[e].charCodeAt(0)) >>> 0;
            t = s;
          }
          for (var n, r = 1, a = 0, o = t.length, h = 0; 0 < o; ) {
            o -= n = 1024 < o ? 1024 : o;
            do {
              a += r += t[h++];
            } while (--n);
            (r %= 65521), (a %= 65521);
          }
          return ((a << 16) | r) >>> 0;
        }
        function o(e, i) {
          (this.index = "number" == typeof i ? i : 0),
            (this.i = 0),
            (this.buffer =
              e instanceof (r ? Uint8Array : Array)
                ? e
                : new (r ? Uint8Array : Array)(32768)),
            2 * this.buffer.length <= this.index && t(Error("invalid index")),
            this.buffer.length <= this.index && this.f();
        }
        (o.prototype.f = function () {
          var t,
            e = this.buffer,
            i = e.length,
            s = new (r ? Uint8Array : Array)(i << 1);
          if (r) s.set(e);
          else for (t = 0; t < i; ++t) s[t] = e[t];
          return (this.buffer = s);
        }),
          (o.prototype.d = function (t, e, i) {
            var s,
              n = this.buffer,
              r = this.index,
              a = this.i,
              o = n[r];
            if (
              (i &&
                1 < e &&
                (t =
                  8 < e
                    ? ((d[255 & t] << 24) |
                        (d[(t >>> 8) & 255] << 16) |
                        (d[(t >>> 16) & 255] << 8) |
                        d[(t >>> 24) & 255]) >>
                      (32 - e)
                    : d[t] >> (8 - e)),
              8 > e + a)
            )
              (o = (o << e) | t), (a += e);
            else
              for (s = 0; s < e; ++s)
                (o = (o << 1) | ((t >> (e - s - 1)) & 1)),
                  8 == ++a &&
                    ((a = 0),
                    (n[r++] = d[o]),
                    (o = 0),
                    r === n.length && (n = this.f()));
            (n[r] = o), (this.buffer = n), (this.i = a), (this.index = r);
          }),
          (o.prototype.finish = function () {
            var t,
              e = this.buffer,
              i = this.index;
            return (
              0 < this.i && ((e[i] <<= 8 - this.i), (e[i] = d[e[i]]), i++),
              r ? (t = e.subarray(0, i)) : ((e.length = i), (t = e)),
              t
            );
          });
        var h,
          l = new (r ? Uint8Array : Array)(256);
        for (h = 0; 256 > h; ++h) {
          for (var c = (_ = h), u = 7, _ = _ >>> 1; _; _ >>>= 1)
            (c <<= 1), (c |= 1 & _), --u;
          l[h] = ((c << u) & 255) >>> 0;
        }
        var d = l;
        function p(t) {
          (this.buffer = new (r ? Uint16Array : Array)(2 * t)),
            (this.length = 0);
        }
        function m(t) {
          var e,
            i,
            s,
            n,
            a,
            o,
            h,
            l,
            c,
            u = t.length,
            _ = 0,
            d = Number.POSITIVE_INFINITY;
          for (l = 0; l < u; ++l)
            t[l] > _ && (_ = t[l]), t[l] < d && (d = t[l]);
          for (
            e = 1 << _,
              i = new (r ? Uint32Array : Array)(e),
              s = 1,
              n = 0,
              a = 2;
            s <= _;

          ) {
            for (l = 0; l < u; ++l)
              if (t[l] === s) {
                for (o = 0, h = n, c = 0; c < s; ++c)
                  (o = (o << 1) | (1 & h)), (h >>= 1);
                for (c = o; c < e; c += a) i[c] = (s << 16) | l;
                ++n;
              }
            ++s, (n <<= 1), (a <<= 1);
          }
          return [i, _, d];
        }
        function f(t, e) {
          (this.h = y),
            (this.w = 0),
            (this.input = t),
            (this.b = 0),
            e &&
              (e.lazy && (this.w = e.lazy),
              "number" == typeof e.compressionType &&
                (this.h = e.compressionType),
              e.outputBuffer &&
                (this.a =
                  r && e.outputBuffer instanceof Array
                    ? new Uint8Array(e.outputBuffer)
                    : e.outputBuffer),
              "number" == typeof e.outputIndex && (this.b = e.outputIndex)),
            this.a || (this.a = new (r ? Uint8Array : Array)(32768));
        }
        (p.prototype.getParent = function (t) {
          return 2 * (((t - 2) / 4) | 0);
        }),
          (p.prototype.push = function (t, e) {
            var i,
              s,
              n,
              r = this.buffer;
            for (
              i = this.length, r[this.length++] = e, r[this.length++] = t;
              0 < i && ((s = this.getParent(i)), r[i] > r[s]);

            )
              (n = r[i]),
                (r[i] = r[s]),
                (r[s] = n),
                (n = r[i + 1]),
                (r[i + 1] = r[s + 1]),
                (r[s + 1] = n),
                (i = s);
            return this.length;
          }),
          (p.prototype.pop = function () {
            var t,
              e,
              i,
              s,
              n,
              r = this.buffer;
            for (
              e = r[0],
                t = r[1],
                this.length -= 2,
                r[0] = r[this.length],
                r[1] = r[this.length + 1],
                n = 0;
              !((s = 2 * n + 2) >= this.length) &&
              (s + 2 < this.length && r[s + 2] > r[s] && (s += 2), r[s] > r[n]);

            )
              (i = r[n]),
                (r[n] = r[s]),
                (r[s] = i),
                (i = r[n + 1]),
                (r[n + 1] = r[s + 1]),
                (r[s + 1] = i),
                (n = s);
            return { index: t, value: e, length: this.length };
          });
        var g,
          y = 2,
          T = { NONE: 0, r: 1, j: y, N: 3 },
          S = [];
        for (g = 0; 288 > g; g++)
          switch (i) {
            case 143 >= g:
              S.push([g + 48, 8]);
              break;
            case 255 >= g:
              S.push([g - 144 + 400, 9]);
              break;
            case 279 >= g:
              S.push([g - 256 + 0, 7]);
              break;
            case 287 >= g:
              S.push([g - 280 + 192, 8]);
              break;
            default:
              t("invalid literal: " + g);
          }
        function E(t, e) {
          (this.length = t), (this.G = e);
        }
        function v() {
          var e = b;
          switch (i) {
            case 3 === e:
              return [257, e - 3, 0];
            case 4 === e:
              return [258, e - 4, 0];
            case 5 === e:
              return [259, e - 5, 0];
            case 6 === e:
              return [260, e - 6, 0];
            case 7 === e:
              return [261, e - 7, 0];
            case 8 === e:
              return [262, e - 8, 0];
            case 9 === e:
              return [263, e - 9, 0];
            case 10 === e:
              return [264, e - 10, 0];
            case 12 >= e:
              return [265, e - 11, 1];
            case 14 >= e:
              return [266, e - 13, 1];
            case 16 >= e:
              return [267, e - 15, 1];
            case 18 >= e:
              return [268, e - 17, 1];
            case 22 >= e:
              return [269, e - 19, 2];
            case 26 >= e:
              return [270, e - 23, 2];
            case 30 >= e:
              return [271, e - 27, 2];
            case 34 >= e:
              return [272, e - 31, 2];
            case 42 >= e:
              return [273, e - 35, 3];
            case 50 >= e:
              return [274, e - 43, 3];
            case 58 >= e:
              return [275, e - 51, 3];
            case 66 >= e:
              return [276, e - 59, 3];
            case 82 >= e:
              return [277, e - 67, 4];
            case 98 >= e:
              return [278, e - 83, 4];
            case 114 >= e:
              return [279, e - 99, 4];
            case 130 >= e:
              return [280, e - 115, 4];
            case 162 >= e:
              return [281, e - 131, 5];
            case 194 >= e:
              return [282, e - 163, 5];
            case 226 >= e:
              return [283, e - 195, 5];
            case 257 >= e:
              return [284, e - 227, 5];
            case 258 === e:
              return [285, e - 258, 0];
            default:
              t("invalid length: " + e);
          }
        }
        f.prototype.n = function () {
          var s,
            n,
            a,
            h,
            l = this.input;
          switch (this.h) {
            case 0:
              for (a = 0, h = l.length; a < h; ) {
                var c,
                  u,
                  _,
                  d = (n = r
                    ? l.subarray(a, a + 65535)
                    : l.slice(a, a + 65535)),
                  p = (a += n.length) === h,
                  m = e,
                  f = e,
                  g = this.a,
                  T = this.b;
                if (r) {
                  for (
                    g = new Uint8Array(this.a.buffer);
                    g.length <= T + d.length + 5;

                  )
                    g = new Uint8Array(g.length << 1);
                  g.set(this.a);
                }
                if (
                  ((c = p ? 1 : 0),
                  (g[T++] = 0 | c),
                  (_ = (65536 + ~(u = d.length)) & 65535),
                  (g[T++] = 255 & u),
                  (g[T++] = (u >>> 8) & 255),
                  (g[T++] = 255 & _),
                  (g[T++] = (_ >>> 8) & 255),
                  r)
                )
                  g.set(d, T), (T += d.length), (g = g.subarray(0, T));
                else {
                  for (m = 0, f = d.length; m < f; ++m) g[T++] = d[m];
                  g.length = T;
                }
                (this.b = T), (this.a = g);
              }
              break;
            case 1:
              var E = new o(new Uint8Array(this.a.buffer), this.b);
              E.d(1, 1, i), E.d(1, 2, i);
              var v,
                b,
                A,
                C = I(this, l);
              for (v = 0, b = C.length; v < b; v++)
                if (((A = C[v]), o.prototype.d.apply(E, S[A]), 256 < A))
                  E.d(C[++v], C[++v], i),
                    E.d(C[++v], 5),
                    E.d(C[++v], C[++v], i);
                else if (256 === A) break;
              (this.a = E.finish()), (this.b = this.a.length);
              break;
            case y:
              var O,
                D,
                x,
                M,
                P,
                N,
                L,
                B,
                F,
                U,
                k,
                z,
                H,
                G,
                V,
                j = new o(new Uint8Array(this.a), this.b),
                W = [
                  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1,
                  15,
                ],
                X = Array(19);
              for (
                O = y,
                  j.d(1, 1, i),
                  j.d(O, 2, i),
                  D = I(this, l),
                  L = R((N = w(this.L, 15))),
                  F = R((B = w(this.K, 7))),
                  x = 286;
                257 < x && 0 === N[x - 1];
                x--
              );
              for (M = 30; 1 < M && 0 === B[M - 1]; M--);
              var Y,
                K,
                q,
                $,
                Z,
                Q,
                J = x,
                tt = M,
                et = new (r ? Uint32Array : Array)(J + tt),
                it = new (r ? Uint32Array : Array)(316),
                st = new (r ? Uint8Array : Array)(19);
              for (Y = K = 0; Y < J; Y++) et[K++] = N[Y];
              for (Y = 0; Y < tt; Y++) et[K++] = B[Y];
              if (!r) for (Y = 0, $ = st.length; Y < $; ++Y) st[Y] = 0;
              for (Y = Z = 0, $ = et.length; Y < $; Y += K) {
                for (K = 1; Y + K < $ && et[Y + K] === et[Y]; ++K);
                if (((q = K), 0 === et[Y]))
                  if (3 > q) for (; 0 < q--; ) (it[Z++] = 0), st[0]++;
                  else
                    for (; 0 < q; )
                      (Q = 138 > q ? q : 138) > q - 3 && Q < q && (Q = q - 3),
                        10 >= Q
                          ? ((it[Z++] = 17), (it[Z++] = Q - 3), st[17]++)
                          : ((it[Z++] = 18), (it[Z++] = Q - 11), st[18]++),
                        (q -= Q);
                else if (((it[Z++] = et[Y]), st[et[Y]]++, 3 > --q))
                  for (; 0 < q--; ) (it[Z++] = et[Y]), st[et[Y]]++;
                else
                  for (; 0 < q; )
                    (Q = 6 > q ? q : 6) > q - 3 && Q < q && (Q = q - 3),
                      (it[Z++] = 16),
                      (it[Z++] = Q - 3),
                      st[16]++,
                      (q -= Q);
              }
              for (
                s = r ? it.subarray(0, Z) : it.slice(0, Z), U = w(st, 7), G = 0;
                19 > G;
                G++
              )
                X[G] = U[W[G]];
              for (P = 19; 4 < P && 0 === X[P - 1]; P--);
              for (
                k = R(U),
                  j.d(x - 257, 5, i),
                  j.d(M - 1, 5, i),
                  j.d(P - 4, 4, i),
                  G = 0;
                G < P;
                G++
              )
                j.d(X[G], 3, i);
              for (G = 0, V = s.length; G < V; G++)
                if (((z = s[G]), j.d(k[z], U[z], i), 16 <= z)) {
                  switch ((G++, z)) {
                    case 16:
                      H = 2;
                      break;
                    case 17:
                      H = 3;
                      break;
                    case 18:
                      H = 7;
                      break;
                    default:
                      t("invalid code: " + z);
                  }
                  j.d(s[G], H, i);
                }
              var nt,
                rt,
                at,
                ot,
                ht,
                lt,
                ct,
                ut,
                _t = [L, N],
                dt = [F, B];
              for (
                ht = _t[0],
                  lt = _t[1],
                  ct = dt[0],
                  ut = dt[1],
                  nt = 0,
                  rt = D.length;
                nt < rt;
                ++nt
              )
                if (((at = D[nt]), j.d(ht[at], lt[at], i), 256 < at))
                  j.d(D[++nt], D[++nt], i),
                    (ot = D[++nt]),
                    j.d(ct[ot], ut[ot], i),
                    j.d(D[++nt], D[++nt], i);
                else if (256 === at) break;
              (this.a = j.finish()), (this.b = this.a.length);
              break;
            default:
              t("invalid compression type");
          }
          return this.a;
        };
        var b,
          A,
          C = [];
        for (b = 3; 258 >= b; b++)
          (A = v()), (C[b] = (A[2] << 24) | (A[1] << 16) | A[0]);
        var O = r ? new Uint32Array(C) : C;
        function I(s, n) {
          function a(e, s) {
            var n,
              r,
              a,
              o,
              h = e.G,
              l = [],
              c = 0;
            switch (
              ((n = O[e.length]),
              (l[c++] = 65535 & n),
              (l[c++] = (n >> 16) & 255),
              (l[c++] = n >> 24),
              i)
            ) {
              case 1 === h:
                r = [0, h - 1, 0];
                break;
              case 2 === h:
                r = [1, h - 2, 0];
                break;
              case 3 === h:
                r = [2, h - 3, 0];
                break;
              case 4 === h:
                r = [3, h - 4, 0];
                break;
              case 6 >= h:
                r = [4, h - 5, 1];
                break;
              case 8 >= h:
                r = [5, h - 7, 1];
                break;
              case 12 >= h:
                r = [6, h - 9, 2];
                break;
              case 16 >= h:
                r = [7, h - 13, 2];
                break;
              case 24 >= h:
                r = [8, h - 17, 3];
                break;
              case 32 >= h:
                r = [9, h - 25, 3];
                break;
              case 48 >= h:
                r = [10, h - 33, 4];
                break;
              case 64 >= h:
                r = [11, h - 49, 4];
                break;
              case 96 >= h:
                r = [12, h - 65, 5];
                break;
              case 128 >= h:
                r = [13, h - 97, 5];
                break;
              case 192 >= h:
                r = [14, h - 129, 6];
                break;
              case 256 >= h:
                r = [15, h - 193, 6];
                break;
              case 384 >= h:
                r = [16, h - 257, 7];
                break;
              case 512 >= h:
                r = [17, h - 385, 7];
                break;
              case 768 >= h:
                r = [18, h - 513, 8];
                break;
              case 1024 >= h:
                r = [19, h - 769, 8];
                break;
              case 1536 >= h:
                r = [20, h - 1025, 9];
                break;
              case 2048 >= h:
                r = [21, h - 1537, 9];
                break;
              case 3072 >= h:
                r = [22, h - 2049, 10];
                break;
              case 4096 >= h:
                r = [23, h - 3073, 10];
                break;
              case 6144 >= h:
                r = [24, h - 4097, 11];
                break;
              case 8192 >= h:
                r = [25, h - 6145, 11];
                break;
              case 12288 >= h:
                r = [26, h - 8193, 12];
                break;
              case 16384 >= h:
                r = [27, h - 12289, 12];
                break;
              case 24576 >= h:
                r = [28, h - 16385, 13];
                break;
              case 32768 >= h:
                r = [29, h - 24577, 13];
                break;
              default:
                t("invalid distance");
            }
            for (
              n = r,
                l[c++] = n[0],
                l[c++] = n[1],
                l[c++] = n[2],
                a = 0,
                o = l.length;
              a < o;
              ++a
            )
              g[y++] = l[a];
            S[l[0]]++, v[l[3]]++, (T = e.length + s - 1), (p = null);
          }
          var o,
            h,
            l,
            c,
            u,
            _,
            d,
            p,
            m,
            f = {},
            g = r ? new Uint16Array(2 * n.length) : [],
            y = 0,
            T = 0,
            S = new (r ? Uint32Array : Array)(286),
            v = new (r ? Uint32Array : Array)(30),
            b = s.w;
          if (!r) {
            for (l = 0; 285 >= l; ) S[l++] = 0;
            for (l = 0; 29 >= l; ) v[l++] = 0;
          }
          for (S[256] = 1, o = 0, h = n.length; o < h; ++o) {
            for (l = u = 0, c = 3; l < c && o + l !== h; ++l)
              u = (u << 8) | n[o + l];
            if ((f[u] === e && (f[u] = []), (_ = f[u]), !(0 < T--))) {
              for (; 0 < _.length && 32768 < o - _[0]; ) _.shift();
              if (o + 3 >= h) {
                for (p && a(p, -1), l = 0, c = h - o; l < c; ++l)
                  (m = n[o + l]), (g[y++] = m), ++S[m];
                break;
              }
              if (0 < _.length) {
                var A = e,
                  C = e,
                  I = 0,
                  w = e,
                  R = e,
                  D = e,
                  x = n.length,
                  M = ((R = 0), _.length);
                t: for (; R < M; R++) {
                  if (((A = _[M - R - 1]), (w = 3), 3 < I)) {
                    for (D = I; 3 < D; D--)
                      if (n[A + D - 1] !== n[o + D - 1]) continue t;
                    w = I;
                  }
                  for (; 258 > w && o + w < x && n[A + w] === n[o + w]; ) ++w;
                  if ((w > I && ((C = A), (I = w)), 258 === w)) break;
                }
                (d = new E(I, o - C)),
                  p
                    ? p.length < d.length
                      ? ((m = n[o - 1]), (g[y++] = m), ++S[m], a(d, 0))
                      : a(p, -1)
                    : d.length < b
                    ? (p = d)
                    : a(d, 0);
              } else p ? a(p, -1) : ((m = n[o]), (g[y++] = m), ++S[m]);
            }
            _.push(o);
          }
          return (
            (g[y++] = 256),
            S[256]++,
            (s.L = S),
            (s.K = v),
            r ? g.subarray(0, y) : g
          );
        }
        function w(t, e) {
          function i(t) {
            var e = b[t][A[t]];
            e === y ? (i(t + 1), i(t + 1)) : --E[e], ++A[t];
          }
          var s,
            n,
            a,
            o,
            h,
            l = t.length,
            c = new p(572),
            u = new (r ? Uint8Array : Array)(l);
          if (!r) for (o = 0; o < l; o++) u[o] = 0;
          for (o = 0; o < l; ++o) 0 < t[o] && c.push(o, t[o]);
          if (
            ((s = Array(c.length / 2)),
            (n = new (r ? Uint32Array : Array)(c.length / 2)),
            1 === s.length)
          )
            return (u[c.pop().index] = 1), u;
          for (o = 0, h = c.length / 2; o < h; ++o)
            (s[o] = c.pop()), (n[o] = s[o].value);
          var _,
            d,
            m,
            f,
            g,
            y = n.length,
            T = new (r ? Uint16Array : Array)(e),
            S = new (r ? Uint8Array : Array)(e),
            E = new (r ? Uint8Array : Array)(y),
            v = Array(e),
            b = Array(e),
            A = Array(e),
            C = (1 << e) - y,
            O = 1 << (e - 1);
          for (T[e - 1] = y, d = 0; d < e; ++d)
            C < O ? (S[d] = 0) : ((S[d] = 1), (C -= O)),
              (C <<= 1),
              (T[e - 2 - d] = ((T[e - 1 - d] / 2) | 0) + y);
          for (
            T[0] = S[0], v[0] = Array(T[0]), b[0] = Array(T[0]), d = 1;
            d < e;
            ++d
          )
            T[d] > 2 * T[d - 1] + S[d] && (T[d] = 2 * T[d - 1] + S[d]),
              (v[d] = Array(T[d])),
              (b[d] = Array(T[d]));
          for (_ = 0; _ < y; ++_) E[_] = e;
          for (m = 0; m < T[e - 1]; ++m)
            (v[e - 1][m] = n[m]), (b[e - 1][m] = m);
          for (_ = 0; _ < e; ++_) A[_] = 0;
          for (1 === S[e - 1] && (--E[0], ++A[e - 1]), d = e - 2; 0 <= d; --d) {
            for (f = _ = 0, g = A[d + 1], m = 0; m < T[d]; m++)
              (f = v[d + 1][g] + v[d + 1][g + 1]) > n[_]
                ? ((v[d][m] = f), (b[d][m] = y), (g += 2))
                : ((v[d][m] = n[_]), (b[d][m] = _), ++_);
            (A[d] = 0), 1 === S[d] && i(d);
          }
          for (a = E, o = 0, h = s.length; o < h; ++o) u[s[o].index] = a[o];
          return u;
        }
        function R(e) {
          var i,
            s,
            n,
            a,
            o = new (r ? Uint16Array : Array)(e.length),
            h = [],
            l = [],
            c = 0;
          for (i = 0, s = e.length; i < s; i++) h[e[i]] = 1 + (0 | h[e[i]]);
          for (i = 1, s = 16; i <= s; i++)
            (l[i] = c),
              (c += 0 | h[i]) > 1 << i && t("overcommitted"),
              (c <<= 1);
          for (
            65536 > c && t("undercommitted"), i = 0, s = e.length;
            i < s;
            i++
          )
            for (c = l[e[i]], l[e[i]] += 1, n = o[i] = 0, a = e[i]; n < a; n++)
              (o[i] = (o[i] << 1) | (1 & c)), (c >>>= 1);
          return o;
        }
        function D(t, e) {
          (this.input = t),
            (this.a = new (r ? Uint8Array : Array)(32768)),
            (this.h = x.j);
          var i,
            s = {};
          for (i in ((!e && (e = {})) ||
            "number" != typeof e.compressionType ||
            (this.h = e.compressionType),
          e))
            s[i] = e[i];
          (s.outputBuffer = this.a), (this.z = new f(this.input, s));
        }
        var x = T;
        function M(e, i) {
          switch (
            ((this.k = []),
            (this.l = 32768),
            (this.e = this.g = this.c = this.q = 0),
            (this.input = r ? new Uint8Array(e) : e),
            (this.s = !1),
            (this.m = N),
            (this.B = !1),
            (!i && (i = {})) ||
              (i.index && (this.c = i.index),
              i.bufferSize && (this.l = i.bufferSize),
              i.bufferType && (this.m = i.bufferType),
              i.resize && (this.B = i.resize)),
            this.m)
          ) {
            case P:
              (this.b = 32768),
                (this.a = new (r ? Uint8Array : Array)(32768 + this.l + 258));
              break;
            case N:
              (this.b = 0),
                (this.a = new (r ? Uint8Array : Array)(this.l)),
                (this.f = this.J),
                (this.t = this.H),
                (this.o = this.I);
              break;
            default:
              t(Error("invalid inflate mode"));
          }
        }
        (D.prototype.n = function () {
          var e,
            i,
            s,
            n,
            o,
            h,
            l,
            c = 0;
          switch (((l = this.a), (e = ct))) {
            case ct:
              i = Math.LOG2E * Math.log(32768) - 8;
              break;
            default:
              t(Error("invalid compression method"));
          }
          switch (((s = (i << 4) | e), (l[c++] = s), e)) {
            case ct:
              switch (this.h) {
                case x.NONE:
                  o = 0;
                  break;
                case x.r:
                  o = 1;
                  break;
                case x.j:
                  o = 2;
                  break;
                default:
                  t(Error("unsupported compression type"));
              }
              break;
            default:
              t(Error("invalid compression method"));
          }
          return (
            (n = (o << 6) | 0),
            (l[c++] = n | (31 - ((256 * s + n) % 31))),
            (h = a(this.input)),
            (this.z.b = c),
            (c = (l = this.z.n()).length),
            r &&
              ((l = new Uint8Array(l.buffer)).length <= c + 4 &&
                ((this.a = new Uint8Array(l.length + 4)),
                this.a.set(l),
                (l = this.a)),
              (l = l.subarray(0, c + 4))),
            (l[c++] = (h >> 24) & 255),
            (l[c++] = (h >> 16) & 255),
            (l[c++] = (h >> 8) & 255),
            (l[c++] = 255 & h),
            l
          );
        }),
          n("Zlib.Deflate", D),
          n("Zlib.Deflate.compress", function (t, e) {
            return new D(t, e).n();
          }),
          n("Zlib.Deflate.CompressionType", x),
          n("Zlib.Deflate.CompressionType.NONE", x.NONE),
          n("Zlib.Deflate.CompressionType.FIXED", x.r),
          n("Zlib.Deflate.CompressionType.DYNAMIC", x.j);
        var P = 0,
          N = 1,
          L = { D: P, C: N };
        M.prototype.p = function () {
          for (; !this.s; ) {
            var s = tt(this, 3);
            switch ((1 & s && (this.s = i), (s >>>= 1))) {
              case 0:
                var n = this.input,
                  a = this.c,
                  o = this.a,
                  h = this.b,
                  l = e,
                  c = e,
                  u = e,
                  _ = o.length,
                  d = e;
                switch (
                  ((this.e = this.g = 0),
                  (l = n[a++]) === e &&
                    t(
                      Error(
                        "invalid uncompressed block header: LEN (first byte)"
                      )
                    ),
                  (c = l),
                  (l = n[a++]) === e &&
                    t(
                      Error(
                        "invalid uncompressed block header: LEN (second byte)"
                      )
                    ),
                  (c |= l << 8),
                  (l = n[a++]) === e &&
                    t(
                      Error(
                        "invalid uncompressed block header: NLEN (first byte)"
                      )
                    ),
                  (u = l),
                  (l = n[a++]) === e &&
                    t(
                      Error(
                        "invalid uncompressed block header: NLEN (second byte)"
                      )
                    ),
                  c === ~(u |= l << 8) &&
                    t(
                      Error("invalid uncompressed block header: length verify")
                    ),
                  a + c > n.length && t(Error("input buffer is broken")),
                  this.m)
                ) {
                  case P:
                    for (; h + c > o.length; ) {
                      if (((c -= d = _ - h), r))
                        o.set(n.subarray(a, a + d), h), (h += d), (a += d);
                      else for (; d--; ) o[h++] = n[a++];
                      (this.b = h), (o = this.f()), (h = this.b);
                    }
                    break;
                  case N:
                    for (; h + c > o.length; ) o = this.f({ v: 2 });
                    break;
                  default:
                    t(Error("invalid inflate mode"));
                }
                if (r) o.set(n.subarray(a, a + c), h), (h += c), (a += c);
                else for (; c--; ) o[h++] = n[a++];
                (this.c = a), (this.b = h), (this.a = o);
                break;
              case 1:
                this.o(Z, J);
                break;
              case 2:
                it(this);
                break;
              default:
                t(Error("unknown BTYPE: " + s));
            }
          }
          return this.t();
        };
        var B,
          F,
          U = [
            16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
          ],
          k = r ? new Uint16Array(U) : U,
          z = [
            3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51,
            59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258,
          ],
          H = r ? new Uint16Array(z) : z,
          G = [
            0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,
            4, 5, 5, 5, 5, 0, 0, 0,
          ],
          V = r ? new Uint8Array(G) : G,
          j = [
            1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385,
            513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385,
            24577,
          ],
          W = r ? new Uint16Array(j) : j,
          X = [
            0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,
            10, 10, 11, 11, 12, 12, 13, 13,
          ],
          Y = r ? new Uint8Array(X) : X,
          K = new (r ? Uint8Array : Array)(288);
        for (B = 0, F = K.length; B < F; ++B)
          K[B] = 143 >= B ? 8 : 255 >= B ? 9 : 279 >= B ? 7 : 8;
        var q,
          $,
          Z = m(K),
          Q = new (r ? Uint8Array : Array)(30);
        for (q = 0, $ = Q.length; q < $; ++q) Q[q] = 5;
        var J = m(Q);
        function tt(i, s) {
          for (var n, r = i.g, a = i.e, o = i.input, h = i.c; a < s; )
            (n = o[h++]) === e && t(Error("input buffer is broken")),
              (r |= n << a),
              (a += 8);
          return (
            (n = r & ((1 << s) - 1)),
            (i.g = r >>> s),
            (i.e = a - s),
            (i.c = h),
            n
          );
        }
        function et(i, s) {
          for (
            var n,
              r,
              a,
              o = i.g,
              h = i.e,
              l = i.input,
              c = i.c,
              u = s[0],
              _ = s[1];
            h < _;

          )
            (n = l[c++]) === e && t(Error("input buffer is broken")),
              (o |= n << h),
              (h += 8);
          return (
            (a = (r = u[o & ((1 << _) - 1)]) >>> 16),
            (i.g = o >> a),
            (i.e = h - a),
            (i.c = c),
            65535 & r
          );
        }
        function it(t) {
          function e(t, e, i) {
            var s, n, r, a;
            for (a = 0; a < t; )
              switch (((s = et(this, e)), s)) {
                case 16:
                  for (r = 3 + tt(this, 2); r--; ) i[a++] = n;
                  break;
                case 17:
                  for (r = 3 + tt(this, 3); r--; ) i[a++] = 0;
                  n = 0;
                  break;
                case 18:
                  for (r = 11 + tt(this, 7); r--; ) i[a++] = 0;
                  n = 0;
                  break;
                default:
                  n = i[a++] = s;
              }
            return i;
          }
          var i,
            s,
            n,
            a,
            o = tt(t, 5) + 257,
            h = tt(t, 5) + 1,
            l = tt(t, 4) + 4,
            c = new (r ? Uint8Array : Array)(k.length);
          for (a = 0; a < l; ++a) c[k[a]] = tt(t, 3);
          (i = m(c)),
            (s = new (r ? Uint8Array : Array)(o)),
            (n = new (r ? Uint8Array : Array)(h)),
            t.o(m(e.call(t, o, i, s)), m(e.call(t, h, i, n)));
        }
        function st(e, i) {
          var s, n;
          switch (
            ((this.input = e),
            (this.c = 0),
            (!i && (i = {})) ||
              (i.index && (this.c = i.index), i.verify && (this.M = i.verify)),
            (s = e[this.c++]),
            (n = e[this.c++]),
            15 & s)
          ) {
            case ct:
              this.method = ct;
              break;
            default:
              t(Error("unsupported compression method"));
          }
          0 != ((s << 8) + n) % 31 &&
            t(Error("invalid fcheck flag:" + (((s << 8) + n) % 31))),
            32 & n && t(Error("fdict flag is not supported")),
            (this.A = new M(e, {
              index: this.c,
              bufferSize: i.bufferSize,
              bufferType: i.bufferType,
              resize: i.resize,
            }));
        }
        (M.prototype.o = function (t, e) {
          var i = this.a,
            s = this.b;
          this.u = t;
          for (var n, r, a, o, h = i.length - 258; 256 !== (n = et(this, t)); )
            if (256 > n)
              s >= h && ((this.b = s), (i = this.f()), (s = this.b)),
                (i[s++] = n);
            else
              for (
                o = H[(r = n - 257)],
                  0 < V[r] && (o += tt(this, V[r])),
                  n = et(this, e),
                  a = W[n],
                  0 < Y[n] && (a += tt(this, Y[n])),
                  s >= h && ((this.b = s), (i = this.f()), (s = this.b));
                o--;

              )
                i[s] = i[s++ - a];
          for (; 8 <= this.e; ) (this.e -= 8), this.c--;
          this.b = s;
        }),
          (M.prototype.I = function (t, e) {
            var i = this.a,
              s = this.b;
            this.u = t;
            for (var n, r, a, o, h = i.length; 256 !== (n = et(this, t)); )
              if (256 > n) s >= h && (h = (i = this.f()).length), (i[s++] = n);
              else
                for (
                  o = H[(r = n - 257)],
                    0 < V[r] && (o += tt(this, V[r])),
                    n = et(this, e),
                    a = W[n],
                    0 < Y[n] && (a += tt(this, Y[n])),
                    s + o > h && (h = (i = this.f()).length);
                  o--;

                )
                  i[s] = i[s++ - a];
            for (; 8 <= this.e; ) (this.e -= 8), this.c--;
            this.b = s;
          }),
          (M.prototype.f = function () {
            var t,
              e,
              i = new (r ? Uint8Array : Array)(this.b - 32768),
              s = this.b - 32768,
              n = this.a;
            if (r) i.set(n.subarray(32768, i.length));
            else for (t = 0, e = i.length; t < e; ++t) i[t] = n[t + 32768];
            if ((this.k.push(i), (this.q += i.length), r))
              n.set(n.subarray(s, s + 32768));
            else for (t = 0; 32768 > t; ++t) n[t] = n[s + t];
            return (this.b = 32768), n;
          }),
          (M.prototype.J = function (t) {
            var e,
              i,
              s,
              n = (this.input.length / this.c + 1) | 0,
              a = this.input,
              o = this.a;
            return (
              t &&
                ("number" == typeof t.v && (n = t.v),
                "number" == typeof t.F && (n += t.F)),
              (i =
                2 > n
                  ? (s = (((a.length - this.c) / this.u[2] / 2) * 258) | 0) <
                    o.length
                    ? o.length + s
                    : o.length << 1
                  : o.length * n),
              r ? (e = new Uint8Array(i)).set(o) : (e = o),
              (this.a = e)
            );
          }),
          (M.prototype.t = function () {
            var t,
              e,
              i,
              s,
              n,
              a = 0,
              o = this.a,
              h = this.k,
              l = new (r ? Uint8Array : Array)(this.q + (this.b - 32768));
            if (0 === h.length)
              return r
                ? this.a.subarray(32768, this.b)
                : this.a.slice(32768, this.b);
            for (e = 0, i = h.length; e < i; ++e)
              for (s = 0, n = (t = h[e]).length; s < n; ++s) l[a++] = t[s];
            for (e = 32768, i = this.b; e < i; ++e) l[a++] = o[e];
            return (this.k = []), (this.buffer = l);
          }),
          (M.prototype.H = function () {
            var t,
              e = this.b;
            return (
              r
                ? this.B
                  ? (t = new Uint8Array(e)).set(this.a.subarray(0, e))
                  : (t = this.a.subarray(0, e))
                : (this.a.length > e && (this.a.length = e), (t = this.a)),
              (this.buffer = t)
            );
          }),
          (st.prototype.p = function () {
            var e,
              i = this.input;
            return (
              (e = this.A.p()),
              (this.c = this.A.c),
              this.M &&
                ((i[this.c++] << 24) |
                  (i[this.c++] << 16) |
                  (i[this.c++] << 8) |
                  i[this.c++]) >>>
                  0 !==
                  a(e) &&
                t(Error("invalid adler-32 checksum")),
              e
            );
          }),
          n("Zlib.Inflate", st),
          n("Zlib.Inflate.BufferType", L),
          (L.ADAPTIVE = L.C),
          (L.BLOCK = L.D),
          n("Zlib.Inflate.prototype.decompress", st.prototype.p);
        var nt,
          rt,
          at = new (r ? Uint8Array : Array)(288);
        for (nt = 0, rt = at.length; nt < rt; ++nt)
          at[nt] = 143 >= nt ? 8 : 255 >= nt ? 9 : 279 >= nt ? 7 : 8;
        m(at);
        var ot,
          ht,
          lt = new (r ? Uint8Array : Array)(30);
        for (ot = 0, ht = lt.length; ot < ht; ++ot) lt[ot] = 5;
        m(lt);
        var ct = 8;
      }).call(Fat);
      var Uat = Fat.Zlib;
      (Uat.Deflate = Uat.Deflate),
        (Uat.Deflate.compress = Uat.Deflate.compress),
        (Uat.Inflate = Uat.Inflate),
        (Uat.Inflate.BufferType = Uat.Inflate.BufferType),
        (Uat.Inflate.prototype.decompress = Uat.Inflate.prototype.decompress);
      class kat {
        constructor(t) {
          let e;
          (this.pos = 8),
            (this.palette = []),
            (this.imgData = []),
            (this.text = {}),
            (this.width = 0),
            (this.height = 0),
            (this.bits = 0),
            (this.colorType = 0),
            (this.compressionMethod = 0),
            (this.filterMethod = 0),
            (this.interlaceMethod = 0),
            (this.colors = 0),
            (this.hasAlphaChannel = !1),
            (this.pixelBitlength = 0),
            (this.data = t),
            (this.transparency = { indexed: [], rgb: 0, grayscale: 0 });
          let i = 0,
            s = 0,
            n = 0;
          for (;;) {
            n = this.readUInt32();
            const r = (() => {
              const t = [];
              for (i = 0; i < 4; ++i)
                t.push(String.fromCharCode(this.data[this.pos++]));
              return t;
            })
              .call(this)
              .join("");
            switch (r) {
              case "IHDR":
                (this.width = this.readUInt32()),
                  (this.height = this.readUInt32()),
                  (this.bits = this.data[this.pos++]),
                  (this.colorType = this.data[this.pos++]),
                  (this.compressionMethod = this.data[this.pos++]),
                  (this.filterMethod = this.data[this.pos++]),
                  (this.interlaceMethod = this.data[this.pos++]);
                break;
              case "acTL":
                this.animation = {
                  numFrames: this.readUInt32(),
                  numPlays: this.readUInt32() || 1 / 0,
                  frames: [],
                };
                break;
              case "PLTE":
                this.palette = this.read(n);
                break;
              case "fcTL":
                e && this.animation.frames.push(e),
                  (this.pos += 4),
                  (e = {
                    width: this.readUInt32(),
                    height: this.readUInt32(),
                    xOffset: this.readUInt32(),
                    yOffset: this.readUInt32(),
                  });
                const a = this.readUInt16(),
                  o = this.readUInt16() || 100;
                (e.delay = (1e3 * a) / o),
                  (e.disposeOp = this.data[this.pos++]),
                  (e.blendOp = this.data[this.pos++]),
                  (e.data = []);
                break;
              case "IDAT":
              case "fdAT":
                for (
                  "fdAT" === r && ((this.pos += 4), (n -= 4)),
                    t = (null != e ? e.data : void 0) || this.imgData,
                    i = 0;
                  n >= 0 ? i < n : i > n;
                  n >= 0 ? ++i : --i
                )
                  t.push(this.data[this.pos++]);
                break;
              case "tRNS":
                switch (((this.transparency = {}), this.colorType)) {
                  case 3:
                    this.transparency.indexed = this.read(n);
                    const t = 255 - this.transparency.indexed.length;
                    if (t > 0)
                      for (s = 0; t >= 0 ? s < t : s > t; t >= 0 ? ++s : --s)
                        this.transparency.indexed.push(255);
                    break;
                  case 0:
                    this.transparency.grayscale = this.read(n)[0];
                    break;
                  case 2:
                    this.transparency.rgb = this.read(n);
                }
                break;
              case "tEXt":
                const h = this.read(n),
                  l = h.indexOf(0),
                  c = String.fromCharCode.apply(String, h.slice(0, l));
                this.text[c] = String.fromCharCode.apply(
                  String,
                  h.slice(l + 1)
                );
                break;
              case "IEND":
                e && this.animation.frames.push(e),
                  (this.colors = (() => {
                    switch (this.colorType) {
                      case 0:
                      case 3:
                      case 4:
                        return 1;
                      case 2:
                      case 6:
                        return 3;
                    }
                  }).call(this));
                const u = this.colorType;
                this.hasAlphaChannel = 4 === u || 6 === u;
                const _ = this.colors + (this.hasAlphaChannel ? 1 : 0);
                return (
                  (this.pixelBitlength = this.bits * _),
                  (this.colorSpace = (() => {
                    switch (this.colors) {
                      case 1:
                        return "DeviceGray";
                      case 3:
                        return "DeviceRGB";
                    }
                  }).call(this)),
                  void (
                    this.imgData instanceof Uint8Array ||
                    (this.imgData = new Uint8Array(this.imgData))
                  )
                );
              default:
                this.pos += n;
            }
            if (((this.pos += 4), this.pos > this.data.length))
              throw new Error(X(6017));
          }
        }
        read(t) {
          let e = 0;
          const i = [];
          for (e = 0; t >= 0 ? e < t : e > t; t >= 0 ? ++e : --e)
            i.push(this.data[this.pos++]);
          return i;
        }
        readUInt32() {
          return (
            (this.data[this.pos++] << 24) |
            (this.data[this.pos++] << 16) |
            (this.data[this.pos++] << 8) |
            this.data[this.pos++]
          );
        }
        readUInt16() {
          return (this.data[this.pos++] << 8) | this.data[this.pos++];
        }
        decodePixels(t) {
          if ((null == t && (t = this.imgData), 0 === t.length))
            return new Uint8Array(0);
          t = new Uat.Inflate(t, { index: 0, verify: !1 }).decompress();
          const e = this.pixelBitlength / 8,
            i = e * this.width,
            s = new Uint8Array(i * this.height),
            n = t.length;
          let r = 0,
            a = 0,
            o = 0,
            h = 0,
            l = 0,
            c = 0,
            u = 0,
            _ = 0,
            d = 0,
            p = 0,
            m = 0,
            f = 0,
            g = 0,
            y = 0,
            T = 0,
            S = 0,
            E = 0,
            v = 0,
            b = 0;
          for (; a < n; ) {
            switch (t[a++]) {
              case 0:
                for (c = u = 0; u < i; c = u += 1) s[o++] = t[a++];
                break;
              case 1:
                for (c = _ = 0; _ < i; c = _ += 1)
                  (h = t[a++]),
                    (f = c < e ? 0 : s[o - e]),
                    (s[o++] = (h + f) % 256);
                break;
              case 2:
                for (c = d = 0; d < i; c = d += 1)
                  (h = t[a++]),
                    (l = (c - (c % e)) / e),
                    (v = r && s[(r - 1) * i + l * e + (c % e)]),
                    (s[o++] = (v + h) % 256);
                break;
              case 3:
                for (c = p = 0; p < i; c = p += 1)
                  (h = t[a++]),
                    (l = (c - (c % e)) / e),
                    (f = c < e ? 0 : s[o - e]),
                    (v = r && s[(r - 1) * i + l * e + (c % e)]),
                    (s[o++] = (h + Math.floor((f + v) / 2)) % 256);
                break;
              case 4:
                for (c = m = 0; m < i; c = m += 1)
                  (h = t[a++]),
                    (l = (c - (c % e)) / e),
                    (f = c < e ? 0 : s[o - e]),
                    0 === r
                      ? (v = b = 0)
                      : ((v = s[(r - 1) * i + l * e + (c % e)]),
                        (b = l && s[(r - 1) * i + (l - 1) * e + (c % e)])),
                    (g = f + v - b),
                    (y = Math.abs(g - f)),
                    (S = Math.abs(g - v)),
                    (E = Math.abs(g - b)),
                    (T = y <= S && y <= E ? f : S <= E ? v : b),
                    (s[o++] = (h + T) % 256);
                break;
              default:
                throw new Error(X(6018, t[a - 1]));
            }
            r++;
          }
          return s;
        }
        copyToImageData(t, e) {
          let i,
            s = this.hasAlphaChannel,
            n = this.colors;
          this.palette.length &&
            ((i =
              null != this._decodedPalette
                ? this._decodedPalette
                : (this._decodedPalette = this.decodePalette())),
            (n = 4),
            (s = !0));
          const r = t.data || t,
            a = r.length,
            o = i || e;
          let h = 0,
            l = 0,
            c = 0,
            u = 0;
          if (1 === n)
            for (; h < a; )
              (c = i ? 4 * e[h / 4] : l),
                (u = o[c++]),
                (r[h++] = u),
                (r[h++] = u),
                (r[h++] = u),
                (r[h++] = s ? o[c++] : 255),
                (l = c);
          else
            for (; h < a; )
              (c = i ? 4 * e[h / 4] : l),
                (r[h++] = o[c++]),
                (r[h++] = o[c++]),
                (r[h++] = o[c++]),
                (r[h++] = s ? o[c++] : 255),
                (l = c);
        }
        decodePalette() {
          const t = this.palette,
            e = this.transparency.indexed || [],
            i = new Uint8Array((e.length || 0) + t.length);
          let s = 0,
            n = 0,
            r = 0;
          for (let a = 0, o = 0, h = t.length; o < h; a = o += 3)
            (i[s++] = t[a]),
              (i[s++] = t[a + 1]),
              (i[s++] = t[a + 2]),
              (r = e[n++]),
              (i[s++] = null != r ? r : 255);
          return i;
        }
        render(t) {
          (t.width = this.width), (t.height = this.height);
          const e = t.getContext("2d"),
            i = e.createImageData(this.width, this.height);
          return (
            this.copyToImageData(i, this.decodePixels(null)),
            e.putImageData(i, 0, 0)
          );
        }
      }
      class zat {
        constructor() {
          (this._littleEndian = !1),
            (this._tiffData = []),
            (this._fileDirectories = []);
        }
        getUint8(t) {
          return this._tiffData[t];
        }
        getUint16(t) {
          return this._littleEndian
            ? (this._tiffData[t + 1] << 8) | this._tiffData[t]
            : (this._tiffData[t] << 8) | this._tiffData[t + 1];
        }
        getUint32(t) {
          const e = this._tiffData;
          return this._littleEndian
            ? (e[t + 3] << 24) | (e[t + 2] << 16) | (e[t + 1] << 8) | e[t]
            : (e[t] << 24) | (e[t + 1] << 16) | (e[t + 2] << 8) | e[t + 3];
        }
        checkLittleEndian() {
          const t = this.getUint16(0);
          if (18761 === t) this._littleEndian = !0;
          else {
            if (19789 !== t) throw (console.log(t), TypeError(X(6019)));
            this._littleEndian = !1;
          }
          return this._littleEndian;
        }
        hasTowel() {
          if (42 !== this.getUint16(2)) throw RangeError(X(6020));
          return !0;
        }
        getFieldTypeName(t) {
          return t in Gat ? Gat[t] : null;
        }
        getFieldTagName(t) {
          return t in Hat ? Hat[t] : (B(6021, t), `Tag${t}`);
        }
        getFieldTypeLength(t) {
          return -1 !== ["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(t)
            ? 1
            : -1 !== ["SHORT", "SSHORT"].indexOf(t)
            ? 2
            : -1 !== ["LONG", "SLONG", "FLOAT"].indexOf(t)
            ? 4
            : -1 !== ["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(t)
            ? 8
            : 0;
        }
        getFieldValues(t, e, i, s) {
          const n = [],
            r = this.getFieldTypeLength(e);
          if (r * i <= 4)
            !1 === this._littleEndian ? n.push(s >>> (8 * (4 - r))) : n.push(s);
          else
            for (let t = 0; t < i; t++) {
              const i = r * t;
              r >= 8
                ? -1 !== ["RATIONAL", "SRATIONAL"].indexOf(e)
                  ? (n.push(this.getUint32(s + i)),
                    n.push(this.getUint32(s + i + 4)))
                  : B(8e3)
                : n.push(this.getBytes(r, s + i));
            }
          return (
            "ASCII" === e &&
              n.forEach((t, e, i) => {
                i[e] = String.fromCharCode(t);
              }),
            n
          );
        }
        getBytes(t, e) {
          if (t <= 0) B(8001);
          else {
            if (t <= 1) return this.getUint8(e);
            if (t <= 2) return this.getUint16(e);
            if (t <= 3) return this.getUint32(e) >>> 8;
            if (t <= 4) return this.getUint32(e);
            B(8002);
          }
          return 0;
        }
        getBits(t, e, i) {
          i = i || 0;
          const s = e + Math.floor(i / 8),
            n = i + t,
            r = 32 - t;
          let a = 0,
            o = 0;
          return (
            n <= 0
              ? B(6023)
              : n <= 8
              ? ((a = 24 + i), (o = this.getUint8(s)))
              : n <= 16
              ? ((a = 16 + i), (o = this.getUint16(s)))
              : n <= 32
              ? ((a = i), (o = this.getUint32(s)))
              : B(6022),
            {
              bits: (o << a) >>> r,
              byteOffset: s + Math.floor(n / 8),
              bitOffset: n % 8,
            }
          );
        }
        parseFileDirectory(t) {
          const e = this.getUint16(t),
            i = [];
          let s = 0,
            n = 0;
          for (s = t + 2, n = 0; n < e; s += 12, n++) {
            const t = this.getUint16(s),
              e = this.getUint16(s + 2),
              n = this.getUint32(s + 4),
              r = this.getUint32(s + 8),
              a = this.getFieldTagName(t),
              o = this.getFieldTypeName(e),
              h = this.getFieldValues(a, o, n, r);
            i[a] = { type: o, values: h };
          }
          this._fileDirectories.push(i);
          const r = this.getUint32(s);
          0 !== r && this.parseFileDirectory(r);
        }
        clampColorSample(t, e) {
          const i = Math.pow(2, 8 - e);
          return Math.floor(t * i + (i - 1));
        }
        parseTIFF(t, e) {
          if (
            ((e = e || h.document.createElement("canvas")),
            (this._tiffData = t),
            (this._canvas = e),
            this.checkLittleEndian(),
            !this.hasTowel())
          )
            return;
          const i = this.getUint32(4);
          (this._fileDirectories.length = 0), this.parseFileDirectory(i);
          const s = this._fileDirectories[0],
            n = s.ImageWidth.values[0],
            r = s.ImageLength.values[0];
          (this._canvas.width = n), (this._canvas.height = r);
          const a = [],
            o = s.Compression ? s.Compression.values[0] : 1,
            l = s.SamplesPerPixel.values[0],
            c = [];
          let u = 0,
            _ = !1;
          s.BitsPerSample.values.forEach((t, e) => {
            (c[e] = {
              bitsPerSample: t,
              hasBytesPerSample: !1,
              bytesPerSample: void 0,
            }),
              t % 8 == 0 &&
                ((c[e].hasBytesPerSample = !0), (c[e].bytesPerSample = t / 8)),
              (u += t);
          }, this);
          let d = 0;
          u % 8 == 0 && ((_ = !0), (d = u / 8));
          const p = s.StripOffsets.values,
            m = p.length;
          let f;
          if (s.StripByteCounts) f = s.StripByteCounts.values;
          else {
            if ((B(8003), 1 !== m)) throw Error(X(6024));
            f = [Math.ceil((n * r * u) / 8)];
          }
          let g = 1,
            y = 1;
          for (let t = 0; t < m; t++) {
            const e = p[t];
            a[t] = [];
            const i = f[t];
            for (
              let s = 0, n = 0, r = 1, h = !0, u = [], p = 0, m = 0, f = 0;
              s < i;
              s += r
            )
              switch (o) {
                case 1:
                  u = [];
                  for (let t = 0; t < l; t++) {
                    const i = c[t];
                    if (!i.hasBytesPerSample) {
                      const t = this.getBits(i.bitsPerSample, e + s, n);
                      throw (
                        (u.push(t.bits),
                        (s = t.byteOffset - e),
                        (n = t.bitOffset),
                        RangeError(X(6025)))
                      );
                    }
                    {
                      const n = i.bytesPerSample * t;
                      u.push(this.getBytes(i.bytesPerSample, e + s + n));
                    }
                  }
                  if ((a[t].push(u), !_)) throw ((r = 0), RangeError(X(6026)));
                  r = d;
                  break;
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                  break;
                case 32773:
                  if (h) {
                    h = !1;
                    const t = this.getUint8(e + s);
                    t >= 0 && t <= 127
                      ? (g = t + 1)
                      : t >= -127 && t <= -1
                      ? (y = 1 - t)
                      : (h = !0);
                  } else {
                    const i = this.getUint8(e + s);
                    for (let e = 0; e < y; e++) {
                      const e = c[m];
                      if (!e.hasBytesPerSample) throw RangeError(X(6025));
                      (f = (f << (8 * p)) | i),
                        p++,
                        p === e.bytesPerSample && (u.push(f), (f = p = 0), m++),
                        m === l && (a[t].push(u), (u = []), (m = 0));
                    }
                    g--, 0 === g && (h = !0);
                  }
                  r = 1;
              }
          }
          if (e.getContext) {
            const t = this._canvas.getContext("2d");
            t.fillStyle = "rgba(255, 255, 255, 0)";
            const e = s.RowsPerStrip ? s.RowsPerStrip.values[0] : r,
              i = a.length,
              o = r % e,
              h = 0 === o ? e : o;
            let l = e,
              u = 0;
            const _ = s.PhotometricInterpretation.values[0];
            let d = [],
              p = 0;
            s.ExtraSamples && ((d = s.ExtraSamples.values), (p = d.length));
            let m = [],
              f = 0;
            s.ColorMap &&
              ((m = s.ColorMap.values), (f = Math.pow(2, c[0].bitsPerSample)));
            for (let e = 0; e < i; e++) {
              e + 1 === i && (l = h);
              const s = a[e].length,
                r = u * e;
              for (let i = 0, o = 0; i < l && o < s; i++)
                for (let s = 0; s < n; s++, o++) {
                  const n = a[e][o];
                  let h = 0,
                    l = 0,
                    u = 0,
                    g = 1;
                  if (p > 0)
                    for (let t = 0; t < p; t++)
                      if (1 === d[t] || 2 === d[t]) {
                        g = n[3 + t] / 256;
                        break;
                      }
                  switch (_) {
                    case 0:
                      let t = 0;
                      c[0].hasBytesPerSample &&
                        (t = Math.pow(16, 2 * c[0].bytesPerSample)),
                        n.forEach((e, i, s) => {
                          s[i] = t - e;
                        });
                    case 1:
                      h =
                        l =
                        u =
                          this.clampColorSample(n[0], c[0].bitsPerSample);
                      break;
                    case 2:
                      (h = this.clampColorSample(n[0], c[0].bitsPerSample)),
                        (l = this.clampColorSample(n[1], c[1].bitsPerSample)),
                        (u = this.clampColorSample(n[2], c[2].bitsPerSample));
                      break;
                    case 3:
                      if (void 0 === m) throw Error(X(6027));
                      const e = n[0];
                      (h = this.clampColorSample(m[e], 16)),
                        (l = this.clampColorSample(m[f + e], 16)),
                        (u = this.clampColorSample(m[2 * f + e], 16));
                      break;
                    default:
                      throw RangeError(X(6028, _));
                  }
                  (t.fillStyle = `rgba(${h}, ${l}, ${u}, ${g})`),
                    t.fillRect(s, r + i, 1, 1);
                }
              u = l;
            }
          }
          return this._canvas;
        }
      }
      const Hat = {
          315: "Artist",
          258: "BitsPerSample",
          265: "CellLength",
          264: "CellWidth",
          320: "ColorMap",
          259: "Compression",
          33432: "Copyright",
          306: "DateTime",
          338: "ExtraSamples",
          266: "FillOrder",
          289: "FreeByteCounts",
          288: "FreeOffsets",
          291: "GrayResponseCurve",
          290: "GrayResponseUnit",
          316: "HostComputer",
          270: "ImageDescription",
          257: "ImageLength",
          256: "ImageWidth",
          271: "Make",
          281: "MaxSampleValue",
          280: "MinSampleValue",
          272: "Model",
          254: "NewSubfileType",
          274: "Orientation",
          262: "PhotometricInterpretation",
          284: "PlanarConfiguration",
          296: "ResolutionUnit",
          278: "RowsPerStrip",
          277: "SamplesPerPixel",
          305: "Software",
          279: "StripByteCounts",
          273: "StripOffsets",
          255: "SubfileType",
          263: "Threshholding",
          282: "XResolution",
          283: "YResolution",
          326: "BadFaxLines",
          327: "CleanFaxData",
          343: "ClipPath",
          328: "ConsecutiveBadFaxLines",
          433: "Decode",
          434: "DefaultImageColor",
          269: "DocumentName",
          336: "DotRange",
          321: "HalftoneHints",
          346: "Indexed",
          347: "JPEGTables",
          285: "PageName",
          297: "PageNumber",
          317: "Predictor",
          319: "PrimaryChromaticities",
          532: "ReferenceBlackWhite",
          339: "SampleFormat",
          559: "StripRowCounts",
          330: "SubIFDs",
          292: "T4Options",
          293: "T6Options",
          325: "TileByteCounts",
          323: "TileLength",
          324: "TileOffsets",
          322: "TileWidth",
          301: "TransferFunction",
          318: "WhitePoint",
          344: "XClipPathUnits",
          286: "XPosition",
          529: "YCbCrCoefficients",
          531: "YCbCrPositioning",
          530: "YCbCrSubSampling",
          345: "YClipPathUnits",
          287: "YPosition",
          37378: "ApertureValue",
          40961: "ColorSpace",
          36868: "DateTimeDigitized",
          36867: "DateTimeOriginal",
          34665: "Exif IFD",
          36864: "ExifVersion",
          33434: "ExposureTime",
          41728: "FileSource",
          37385: "Flash",
          40960: "FlashpixVersion",
          33437: "FNumber",
          42016: "ImageUniqueID",
          37384: "LightSource",
          37500: "MakerNote",
          37377: "ShutterSpeedValue",
          37510: "UserComment",
          33723: "IPTC",
          34675: "ICC Profile",
          700: "XMP",
          42112: "GDAL_METADATA",
          42113: "GDAL_NODATA",
          34377: "Photoshop",
        },
        Gat = {
          1: "BYTE",
          2: "ASCII",
          3: "SHORT",
          4: "LONG",
          5: "RATIONAL",
          6: "SBYTE",
          7: "UNDEFINED",
          8: "SSHORT",
          9: "SLONG",
          10: "SRATIONAL",
          11: "FLOAT",
          12: "DOUBLE",
        },
        Vat = new Array(123);
      for (let t = 0; t < 123; ++t) Vat[t] = 64;
      for (let t = 0; t < 64; ++t)
        Vat[
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charCodeAt(
            t
          )
        ] = t;
      var jat = {
          name: "Jacob__Codec__Base64",
          decode: function (t) {
            var e,
              i,
              s,
              n,
              r,
              a,
              o = [],
              h = 0;
            for (t = t.replace(/[^A-Za-z0-9\+\/\=]/g, ""); h < t.length; )
              (e =
                (Vat[t.charCodeAt(h++)] << 2) |
                ((n = Vat[t.charCodeAt(h++)]) >> 4)),
                (i = ((15 & n) << 4) | ((r = Vat[t.charCodeAt(h++)]) >> 2)),
                (s = ((3 & r) << 6) | (a = Vat[t.charCodeAt(h++)])),
                o.push(String.fromCharCode(e)),
                64 !== r && o.push(String.fromCharCode(i)),
                64 !== a && o.push(String.fromCharCode(s));
            return o.join("");
          },
          decodeAsArray: function (t, e) {
            var i,
              s,
              n,
              r = this.decode(t),
              a = [];
            for (i = 0, n = r.length / e; i < n; i++)
              for (a[i] = 0, s = e - 1; s >= 0; --s)
                a[i] += r.charCodeAt(i * e + s) << (8 * s);
            return a;
          },
        },
        Wat = function (t) {
          (this.data = t),
            (this.debug = !1),
            (this.gpflags = void 0),
            (this.files = 0),
            (this.unzipped = []),
            (this.buf32k = new Array(32768)),
            (this.bIdx = 0),
            (this.modeZIP = !1),
            (this.bytepos = 0),
            (this.bb = 1),
            (this.bits = 0),
            (this.nameBuf = []),
            (this.fileout = void 0),
            (this.literalTree = new Array(Wat.LITERALS)),
            (this.distanceTree = new Array(32)),
            (this.treepos = 0),
            (this.Places = null),
            (this.len = 0),
            (this.fpos = new Array(17)),
            (this.fpos[0] = 0),
            (this.flens = void 0),
            (this.fmax = void 0);
        };
      (Wat.gunzip = function (t) {
        return (
          t.constructor === Array || t.constructor, new Wat(t).gunzip()[0][0]
        );
      }),
        (Wat.HufNode = function () {
          (this.b0 = 0), (this.b1 = 0), (this.jump = null), (this.jumppos = -1);
        }),
        (Wat.LITERALS = 288),
        (Wat.NAMEMAX = 256),
        (Wat.bitReverse = [
          0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112,
          240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184,
          120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52,
          180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220,
          60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82,
          210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154,
          90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22,
          150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238,
          30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97,
          225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169,
          105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37,
          165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205,
          45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67,
          195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139,
          75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7,
          135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247,
          15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127,
          255,
        ]),
        (Wat.cplens = [
          3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51,
          59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0,
        ]),
        (Wat.cplext = [
          0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,
          4, 5, 5, 5, 5, 0, 99, 99,
        ]),
        (Wat.cpdist = [
          1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385,
          513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385,
          24577,
        ]),
        (Wat.cpdext = [
          0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
          10, 11, 11, 12, 12, 13, 13,
        ]),
        (Wat.border = [
          16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
        ]),
        (Wat.prototype.gunzip = function () {
          return (this.outputArr = []), this.nextFile(), this.unzipped;
        }),
        (Wat.prototype.readByte = function () {
          return (
            (this.bits += 8),
            this.bytepos < this.data.length
              ? this.data.charCodeAt(this.bytepos++)
              : -1
          );
        }),
        (Wat.prototype.byteAlign = function () {
          this.bb = 1;
        }),
        (Wat.prototype.readBit = function () {
          var t;
          return (
            this.bits++,
            (t = 1 & this.bb),
            (this.bb >>= 1),
            0 === this.bb &&
              ((this.bb = this.readByte()),
              (t = 1 & this.bb),
              (this.bb = (this.bb >> 1) | 128)),
            t
          );
        }),
        (Wat.prototype.readBits = function (t) {
          for (var e = 0, i = t; i--; ) e = (e << 1) | this.readBit();
          return t && (e = Wat.bitReverse[e] >> (8 - t)), e;
        }),
        (Wat.prototype.flushBuffer = function () {
          this.bIdx = 0;
        }),
        (Wat.prototype.addBuffer = function (t) {
          (this.buf32k[this.bIdx++] = t),
            this.outputArr.push(String.fromCharCode(t)),
            32768 === this.bIdx && (this.bIdx = 0);
        }),
        (Wat.prototype.IsPat = function () {
          for (;;) {
            if (this.fpos[this.len] >= this.fmax) return -1;
            if (this.flens[this.fpos[this.len]] === this.len)
              return this.fpos[this.len]++;
            this.fpos[this.len]++;
          }
        }),
        (Wat.prototype.Rec = function () {
          var t,
            e = this.Places[this.treepos];
          if (17 === this.len) return -1;
          if ((this.treepos++, this.len++, (t = this.IsPat()) >= 0)) e.b0 = t;
          else if (((e.b0 = 32768), this.Rec())) return -1;
          if ((t = this.IsPat()) >= 0) (e.b1 = t), (e.jump = null);
          else if (
            ((e.b1 = 32768),
            (e.jump = this.Places[this.treepos]),
            (e.jumppos = this.treepos),
            this.Rec())
          )
            return -1;
          return this.len--, 0;
        }),
        (Wat.prototype.CreateTree = function (t, e, i) {
          var s;
          for (
            this.Places = t,
              this.treepos = 0,
              this.flens = i,
              this.fmax = e,
              s = 0;
            s < 17;
            s++
          )
            this.fpos[s] = 0;
          return (this.len = 0), this.Rec() ? -1 : 0;
        }),
        (Wat.prototype.DecodeValue = function (t) {
          for (var e, i, s = 0, n = t[s]; ; )
            if (this.readBit()) {
              if (!(32768 & n.b1)) return n.b1;
              for (n = n.jump, e = t.length, i = 0; i < e; i++)
                if (t[i] === n) {
                  s = i;
                  break;
                }
            } else {
              if (!(32768 & n.b0)) return n.b0;
              n = t[++s];
            }
          return -1;
        }),
        (Wat.prototype.DeflateLoop = function () {
          var t, e, i;
          do {
            var s, n;
            if (((t = this.readBit()), 0 === (e = this.readBits(2))))
              for (
                this.byteAlign(),
                  s = this.readByte(),
                  s |= this.readByte() << 8,
                  n = this.readByte(),
                  65535 & (s ^ ~(n |= this.readByte() << 8)) &&
                    document.write("BlockLen checksum mismatch\n");
                s--;

              )
                (r = this.readByte()), this.addBuffer(r);
            else if (1 === e)
              for (;;)
                if (
                  ((a = Wat.bitReverse[this.readBits(7)] >> 1) > 23
                    ? (a = (a << 1) | this.readBit()) > 199
                      ? (a = ((a -= 128) << 1) | this.readBit())
                      : (a -= 48) > 143 && (a += 136)
                    : (a += 256),
                  a < 256)
                )
                  this.addBuffer(a);
                else {
                  if (256 === a) break;
                  for (
                    a -= 257,
                      p = this.readBits(Wat.cplext[a]) + Wat.cplens[a],
                      a = Wat.bitReverse[this.readBits(5)] >> 3,
                      Wat.cpdext[a] > 8
                        ? ((m = this.readBits(8)),
                          (m |= this.readBits(Wat.cpdext[a] - 8) << 8))
                        : (m = this.readBits(Wat.cpdext[a])),
                      m += Wat.cpdist[a],
                      a = 0;
                    a < p;
                    a++
                  ) {
                    var r = this.buf32k[(this.bIdx - m) & 32767];
                    this.addBuffer(r);
                  }
                }
            else if (2 === e) {
              var a,
                o,
                h,
                l,
                c,
                u = new Array(320);
              for (
                h = 257 + this.readBits(5),
                  l = 1 + this.readBits(5),
                  c = 4 + this.readBits(4),
                  a = 0;
                a < 19;
                a++
              )
                u[a] = 0;
              for (a = 0; a < c; a++) u[Wat.border[a]] = this.readBits(3);
              for (p = this.distanceTree.length, i = 0; i < p; i++)
                this.distanceTree[i] = new Wat.HufNode();
              if (this.CreateTree(this.distanceTree, 19, u, 0))
                return this.flushBuffer(), 1;
              for (o = h + l, i = 0; i < o; )
                if ((a = this.DecodeValue(this.distanceTree)) < 16) u[i++] = a;
                else if (16 === a) {
                  var _;
                  if (i + (a = 3 + this.readBits(2)) > o)
                    return this.flushBuffer(), 1;
                  for (_ = i ? u[i - 1] : 0; a--; ) u[i++] = _;
                } else {
                  if (
                    i +
                      (a =
                        17 === a
                          ? 3 + this.readBits(3)
                          : 11 + this.readBits(7)) >
                    o
                  )
                    return this.flushBuffer(), 1;
                  for (; a--; ) u[i++] = 0;
                }
              for (p = this.literalTree.length, i = 0; i < p; i++)
                this.literalTree[i] = new Wat.HufNode();
              if (this.CreateTree(this.literalTree, h, u, 0))
                return this.flushBuffer(), 1;
              for (p = this.literalTree.length, i = 0; i < p; i++)
                this.distanceTree[i] = new Wat.HufNode();
              var d = new Array();
              for (i = h; i < u.length; i++) d[i - h] = u[i];
              if (this.CreateTree(this.distanceTree, l, d, 0))
                return this.flushBuffer(), 1;
              for (;;)
                if ((a = this.DecodeValue(this.literalTree)) >= 256) {
                  var p, m;
                  if (0 == (a -= 256)) break;
                  for (
                    a--,
                      p = this.readBits(Wat.cplext[a]) + Wat.cplens[a],
                      a = this.DecodeValue(this.distanceTree),
                      Wat.cpdext[a] > 8
                        ? ((m = this.readBits(8)),
                          (m |= this.readBits(Wat.cpdext[a] - 8) << 8))
                        : (m = this.readBits(Wat.cpdext[a])),
                      m += Wat.cpdist[a];
                    p--;

                  )
                    (r = this.buf32k[(this.bIdx - m) & 32767]),
                      this.addBuffer(r);
                } else this.addBuffer(a);
            }
          } while (!t);
          return this.flushBuffer(), this.byteAlign(), 0;
        }),
        (Wat.prototype.unzipFile = function (t) {
          var e;
          for (this.gunzip(), e = 0; e < this.unzipped.length; e++)
            if (this.unzipped[e][1] === t) return this.unzipped[e][0];
        }),
        (Wat.prototype.nextFile = function () {
          (this.outputArr = []), (this.modeZIP = !1);
          var t = [];
          if (
            ((t[0] = this.readByte()),
            (t[1] = this.readByte()),
            120 === t[0] &&
              218 === t[1] &&
              (this.DeflateLoop(),
              (this.unzipped[this.files] = [
                this.outputArr.join(""),
                "geonext.gxt",
              ]),
              this.files++),
            31 === t[0] &&
              139 === t[1] &&
              (this.skipdir(),
              (this.unzipped[this.files] = [this.outputArr.join(""), "file"]),
              this.files++),
            80 === t[0] &&
              75 === t[1] &&
              ((this.modeZIP = !0),
              (t[2] = this.readByte()),
              (t[3] = this.readByte()),
              3 === t[2] && 4 === t[3]))
          ) {
            (t[0] = this.readByte()),
              (t[1] = this.readByte()),
              (this.gpflags = this.readByte()),
              (this.gpflags |= this.readByte() << 8);
            var e = this.readByte();
            (e |= this.readByte() << 8),
              this.readByte(),
              this.readByte(),
              this.readByte(),
              this.readByte(),
              this.readByte(),
              this.readByte(),
              this.readByte(),
              this.readByte(),
              this.readByte(),
              this.readByte(),
              this.readByte(),
              this.readByte();
            var i = this.readByte();
            i |= this.readByte() << 8;
            var s = this.readByte();
            for (s |= this.readByte() << 8, r = 0, this.nameBuf = []; i--; ) {
              var n = this.readByte();
              ("/" === n) | (":" === n)
                ? (r = 0)
                : r < Wat.NAMEMAX - 1 &&
                  (this.nameBuf[r++] = String.fromCharCode(n));
            }
            this.fileout || (this.fileout = this.nameBuf);
            for (var r = 0; r < s; ) (n = this.readByte()), r++;
            8 === e &&
              (this.DeflateLoop(),
              (this.unzipped[this.files] = [
                this.outputArr.join(""),
                this.nameBuf.join(""),
              ]),
              this.files++),
              this.skipdir();
          }
        }),
        (Wat.prototype.skipdir = function () {
          var t,
            e,
            i = [];
          if (
            (8 & this.gpflags &&
              ((i[0] = this.readByte()),
              (i[1] = this.readByte()),
              (i[2] = this.readByte()),
              (i[3] = this.readByte()),
              this.readByte(),
              this.readByte(),
              this.readByte(),
              this.readByte(),
              this.readByte(),
              this.readByte(),
              this.readByte(),
              this.readByte()),
            this.modeZIP && this.nextFile(),
            (i[0] = this.readByte()),
            8 !== i[0])
          )
            return 0;
          if (
            ((this.gpflags = this.readByte()),
            this.readByte(),
            this.readByte(),
            this.readByte(),
            this.readByte(),
            this.readByte(),
            this.readByte(),
            4 & this.gpflags)
          )
            for (
              i[0] = this.readByte(),
                i[2] = this.readByte(),
                this.len = i[0] + 256 * i[1],
                t = 0;
              t < this.len;
              t++
            )
              this.readByte();
          if (8 & this.gpflags)
            for (t = 0, this.nameBuf = []; (e = this.readByte()); )
              ("7" !== e && ":" !== e) || (t = 0),
                t < Wat.NAMEMAX - 1 && (this.nameBuf[t++] = e);
          if (16 & this.gpflags) for (; (e = this.readByte()); );
          2 & this.gpflags && (this.readByte(), this.readByte()),
            this.DeflateLoop(),
            this.readByte(),
            this.readByte(),
            this.readByte(),
            this.readByte(),
            this.modeZIP && this.nextFile();
        });
      var Xat,
        Yat,
        Kat,
        qat,
        $at,
        Zat,
        Qat,
        Jat,
        tot,
        eot,
        iot,
        sot,
        not,
        rot,
        aot,
        oot,
        hot,
        lot,
        cot,
        uot,
        _ot,
        dot,
        pot,
        mot,
        fot,
        got,
        yot,
        Tot,
        Sot,
        Eot,
        vot,
        bot,
        Aot,
        Cot,
        Oot,
        Iot,
        wot,
        Rot,
        Dot,
        xot,
        Mot,
        Pot,
        Not,
        Lot,
        Bot,
        Fot,
        Uot,
        kot,
        zot,
        Hot,
        Got,
        Vot,
        jot = { name: "Jacob__Codec" };
      let Wot;
      function Xot(t) {
        const e = t.parent,
          i = t.getComponent(Yot);
        return e && i ? Xot(e) : t.getComponentsInChildren(Yot);
      }
      (jot.Base64 = jat),
        (jot.GZip = Wat),
        (jot.unzip = function () {
          return jot.GZip.gunzip.apply(jot.GZip, arguments);
        }),
        (jot.unzipBase64 = function () {
          var t = jot.Base64.decode.apply(jot.Base64, arguments);
          try {
            return jot.GZip.gunzip.call(jot.GZip, t);
          } catch (e) {
            return t.slice(7);
          }
        }),
        (jot.unzipBase64AsArray = function (t, e) {
          e = e || 1;
          var i,
            s,
            n,
            r = this.unzipBase64(t),
            a = [];
          for (i = 0, n = r.length / e; i < n; i++)
            for (a[i] = 0, s = e - 1; s >= 0; --s)
              a[i] += r.charCodeAt(i * e + s) << (8 * s);
          return a;
        }),
        (jot.unzipAsArray = function (t, e) {
          e = e || 1;
          var i,
            s,
            n,
            r = this.unzip(t),
            a = [];
          for (i = 0, n = r.length / e; i < n; i++)
            for (a[i] = 0, s = e - 1; s >= 0; --s)
              a[i] += r.charCodeAt(i * e + s) << (8 * s);
          return a;
        }),
        (function (t) {
          (t[(t.JPG = 0)] = "JPG"),
            (t[(t.PNG = 1)] = "PNG"),
            (t[(t.TIFF = 2)] = "TIFF"),
            (t[(t.WEBP = 3)] = "WEBP"),
            (t[(t.PVR = 4)] = "PVR"),
            (t[(t.ETC = 5)] = "ETC"),
            (t[(t.S3TC = 6)] = "S3TC"),
            (t[(t.ATITC = 7)] = "ATITC"),
            (t[(t.TGA = 8)] = "TGA"),
            (t[(t.RAWDATA = 9)] = "RAWDATA"),
            (t[(t.UNKNOWN = 10)] = "UNKNOWN");
        })(Wot || (Wot = {}));
      let Yot = t(
        "ParticleSystem2D",
        ((Xat = Ca("cc.ParticleSystem2D")),
        (Yat = ao(Bat)),
        (Kat = ao(uC)),
        (qat = ao(Tat)),
        ($at = ao(yat)),
        (Zat = La("preview")),
        Xat(
          (((Vot = class t extends ew {
            get custom() {
              return this._custom;
            }
            set custom(t) {
              this._custom !== t &&
                ((this._custom = t), this._applyFile(), this._updateMaterial());
            }
            get file() {
              return this._file;
            }
            set file(t) {
              this._file !== t &&
                ((this._file = t), t ? this._applyFile() : (this.custom = !0));
            }
            get spriteFrame() {
              return this._spriteFrame;
            }
            set spriteFrame(t) {
              this._renderSpriteFrame !== t &&
                ((this._renderSpriteFrame = t),
                (t && !t._uuid) || (this._spriteFrame = t),
                this._applySpriteFrame());
            }
            get particleCount() {
              return this._simulator.particles.length;
            }
            get totalParticles() {
              return this._totalParticles;
            }
            set totalParticles(t) {
              this._totalParticles !== t && (this._totalParticles = t);
            }
            get startColor() {
              return this._startColor;
            }
            set startColor(t) {
              (this._startColor.r = t.r),
                (this._startColor.g = t.g),
                (this._startColor.b = t.b),
                (this._startColor.a = t.a);
            }
            get startColorVar() {
              return this._startColorVar;
            }
            set startColorVar(t) {
              (this._startColorVar.r = t.r),
                (this._startColorVar.g = t.g),
                (this._startColorVar.b = t.b),
                (this._startColorVar.a = t.a);
            }
            set color(t) {}
            get color() {
              return this._color;
            }
            get endColor() {
              return this._endColor;
            }
            set endColor(t) {
              (this._endColor.r = t.r),
                (this._endColor.g = t.g),
                (this._endColor.b = t.b),
                (this._endColor.a = t.a);
            }
            get endColorVar() {
              return this._endColorVar;
            }
            set endColorVar(t) {
              (this._endColorVar.r = t.r),
                (this._endColorVar.g = t.g),
                (this._endColorVar.b = t.b),
                (this._endColorVar.a = t.a);
            }
            get positionType() {
              return this._positionType;
            }
            set positionType(t) {
              (this._positionType = t),
                this._updateMaterial(),
                this._updatePositionType();
            }
            get preview() {
              return this._preview;
            }
            set preview(t) {
              t ? this._startPreview() : this._stopPreview(),
                (this._preview = t);
            }
            get stopped() {
              return this._stopped;
            }
            get active() {
              return this._simulator.active;
            }
            get assembler() {
              return this._assembler;
            }
            constructor() {
              super(),
                (this.duration = tot && tot()),
                (this.emissionRate = eot && eot()),
                (this.life = iot && iot()),
                (this.lifeVar = sot && sot()),
                (this.angle = not && not()),
                (this.angleVar = rot && rot()),
                (this.startSize = aot && aot()),
                (this.startSizeVar = oot && oot()),
                (this.endSize = hot && hot()),
                (this.endSizeVar = lot && lot()),
                (this.startSpin = cot && cot()),
                (this.startSpinVar = uot && uot()),
                (this.endSpin = _ot && _ot()),
                (this.endSpinVar = dot && dot()),
                (this.sourcePos = pot && pot()),
                (this.posVar = mot && mot()),
                (this.emitterMode = fot && fot()),
                (this.gravity = got && got()),
                (this.speed = yot && yot()),
                (this.speedVar = Tot && Tot()),
                (this.tangentialAccel = Sot && Sot()),
                (this.tangentialAccelVar = Eot && Eot()),
                (this.radialAccel = vot && vot()),
                (this.radialAccelVar = bot && bot()),
                (this.rotationIsDir = Aot && Aot()),
                (this.startRadius = Cot && Cot()),
                (this.startRadiusVar = Oot && Oot()),
                (this.endRadius = Iot && Iot()),
                (this.endRadiusVar = wot && wot()),
                (this.rotatePerS = Rot && Rot()),
                (this.rotatePerSVar = Dot && Dot()),
                (this.aspectRatio = 1),
                (this.playOnLoad = xot && xot()),
                (this.autoRemoveOnFinish = Mot && Mot()),
                (this._preview = Pot && Pot()),
                (this._custom = Not && Not()),
                (this._file = Lot && Lot()),
                (this._spriteFrame = Bot && Bot()),
                (this._totalParticles = Fot && Fot()),
                (this._startColor = Uot && Uot()),
                (this._startColorVar = kot && kot()),
                (this._endColor = zot && zot()),
                (this._endColorVar = Hot && Hot()),
                (this._positionType = Got && Got()),
                (this._stopped = !0),
                (this._useFile = void 0),
                this.initProperties(),
                (this._useFile = !1);
            }
            onEnable() {
              super.onEnable(),
                this._updateMaterial(),
                this._updatePositionType();
            }
            onDestroy() {
              super.onDestroy(),
                this.autoRemoveOnFinish && (this.autoRemoveOnFinish = !1),
                (this._simulator.uvFilled = 0),
                this._simulator.renderData &&
                  this._assembler &&
                  this._assembler.removeData(this._simulator.renderData);
            }
            initProperties() {
              (this._previewTimer = null),
                (this._focused = !1),
                (this.aspectRatio = 1),
                (this._simulator = new Rat(this));
            }
            onFocusInEditor() {
              this._focused = !0;
              const t = Xot(this.node);
              for (let e = 0; e < t.length; ++e) t[e]._startPreview();
            }
            onLostFocusInEditor() {
              this._focused = !1;
              const t = Xot(this.node);
              for (let e = 0; e < t.length; ++e) t[e]._stopPreview();
            }
            _startPreview() {
              this._preview && this.resetSystem();
            }
            _stopPreview() {
              this._preview && (this.resetSystem(), this.stopSystem()),
                this._previewTimer && clearInterval(this._previewTimer);
            }
            __preload() {
              super.__preload(),
                this._custom && this.spriteFrame && !this._renderSpriteFrame
                  ? this._applySpriteFrame()
                  : this._file &&
                    (this._custom
                      ? !this._getTexture() && this._applyFile()
                      : this._applyFile()),
                this.playOnLoad && this.resetSystem();
            }
            _flushAssembler() {
              const e = t.Assembler.getAssembler(this);
              this._assembler !== e && (this._assembler = e),
                this._assembler &&
                  this._assembler.createData &&
                  ((this._simulator.renderData =
                    this._assembler.createData(this)),
                  this._simulator.renderData.particleInitRenderDrawInfo(
                    this.renderEntity
                  ),
                  this._simulator.initDrawInfo());
            }
            lateUpdate(t) {
              this._simulator.finished || this._simulator.step(t);
            }
            addParticle() {}
            stopSystem() {
              (this._stopped = !0), this._simulator.stop();
            }
            resetSystem() {
              (this._stopped = !1),
                this._simulator.reset(),
                this.markForUpdateRenderData();
            }
            isFull() {
              return this.particleCount >= this.totalParticles;
            }
            _applyFile() {
              const t = this._file;
              if (t) {
                if (!t) return void G(6029);
                if (!this.isValid) return;
                (this._plistFile = t.nativeUrl),
                  this._custom ||
                    (this._spriteFrame !== t.spriteFrame &&
                      (this.spriteFrame = t.spriteFrame),
                    this._initWithDictionary(t._nativeAsset)),
                  this._spriteFrame
                    ? !this._renderSpriteFrame &&
                      this._spriteFrame &&
                      this._applySpriteFrame()
                    : t.spriteFrame
                    ? (this.spriteFrame = t.spriteFrame)
                    : this._custom &&
                      this._initTextureWithDictionary(t._nativeAsset);
              }
            }
            _initTextureWithDictionary(t) {
              if (t.spriteFrameUuid) {
                const e = t.spriteFrameUuid;
                Tv.loadAny(e, (e, i) => {
                  e
                    ? ((t.spriteFrameUuid = void 0),
                      this._initTextureWithDictionary(t),
                      R(e))
                    : (this.spriteFrame = i);
                });
              } else {
                const i = wr(this._plistFile, t.textureFileName || "");
                if (t.textureFileName)
                  Tv.loadRemote(i, (e, i) => {
                    e
                      ? ((t.textureFileName = void 0),
                        this._initTextureWithDictionary(t),
                        R(e))
                      : (this.spriteFrame = i
                          ? uC.createWithImage(i)
                          : uC.createWithImage(Pv.get("white-texture")));
                  });
                else if (t.textureImageData) {
                  const s = t.textureImageData;
                  if (!(s && s.length > 0)) return !1;
                  {
                    let t = i;
                    this.file && (t += `-${this.file.uuid}`);
                    let n = Tv.assets.get(t);
                    if (!n) {
                      const i = jot.unzipBase64AsArray(s, 1);
                      if (!i) return z(6030, this._file.name), !1;
                      const r =
                        (e = i).length > 8 &&
                        137 === e[0] &&
                        80 === e[1] &&
                        78 === e[2] &&
                        71 === e[3] &&
                        13 === e[4] &&
                        10 === e[5] &&
                        26 === e[6] &&
                        10 === e[7]
                          ? Wot.PNG
                          : e.length > 2 &&
                            ((73 === e[0] && 73 === e[1]) ||
                              (77 === e[0] && 77 === e[1]) ||
                              (255 === e[0] && 216 === e[1]))
                          ? Wot.TIFF
                          : Wot.UNKNOWN;
                      if (r !== Wot.TIFF && r !== Wot.PNG)
                        return z(6031, this._file.name), !1;
                      const a = h.document.createElement("canvas");
                      r === Wot.PNG
                        ? new kat(i).render(a)
                        : (this._tiffReader || (this._tiffReader = new zat()),
                          this._tiffReader.parseTIFF(i, a)),
                        (n = new wd(a)),
                        Tv.assets.add(t, n);
                    }
                    n || z(6032, this._file.name),
                      (this.spriteFrame = n
                        ? uC.createWithImage(n)
                        : uC.createWithImage(Pv.get("white-texture")));
                  }
                }
              }
              var e;
              return !0;
            }
            _initWithDictionary(t) {
              (this._useFile = !0),
                (this.totalParticles = parseInt(t.maxParticles || 0)),
                (this.life = parseFloat(t.particleLifespan || 0)),
                (this.lifeVar = parseFloat(t.particleLifespanVariance || 0));
              const e = t.emissionRate;
              (this.emissionRate =
                e ||
                Math.min(this.totalParticles / this.life, Number.MAX_VALUE)),
                (this.duration = parseFloat(t.duration || 0)),
                (this._srcBlendFactor = parseInt(
                  t.blendFuncSource || Pc.SRC_ALPHA
                )),
                (this._dstBlendFactor = parseInt(
                  t.blendFuncDestination || Pc.ONE_MINUS_SRC_ALPHA
                ));
              const i = this._startColor;
              (i.r = 255 * parseFloat(t.startColorRed || 0)),
                (i.g = 255 * parseFloat(t.startColorGreen || 0)),
                (i.b = 255 * parseFloat(t.startColorBlue || 0)),
                (i.a = 255 * parseFloat(t.startColorAlpha || 0));
              const s = this._startColorVar;
              (s.r = 255 * parseFloat(t.startColorVarianceRed || 0)),
                (s.g = 255 * parseFloat(t.startColorVarianceGreen || 0)),
                (s.b = 255 * parseFloat(t.startColorVarianceBlue || 0)),
                (s.a = 255 * parseFloat(t.startColorVarianceAlpha || 0));
              const n = this._endColor;
              (n.r = 255 * parseFloat(t.finishColorRed || 0)),
                (n.g = 255 * parseFloat(t.finishColorGreen || 0)),
                (n.b = 255 * parseFloat(t.finishColorBlue || 0)),
                (n.a = 255 * parseFloat(t.finishColorAlpha || 0));
              const r = this._endColorVar;
              if (
                ((r.r = 255 * parseFloat(t.finishColorVarianceRed || 0)),
                (r.g = 255 * parseFloat(t.finishColorVarianceGreen || 0)),
                (r.b = 255 * parseFloat(t.finishColorVarianceBlue || 0)),
                (r.a = 255 * parseFloat(t.finishColorVarianceAlpha || 0)),
                (this.startSize = parseFloat(t.startParticleSize || 0)),
                (this.startSizeVar = parseFloat(
                  t.startParticleSizeVariance || 0
                )),
                (this.endSize = parseFloat(t.finishParticleSize || 0)),
                (this.endSizeVar = parseFloat(
                  t.finishParticleSizeVariance || 0
                )),
                (this.positionType = parseFloat(
                  void 0 !== t.positionType ? t.positionType : Tat.FREE
                )),
                this.sourcePos.set(0, 0),
                this.posVar.set(
                  parseFloat(t.sourcePositionVariancex || 0),
                  parseFloat(t.sourcePositionVariancey || 0)
                ),
                (this.angle = parseFloat(t.angle || 0)),
                (this.angleVar = parseFloat(t.angleVariance || 0)),
                (this.startSpin = parseFloat(t.rotationStart || 0)),
                (this.startSpinVar = parseFloat(t.rotationStartVariance || 0)),
                (this.endSpin = parseFloat(t.rotationEnd || 0)),
                (this.endSpinVar = parseFloat(t.rotationEndVariance || 0)),
                (this.emitterMode = parseInt(t.emitterType || yat.GRAVITY)),
                this.emitterMode === yat.GRAVITY)
              ) {
                this.gravity.set(
                  parseFloat(t.gravityx || 0),
                  parseFloat(t.gravityy || 0)
                ),
                  (this.speed = parseFloat(t.speed || 0)),
                  (this.speedVar = parseFloat(t.speedVariance || 0)),
                  (this.radialAccel = parseFloat(t.radialAcceleration || 0)),
                  (this.radialAccelVar = parseFloat(
                    t.radialAccelVariance || 0
                  )),
                  (this.tangentialAccel = parseFloat(
                    t.tangentialAcceleration || 0
                  )),
                  (this.tangentialAccelVar = parseFloat(
                    t.tangentialAccelVariance || 0
                  ));
                let e = t.rotationIsDir || "";
                null !== e
                  ? ((e = e.toString().toLowerCase()),
                    (this.rotationIsDir = "true" === e || "1" === e))
                  : (this.rotationIsDir = !1);
              } else {
                if (this.emitterMode !== yat.RADIUS) return z(6009), !1;
                (this.startRadius = parseFloat(t.maxRadius || 0)),
                  (this.startRadiusVar = parseFloat(t.maxRadiusVariance || 0)),
                  (this.endRadius = parseFloat(t.minRadius || 0)),
                  (this.endRadiusVar = parseFloat(t.minRadiusVariance || 0)),
                  (this.rotatePerS = parseFloat(t.rotatePerSecond || 0)),
                  (this.rotatePerSVar = parseFloat(
                    t.rotatePerSecondVariance || 0
                  ));
              }
              return this._initTextureWithDictionary(t), !0;
            }
            _syncAspect() {
              if (this._renderSpriteFrame) {
                const t = this._renderSpriteFrame.rect;
                this.aspectRatio = t.width / t.height;
              }
            }
            _applySpriteFrame() {
              (this._renderSpriteFrame =
                this._renderSpriteFrame || this._spriteFrame),
                this._renderSpriteFrame
                  ? this._renderSpriteFrame.texture &&
                    (this._simulator && this._simulator.updateUVs(!0),
                    this._syncAspect(),
                    this._updateMaterial(),
                    (this._stopped = !1),
                    this.markForUpdateRenderData())
                  : this.resetSystem();
            }
            _getTexture() {
              return this._renderSpriteFrame && this._renderSpriteFrame.texture;
            }
            _updateMaterial() {
              if (this._customMaterial) {
                this.setSharedMaterial(this._customMaterial, 0);
                const t =
                  this.getRenderMaterial(0).passes[0].blendState.targets[0];
                (this._dstBlendFactor = t.blendDst),
                  (this._srcBlendFactor = t.blendSrc);
              }
              const t = this.getMaterialInstance(0);
              t &&
                t.recompileShaders({
                  USE_LOCAL: this._positionType !== Tat.FREE,
                }),
                t && t.passes.length > 0 && this._updateBlendFunc();
            }
            _finishedSimulation() {
              this.resetSystem(),
                this.stopSystem(),
                this.markForUpdateRenderData(),
                this.autoRemoveOnFinish && this._stopped && this.node.destroy();
            }
            _canRender() {
              return (
                super._canRender() &&
                !this._stopped &&
                null !== this._renderSpriteFrame &&
                void 0 !== this._renderSpriteFrame
              );
            }
            _render(t) {
              this._positionType === Tat.RELATIVE
                ? t.commitComp(
                    this,
                    this._simulator.renderData,
                    this._renderSpriteFrame,
                    this._assembler,
                    this.node.parent
                  )
                : this.positionType === Tat.GROUPED
                ? t.commitComp(
                    this,
                    this._simulator.renderData,
                    this._renderSpriteFrame,
                    this._assembler,
                    this.node
                  )
                : t.commitComp(
                    this,
                    this._simulator.renderData,
                    this._renderSpriteFrame,
                    this._assembler,
                    null
                  );
            }
            _updatePositionType() {
              this._positionType === Tat.RELATIVE
                ? (this._renderEntity.setRenderTransform(this.node.parent),
                  this._renderEntity.setUseLocal(!0))
                : this.positionType === Tat.GROUPED
                ? (this._renderEntity.setRenderTransform(this.node),
                  this._renderEntity.setUseLocal(!0))
                : (this._renderEntity.setRenderTransform(null),
                  this._renderEntity.setUseLocal(!1));
            }
          }).EmitterMode = yat),
          (Vot.PositionType = Tat),
          (Vot.DURATION_INFINITY = -1),
          (Vot.START_SIZE_EQUAL_TO_END_SIZE = -1),
          (Vot.START_RADIUS_EQUAL_TO_END_RADIUS = -1),
          s(
            (Jat = Vot).prototype,
            "file",
            [Yat],
            Object.getOwnPropertyDescriptor(Jat.prototype, "file"),
            Jat.prototype
          ),
          s(
            Jat.prototype,
            "spriteFrame",
            [Kat],
            Object.getOwnPropertyDescriptor(Jat.prototype, "spriteFrame"),
            Jat.prototype
          ),
          (tot = fa(Jat.prototype, "duration", [Na], function () {
            return -1;
          })),
          (eot = fa(Jat.prototype, "emissionRate", [Na], function () {
            return 10;
          })),
          (iot = fa(Jat.prototype, "life", [Na], function () {
            return 1;
          })),
          (sot = fa(Jat.prototype, "lifeVar", [Na], function () {
            return 0;
          })),
          s(
            Jat.prototype,
            "color",
            [oo],
            Object.getOwnPropertyDescriptor(Jat.prototype, "color"),
            Jat.prototype
          ),
          (not = fa(Jat.prototype, "angle", [Na], function () {
            return 90;
          })),
          (rot = fa(Jat.prototype, "angleVar", [Na], function () {
            return 20;
          })),
          (aot = fa(Jat.prototype, "startSize", [Na], function () {
            return 50;
          })),
          (oot = fa(Jat.prototype, "startSizeVar", [Na], function () {
            return 0;
          })),
          (hot = fa(Jat.prototype, "endSize", [Na], function () {
            return 0;
          })),
          (lot = fa(Jat.prototype, "endSizeVar", [Na], function () {
            return 0;
          })),
          (cot = fa(Jat.prototype, "startSpin", [Na], function () {
            return 0;
          })),
          (uot = fa(Jat.prototype, "startSpinVar", [Na], function () {
            return 0;
          })),
          (_ot = fa(Jat.prototype, "endSpin", [Na], function () {
            return 0;
          })),
          (dot = fa(Jat.prototype, "endSpinVar", [Na], function () {
            return 0;
          })),
          (pot = fa(Jat.prototype, "sourcePos", [Na], function () {
            return Ss.ZERO.clone();
          })),
          (mot = fa(Jat.prototype, "posVar", [Na], function () {
            return Ss.ZERO.clone();
          })),
          s(
            Jat.prototype,
            "positionType",
            [qat],
            Object.getOwnPropertyDescriptor(Jat.prototype, "positionType"),
            Jat.prototype
          ),
          (fot = fa(Jat.prototype, "emitterMode", [Na, $at], function () {
            return yat.GRAVITY;
          })),
          (got = fa(Jat.prototype, "gravity", [Na], function () {
            return Ss.ZERO.clone();
          })),
          (yot = fa(Jat.prototype, "speed", [Na], function () {
            return 180;
          })),
          (Tot = fa(Jat.prototype, "speedVar", [Na], function () {
            return 50;
          })),
          (Sot = fa(Jat.prototype, "tangentialAccel", [Na], function () {
            return 80;
          })),
          (Eot = fa(Jat.prototype, "tangentialAccelVar", [Na], function () {
            return 0;
          })),
          (vot = fa(Jat.prototype, "radialAccel", [Na], function () {
            return 0;
          })),
          (bot = fa(Jat.prototype, "radialAccelVar", [Na], function () {
            return 0;
          })),
          (Aot = fa(Jat.prototype, "rotationIsDir", [Na], function () {
            return !1;
          })),
          (Cot = fa(Jat.prototype, "startRadius", [Na], function () {
            return 0;
          })),
          (Oot = fa(Jat.prototype, "startRadiusVar", [Na], function () {
            return 0;
          })),
          (Iot = fa(Jat.prototype, "endRadius", [Na], function () {
            return 0;
          })),
          (wot = fa(Jat.prototype, "endRadiusVar", [Na], function () {
            return 0;
          })),
          (Rot = fa(Jat.prototype, "rotatePerS", [Na], function () {
            return 0;
          })),
          (Dot = fa(Jat.prototype, "rotatePerSVar", [Na], function () {
            return 0;
          })),
          (xot = fa(Jat.prototype, "playOnLoad", [Na], function () {
            return !0;
          })),
          (Mot = fa(Jat.prototype, "autoRemoveOnFinish", [Na], function () {
            return !1;
          })),
          (Pot = fa(Jat.prototype, "_preview", [Zat], function () {
            return !0;
          })),
          (Not = fa(Jat.prototype, "_custom", [Na], function () {
            return !1;
          })),
          (Lot = fa(Jat.prototype, "_file", [Na], function () {
            return null;
          })),
          (Bot = fa(Jat.prototype, "_spriteFrame", [Na], function () {
            return null;
          })),
          (Fot = fa(Jat.prototype, "_totalParticles", [Na], function () {
            return 150;
          })),
          (Uot = fa(Jat.prototype, "_startColor", [Na], function () {
            return new Qi(255, 255, 255, 255);
          })),
          (kot = fa(Jat.prototype, "_startColorVar", [Na], function () {
            return new Qi(0, 0, 0, 0);
          })),
          (zot = fa(Jat.prototype, "_endColor", [Na], function () {
            return new Qi(255, 255, 255, 0);
          })),
          (Hot = fa(Jat.prototype, "_endColorVar", [Na], function () {
            return new Qi(0, 0, 0, 0);
          })),
          (Got = fa(Jat.prototype, "_positionType", [Na], function () {
            return Tat.FREE;
          })),
          (Qat = Jat))
        ) || Qat)
      );
      var Kot, qot, $ot, Zot, Qot, Jot, tht, eht, iht, sht, nht;
      let rht = t(
        "MotionStreak",
        ((Kot = Ca("cc.MotionStreak")),
        (qot = ao(sm)),
        Kot(
          (((nht = class t extends ew {
            constructor(...t) {
              super(...t),
                (this._preview = Qot && Qot()),
                (this._fadeTime = Jot && Jot()),
                (this._minSeg = tht && tht()),
                (this._stroke = eht && eht()),
                (this._texture = iht && iht()),
                (this._fastMode = sht && sht()),
                (this._points = []);
            }
            get preview() {
              return this._preview;
            }
            set preview(t) {
              (this._preview = t), this.reset();
            }
            get fadeTime() {
              return this._fadeTime;
            }
            set fadeTime(t) {
              (this._fadeTime = t), this.reset();
            }
            get minSeg() {
              return this._minSeg;
            }
            set minSeg(t) {
              this._minSeg = t;
            }
            get stroke() {
              return this._stroke;
            }
            set stroke(t) {
              this._stroke = t;
            }
            get texture() {
              return this._texture;
            }
            set texture(t) {
              this._texture !== t && (this._texture = t);
            }
            get fastMode() {
              return this._fastMode;
            }
            set fastMode(t) {
              this._fastMode = t;
            }
            get points() {
              return this._points;
            }
            onEnable() {
              super.onEnable(), this.reset();
            }
            _flushAssembler() {
              const e = t.Assembler.getAssembler(this);
              this._assembler !== e && (this._assembler = e),
                this._renderData ||
                  (this._assembler &&
                    this._assembler.createData &&
                    ((this._renderData = this._assembler.createData(this)),
                    (this._renderData.material = this.material),
                    this._updateColor()));
            }
            onFocusInEditor() {
              this._preview && this.reset();
            }
            onLostFocusInEditor() {
              this._preview && this.reset();
            }
            reset() {
              (this._points.length = 0),
                this._renderData && this._renderData.clear();
            }
            lateUpdate(t) {
              this._assembler && this._assembler.update(this, t);
            }
            _render(t) {
              t.commitComp(
                this,
                this._renderData,
                this._texture,
                this._assembler,
                null
              );
            }
          }).Point = class {
            constructor(t, e) {
              (this.point = new Ss()),
                (this.dir = new Ss()),
                (this.distance = 0),
                (this.time = 0),
                t && this.point.set(t),
                e && this.dir.set(e);
            }
            setPoint(t, e) {
              (this.point.x = t), (this.point.y = e);
            }
            setDir(t, e) {
              (this.dir.x = t), (this.dir.y = e);
            }
          }),
          s(
            (Zot = nht).prototype,
            "texture",
            [qot],
            Object.getOwnPropertyDescriptor(Zot.prototype, "texture"),
            Zot.prototype
          ),
          (Qot = fa(Zot.prototype, "_preview", [Na], function () {
            return !1;
          })),
          (Jot = fa(Zot.prototype, "_fadeTime", [Na], function () {
            return 1;
          })),
          (tht = fa(Zot.prototype, "_minSeg", [Na], function () {
            return 1;
          })),
          (eht = fa(Zot.prototype, "_stroke", [Na], function () {
            return 64;
          })),
          (iht = fa(Zot.prototype, "_texture", [Na], function () {
            return null;
          })),
          (sht = fa(Zot.prototype, "_fastMode", [Na], function () {
            return !1;
          })),
          ($ot = Zot))
        ) || $ot)
      );
      new Ss();
      const aht = new Ss(),
        oht = new Ss();
      let hht;
      function lht(t, e) {
        return (t.x = -e.y), (t.y = e.x), t;
      }
      const cht = {
          createData(t) {
            const e = t.requestRenderData();
            return (e.dataLength = 4), e.resize(16, 42), e;
          },
          update(t, e) {
            const i = t.stroke / 2,
              s = t.node.worldMatrix,
              n = s.m12,
              r = s.m13,
              a = t.points;
            let o;
            if (a.length > 1) {
              const e = a[0],
                i = e.point.x - n,
                s = e.point.y - r;
              i * i + s * s < t.minSeg && (o = e);
            }
            o || ((o = new rht.Point()), a.unshift(o)),
              o.setPoint(n, r),
              (o.time = t.fadeTime + e);
            let h = 0,
              l = 0;
            if (a.length < 2) return;
            const c = t.renderData;
            this.updateRenderDataCache(t, c);
            const u = t.color,
              _ = u.r,
              d = u.g,
              p = u.b,
              m = u.a,
              f = a[1];
            (f.distance = Ss.subtract(oht, o.point, f.point).length()),
              oht.normalize(),
              f.setDir(oht.x, oht.y),
              o.setDir(oht.x, oht.y),
              (c.dataLength = 2 * a.length);
            const g = c.data,
              y = t.fadeTime;
            let T = !1;
            for (let t = a.length - 1; t >= 0; t--) {
              const s = a[t],
                n = s.point,
                r = s.dir;
              if (((s.time -= e), s.time < 0)) {
                a.splice(t, 1);
                continue;
              }
              const o = s.time / y,
                l = a[t - 1];
              if (!T) {
                if (!l) {
                  a.splice(t, 1);
                  continue;
                }
                (n.x = l.point.x - r.x * o), (n.y = l.point.y - r.y * o);
              }
              (T = !0), lht(aht, r);
              const c = o * m;
              let u = h;
              (g[u].x = n.x + aht.x * i),
                (g[u].y = n.y + aht.y * i),
                (g[u].u = 1),
                (g[u].v = o),
                g[u].color.set(_, d, p, c),
                (u += 1),
                (g[u].x = n.x - aht.x * i),
                (g[u].y = n.y - aht.y * i),
                (g[u].u = 0),
                (g[u].v = o),
                g[u].color.set(_, d, p, c),
                (h += 2);
            }
            (l = h <= 2 ? 0 : 3 * (h - 2)), c.resize(h, l);
            {
              const e = c.indexCount;
              this.createQuadIndices(t, e),
                c.chunk.setIndexBuffer(hht),
                this.updateWorldVertexAllData(t),
                c.updateRenderData(t, t.texture),
                t.markForUpdateRenderData();
            }
          },
          updateWorldVertexAllData(t) {
            const e = t.renderData,
              i = e.floatStride,
              s = e.data,
              n = e.chunk.vb;
            for (let t = 0; t < s.length; t++) {
              const e = t * i;
              (n[e + 0] = s[t].x),
                (n[e + 1] = s[t].y),
                (n[e + 2] = s[t].z),
                (n[e + 3] = s[t].u),
                (n[e + 4] = s[t].v),
                Qi.toArray(n, s[t].color, e + 5);
            }
          },
          createQuadIndices(t, e) {
            let i = t.renderData.chunk.meshBuffer.indexOffset;
            (hht = null), (hht = new Uint16Array(e));
            for (let t = 0, s = e; t < s; t += 2) {
              const e = 0 + t;
              (hht[i++] = e),
                (hht[i++] = e + 2),
                (hht[i++] = e + 1),
                (hht[i++] = e + 1),
                (hht[i++] = e + 2),
                (hht[i++] = e + 3);
            }
          },
          updateRenderDataCache(t, e) {
            e.passDirty && e.updatePass(t),
              e.nodeDirty && e.updateNode(t),
              e.textureDirty &&
                t.texture &&
                (e.updateTexture(t.texture),
                (e.material = t.getRenderMaterial(0))),
              e.hashDirty && e.updateHash();
          },
          updateRenderData(t) {
            t.renderData.renderDrawInfo.setVertDirty(!1),
              (t.node.hasChangedFlags = 0);
          },
          updateColor(t) {},
          fillBuffers(t, e) {
            const i = t.renderData,
              s = i.chunk,
              n = i.data,
              r = i.vertexCount,
              a = i.indexCount,
              o = s.vb;
            let h = 0;
            for (let t = 0; t < r; t++) {
              const e = n[t];
              (o[h++] = e.x),
                (o[h++] = e.y),
                (o[h++] = e.z),
                (o[h++] = e.u),
                (o[h++] = e.v),
                Qi.toArray(o, e.color, h),
                (h += 4);
            }
            s.bufferId;
            const l = s.vertexOffset,
              c = s.meshBuffer,
              u = s.meshBuffer.iData;
            let _ = c.indexOffset;
            for (let t = 0, e = a; t < e; t += 2) {
              const e = l + t;
              (u[_++] = e),
                (u[_++] = e + 2),
                (u[_++] = e + 1),
                (u[_++] = e + 1),
                (u[_++] = e + 2),
                (u[_++] = e + 3);
            }
            (c.indexOffset += i.indexCount), c.setDirty();
          },
        },
        uht = t("MotionStreakAssemblerManager", { getAssembler: () => cht });
      rht.Assembler = uht;
      const _ht = {
          maxParticleDeltaTime: 0,
          createData: () => uI.add(),
          removeData(t) {
            uI.remove(t);
          },
          updateRenderData() {},
          fillBuffers(t, e) {},
        },
        dht = t("ParticleSystem2DAssembler", {
          getAssembler: () => (
            _ht.maxParticleDeltaTime ||
              (_ht.maxParticleDeltaTime = (a.game.frameTime / 1e3) * 2),
            _ht
          ),
        });
      var pht;
      Yot.Assembler = dht;
      let mht =
        Ca("cc.PerfCounter")(
          (pht = class extends (
            class {
              get value() {
                return this._value;
              }
              set value(t) {
                this._value = t;
              }
              constructor(t, e, i) {
                (this._total = 0),
                  (this._value = 0),
                  (this._averageValue = 0),
                  (this._accumValue = 0),
                  (this._accumSamples = 0),
                  (this._id = t),
                  (this._opts = e),
                  (this._accumStart = i);
              }
              sample(t) {
                this._average(this._value, t);
              }
              human() {
                const { average: t, isInteger: e } = this._opts,
                  i = t ? this._averageValue : this._value;
                return e ? Math.round(i) : Math.round(100 * i) / 100;
              }
              alarm() {
                return (
                  (void 0 !== this._opts.below &&
                    this._value < this._opts.below) ||
                  (void 0 !== this._opts.over && this._value > this._opts.over)
                );
              }
              _average(t, e = 0) {
                if (this._opts.average) {
                  (this._accumValue += t), ++this._accumSamples;
                  const i = e;
                  i - this._accumStart >= this._opts.average &&
                    ((this._averageValue =
                      this._accumValue / this._accumSamples),
                    (this._accumValue = 0),
                    (this._accumStart = i),
                    (this._accumSamples = 0));
                }
              }
            }
          ) {
            constructor(t, e, i) {
              super(t, e, i), (this._time = i);
            }
            start(t = 0) {
              this._time = t;
            }
            end(t = 0) {
              (this._value = t - this._time), this._average(this._value);
            }
            tick() {
              this.end(), this.start();
            }
            frame(t) {
              const e = t,
                i = e - this._time;
              this._total++,
                i > (this._opts.average || 1e3) &&
                  ((this._value = (1e3 * this._total) / i),
                  (this._total = 0),
                  (this._time = e),
                  this._average(this._value));
            }
          })
        ) || pht;
      const fht = "0123456789. ",
        ght = 500,
        yht = {
          0: 0,
          1: 1,
          2: 2,
          3: 3,
          4: 4,
          5: 5,
          6: 6,
          7: 7,
          8: 8,
          9: 9,
          ".": 10,
        },
        Tht = {
          fps: {
            desc: "Framerate (FPS)",
            below: 30,
            average: ght,
            isInteger: !0,
          },
          draws: { desc: "Draw call", isInteger: !0 },
          frame: { desc: "Frame time (ms)", min: 0, max: 50, average: ght },
          instances: { desc: "Instance Count", isInteger: !0 },
          tricount: { desc: "Triangle", isInteger: !0 },
          logic: {
            desc: "Game Logic (ms)",
            min: 0,
            max: 50,
            average: ght,
            color: "#080",
          },
          physics: { desc: "Physics (ms)", min: 0, max: 50, average: ght },
          render: {
            desc: "Renderer (ms)",
            min: 0,
            max: 50,
            average: ght,
            color: "#f90",
          },
          present: {
            desc: "Present (ms)",
            min: 0,
            max: 50,
            average: ght,
            color: "#f90",
          },
          textureMemory: { desc: "GFX Texture Mem(M)" },
          bufferMemory: { desc: "GFX Buffer Mem(M)" },
        },
        Sht = {
          fontSize: 23,
          quadHeight: 0.4,
          segmentsPerLine: 8,
          textureWidth: 280,
          textureHeight: 280,
        };
      class Eht extends jl {
        constructor() {
          super(),
            (this._profilerStats = null),
            (this._showFPS = !1),
            (this._rootNode = null),
            (this._device = null),
            (this._swapchain = null),
            (this._meshRenderer = null),
            (this._canvas = null),
            (this._ctx = null),
            (this._texture = null),
            (this._region = new _u()),
            (this._canvasArr = []),
            (this._regionArr = [this._region]),
            (this.digitsData = null),
            (this.offsetData = null),
            (this.pass = null),
            (this._canvasDone = !1),
            (this._statsDone = !1),
            (this._inited = !1),
            (this._lineHeight =
              Sht.textureHeight / (Object.keys(Tht).length + 1)),
            (this._wordHeight = 0),
            (this._eachNumWidth = 0),
            (this._totalLines = 0),
            (this.lastTime = 0),
            (this._canvas = h.document.createElement("canvas")),
            (this._ctx = this._canvas.getContext("2d")),
            this._canvasArr.push(this._canvas);
        }
        init() {
          ge.querySettings(fe.Category.PROFILING, "showFPS")
            ? this.showStats()
            : this.hideStats();
        }
        get _stats() {
          return z(16381), this._profilerStats;
        }
        get stats() {
          return this._profilerStats;
        }
        isShowingStats() {
          return this._showFPS;
        }
        hideStats() {
          this._showFPS &&
            (this._rootNode && (this._rootNode.active = !1),
            a.director.off(
              a.Director.EVENT_BEFORE_UPDATE,
              this.beforeUpdate,
              this
            ),
            a.director.off(
              a.Director.EVENT_AFTER_UPDATE,
              this.afterUpdate,
              this
            ),
            a.director.off(
              a.Director.EVENT_BEFORE_PHYSICS,
              this.beforePhysics,
              this
            ),
            a.director.off(
              a.Director.EVENT_AFTER_PHYSICS,
              this.afterPhysics,
              this
            ),
            a.director.off(a.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this),
            a.director.off(
              a.Director.EVENT_AFTER_RENDER,
              this.afterRender,
              this
            ),
            a.director.off(
              a.Director.EVENT_AFTER_DRAW,
              this.afterPresent,
              this
            ),
            (this._showFPS = !1),
            (Lv.root.pipeline.profiler = null),
            (a.game.config.showFPS = !1));
        }
        showStats() {
          if (!this._showFPS) {
            if (!this._device) {
              const t = a.director.root;
              (this._device = I_.gfxDevice),
                (this._swapchain = t.mainWindow.swapchain);
            }
            this.generateCanvas(),
              this.generateStats(),
              a.game.once(a.Game.EVENT_ENGINE_INITED, this.generateNode, this),
              a.game.on(a.Game.EVENT_RESTART, this.generateNode, this),
              this._rootNode && (this._rootNode.active = !0),
              a.director.on(
                a.Director.EVENT_BEFORE_UPDATE,
                this.beforeUpdate,
                this
              ),
              a.director.on(
                a.Director.EVENT_AFTER_UPDATE,
                this.afterUpdate,
                this
              ),
              a.director.on(
                a.Director.EVENT_BEFORE_PHYSICS,
                this.beforePhysics,
                this
              ),
              a.director.on(
                a.Director.EVENT_AFTER_PHYSICS,
                this.afterPhysics,
                this
              ),
              a.director.on(
                a.Director.EVENT_BEFORE_DRAW,
                this.beforeDraw,
                this
              ),
              a.director.on(
                a.Director.EVENT_AFTER_RENDER,
                this.afterRender,
                this
              ),
              a.director.on(
                a.Director.EVENT_AFTER_DRAW,
                this.afterPresent,
                this
              ),
              (this._showFPS = !0),
              (this._canvasDone = !0),
              (this._statsDone = !0),
              (a.game.config.showFPS = !0);
          }
        }
        generateCanvas() {
          if (this._canvasDone) return;
          const { textureWidth: t, textureHeight: e } = Sht;
          this._ctx &&
            this._canvas &&
            ((this._canvas.width = t),
            (this._canvas.height = e),
            (this._canvas.style.width = `${this._canvas.width}`),
            (this._canvas.style.height = `${this._canvas.height}`),
            (this._ctx.font = `${Sht.fontSize}px Arial`),
            (this._ctx.textBaseline = "top"),
            (this._ctx.fillStyle = "#fff"),
            (this._texture = this._device.createTexture(
              new bu(bc.TEX2D, Ac.SAMPLED | Ac.TRANSFER_DST, fc.RGBA8, t, e)
            )),
            (this._region.texExtent.width = t),
            (this._region.texExtent.height = e));
        }
        generateStats() {
          if (this._statsDone || !this._ctx || !this._canvas) return;
          this._profilerStats = null;
          const t = performance.now();
          this._ctx.textAlign = "left";
          let e = 0;
          for (const i in Tht) {
            const s = Tht[i];
            this._ctx.fillText(s.desc, 0, e * this._lineHeight),
              (s.counter = new mht(i, s, t)),
              e++;
          }
          (this._totalLines = e),
            (this._wordHeight =
              (this._totalLines * this._lineHeight) / this._canvas.height);
          for (let t = 0; t < fht.length; ++t) {
            const e = this._ctx.measureText(fht[t]).width;
            this._eachNumWidth = Math.max(this._eachNumWidth, e);
          }
          for (let t = 0; t < fht.length; ++t)
            this._ctx.fillText(
              fht[t],
              t * this._eachNumWidth,
              this._totalLines * this._lineHeight
            );
          (this._eachNumWidth /= this._canvas.width),
            (this._profilerStats = Tht),
            (this._canvasArr[0] = this._canvas),
            this._device.copyTexImagesToTexture(
              this._canvasArr,
              this._texture,
              this._regionArr
            );
        }
        generateNode() {
          if (this._rootNode && this._rootNode.isValid) return;
          (this._rootNode = new Pf("PROFILER_NODE")),
            (this._rootNode._objFlags =
              a.Object.Flags.DontSave | a.Object.Flags.HideInHierarchy),
            a.game.addPersistRootNode(this._rootNode);
          const t = new Pf("Profiler_Root");
          t.parent = this._rootNode;
          const e = Sht.quadHeight,
            i = e / this._totalLines,
            s = e / this._wordHeight,
            n = i / Sht.fontSize,
            r = this._eachNumWidth * this._canvas.width * n,
            o = [0, e, 0, s, e, 0, s, 0, 0, 0, 0, 0],
            h = [0, 2, 1, 0, 3, 2],
            l = [
              0,
              0,
              -1,
              0,
              1,
              0,
              -1,
              0,
              1,
              this._wordHeight,
              -1,
              0,
              0,
              this._wordHeight,
              -1,
              0,
            ];
          let c = 0;
          for (let t = 0; t < this._totalLines; t++)
            for (let n = 0; n < Sht.segmentsPerLine; n++) {
              o.push(s + n * r, e - t * i, 0),
                o.push(s + (n + 1) * r, e - t * i, 0),
                o.push(s + (n + 1) * r, e - (t + 1) * i, 0),
                o.push(s + n * r, e - (t + 1) * i, 0),
                (c = 4 * (t * Sht.segmentsPerLine + n + 1)),
                h.push(0 + c, 2 + c, 1 + c, 0 + c, 3 + c, 2 + c);
              const a = t * Sht.segmentsPerLine + n,
                u = Math.floor(a / 4),
                _ = a - 4 * u;
              l.push(0, this._wordHeight, u, _),
                l.push(this._eachNumWidth, this._wordHeight, u, _),
                l.push(this._eachNumWidth, 1, u, _),
                l.push(0, 1, u, _);
            }
          (this._meshRenderer = t.addComponent(dF)),
            (this._meshRenderer.mesh = sC({
              positions: o,
              indices: h,
              colors: l,
            }));
          const u = new ey();
          u.initialize({ effectName: "util/profiler" });
          const _ = (this.pass = u.passes[0]),
            d = _.getBinding("mainTexture"),
            p = _.getBinding("digits"),
            m = _.getBinding("offset");
          _.bindTexture(d, this._texture),
            (this.digitsData = _.blocks[p]),
            (this.offsetData = _.blocks[m]),
            (this.offsetData[3] = -1),
            (this._meshRenderer.material = u),
            (this._meshRenderer.node.layer = Rf.Enum.PROFILER),
            (this._inited = !0);
        }
        beforeUpdate() {
          if (!this._profilerStats) return;
          const t = performance.now();
          this._profilerStats.frame.counter.start(t),
            this._profilerStats.logic.counter.start(t);
        }
        afterUpdate() {
          if (!this._profilerStats) return;
          const t = performance.now();
          a.director.isPaused()
            ? this._profilerStats.frame.counter.start(t)
            : this._profilerStats.logic.counter.end(t);
        }
        beforePhysics() {
          if (!this._profilerStats) return;
          const t = performance.now();
          this._profilerStats.physics.counter.start(t);
        }
        afterPhysics() {
          if (!this._profilerStats) return;
          const t = performance.now();
          this._profilerStats.physics.counter.end(t);
        }
        beforeDraw() {
          if (!this._profilerStats || !this._inited) return;
          const t = this._swapchain.surfaceTransform,
            e = this._device.capabilities.clipSpaceSignY;
          if (t !== this.offsetData[3]) {
            const i = ps[t];
            let s = -0.9,
              n = -0.9 * e;
            zr.isXR && ((s = -0.5), (n = -0.5 * e)),
              (this.offsetData[0] = s * i[0] + n * i[2]),
              (this.offsetData[1] = s * i[1] + n * i[3]),
              (this.offsetData[2] = this._eachNumWidth),
              (this.offsetData[3] = t);
          }
          this.pass.setRootBufferDirty(!0),
            this._meshRenderer.model
              ? (Lv.root.pipeline.profiler = this._meshRenderer.model)
              : (Lv.root.pipeline.profiler = null);
          const i = performance.now();
          this._profilerStats.render.counter.start(i);
        }
        afterRender() {
          if (!this._profilerStats || !this._inited) return;
          const t = performance.now();
          this._profilerStats.render.counter.end(t),
            this._profilerStats.present.counter.start(t);
        }
        afterPresent() {
          if (!this._profilerStats || !this._inited) return;
          const t = performance.now();
          if (
            (this._profilerStats.frame.counter.end(t),
            this._profilerStats.fps.counter.frame(t),
            this._profilerStats.present.counter.end(t),
            t - this.lastTime < ght)
          )
            return;
          this.lastTime = t;
          const e = this._device;
          (this._profilerStats.draws.counter.value = e.numDrawCalls),
            (this._profilerStats.instances.counter.value = e.numInstances),
            (this._profilerStats.bufferMemory.counter.value =
              e.memoryStatus.bufferSize / 1048576),
            (this._profilerStats.textureMemory.counter.value =
              e.memoryStatus.textureSize / 1048576),
            (this._profilerStats.tricount.counter.value = e.numTris);
          let i = 0;
          const s = this.digitsData;
          for (const e in this._profilerStats) {
            const n = this._profilerStats[e];
            n.counter.sample(t);
            const r = n.counter.human().toString();
            for (let t = Sht.segmentsPerLine - 1; t >= 0; t--) {
              const e = i * Sht.segmentsPerLine + t,
                n = r[r.length - (Sht.segmentsPerLine - t)];
              let a = yht[n];
              void 0 === a && (a = 11), (s[e] = a);
            }
            i++;
          }
        }
      }
      t("Profiler", Eht);
      const vht = t("profiler", new Eht());
      Lv.registerSystem("profiler", vht, 0),
        (a.profiler = vht),
        new Cu(Rc.POINT, Rc.POINT, Rc.NONE, Dc.CLAMP, Dc.CLAMP, Dc.CLAMP);
      const bht = function (t, e, i) {
        (t[e + 0] = i.m00),
          (t[e + 1] = i.m01),
          (t[e + 2] = i.m02),
          (t[e + 3] = i.m12),
          (t[e + 4] = i.m04),
          (t[e + 5] = i.m05),
          (t[e + 6] = i.m06),
          (t[e + 7] = i.m13),
          (t[e + 8] = i.m08),
          (t[e + 9] = i.m09),
          (t[e + 10] = i.m10),
          (t[e + 11] = i.m14);
      };
      function Aht(t, e) {
        const i = 4 / Math.sqrt(e);
        return 12 * Math.ceil(Math.max(480 * i, t) / 12);
      }
      new as(), new as(), new Yi(), new as(), new Yi();
      const Cht = new Yi(),
        Oht = new Yi(),
        Iht = new Yi(),
        wht = new Yi(),
        Rht = new ms(),
        Dht = new ms(),
        xht = new Kr(),
        Mht = Number.MAX_SAFE_INTEGER;
      class Pht {
        get pixelsPerJoint() {
          return this._pixelsPerJoint;
        }
        constructor(t) {
          (this._device = void 0),
            (this._pool = void 0),
            (this._textureBuffers = new Map()),
            (this._formatSize = void 0),
            (this._pixelsPerJoint = void 0),
            (this._customPool = void 0),
            (this._chunkIdxMap = new Map()),
            (this._device = t);
          const e = (function (t) {
            return t.getFormatFeatures(fc.RGBA32F) & Oc.SAMPLED_TEXTURE
              ? fc.RGBA32F
              : fc.RGBA8;
          })(this._device);
          (this._formatSize = a_[e].size),
            (this._pixelsPerJoint = 48 / this._formatSize),
            (this._pool = new _R(t)),
            this._pool.initialize({ format: e, roundUpFn: Aht }),
            (this._customPool = new _R(t)),
            this._customPool.initialize({ format: e, roundUpFn: Aht });
        }
        clear() {
          this._pool.destroy(), this._textureBuffers.clear();
        }
        registerCustomTextureLayouts(t) {
          for (let e = 0; e < t.length; e++) {
            const i = t[e];
            let s = i.textureLength;
            this._device.getFormatFeatures(fc.RGBA32F) & Oc.SAMPLED_TEXTURE ||
              (s *= 2);
            const n = this._customPool.createChunk(s);
            for (let t = 0; t < i.contents.length; t++) {
              const e = i.contents[t],
                { skeleton: s } = e;
              this._chunkIdxMap.set(s, n);
              for (let t = 0; t < e.clips.length; t++) {
                const i = e.clips[t];
                this._chunkIdxMap.set(s ^ i, n);
              }
            }
          }
        }
        getDefaultPoseTexture(t, e, i) {
          const s = 0 ^ t.hash;
          let n = this._textureBuffers.get(s) || null;
          if (n && n.bounds.has(e.hash)) return n.refCount++, n;
          const { joints: r, bindposes: a } = t;
          let o = null,
            h = !1;
          const l = r.length;
          if (n) n.refCount++;
          else {
            const e = 12 * l,
              i = this._chunkIdxMap.get(s),
              r =
                void 0 !== i
                  ? this._customPool.alloc(
                      e * Float32Array.BYTES_PER_ELEMENT,
                      i
                    )
                  : this._pool.alloc(e * Float32Array.BYTES_PER_ELEMENT);
            if (!r) return n;
            (n = {
              pixelOffset: r.start / this._formatSize,
              refCount: 1,
              bounds: new Map(),
              skeletonHash: t.hash,
              clipHash: 0,
              readyToBeDeleted: !1,
              handle: r,
            }),
              (o = new Float32Array(e)),
              (h = !0);
          }
          Yi.set(Iht, Mht, Mht, Mht), Yi.set(wht, -Mht, -Mht, -Mht);
          const c = e.getBoneSpaceBounds(t);
          for (let e = 0, s = 0; e < l; e++, s += 12) {
            const n = i.getChildByPath(r[e]),
              l = n ? Hz(n, i, Rht) : t.inverseBindposes[e],
              u = c[e];
            u &&
              (Kr.transform(xht, u, l),
              xht.getBoundary(Cht, Oht),
              Yi.min(Iht, Iht, Cht),
              Yi.max(wht, wht, Oht)),
              h &&
                (n && ms.multiply(l, l, a[e]), bht(o, s, n ? l : ms.IDENTITY));
          }
          const u = [new Kr()];
          return (
            n.bounds.set(e.hash, u),
            Kr.fromPoints(u[0], Iht, wht),
            h &&
              (this._pool.update(n.handle, o.buffer),
              this._textureBuffers.set(s, n)),
            n
          );
        }
        getSequencePoseTexture(t, e, i, s) {
          const n = t.hash ^ e.hash;
          let r = this._textureBuffers.get(n) || null;
          if (r && r.bounds.has(i.hash)) return r.refCount++, r;
          const { joints: a, bindposes: o } = t,
            h = aK.getOrExtract(e),
            { frames: l } = h;
          let c = null,
            u = !1;
          const _ = a.length;
          if (r) r.refCount++;
          else {
            const i = 12 * _ * l,
              a = this._chunkIdxMap.get(n),
              o =
                void 0 !== a
                  ? this._customPool.alloc(
                      i * Float32Array.BYTES_PER_ELEMENT,
                      a
                    )
                  : this._pool.alloc(i * Float32Array.BYTES_PER_ELEMENT);
            if (!o) return null;
            const h = this._createAnimInfos(t, e, s);
            (r = {
              pixelOffset: o.start / this._formatSize,
              refCount: 1,
              bounds: new Map(),
              skeletonHash: t.hash,
              clipHash: e.hash,
              readyToBeDeleted: !1,
              handle: o,
              animInfos: h,
            }),
              (c = new Float32Array(i)),
              (u = !0);
          }
          const d = i.getBoneSpaceBounds(t),
            p = [];
          r.bounds.set(i.hash, p);
          for (let t = 0; t < l; t++)
            p.push(new Kr(Mht, Mht, Mht, -Mht, -Mht, -Mht));
          for (let e = 0, i = 0; e < l; e++) {
            const s = p[e];
            for (let n = 0; n < _; n++, i += 12) {
              const {
                curveData: a,
                downstream: h,
                bindposeIdx: l,
                bindposeCorrection: _,
              } = r.animInfos[n];
              let p,
                m = !0;
              a && h
                ? (p = ms.multiply(Rht, a[e], h))
                : a
                ? (p = a[e])
                : h
                ? (p = h)
                : ((p = t.inverseBindposes[l]), (m = !1));
              const f = d[n];
              if (f) {
                const t = _ ? ms.multiply(Dht, p, _) : p;
                Kr.transform(xht, f, t),
                  xht.getBoundary(Cht, Oht),
                  Yi.min(s.center, s.center, Cht),
                  Yi.max(s.halfExtents, s.halfExtents, Oht);
              }
              u &&
                (m && ms.multiply(Rht, p, o[l]),
                bht(c, i, m ? Rht : ms.IDENTITY));
            }
            Kr.fromPoints(s, s.center, s.halfExtents);
          }
          return (
            u &&
              (this._pool.update(r.handle, c.buffer),
              this._textureBuffers.set(n, r)),
            r
          );
        }
        releaseHandle(t) {
          if (
            (t.refCount > 0 && t.refCount--, !t.refCount && t.readyToBeDeleted)
          ) {
            const e = t.skeletonHash ^ t.clipHash;
            (void 0 !== this._chunkIdxMap.get(e)
              ? this._customPool
              : this._pool
            ).free(t.handle),
              this._textureBuffers.get(e) === t &&
                this._textureBuffers.delete(e);
          }
        }
        releaseSkeleton(t) {
          const e = this._textureBuffers.values();
          let i = e.next();
          for (; !i.done; ) {
            const s = i.value;
            s.skeletonHash === t.hash &&
              ((s.readyToBeDeleted = !0),
              s.refCount
                ? this._textureBuffers.delete(s.skeletonHash ^ s.clipHash)
                : this.releaseHandle(s)),
              (i = e.next());
          }
        }
        releaseAnimationClip(t) {
          const e = this._textureBuffers.values();
          let i = e.next();
          for (; !i.done; ) {
            const s = i.value;
            s.clipHash === t.hash &&
              ((s.readyToBeDeleted = !0),
              s.refCount
                ? this._textureBuffers.delete(s.skeletonHash ^ s.clipHash)
                : this.releaseHandle(s)),
              (i = e.next());
          }
        }
        _createAnimInfos(t, e, i) {
          const s = [],
            { joints: n, bindposes: r } = t,
            a = n.length,
            o = aK.getOrExtract(e);
          for (let e = 0; e < a; e++) {
            let h,
              l,
              c = n[e],
              u = o.joints[c],
              _ = i.getChildByPath(c);
            for (; !u; ) {
              const t = c.lastIndexOf("/");
              if (
                ((c = c.substring(0, t)),
                (u = o.joints[c]),
                _
                  ? (h || (h = new ms()),
                    ms.fromRTS(Rht, _.rotation, _.position, _.scale),
                    ms.multiply(h, Rht, h),
                    (_ = _.parent))
                  : (l = c),
                t < 0)
              )
                break;
            }
            let d,
              p = e;
            if (void 0 !== l && u) {
              p = e - 1;
              for (let i = 0; i < a; i++)
                if (n[i] === l) {
                  (p = i),
                    (d = new ms()),
                    ms.multiply(d, r[i], t.inverseBindposes[e]);
                  break;
                }
            }
            s.push({
              curveData: u && u.transforms,
              downstream: h,
              bindposeIdx: p,
              bindposeCorrection: d,
            });
          }
          return s;
        }
      }
      class Nht {
        constructor(t) {
          (this._pool = new Map()), (this._device = void 0), (this._device = t);
        }
        getData(t = "-1") {
          const e = this._pool.get(t);
          if (e) return e;
          const i = this._device.createBuffer(
              new yu(
                Tc.UNIFORM | Tc.TRANSFER_DST,
                vc.HOST | vc.DEVICE,
                Nb.SIZE,
                Nb.SIZE
              )
            ),
            s = new Float32Array([0, 0, 0, 0]);
          i.update(s);
          const n = {
            buffer: i,
            data: s,
            dirty: !1,
            dirtyForJSB: new Uint8Array([0]),
            currentClip: null,
          };
          return this._pool.set(t, n), n;
        }
        destroy(t) {
          const e = this._pool.get(t);
          e && (e.buffer.destroy(), this._pool.delete(t));
        }
        switchClip(t, e) {
          return (
            (t.currentClip = e),
            (t.data[0] = 0),
            t.buffer.update(t.data),
            (t.dirty = !1),
            (t.dirtyForJSB[0] = 0),
            t
          );
        }
        clear() {
          for (const t of this._pool.values()) t.buffer.destroy();
          this._pool.clear();
        }
      }
      a.internal.DataPoolManager = class {
        constructor(t) {
          (this.jointTexturePool = void 0),
            (this.jointAnimationInfo = void 0),
            (this.jointTexturePool = new Pht(t)),
            (this.jointAnimationInfo = new Nht(t));
        }
        releaseSkeleton(t) {
          this.jointTexturePool.releaseSkeleton(t);
        }
        releaseAnimationClip(t) {
          this.jointTexturePool.releaseAnimationClip(t);
        }
        clear() {
          this.jointTexturePool.clear(), this.jointAnimationInfo.clear();
        }
      };
      const Lht = new ms(),
        Bht = new ms();
      class Fht extends vG {
        constructor(t, e = "") {
          super(t, e),
            (this._frames = 1),
            (this._bakedDuration = 0),
            (this._animInfo = null),
            (this._sockets = []),
            (this._animInfoMgr = void 0),
            (this._parent = null),
            (this._curvesInited = !1),
            (this._animInfoMgr =
              a.director.root.dataPoolManager.jointAnimationInfo);
        }
        initialize(t) {
          if (this._curveLoaded) return;
          this._parent = t.getComponent("cc.SkeletalAnimation");
          const e = this._parent.useBakedAnimation;
          (this._doNotCreateEval = e),
            super.initialize(t),
            (this._curvesInited = !e);
          const { frames: i, samples: s } = aK.getOrExtract(this.clip);
          (this._frames = i - 1),
            (this._animInfo = this._animInfoMgr.getData(t.uuid)),
            (this._bakedDuration = this._frames / s),
            this.setUseBaked(e);
        }
        onPlay() {
          super.onPlay(),
            this._parent.useBakedAnimation &&
              (this._animInfoMgr.switchClip(this._animInfo, this.clip),
              this._parent.getUsers().forEach((t) => {
                t.uploadAnimation(this.clip);
              }));
        }
        setUseBaked(t) {
          t
            ? ((this._sampleCurves = this._sampleCurvesBaked),
              (this.duration = this._bakedDuration))
            : ((this._sampleCurves = super._sampleCurves),
              (this.duration = this.clip.duration),
              this._curvesInited ||
                ((this._curveLoaded = !1),
                super.initialize(this._targetNode),
                (this._curvesInited = !0)));
        }
        rebuildSocketCurves(t) {
          if (((this._sockets.length = 0), !this._targetNode)) return;
          const e = this._targetNode;
          for (let i = 0; i < t.length; ++i) {
            const s = t[i],
              n = e.getChildByPath(s.path);
            if (!s.target) continue;
            const r = aK.getOrExtract(this.clip);
            let a,
              o = s.path,
              h = r.joints[o],
              l = n;
            for (; !h; ) {
              const t = o.lastIndexOf("/");
              if (
                ((o = o.substring(0, t)),
                (h = r.joints[o]),
                l &&
                  (a || (a = ms.identity(Bht)),
                  ms.fromRTS(Lht, l.rotation, l.position, l.scale),
                  ms.multiply(a, Lht, a),
                  (l = l.parent)),
                t < 0)
              )
                break;
            }
            const c = h && h.transforms,
              { frames: u } = r,
              _ = [];
            for (let t = 0; t < u; t++) {
              let e;
              e = c && a ? ms.multiply(Lht, c[t], a) : c ? c[t] : a || new ms();
              const i = { pos: new Yi(), rot: new as(), scale: new Yi() };
              ms.toRTS(e, i.rot, i.pos, i.scale), _.push(i);
            }
            this._sockets.push({ target: s.target, frames: _ });
          }
        }
        _sampleCurvesBaked(t) {
          const e = t / this.duration,
            i = this._animInfo,
            s = this.clip;
          i.currentClip !== s &&
            (this._animInfoMgr.switchClip(this._animInfo, s),
            this._parent.getUsers().forEach((t) => {
              t.uploadAnimation(s);
            }),
            (i.data[0] = -1));
          const n = (e * this._frames + 0.5) | 0;
          if (n !== i.data[0]) {
            (i.data[0] = n), (i.dirty = !0), (i.dirtyForJSB[0] = 1);
            for (let t = 0; t < this._sockets.length; ++t) {
              const { target: e, frames: i } = this._sockets[t],
                { pos: s, rot: r, scale: a } = i[n];
              e.setRTS(r, s, a);
            }
          }
        }
      }
      var Uht,
        kht,
        zht,
        Hht,
        Ght,
        Vht,
        jht,
        Wht,
        Xht,
        Yht,
        Kht,
        qht,
        $ht,
        Zht,
        Qht;
      t("SkeletalAnimationState", Fht);
      let Jht = t(
        "Socket",
        ((Uht = Ca("cc.SkeletalAnimation.Socket")),
        (kht = ao(Pf)),
        Uht(
          ((Hht = class {
            constructor(t = "", e = null) {
              (this.path = Ght && Ght()),
                (this.target = Vht && Vht()),
                (this.path = t),
                (this.target = e);
            }
          }),
          (Ght = fa(Hht.prototype, "path", [Na], function () {
            return "";
          })),
          (Vht = fa(Hht.prototype, "target", [kht], function () {
            return null;
          })),
          (zht = Hht))
        ) || zht)
      );
      Vt(Jht, "cc.SkeletalAnimationComponent.Socket");
      const tlt = new ms(),
        elt = new ms();
      function ilt(t, e = "", i = []) {
        for (let s = 0; s < t.children.length; s++) {
          const n = t.children[s];
          if (!n) continue;
          const r = e ? `${e}/${n.name}` : n.name;
          i.push(r), ilt(n, r, i);
        }
        return i;
      }
      let slt =
        ((jht = Ca("cc.SkeletalAnimation")),
        (Wht = Ia(99)),
        (Xht = ao([Jht])),
        (Yht = ao([Jht])),
        jht(
          (Kht =
            Wht(
              (((Qht = class extends l2 {
                constructor(...t) {
                  super(...t),
                    (this._useBakedAnimation = $ht && $ht()),
                    (this._sockets = Zht && Zht()),
                    (this._users = new Set()),
                    (this._currentBakedState = null);
                }
                get sockets() {
                  return this._sockets;
                }
                set sockets(t) {
                  if (!this._useBakedEffectively) {
                    const e = EG();
                    e.removeSockets(this.node, this._sockets),
                      e.addSockets(this.node, t);
                  }
                  (this._sockets = t), this.rebuildSocketAnimations();
                }
                get useBakedAnimation() {
                  return this._useBakedAnimation;
                }
                set useBakedAnimation(t) {
                  (this._useBakedAnimation = t), this._applyBakeFlagChange();
                }
                onLoad() {
                  super.onLoad();
                  const t = this.node.getComponentsInChildren(kz);
                  for (let e = 0; e < t.length; ++e) {
                    const i = t[e];
                    i.skinningRoot === this.node &&
                      this.notifySkinnedMeshAdded(i);
                  }
                }
                onDestroy() {
                  super.onDestroy(),
                    a.director.root.dataPoolManager.jointAnimationInfo.destroy(
                      this.node.uuid
                    ),
                    EG().removeSockets(this.node, this._sockets),
                    this._removeAllUsers();
                }
                onEnable() {
                  var t;
                  super.onEnable(),
                    null === (t = this._currentBakedState) ||
                      void 0 === t ||
                      t.resume();
                }
                onDisable() {
                  var t;
                  super.onDisable(),
                    null === (t = this._currentBakedState) ||
                      void 0 === t ||
                      t.pause();
                }
                start() {
                  (this.sockets = this._sockets),
                    this._applyBakeFlagChange(),
                    super.start();
                }
                pause() {
                  var t;
                  this._useBakedEffectively
                    ? null === (t = this._currentBakedState) ||
                      void 0 === t ||
                      t.pause()
                    : super.pause();
                }
                resume() {
                  var t;
                  this._useBakedEffectively
                    ? null === (t = this._currentBakedState) ||
                      void 0 === t ||
                      t.resume()
                    : super.resume();
                }
                stop() {
                  this._useBakedEffectively
                    ? this._currentBakedState &&
                      (this._currentBakedState.stop(),
                      (this._currentBakedState = null))
                    : super.stop();
                }
                querySockets() {
                  const t =
                    (this._defaultClip &&
                      Object.keys(aK.getOrExtract(this._defaultClip).joints)
                        .sort()
                        .reduce(
                          (t, e) => (
                            e.startsWith(`${t[t.length - 1]}/`) || t.push(e), t
                          ),
                          []
                        )) ||
                    [];
                  if (!t.length)
                    return [
                      "please specify a valid default animation clip first",
                    ];
                  const e = [];
                  for (let i = 0; i < t.length; i++) {
                    const s = t[i],
                      n = this.node.getChildByPath(s);
                    n && (e.push(s), ilt(n, s, e));
                  }
                  return e;
                }
                rebuildSocketAnimations() {
                  for (const t of this._sockets) {
                    const e = this.node.getChildByPath(t.path),
                      { target: i } = t;
                    e &&
                      i &&
                      ((i.name = `${t.path.substring(
                        t.path.lastIndexOf("/") + 1
                      )} Socket`),
                      (i.parent = this.node),
                      Hz(e, this.node, tlt),
                      ms.fromRTS(elt, i.rotation, i.position, i.scale),
                      ms.equals(elt, tlt) || (i.matrix = tlt));
                  }
                  for (const t of Object.keys(this._nameToState))
                    this._nameToState[t].rebuildSocketCurves(this._sockets);
                }
                createSocket(t) {
                  const e = this._sockets.find((e) => e.path === t);
                  if (e) return e.target;
                  if (!this.node.getChildByPath(t))
                    return w("illegal socket path"), null;
                  const i = new Pf();
                  return (
                    (i.parent = this.node),
                    this._sockets.push(new Jht(t, i)),
                    this.rebuildSocketAnimations(),
                    i
                  );
                }
                notifySkinnedMeshAdded(t) {
                  const { _useBakedEffectively: e } = this,
                    i = t.associatedAnimation;
                  if (
                    (i && i._users.delete(t),
                    (t.associatedAnimation = this),
                    t.setUseBakedAnimation(e, !0),
                    e)
                  ) {
                    const { _currentBakedState: e } = this;
                    e && t.uploadAnimation(e.clip);
                  }
                  this._users.add(t);
                }
                notifySkinnedMeshRemoved(t) {
                  t.associatedAnimation === this || t.associatedAnimation,
                    t.setUseBakedAnimation(!1),
                    (t.associatedAnimation = null),
                    this._users.delete(t);
                }
                getUsers() {
                  return this._users;
                }
                _createState(t, e) {
                  return new Fht(t, e);
                }
                _doCreateState(t, e) {
                  const i = super._doCreateState(t, e);
                  return i.rebuildSocketCurves(this._sockets), i;
                }
                doPlayOrCrossFade(t, e) {
                  if (this._useBakedEffectively) {
                    this._currentBakedState && this._currentBakedState.stop();
                    const e = t;
                    (this._currentBakedState = e), e.play();
                  } else super.doPlayOrCrossFade(t, e);
                }
                _removeAllUsers() {
                  Array.from(this._users).forEach((t) => {
                    this.notifySkinnedMeshRemoved(t);
                  });
                }
                get _useBakedEffectively() {
                  return this._useBakedAnimation;
                }
                _applyBakeFlagChange() {
                  const t = this._useBakedEffectively;
                  for (const e in this._nameToState)
                    this._nameToState[e].setUseBaked(t);
                  this._users.forEach((e) => {
                    e.setUseBakedAnimation(t);
                  }),
                    t
                      ? EG().removeSockets(this.node, this._sockets)
                      : (EG().addSockets(this.node, this._sockets),
                        (this._currentBakedState = null));
                }
              }).Socket = Jht),
              s(
                (qht = Qht).prototype,
                "sockets",
                [Xht],
                Object.getOwnPropertyDescriptor(qht.prototype, "sockets"),
                qht.prototype
              ),
              ($ht = fa(qht.prototype, "_useBakedAnimation", [Na], function () {
                return !0;
              })),
              (Zht = fa(qht.prototype, "_sockets", [Yht], function () {
                return [];
              })),
              (Kht = qht))
            ) || Kht)
        ) || Kht);
      var nlt;
      t({ SkeletalAnimation: slt, SkeletalAnimationComponent: slt }),
        (a.SkeletalAnimationComponent = slt),
        Vt(slt, "cc.SkeletalAnimationComponent"),
        (function (t) {
          var e, i, s, n, r, a, o, h, l, c, u;
          ((e = t.MixBlend || (t.MixBlend = {}))[(e.setup = 0)] = "setup"),
            (e[(e.first = 1)] = "first"),
            (e[(e.replace = 2)] = "replace"),
            (e[(e.add = 3)] = "add"),
            ((i = t.MixDirection || (t.MixDirection = {}))[(i.mixIn = 0)] =
              "mixIn"),
            (i[(i.mixOut = 1)] = "mixOut"),
            ((s = t.TimelineType || (t.TimelineType = {}))[(s.rotate = 0)] =
              "rotate"),
            (s[(s.translate = 1)] = "translate"),
            (s[(s.scale = 2)] = "scale"),
            (s[(s.shear = 3)] = "shear"),
            (s[(s.attachment = 4)] = "attachment"),
            (s[(s.color = 5)] = "color"),
            (s[(s.deform = 6)] = "deform"),
            (s[(s.event = 7)] = "event"),
            (s[(s.drawOrder = 8)] = "drawOrder"),
            (s[(s.ikConstraint = 9)] = "ikConstraint"),
            (s[(s.transformConstraint = 10)] = "transformConstraint"),
            (s[(s.pathConstraintPosition = 11)] = "pathConstraintPosition"),
            (s[(s.pathConstraintSpacing = 12)] = "pathConstraintSpacing"),
            (s[(s.pathConstraintMix = 13)] = "pathConstraintMix"),
            (s[(s.twoColor = 14)] = "twoColor"),
            (function (t) {
              (t[(t.start = 0)] = "start"),
                (t[(t.interrupt = 1)] = "interrupt"),
                (t[(t.end = 2)] = "end"),
                (t[(t.dispose = 3)] = "dispose"),
                (t[(t.complete = 4)] = "complete"),
                (t[(t.event = 5)] = "event");
            })(t.EventType || (t.EventType = {})),
            ((n = t.BlendMode || (t.BlendMode = {}))[(n.Normal = 0)] =
              "Normal"),
            (n[(n.Additive = 1)] = "Additive"),
            (n[(n.Multiply = 2)] = "Multiply"),
            (n[(n.Screen = 3)] = "Screen"),
            ((r = t.TransformMode || (t.TransformMode = {}))[(r.Normal = 0)] =
              "Normal"),
            (r[(r.OnlyTranslation = 1)] = "OnlyTranslation"),
            (r[(r.NoRotationOrReflection = 2)] = "NoRotationOrReflection"),
            (r[(r.NoScale = 3)] = "NoScale"),
            (r[(r.NoScaleOrReflection = 4)] = "NoScaleOrReflection"),
            ((a = t.PositionMode || (t.PositionMode = {}))[(a.Fixed = 0)] =
              "Fixed"),
            (a[(a.Percent = 1)] = "Percent"),
            ((o = t.SpacingMode || (t.SpacingMode = {}))[(o.Length = 0)] =
              "Length"),
            (o[(o.Fixed = 1)] = "Fixed"),
            (o[(o.Percent = 2)] = "Percent"),
            ((h = t.RotateMode || (t.RotateMode = {}))[(h.Tangent = 0)] =
              "Tangent"),
            (h[(h.Chain = 1)] = "Chain"),
            (h[(h.ChainScale = 2)] = "ChainScale"),
            ((l = t.TextureFilter || (t.TextureFilter = {}))[
              (l.Nearest = 9728)
            ] = "Nearest"),
            (l[(l.Linear = 9729)] = "Linear"),
            (l[(l.MipMap = 9987)] = "MipMap"),
            (l[(l.MipMapNearestNearest = 9984)] = "MipMapNearestNearest"),
            (l[(l.MipMapLinearNearest = 9985)] = "MipMapLinearNearest"),
            (l[(l.MipMapNearestLinear = 9986)] = "MipMapNearestLinear"),
            (l[(l.MipMapLinearLinear = 9987)] = "MipMapLinearLinear"),
            ((c = t.TextureWrap || (t.TextureWrap = {}))[
              (c.MirroredRepeat = 33648)
            ] = "MirroredRepeat"),
            (c[(c.ClampToEdge = 33071)] = "ClampToEdge"),
            (c[(c.Repeat = 10497)] = "Repeat"),
            ((u = t.AttachmentType || (t.AttachmentType = {}))[(u.Region = 0)] =
              "Region"),
            (u[(u.BoundingBox = 1)] = "BoundingBox"),
            (u[(u.Mesh = 2)] = "Mesh"),
            (u[(u.LinkedMesh = 3)] = "LinkedMesh"),
            (u[(u.Path = 4)] = "Path"),
            (u[(u.Point = 5)] = "Point"),
            (u[(u.Clipping = 6)] = "Clipping");
        })(nlt || (nlt = {}));
      var rlt = nlt;
      let alt = 0,
        olt = 0;
      class hlt {
        constructor() {
          (this.start = void 0),
            (this.interrupt = void 0),
            (this.end = void 0),
            (this.dispose = void 0),
            (this.complete = void 0),
            (this.event = void 0);
        }
        static getListeners(t, e) {
          if (!t.listener) {
            t.listener = new hlt();
            const i = ++olt;
            e.setTrackEntryListener(i, t), hlt._trackSet.set(i, t);
          }
          return t.listener;
        }
        static emitListener(t, e, i, s) {
          const n = hlt._listenerSet.get(t);
          if (n)
            switch (s) {
              case rlt.EventType.event:
                n.event && n.event(e, i);
                break;
              case rlt.EventType.start:
                n.start && n.start(e);
                break;
              case rlt.EventType.interrupt:
                n.interrupt && n.interrupt(e);
                break;
              case rlt.EventType.end:
                n.end && n.end(e);
                break;
              case rlt.EventType.dispose:
                n.dispose && n.dispose(e);
                break;
              case rlt.EventType.complete:
                n.complete && n.complete(e);
                break;
              default:
                w("emitListener doesn't handled", s);
            }
        }
        static emitTrackEntryListener(t, e, i, s) {
          const n = this._trackSet.get(t);
          if (n)
            switch (s) {
              case rlt.EventType.start:
                n.listener.start && n.listener.start(e);
                break;
              case rlt.EventType.interrupt:
                n.listener.interrupt && n.listener.interrupt(e);
                break;
              case rlt.EventType.end:
                n.listener.end && n.listener.end(e);
                break;
              case rlt.EventType.dispose:
                n.listener.dispose && n.listener.dispose(e),
                  this._trackSet.delete(t),
                  (n.listener = null);
                break;
              case rlt.EventType.complete:
                n.listener.complete && n.listener.complete(e);
                break;
              case rlt.EventType.event:
                n.listener.event && n.listener.event(e, i);
                break;
              default:
                w("TrackEntry doesn't handled", s);
            }
        }
        static addListener(t) {
          const e = ++alt;
          return hlt._listenerSet.set(e, t), e;
        }
        static removeListener(t) {
          hlt._listenerSet.delete(t);
        }
      }
      var llt;
      (hlt._listenerSet = new Map()),
        (hlt._trackSet = new Map()),
        (globalThis.TrackEntryListeners = hlt);
      const clt = 1 / 60;
      UO(NO);
      const ult = UO(BO);
      class _lt {
        constructor() {
          (this.a = 0),
            (this.b = 0),
            (this.c = 0),
            (this.d = 0),
            (this.worldX = 0),
            (this.worldY = 0);
        }
      }
      class dlt {
        constructor() {
          (this.vCount = 0),
            (this.iCount = 0),
            (this.vData = null),
            (this.iData = null),
            (this.meshes = []);
        }
      }
      class plt {
        constructor() {
          (this.iCount = 0), (this.blendMode = 0), (this.textureID = 0);
        }
      }
      class mlt {
        constructor(t) {
          (this._instance = null),
            (this._state = null),
            (this._skeletonData = null),
            (this._skeleton = null),
            (this._privateMode = !1),
            (this._curIndex = -1),
            (this._isCompleted = !1),
            (this._maxFrameIdex = 0),
            (this._frameIdx = -1),
            (this._inited = !1),
            (this._invalid = !0),
            (this._enableCacheAttachedInfo = !1),
            (this._skeletonInfo = null),
            (this._animationName = null),
            (this.isCompleted = !1),
            (this.totalTime = 0),
            (this.frames = []),
            (this._privateMode = !1),
            (this._inited = !1),
            (this._invalid = !0),
            (this._instance = new rlt.SkeletonInstance()),
            (this._instance.isCache = !0),
            (this._skeletonData = t),
            (this._skeleton = this._instance.initSkeleton(t)),
            this._instance.setUseTint(!0);
        }
        init(t, e) {
          (this._inited = !0),
            (this._animationName = e),
            (this._skeletonInfo = t);
        }
        get skeleton() {
          return this._skeleton;
        }
        setSkin(t) {
          this._skeleton && this._skeleton.setSkinByName(t),
            this._instance.setSkin(t);
        }
        setAnimation(t) {
          const e = this._skeletonData.animations;
          let i = null;
          e.forEach((e) => {
            e.name === t && (i = e);
          }),
            i
              ? ((this._maxFrameIdex = Math.floor(i.duration / clt)),
                this._maxFrameIdex <= 0 && (this._maxFrameIdex = 1),
                this._instance.setAnimation(0, t, !1))
              : w(`find no animation named ${t} !!!`);
        }
        updateToFrame(t) {
          if (this._inited && (this.begin(), this.needToUpdate(t)))
            do {
              this._frameIdx++,
                (this.totalTime += clt),
                this._instance.updateAnimation(clt);
              const t = this._instance.updateRenderData();
              this.updateRenderData(this._frameIdx, t),
                this._frameIdx >= this._maxFrameIdex && (this.isCompleted = !0);
            } while (this.needToUpdate(t));
        }
        getFrame(t) {
          const e = t % this._maxFrameIdex;
          return this.frames[e];
        }
        invalidAnimationFrames() {
          (this._curIndex = -1),
            (this._isCompleted = !1),
            (this.frames.length = 0);
        }
        updateRenderData(t, e) {
          const i = e.vCount,
            s = e.iCount,
            n = ult / Float32Array.BYTES_PER_ELEMENT,
            r = new Uint8Array(Float32Array.BYTES_PER_ELEMENT * n * i),
            a = new Uint16Array(s),
            o = rlt.wasmUtil.wasm.HEAPU8,
            h = e.vPtr,
            l = i * Float32Array.BYTES_PER_ELEMENT * n;
          r.set(o.subarray(h, h + l));
          const c = e.iPtr,
            u = Uint16Array.BYTES_PER_ELEMENT * s;
          new Uint8Array(a.buffer).set(o.subarray(c, c + u));
          const _ = new dlt();
          (_.vCount = i), (_.iCount = s), (_.vData = r), (_.iData = a);
          const d = e.getData(),
            p = d.size();
          for (let t = 0; t < p; t += 6) {
            const e = new plt();
            (e.iCount = d.get(t + 3)),
              (e.blendMode = d.get(t + 4)),
              (e.textureID = d.get(t + 5)),
              _.meshes.push(e);
          }
          const m = this._skeleton.bones,
            f = [];
          m.forEach((t) => {
            const e = new _lt();
            (e.a = t.a),
              (e.b = t.b),
              (e.c = t.c),
              (e.d = t.d),
              (e.worldX = t.worldX),
              (e.worldY = t.worldY),
              f.push(e);
          }),
            (this.frames[t] = { model: _, boneInfos: f });
        }
        begin() {
          if (!this._invalid) return;
          const t = this._skeletonInfo,
            e = null == t ? void 0 : t.curAnimationCache;
          e &&
            e !== this &&
            (this._privateMode ? e.invalidAllFrame() : e.updateToFrame(0));
          const i = null == t ? void 0 : t.listener;
          this._instance.setAnimation(0, this._animationName, !1),
            this.bind(i),
            (t.curAnimationCache = this),
            (this._frameIdx = -1),
            (this.isCompleted = !1),
            (this.totalTime = 0),
            (this._invalid = !1);
        }
        end() {
          this.needToUpdate() ||
            ((this._skeletonInfo.curAnimationCache = null),
            (this.frames.length = this._frameIdx + 1),
            (this.isCompleted = !0),
            this.unbind(this._skeletonInfo.listener));
        }
        bind(t) {
          t.complete = (t) => {
            t &&
              t.animation.name === this._animationName &&
              (this.isCompleted = !0);
          };
        }
        unbind(t) {
          t.complete = null;
        }
        needToUpdate(t) {
          return (
            !this.isCompleted &&
            this.totalTime < 30 &&
            (void 0 === t || this._frameIdx < t)
          );
        }
        isInited() {
          return this._inited;
        }
        isInvalid() {
          return this._invalid;
        }
        invalidAllFrame() {
          (this.isCompleted = !1), (this._invalid = !0);
        }
        enableCacheAttachedInfo() {
          this._enableCacheAttachedInfo ||
            ((this._enableCacheAttachedInfo = !0), this.invalidAllFrame());
        }
        clear() {
          (this._inited = !1), this.invalidAllFrame();
        }
        destroy() {
          this._instance && (this._instance.destroy(), (this._instance = null));
        }
      }
      class flt {
        constructor() {
          (this._privateMode = void 0),
            (this._skeletonCache = void 0),
            (this._animationPool = void 0),
            (this._sharedCacheMap = new Map()),
            (this._privateMode = !1),
            (this._animationPool = {}),
            (this._skeletonCache = {});
        }
        enablePrivateMode() {
          this._privateMode = !0;
        }
        clear() {
          (this._animationPool = {}), (this._skeletonCache = {});
        }
        invalidAnimationCache(t) {
          const e = this._skeletonCache[t];
          if (!e || !e.skeleton) return;
          const i = e.animationsCache;
          for (const t in i) i[t].invalidAllFrame();
        }
        destroySkeleton(t) {
          if (!this._privateMode) {
            let e = this._sharedCacheMap.get(t);
            if (e) {
              if (((e -= 1), e > 0)) return void this._sharedCacheMap.set(t, e);
              this._sharedCacheMap.delete(t);
            }
          }
          const e = this._skeletonCache[t];
          if (!e) return;
          const i = this._privateMode
              ? (t, e) => {
                  e.destroy();
                }
              : (e, i) => {
                  (this._animationPool[`${t}#${e}`] = i), i.clear();
                },
            s = e.animationsCache;
          for (const t in s) {
            const e = s[t];
            e && i(t, e);
          }
          e.skeleton && rlt.wasmUtil.destroySpineSkeleton(e.skeleton),
            delete this._skeletonCache[t];
        }
        createSkeletonInfo(t) {
          const e = t.uuid,
            i = t.getRuntimeData();
          if (!this._privateMode) {
            let t = this._sharedCacheMap.get(e);
            t ? (t += 1) : (t = 1), this._sharedCacheMap.set(e, t);
          }
          if (this._skeletonCache[e]) return this._skeletonCache[e];
          const s = new rlt.Skeleton(i),
            n = new hlt();
          return (this._skeletonCache[e] = {
            skeleton: s,
            clipper: null,
            state: null,
            listener: n,
            animationsCache: {},
            curAnimationCache: null,
            assetUUID: e,
          });
        }
        getSkeletonInfo(t) {
          const e = t.uuid;
          return this._skeletonCache[e];
        }
        getAnimationCache(t, e) {
          const i = this._skeletonCache[t];
          return i ? i.animationsCache[e] : null;
        }
        initAnimationCache(t, e, i) {
          const s = e.getRuntimeData();
          if (!s) return null;
          const n = this._skeletonCache[t];
          if (!n || !n.skeleton) return null;
          const r = n.animationsCache;
          let a = r[i];
          if (!a) {
            const e = `${t}#${i}`;
            (a = this._animationPool[e]),
              a
                ? delete this._animationPool[e]
                : ((a = new mlt(s)), (a._privateMode = this._privateMode)),
              a.init(n, i),
              (r[i] = a);
          }
          return a.init(n, i), a.setAnimation(i), a;
        }
        destroyCachedAnimations(t) {
          if (t) {
            const e = this._animationPool;
            for (const i in e) i.includes(t) && (e[i].destroy(), delete e[i]);
            let i = this._skeletonCache[t];
            const s = i && i.skeleton;
            s && rlt.wasmUtil.destroySpineSkeleton(s),
              i && delete this._skeletonCache[t];
          } else {
            const t = this._animationPool;
            for (const e in t) t[e].destroy(), delete t[e];
          }
        }
      }
      var glt, ylt, Tlt, Slt, Elt, vlt, blt, Alt, Clt, Olt;
      (llt = flt), (flt.FrameTime = clt), (flt.sharedCache = new llt());
      let Ilt =
        ((glt = Ca("sp.SkeletonData")),
        (ylt = ao([sm])),
        (Tlt = ao([Ge])),
        glt(
          ((Elt = class extends Ad {
            get skeletonJsonStr() {
              return this._skeletonJson
                ? JSON.stringify(this._skeletonJson)
                : "";
            }
            get skeletonJson() {
              return this._skeletonJson;
            }
            set skeletonJson(t) {
              this.reset(),
                (this._skeletonJson = "string" == typeof t ? JSON.parse(t) : t),
                !this._uuid && t.skeleton && (this._uuid = t.skeleton.hash);
            }
            get atlasText() {
              return this._atlasText;
            }
            set atlasText(t) {
              (this._atlasText = t), this.reset();
            }
            get _nativeAsset() {
              return this._buffer;
            }
            set _nativeAsset(t) {
              (this._buffer = t), this.reset();
            }
            constructor() {
              super(),
                (this._skeletonJson = vlt && vlt()),
                (this.textures = blt && blt()),
                (this.textureNames = Alt && Alt()),
                (this.scale = Clt && Clt()),
                (this._atlasText = Olt && Olt()),
                (this._buffer = void 0),
                (this._skeletonCache = null),
                (this._skinsEnum = null),
                (this._animsEnum = null),
                this.reset();
            }
            createNode(t) {
              const e = new Pf(this.name);
              return (
                (e.addComponent("cc.Skeleton").skeletonData = this), t(null, e)
              );
            }
            reset() {
              this._skeletonCache = null;
            }
            resetEnums() {}
            getRuntimeData(t) {
              if (this._skeletonCache) return this._skeletonCache;
              if (
                !(this.textures && this.textures.length > 0) &&
                this.textureNames &&
                this.textureNames.length > 0
              )
                return t || R(`${this.name} no textures found!`), null;
              const e = rlt.wasmUtil.querySpineSkeletonDataByUUID(this._uuid);
              if (e) this._skeletonCache = e;
              else if (this._skeletonJson)
                (this._skeletonCache =
                  rlt.wasmUtil.createSpineSkeletonDataWithJson(
                    this.skeletonJsonStr,
                    this._atlasText
                  )),
                  rlt.wasmUtil.registerSpineSkeletonDataWithUUID(
                    this._skeletonCache,
                    this._uuid
                  );
              else {
                const t = new Uint8Array(this._nativeAsset),
                  e = t.length,
                  i = rlt.wasmUtil.queryStoreMemory(e);
                rlt.wasmUtil.wasm.HEAPU8.subarray(i, i + e).set(t),
                  (this._skeletonCache =
                    rlt.wasmUtil.createSpineSkeletonDataWithBinary(
                      e,
                      this._atlasText
                    )),
                  rlt.wasmUtil.registerSpineSkeletonDataWithUUID(
                    this._skeletonCache,
                    this._uuid
                  );
              }
              return this._skeletonCache;
            }
            getSkinsEnum() {
              if (this._skinsEnum) return this._skinsEnum;
              const t = this.getRuntimeData(!0);
              if (t) {
                const e = t.skins,
                  i = {};
                for (let t = 0; t < e.length; t++) i[e[t].name] = t;
                return (this._skinsEnum = ce(i));
              }
              return null;
            }
            getAnimsEnum() {
              if (this._animsEnum && Object.keys(this._animsEnum).length > 1)
                return this._animsEnum;
              const t = this.getRuntimeData(!0);
              if (t) {
                const e = { "<None>": 0 },
                  i = t.animations;
                for (let t = 0; t < i.length; t++) e[i[t].name] = t + 1;
                return (this._animsEnum = ce(e));
              }
              return null;
            }
            destroy() {
              return (
                flt.sharedCache.destroyCachedAnimations(this._uuid),
                rlt.wasmUtil.destroySpineSkeletonDataWithUUID(this._uuid),
                super.destroy()
              );
            }
          }),
          (vlt = fa(Elt.prototype, "_skeletonJson", [Na], function () {
            return null;
          })),
          (blt = fa(Elt.prototype, "textures", [Na, ylt], function () {
            return [];
          })),
          (Alt = fa(Elt.prototype, "textureNames", [Na, Tlt], function () {
            return [];
          })),
          (Clt = fa(Elt.prototype, "scale", [Na], function () {
            return 1;
          })),
          (Olt = fa(Elt.prototype, "_atlasText", [Na], function () {
            return "";
          })),
          (Slt = Elt))
        ) || Slt);
      a.internal.SpineSkeletonData = Ilt;
      class wlt extends jl {
        constructor() {
          super(), (this._skeletons = new Set());
        }
        static getInstance() {
          return (
            wlt._instance ||
              ((wlt._instance = new wlt()),
              Lv.registerSystem(wlt.ID, wlt._instance, jl.Priority.HIGH)),
            wlt._instance
          );
        }
        add(t) {
          t && (this._skeletons.has(t) || this._skeletons.add(t));
        }
        remove(t) {
          t && this._skeletons.has(t) && this._skeletons.delete(t);
        }
        postUpdate(t) {
          this._skeletons &&
            this._skeletons.forEach((e) => {
              e.updateAnimation(t);
            });
        }
        prepareRenderData() {
          this._skeletons &&
            this._skeletons.forEach((t) => {
              t.markForUpdateRenderData();
            });
        }
      }
      (wlt.ID = "SKELETON"),
        (wlt._instance = void 0),
        (a.internal.SpineSkeletonSystem = wlt);
      const Rlt = new ms();
      class Dlt {
        constructor() {
          (this._isInitialized = !1),
            (this._skeletonBones = null),
            (this._socketNodes = null),
            (this._keysToDelete = []),
            (this._isInitialized = !1);
        }
        init(t) {
          var e;
          (this._isInitialized = !1),
            t &&
              0 !==
                (null === (e = t.socketNodes) || void 0 === e
                  ? void 0
                  : e.size) &&
              ((this._skeletonBones = t._skeleton.bones),
              !this._skeletonBones ||
                this._skeletonBones.length < 1 ||
                ((this._socketNodes = t.socketNodes),
                !this._socketNodes ||
                  this._socketNodes.size <= 0 ||
                  ((this._isInitialized = !0), this._syncAttachedNode())));
        }
        updateSkeletonBones(t) {
          this._skeletonBones = t;
        }
        reset() {
          (this._isInitialized = !1),
            (this._skeletonBones = null),
            (this._socketNodes = null),
            (this._keysToDelete.length = 0);
        }
        _syncAttachedNode() {
          if (!this._isInitialized) return;
          const t = this._socketNodes;
          for (const [e, i] of t) {
            if (!i || !i.isValid) {
              this._keysToDelete.push(e);
              continue;
            }
            const t = this._skeletonBones[e];
            t && this.matrixHandle(i, t);
          }
          if (!(this._keysToDelete.length <= 0)) {
            for (const e of this._keysToDelete) t.delete(e);
            this._keysToDelete.length = 0;
          }
        }
        matrixHandle(t, e) {
          const i = Rlt;
          (i.m00 = e.a),
            (i.m01 = e.c),
            (i.m04 = e.b),
            (i.m05 = e.d),
            (i.m12 = e.worldX),
            (i.m13 = e.worldY),
            (t.matrix = Rlt);
        }
      }
      var xlt,
        Mlt,
        Plt,
        Nlt,
        Llt,
        Blt,
        Flt,
        Ult,
        klt,
        zlt,
        Hlt,
        Glt,
        Vlt,
        jlt,
        Wlt,
        Xlt,
        Ylt,
        Klt,
        qlt,
        $lt,
        Zlt,
        Qlt,
        Jlt,
        tct,
        ect,
        ict,
        sct,
        nct,
        rct,
        act;
      let oct,
        hct,
        lct,
        cct,
        uct = 1e4;
      !(function (t) {
        (t[(t.UNSET = -1)] = "UNSET"),
          (t[(t.REALTIME = 0)] = "REALTIME"),
          (t[(t.SHARED_CACHE = 1)] = "SHARED_CACHE"),
          (t[(t.PRIVATE_CACHE = 2)] = "PRIVATE_CACHE");
      })(oct || (oct = {})),
        de(oct),
        (function (t) {
          t[(t.default = 0)] = "default";
        })(hct || (hct = {})),
        de(hct),
        (function (t) {
          t[(t["<None>"] = 0)] = "<None>";
        })(lct || (lct = {})),
        de(lct),
        (function (t) {
          (t[(t.COLORED_TEXTURED = 0)] = "COLORED_TEXTURED"),
            (t[(t.TWO_COLORED = 1)] = "TWO_COLORED");
        })(cct || (cct = {}));
      let _ct =
        ((xlt = Ca("sp.Skeleton.SpineSocket")),
        (Mlt = ao(Pf)),
        xlt(
          ((Nlt = class {
            constructor(t = "", e = null) {
              (this.path = Llt && Llt()),
                (this.target = Blt && Blt()),
                (this.path = t),
                (this.target = e);
            }
          }),
          (Llt = fa(Nlt.prototype, "path", [Na], function () {
            return "";
          })),
          (Blt = fa(Nlt.prototype, "target", [Mlt, Na], function () {
            return null;
          })),
          (Plt = Nlt))
        ) || Plt);
      Vt(_ct, "sp.Skeleton.SpineSocket");
      let dct =
        ((Flt = Ca("sp.Skeleton")),
        (Ult = ao(Ilt)),
        (klt = ao(hct)),
        (zlt = ao(lct)),
        (Hlt = ao(oct)),
        (Glt = ao([_ct])),
        (Vlt = ao(ey)),
        Flt(
          (((act = class t extends ew {
            constructor() {
              super(),
                (this._skeletonData = Xlt && Xlt()),
                (this.defaultSkin = Ylt && Ylt()),
                (this.defaultAnimation = Klt && Klt()),
                (this._premultipliedAlpha = qlt && qlt()),
                (this._timeScale = $lt && $lt()),
                (this._preCacheMode = Zlt && Zlt()),
                (this._cacheMode = Qlt && Qlt()),
                (this._sockets = Jlt && Jlt()),
                (this._useTint = tct && tct()),
                (this._debugMesh = ect && ect()),
                (this._debugBones = ict && ict()),
                (this._debugSlots = sct && sct()),
                (this._enableBatch = nct && nct()),
                (this._runtimeData = null),
                (this._skeleton = null),
                (this._instance = null),
                (this._state = null),
                (this._textures = []),
                (this._skeletonInfo = null),
                (this._animationName = ""),
                (this._skinName = ""),
                (this._drawList = new Xn(
                  () => ({
                    material: null,
                    texture: null,
                    indexOffset: 0,
                    indexCount: 0,
                  }),
                  1
                )),
                (this._materialCache = {}),
                (this.paused = !1),
                (this._enumSkins = ce({})),
                (this._enumAnimations = ce({})),
                (this.attachUtil = void 0),
                (this._socketNodes = new Map()),
                (this._cachedSockets = new Map()),
                (this._startEntry = void 0),
                (this._endEntry = void 0),
                (this._paused = !1),
                (this._accTime = 0),
                (this._playCount = 0),
                (this._skeletonCache = null),
                (this._animCache = null),
                (this._animationQueue = []),
                (this._headAniInfo = null),
                (this._isAniComplete = !0),
                (this._playTimes = 0),
                (this._curFrame = null),
                (this._needUpdateSkeltonData = !0),
                (this._listener = null),
                (this._debugRenderer = null),
                (this._startSlotIndex = void 0),
                (this._endSlotIndex = void 0),
                (this._slotTextures = null),
                (this._vLength = 0),
                (this._vBuffer = null),
                (this._iLength = 0),
                (this._iBuffer = null),
                (this._model = void 0),
                (this._tempColor = { r: 0, g: 0, b: 0, a: 0 }),
                (this._eventListenerID = -1),
                (this.loop = rct && rct()),
                (this._useVertexOpacity = !0),
                (this._startEntry = { animation: { name: "" }, trackIndex: 0 }),
                (this._endEntry = { animation: { name: "" }, trackIndex: 0 }),
                (this._startSlotIndex = -1),
                (this._endSlotIndex = -1),
                (this.attachUtil = new Dlt());
            }
            get drawList() {
              return this._drawList;
            }
            get skeletonData() {
              return this._skeletonData;
            }
            set skeletonData(t) {
              t && t.resetEnums(),
                this._skeletonData !== t &&
                  (this.destroyRenderData(),
                  (this._skeletonData = t),
                  (this.defaultSkin = ""),
                  (this.defaultAnimation = ""),
                  (this._animationName = ""),
                  (this._skinName = ""),
                  this._updateSkeletonData(),
                  this._updateUITransform());
            }
            get _defaultSkinIndex() {
              if (this.skeletonData) {
                const t = this.skeletonData.getSkinsEnum();
                if (t)
                  if ("" === this.defaultSkin) {
                    if (t.hasOwnProperty(0))
                      return (this._defaultSkinIndex = 0), 0;
                  } else {
                    const e = t[this.defaultSkin];
                    if (void 0 !== e) return e;
                  }
              }
              return 0;
            }
            set _defaultSkinIndex(t) {
              let e;
              if (
                (this.skeletonData && (e = this.skeletonData.getSkinsEnum()),
                !e)
              )
                return void R(`${this.name} skin enums are invalid`);
              const i = e[t];
              void 0 !== i
                ? ((this.defaultSkin = String(i)),
                  this.setSkin(this.defaultSkin),
                  this._refreshInspector(),
                  this.markForUpdateRenderData())
                : R(`${this.name} skin enums are invalid`);
            }
            get _animationIndex() {
              const t = this.animation;
              if (this.skeletonData)
                if (t) {
                  const e = this.skeletonData.getAnimsEnum();
                  if (e) {
                    const i = e[t];
                    if (void 0 !== i) return i;
                  }
                } else this._refreshInspector();
              return 0;
            }
            set _animationIndex(t) {
              let e;
              if (
                (this.skeletonData && (e = this.skeletonData.getAnimsEnum()),
                !e)
              )
                return void R(`${this.name} animation enums are invalid`);
              const i = String(e[t]);
              void 0 !== i
                ? ((this.animation = i), (this.animation = i))
                : R(`${this.name} animation enums are invalid`);
            }
            get defaultCacheMode() {
              return this._cacheMode;
            }
            set defaultCacheMode(t) {
              (this._cacheMode = t),
                this.setAnimationCacheMode(this._cacheMode);
            }
            get premultipliedAlpha() {
              return this._premultipliedAlpha;
            }
            set premultipliedAlpha(t) {
              t !== this._premultipliedAlpha &&
                ((this._premultipliedAlpha = t),
                this._instance.setPremultipliedAlpha(t),
                this.markForUpdateRenderData());
            }
            get timeScale() {
              return this._timeScale;
            }
            set timeScale(t) {
              t !== this._timeScale &&
                ((this._timeScale = t),
                this._instance &&
                  (this._instance.dtRate = 1 * this._timeScale));
            }
            get useTint() {
              return this._useTint;
            }
            set useTint(t) {
              t !== this._useTint &&
                ((this._useTint = t), this._updateUseTint());
            }
            get enableBatch() {
              return this._enableBatch;
            }
            set enableBatch(t) {
              t !== this._enableBatch &&
                ((this._enableBatch = t), this._updateBatch());
            }
            get sockets() {
              return this._sockets;
            }
            set sockets(t) {
              (this._sockets = t),
                this._updateSocketBindings(),
                this.attachUtil.init(this);
            }
            get debugSlots() {
              return this._debugSlots;
            }
            set debugSlots(t) {
              t !== this._debugSlots &&
                ((this._debugSlots = t),
                this._updateDebugDraw(),
                this.markForUpdateRenderData());
            }
            get debugBones() {
              return this._debugBones;
            }
            set debugBones(t) {
              t !== this._debugBones &&
                ((this._debugBones = t),
                this._updateDebugDraw(),
                this.markForUpdateRenderData());
            }
            get debugMesh() {
              return this._debugMesh;
            }
            set debugMesh(t) {
              t !== this._debugMesh &&
                ((this._debugMesh = t),
                this._updateDebugDraw(),
                this.markForUpdateRenderData());
            }
            get socketNodes() {
              return this._socketNodes;
            }
            get animation() {
              return this._animationName;
            }
            set animation(t) {
              t ? this.setAnimation(0, t, this.loop) : this.clearAnimation(0);
            }
            get customMaterial() {
              return this._customMaterial;
            }
            set customMaterial(t) {
              (this._customMaterial = t),
                this.updateMaterial(),
                this.markForUpdateRenderData();
            }
            __preload() {
              super.__preload(),
                this._updateSkeletonData(),
                this._updateDebugDraw();
            }
            onRestore() {
              this.updateMaterial(), this.markForUpdateRenderData();
            }
            getState() {
              return this._state;
            }
            onEnable() {
              super.onEnable(),
                this._instance && (this._instance.enable = !0),
                this._flushAssembler(),
                wlt.getInstance().add(this);
            }
            onDisable() {
              super.onDisable(),
                this._instance && (this._instance.enable = !1),
                wlt.getInstance().remove(this);
            }
            onDestroy() {
              var t;
              this._eventListenerID > 0 &&
                (hlt.removeListener(this._eventListenerID),
                (this._eventListenerID = -1)),
                this._drawList.destroy(),
                this.destroyRenderData(),
                this._cleanMaterialCache(),
                (this._vBuffer = null),
                (this._iBuffer = null),
                this.attachUtil.reset(),
                null === (t = this._slotTextures) || void 0 === t || t.clear(),
                (this._slotTextures = null),
                this._cachedSockets.clear(),
                this._socketNodes.clear(),
                (this._animCache = null),
                wlt.getInstance().remove(this),
                this._destroySkeletonInfo(this._skeletonCache),
                (this._skeletonCache = null),
                super.onDestroy();
            }
            clearAnimation(t) {
              this.isAnimationCached() ||
                (this.clearTrack(t || 0), this.setToSetupPose());
            }
            clearAnimations() {
              this.isAnimationCached() ||
                (this.clearTracks(), this.setToSetupPose());
            }
            _updateSkeletonData() {
              const t = this._skeletonData;
              if (!t)
                return (
                  (this._runtimeData = null),
                  (this._state = null),
                  (this._skeleton = null),
                  (this._textures = []),
                  void this._refreshInspector()
                );
              this._instance && (this._instance.dtRate = 1 * this._timeScale),
                (this._needUpdateSkeltonData = !1),
                (this._runtimeData = t.getRuntimeData()),
                this._runtimeData &&
                  (this.setSkeletonData(this._runtimeData),
                  (this._textures = t.textures),
                  this._refreshInspector(),
                  this.defaultAnimation &&
                    (this.animation = this.defaultAnimation.toString()),
                  this.defaultSkin &&
                    "" !== this.defaultSkin &&
                    this.setSkin(this.defaultSkin),
                  this._updateUseTint(),
                  this._indexBoneSockets(),
                  this._updateSocketBindings(),
                  this.attachUtil.init(this),
                  (this._preCacheMode = this._cacheMode));
            }
            setSkeletonData(t) {
              {
                const t = this._skeletonCache;
                this._cacheMode === oct.SHARED_CACHE
                  ? (this._skeletonCache = flt.sharedCache)
                  : this._cacheMode === oct.PRIVATE_CACHE
                  ? ((this._skeletonCache = new flt()),
                    this._skeletonCache.enablePrivateMode())
                  : (this._skeletonCache = null),
                  t !== this._skeletonCache && this._destroySkeletonInfo(t);
              }
              if (this.isAnimationCached()) {
                (this.debugBones || this.debugSlots) &&
                  w("Debug bones or slots is invalid in cached mode");
                const t = this._skeletonCache.getSkeletonInfo(
                  this._skeletonData
                );
                this._skeletonInfo !== t &&
                  (this._destroySkeletonInfo(this._skeletonCache),
                  (this._skeletonInfo = this._skeletonCache.createSkeletonInfo(
                    this._skeletonData
                  )),
                  (this._skeleton = this._skeletonInfo.skeleton));
              } else
                (this._skeleton = this._instance.initSkeleton(t)),
                  (this._state = this._instance.getAnimationState()),
                  this._instance.setPremultipliedAlpha(
                    this._premultipliedAlpha
                  );
              this._flushAssembler();
            }
            setSlotsRange(t, e) {
              this.isAnimationCached()
                ? w("Slots visible range can not be modified in cached mode.")
                : ((this._startSlotIndex = t), (this._endSlotIndex = e));
            }
            getAttachment(t, e) {
              return this._skeleton
                ? this._skeleton.getAttachmentByName(t, e)
                : null;
            }
            setAttachment(t, e) {
              this._skeleton && this._skeleton.setAttachment(t, e),
                this.invalidAnimationCache();
            }
            getTextureAtlas(t) {
              return t.region;
            }
            setAnimation(t, e, i) {
              if ("string" != typeof e) return B(7511), null;
              if (!this._skeleton.data.findAnimation(e))
                return B(7509, e), null;
              let s = null;
              if (
                (void 0 === i && (i = !0),
                (this._playTimes = i ? 0 : 1),
                this.isAnimationCached())
              ) {
                if (
                  (0 !== t &&
                    w("Track index can not greater than 0 in cached mode."),
                  !this._skeletonCache)
                )
                  return null;
                let i = this._skeletonCache.getAnimationCache(
                  this._skeletonData.uuid,
                  e
                );
                var n;
                i ||
                  ((i = this._skeletonCache.initAnimationCache(
                    this.skeletonData.uuid,
                    this._skeletonData,
                    e
                  )),
                  null === (n = i) ||
                    void 0 === n ||
                    n.setSkin(this._skinName)),
                  i &&
                    ((this._animationName = e),
                    (this._isAniComplete = !1),
                    (this._accTime = 0),
                    (this._playCount = 0),
                    (this._animCache = i),
                    this._socketNodes.size > 0 &&
                      this._animCache.enableCacheAttachedInfo(),
                    this._animCache.updateToFrame(0),
                    (this._curFrame = this._animCache.frames[0]));
              } else
                (this._animationName = e),
                  (s = this._instance.setAnimation(t, e, i));
              return this.markForUpdateRenderData(), s;
            }
            addAnimation(t, e, i, s) {
              if (((s = s || 0), this.isAnimationCached()))
                return (
                  0 !== t &&
                    w("Track index can not greater than 0 in cached mode."),
                  this._animationQueue.push({
                    animationName: e,
                    loop: i,
                    delay: s,
                  }),
                  null
                );
              if (this._skeleton) {
                var n;
                const r = this._skeleton.data.findAnimation(e);
                return r
                  ? null === (n = this._state) || void 0 === n
                    ? void 0
                    : n.addAnimationWith(t, r, i, s)
                  : (B(7510, e), null);
              }
              return null;
            }
            findAnimation(t) {
              return this._skeleton
                ? this._skeleton.data.findAnimation(t)
                : null;
            }
            getCurrent(t) {
              if (this.isAnimationCached())
                w("'getCurrent' interface can not be invoked in cached mode.");
              else if (this._state) return this._state.getCurrent(t);
              return null;
            }
            setSkin(t) {
              this._skeleton && this._skeleton.setSkinByName(t),
                this._instance.setSkin(t),
                this.isAnimationCached() &&
                  this._animCache &&
                  this._animCache.setSkin(t),
                (this._skinName = t),
                this.invalidAnimationCache();
            }
            updateAnimation(t) {
              if ((this.markForUpdateRenderData(), !this.paused))
                if (this.isAnimationCached()) {
                  if (((t *= 1 * this._timeScale), this._isAniComplete)) {
                    var e;
                    if (
                      0 === this._animationQueue.length &&
                      !this._headAniInfo
                    ) {
                      const t = this._animCache;
                      if (t && t.isInvalid()) {
                        t.updateToFrame(0);
                        const e = t.frames;
                        this._curFrame = e[e.length - 1];
                      }
                      return;
                    }
                    if (
                      (this._headAniInfo ||
                        (this._headAniInfo = this._animationQueue.shift()),
                      (this._accTime += t),
                      this._accTime >
                        (null === (e = this._headAniInfo) || void 0 === e
                          ? void 0
                          : e.delay))
                    ) {
                      const t = this._headAniInfo;
                      (this._headAniInfo = null),
                        this.setAnimation(
                          0,
                          null == t ? void 0 : t.animationName,
                          null == t ? void 0 : t.loop
                        );
                    }
                    return;
                  }
                  this._updateCache(t);
                } else this._instance.updateAnimation(t);
            }
            _updateCache(t) {
              const e = this._animCache;
              if (!e.isInited()) return;
              const i = e.frames,
                s = flt.FrameTime;
              0 === this._accTime &&
                0 === this._playCount &&
                ((this._startEntry.animation.name = this._animationName),
                this._listener &&
                  this._listener.start &&
                  this._listener.start(this._startEntry)),
                (this._accTime += t);
              let n = Math.floor(this._accTime / s);
              if (
                (e.isCompleted || e.updateToFrame(n),
                (this._curFrame = i[n]),
                void 0 !== this._curFrame &&
                  this.attachUtil.updateSkeletonBones(this._curFrame.boneInfos),
                e.isCompleted && n >= i.length)
              ) {
                if (
                  (this._playCount++,
                  this._playTimes > 0 && this._playCount >= this._playTimes)
                )
                  return (
                    (this._curFrame = i[i.length - 1]),
                    (this._accTime = 0),
                    (this._playCount = 0),
                    (this._isAniComplete = !0),
                    void this._emitCacheCompleteEvent()
                  );
                (this._accTime = 0),
                  (n = 0),
                  (this._curFrame = i[n]),
                  this._emitCacheCompleteEvent();
              }
            }
            _emitCacheCompleteEvent() {
              this._listener &&
                ((this._endEntry.animation.name = this._animationName),
                this._listener.complete &&
                  this._listener.complete(this._endEntry),
                this._listener.end && this._listener.end(this._endEntry));
            }
            updateRenderData() {
              return this.isAnimationCached()
                ? this._curFrame
                  ? this._curFrame.model
                  : null
                : this._instance.updateRenderData();
            }
            _flushAssembler() {
              const e = t.Assembler.getAssembler(this);
              this._assembler !== e && (this._assembler = e),
                this._skeleton &&
                  this._assembler &&
                  ((this._renderData = this._assembler.createData(this)),
                  this.markForUpdateRenderData(),
                  this._updateColor());
            }
            _render(t) {
              let e = 0;
              if (this.renderData && this._drawList.length > 0) {
                const i = this.renderData,
                  s = i.chunk,
                  n = s.vertexAccessor,
                  r = i.getMeshBuffer(),
                  a = r.indexOffset;
                for (let i = 0; i < this._drawList.length; i++) {
                  const s = this._drawList.data[i];
                  s.texture &&
                    t.commitMiddleware(
                      this,
                      r,
                      a + s.indexOffset,
                      s.indexCount,
                      s.texture,
                      s.material,
                      this._enableBatch
                    ),
                    (e += s.indexCount);
                }
                const o = i.indices.subarray(0, e);
                n.appendIndices(s.bufferId, o),
                  n.getMeshBuffer(s.bufferId).setDirty();
              }
            }
            requestDrawData(t, e, i, s) {
              const n = this._drawList.add();
              if (((n.material = t), e < 1e4)) n.texture = this._textures[e];
              else {
                var r;
                const t =
                  null === (r = this._slotTextures) || void 0 === r
                    ? void 0
                    : r.get(e);
                t && (n.texture = t);
              }
              return (n.indexOffset = i), (n.indexCount = s), n;
            }
            _updateBuiltinMaterial() {
              return Pv.get("default-spine-material");
            }
            updateMaterial() {
              let t;
              (t = this._customMaterial
                ? this._customMaterial
                : this._updateBuiltinMaterial()),
                this.setSharedMaterial(t, 0),
                this._cleanMaterialCache();
            }
            getMaterialTemplate() {
              return null !== this.customMaterial
                ? this.customMaterial
                : (this.material || this.updateMaterial(), this.material);
            }
            _cleanMaterialCache() {
              for (const t in this._materialCache)
                this._materialCache[t].destroy();
              this._materialCache = {};
            }
            getMaterialForBlendAndTint(t, e, i) {
              const s = `${i}/${t}/${e}`;
              let n = this._materialCache[s];
              if (n) return n;
              const r = this.getMaterialTemplate();
              (n = new OI({ parent: r, subModelIdx: 0, owner: this })),
                (this._materialCache[s] = n),
                n.overridePipelineStates({
                  blendState: {
                    blendColor: Qi.WHITE,
                    targets: [
                      {
                        blendEq: Nc.ADD,
                        blendAlphaEq: Nc.ADD,
                        blendSrc: t,
                        blendDst: e,
                        blendSrcAlpha: t,
                        blendDstAlpha: e,
                      },
                    ],
                  },
                });
              let a = !1;
              i === cct.TWO_COLORED && (a = !0);
              const o = !this._enableBatch;
              return n.recompileShaders({ TWO_COLORED: a, USE_LOCAL: o }), n;
            }
            _updateAnimEnum() {
              let t;
              (t = this.skeletonData ? this.skeletonData.getAnimsEnum() : lct),
                (this._enumAnimations = ce({})),
                Object.assign(this._enumAnimations, t),
                ce.update(this._enumAnimations),
                Je(this, "_animationIndex", this._enumAnimations);
            }
            _updateSkinEnum() {
              let t;
              (t = this.skeletonData ? this.skeletonData.getSkinsEnum() : hct),
                (this._enumSkins = ce({})),
                Object.assign(this._enumSkins, t),
                ce.update(this._enumSkins),
                Je(this, "_defaultSkinIndex", this._enumSkins);
            }
            _refreshInspector() {}
            destroyRenderData() {
              this._drawList.reset(), super.destroyRenderData();
            }
            createRenderEntity() {
              const t = new oI(tI.DYNAMIC);
              return t.setUseLocal(!0), t;
            }
            markForUpdateRenderData(t = !0) {
              super.markForUpdateRenderData(t),
                this._debugRenderer &&
                  this._debugRenderer.markForUpdateRenderData(t);
            }
            syncAttachedNode() {
              this.attachUtil._syncAttachedNode();
            }
            isAnimationCached() {
              return this._cacheMode !== oct.REALTIME;
            }
            setAnimationCacheMode(t) {
              this._preCacheMode !== t &&
                ((this._cacheMode = t),
                (this._preCacheMode = t),
                this._instance &&
                  (this._instance.isCache = this.isAnimationCached()),
                this._updateSkeletonData(),
                this.markForUpdateRenderData());
            }
            setToSetupPose() {
              this._skeleton && this._skeleton.setToSetupPose();
            }
            setBonesToSetupPose() {
              this._skeleton && this._skeleton.setBonesToSetupPose();
            }
            setSlotsToSetupPose() {
              this._skeleton && this._skeleton.setSlotsToSetupPose();
            }
            invalidAnimationCache() {
              this.isAnimationCached() &&
                this._skeletonCache &&
                this._skeletonCache.invalidAnimationCache(
                  this._skeletonData.uuid
                );
            }
            findBone(t) {
              return this._skeleton ? this._skeleton.findBone(t) : null;
            }
            findSlot(t) {
              return this._skeleton ? this._skeleton.findSlot(t) : null;
            }
            setMix(t, e, i) {
              this.isAnimationCached()
                ? w("cached mode not support setMix!!!")
                : this._state && this._instance.setMix(t, e, i);
            }
            clearTracks() {
              this.isAnimationCached()
                ? w(
                    "'clearTracks' interface can not be invoked in cached mode."
                  )
                : this._state &&
                  (this._state.clearTracks(), this.setToSetupPose());
            }
            clearTrack(t) {
              this.isAnimationCached()
                ? w("'clearTrack' interface can not be invoked in cached mode.")
                : this._state && this._state.clearTrack(t);
            }
            updateWorldTransform() {
              this.isAnimationCached() &&
                this._skeleton &&
                this._skeleton.updateWorldTransform();
            }
            _verifySockets(t) {
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e].target;
                !i ||
                  (i.parent && i.parent === this.node) ||
                  R(
                    `Target node ${i.name} is expected to be a direct child of ${this.node.name}`
                  );
              }
              const e = new Map();
              t.forEach((t) => {
                t.target &&
                  (e.get(t.target)
                    ? R(`Target node ${t.target.name} has existed.`)
                    : e.set(t.target, !0));
              });
            }
            _updateSocketBindings() {
              if (this._skeleton) {
                this._socketNodes.clear();
                for (let t = 0, e = this._sockets.length; t < e; t++) {
                  const e = this._sockets[t];
                  if (e.path && e.target) {
                    const t = this._cachedSockets.get(e.path);
                    if (!t) {
                      R(`Skeleton data does not contain path ${e.path}`);
                      continue;
                    }
                    this._socketNodes.set(t, e.target);
                  }
                }
              }
            }
            _indexBoneSockets() {
              if (!this._skeleton) return;
              this._cachedSockets.clear();
              const t = this._skeleton.bones,
                e = (i) =>
                  null == i.parent
                    ? i.data.name || "<Unamed>"
                    : `${e(t[i.parent.data.index])}/${i.data.name}`;
              for (let i = 0, s = t.length; i < s; i++) {
                const s = t[i].data,
                  n = e(t[i]);
                this._cachedSockets.set(n, s.index);
              }
            }
            querySockets() {
              return this._skeleton
                ? (0 === this._cachedSockets.size && this._indexBoneSockets(),
                  this._cachedSockets.size > 0
                    ? Array.from(this._cachedSockets.keys()).sort()
                    : [])
                : [];
            }
            _updateUseTint() {
              this._cleanMaterialCache(),
                this.destroyRenderData(),
                this._assembler &&
                  this._skeleton &&
                  ((this._renderData = this._assembler.createData(this)),
                  this.markForUpdateRenderData());
            }
            _updateBatch() {
              this._cleanMaterialCache(), this.markForUpdateRenderData();
            }
            _updateDebugDraw() {
              if (this.debugBones || this.debugSlots || this.debugMesh) {
                if (!this._debugRenderer) {
                  const t = new Pf("DEBUG_DRAW_NODE");
                  (t.layer = this.node.layer),
                    (t.hideFlags |=
                      $n.Flags.DontSave | $n.Flags.HideInHierarchy);
                  const e = t.addComponent(ED);
                  (e.lineWidth = 5),
                    (e.strokeColor = new Qi(255, 0, 0, 255)),
                    (this._debugRenderer = e),
                    (t.parent = this.node),
                    this.node.on(bf.LAYER_CHANGED, this._applyLayer, this);
                }
                this.isAnimationCached() &&
                  w("Debug bones or slots is invalid in cached mode");
              } else
                this._debugRenderer &&
                  (this.node.off(bf.LAYER_CHANGED, this._applyLayer, this),
                  this._debugRenderer.node.destroy(),
                  (this._debugRenderer = null),
                  this.isAnimationCached() ||
                    (this._instance && this._instance.setDebugMode(!1)));
            }
            _updateUITransform() {
              const t = this.node._uiProps.uiTransformComp,
                e = this._runtimeData;
              if (!e)
                return (
                  t.setContentSize(100, 100),
                  (t.anchorX = 0.5),
                  void (t.anchorX = 0.5)
                );
              const i = e.width,
                s = e.height;
              i &&
                s &&
                (t.setContentSize(i, s),
                0 !== i && (t.anchorX = Math.abs(e.x) / i),
                0 !== s && (t.anchorY = Math.abs(e.y) / s));
            }
            _updateColor() {
              const t = this.node._uiProps.opacity;
              if (
                this._tempColor.r === this._color.r &&
                this._tempColor.g === this._color.g &&
                this._tempColor.b === this._color.b &&
                this._tempColor.a === t
              )
                return;
              (this.node._uiProps.colorDirty = !0),
                (this._tempColor.r = this._color.r),
                (this._tempColor.g = this._color.g),
                (this._tempColor.b = this._color.b),
                (this._tempColor.a = t);
              const e = this._color.r / 255,
                i = this._color.g / 255,
                s = this._color.b / 255;
              this._instance.setColor(e, i, s, t);
            }
            setVertexEffectDelegate(t) {
              if (!this._instance) return;
              if (!t) return void this._instance.clearEffect();
              const e = null == t ? void 0 : t.getEffectType();
              if ("jitter" === e) {
                const e = null == t ? void 0 : t.getJitterVertexEffect();
                this._instance.setJitterEffect(e);
              } else if ("swirl" === e) {
                const e = null == t ? void 0 : t.getJitterVertexEffect();
                this._instance.setSwirlEffect(e);
              }
            }
            _ensureListener() {
              this._listener ||
                ((this._listener = new hlt()),
                (this._eventListenerID = hlt.addListener(this._listener)),
                this._instance.setListener(this._eventListenerID));
            }
            setStartListener(t) {
              this._ensureListener(), (this._listener.start = t);
            }
            setInterruptListener(t) {
              this._ensureListener(), (this._listener.interrupt = t);
            }
            setEndListener(t) {
              this._ensureListener(), (this._listener.end = t);
            }
            setDisposeListener(t) {
              this._ensureListener(), (this._listener.dispose = t);
            }
            setCompleteListener(t) {
              this._ensureListener(), (this._listener.complete = t);
            }
            setEventListener(t) {
              this._ensureListener(), (this._listener.event = t);
            }
            setTrackStartListener(t, e) {
              hlt.getListeners(t, this._instance).start = e;
            }
            setTrackInterruptListener(t, e) {
              hlt.getListeners(t, this._instance).interrupt = e;
            }
            setTrackEndListener(t, e) {
              hlt.getListeners(t, this._instance).end = e;
            }
            setTrackDisposeListener(t, e) {
              hlt.getListeners(t, this._instance).dispose = e;
            }
            setTrackCompleteListener(t, e) {
              hlt.getListeners(t, this._instance).complete = (t) => {
                const i = Math.floor(t.trackTime / t.animationEnd);
                e(t, i);
              };
            }
            setTrackEventListener(t, e) {
              hlt.getListeners(t, this._instance).event = e;
            }
            getDebugShapes() {
              return this._instance.getDebugShapes();
            }
            setSlotTexture(t, e, i) {
              if (this.isAnimationCached())
                return void R("Cached mode can't change texture of slot");
              if (!this.findSlot(t)) return void R(`No slot named:${t}`);
              const s = e.width,
                n = e.height,
                r = i || !1;
              this._instance.resizeSlotRegion(t, s, n, r),
                this._slotTextures || (this._slotTextures = new Map());
              let a = 0;
              this._slotTextures.forEach((t, i) => {
                t === e && (a = i);
              }),
                0 === a && ((a = ++uct), this._slotTextures.set(a, e)),
                this._instance.setSlotTexture(t, a);
            }
            _destroySkeletonInfo(t) {
              t &&
                this._skeletonInfo &&
                (t.destroySkeleton(this._skeletonInfo.assetUUID),
                (this._skeletonInfo = null));
            }
            _applyLayer() {
              this._debugRenderer &&
                (this._debugRenderer.node.layer = this.node.layer);
            }
          }).SpineSocket = _ct),
          (act.AnimationCacheMode = oct),
          (Xlt = fa((Wlt = act).prototype, "_skeletonData", [Na], function () {
            return null;
          })),
          (Ylt = fa(Wlt.prototype, "defaultSkin", [Na], function () {
            return "";
          })),
          (Klt = fa(Wlt.prototype, "defaultAnimation", [Na], function () {
            return "";
          })),
          (qlt = fa(Wlt.prototype, "_premultipliedAlpha", [Na], function () {
            return !0;
          })),
          ($lt = fa(Wlt.prototype, "_timeScale", [Na], function () {
            return 1;
          })),
          (Zlt = fa(Wlt.prototype, "_preCacheMode", [Na], function () {
            return oct.UNSET;
          })),
          (Qlt = fa(Wlt.prototype, "_cacheMode", [Na], function () {
            return oct.REALTIME;
          })),
          (Jlt = fa(Wlt.prototype, "_sockets", [Na], function () {
            return [];
          })),
          (tct = fa(Wlt.prototype, "_useTint", [Na], function () {
            return !1;
          })),
          (ect = fa(Wlt.prototype, "_debugMesh", [Na], function () {
            return !1;
          })),
          (ict = fa(Wlt.prototype, "_debugBones", [Na], function () {
            return !1;
          })),
          (sct = fa(Wlt.prototype, "_debugSlots", [Na], function () {
            return !1;
          })),
          (nct = fa(Wlt.prototype, "_enableBatch", [Na], function () {
            return !1;
          })),
          s(
            Wlt.prototype,
            "skeletonData",
            [Ult],
            Object.getOwnPropertyDescriptor(Wlt.prototype, "skeletonData"),
            Wlt.prototype
          ),
          s(
            Wlt.prototype,
            "_defaultSkinIndex",
            [klt],
            Object.getOwnPropertyDescriptor(Wlt.prototype, "_defaultSkinIndex"),
            Wlt.prototype
          ),
          s(
            Wlt.prototype,
            "_animationIndex",
            [zlt],
            Object.getOwnPropertyDescriptor(Wlt.prototype, "_animationIndex"),
            Wlt.prototype
          ),
          s(
            Wlt.prototype,
            "defaultCacheMode",
            [Hlt],
            Object.getOwnPropertyDescriptor(Wlt.prototype, "defaultCacheMode"),
            Wlt.prototype
          ),
          (rct = fa(Wlt.prototype, "loop", [Na], function () {
            return !0;
          })),
          s(
            Wlt.prototype,
            "sockets",
            [Glt],
            Object.getOwnPropertyDescriptor(Wlt.prototype, "sockets"),
            Wlt.prototype
          ),
          s(
            Wlt.prototype,
            "customMaterial",
            [oo, Vlt],
            Object.getOwnPropertyDescriptor(Wlt.prototype, "customMaterial"),
            Wlt.prototype
          ),
          (jlt = Wlt))
        ) || jlt);
      a.internal.SpineSkeleton = dct;
      const pct = new Qi(0, 0, 255, 255),
        mct = new Qi(255, 0, 0, 255),
        fct = new Qi(0, 255, 0, 255),
        gct = new Qi(255, 255, 0, 255);
      let yct,
        Tct,
        Sct,
        Ect,
        vct = null,
        bct = null,
        Act = !1,
        Cct = !1;
      const Oct = UO(NO),
        Ict = UO(BO),
        wct = new Yi(0, 0, 0);
      function Rct(t, e) {
        let i, s;
        switch (t) {
          case 1:
            (i = Act ? Pc.ONE : Pc.SRC_ALPHA), (s = Pc.ONE);
            break;
          case 2:
            (i = Pc.DST_COLOR), (s = Pc.ONE_MINUS_SRC_ALPHA);
            break;
          case 3:
            (i = Pc.ONE), (s = Pc.ONE_MINUS_SRC_COLOR);
            break;
          case 0:
          default:
            (i = Act ? Pc.ONE : Pc.SRC_ALPHA), (s = Pc.ONE_MINUS_SRC_ALPHA);
        }
        return e.getMaterialForBlendAndTint(
          i,
          s,
          Cct ? cct.TWO_COLORED : cct.COLORED_TEXTURED
        );
      }
      const Dct = {
        vCount: 32767,
        ensureAccessor(t) {
          let e = t ? bct : vct;
          if (!e) {
            const i = Lv.root.device,
              s = Lv.root.batcher2D,
              n = t ? BO : NO;
            t
              ? ((e = bct = new YO(i, n, this.vCount)),
                s.registerBufferAccessor(Number.parseInt("SPINETINT", 36), bct))
              : ((e = vct = new YO(i, n, this.vCount)),
                s.registerBufferAccessor(Number.parseInt("SPINE", 36), vct));
          }
          return e;
        },
        createData(t) {
          let e = t.renderData;
          if (!e) {
            const i = t.useTint || t.isAnimationCached(),
              s = this.ensureAccessor(i);
            e = cI.add(i ? BO : NO, s);
          }
          return e;
        },
        updateRenderData(t, e) {
          var i;
          t._skeleton &&
            t.node.active &&
            null !== (i = t.skeletonData) &&
            void 0 !== i &&
            i.isValid &&
            (function (t) {
              if ((t.drawList.reset(), 0 === t.color.a)) return;
              t._updateColor(),
                (Act = t.premultipliedAlpha),
                (Cct = t.useTint || t.isAnimationCached()),
                t.isAnimationCached()
                  ? (function (t) {
                      const e = t.updateRenderData();
                      if (!e) return;
                      const i = e.vCount,
                        s = e.iCount;
                      if (i < 1 || s < 1) return;
                      const n = t.renderData;
                      (n.vertexCount === i && n.indexCount === s) ||
                        (n.resize(i, s), (n.indices = new Uint16Array(s)));
                      const r = n.chunk.vb,
                        a = new Uint8Array(
                          r.buffer,
                          r.byteOffset,
                          Float32Array.BYTES_PER_ELEMENT * r.length
                        );
                      a.set(e.vData);
                      const o = t.color,
                        h = t.node._uiProps.opacity;
                      if (1 - h > gi || 4294967295 !== Qi.toUint32(o) || Act) {
                        (yct = o.r / 255),
                          (Tct = o.g / 255),
                          (Sct = o.b / 255),
                          (Ect = h);
                        for (let t = 0; t < i; t++) {
                          const e =
                              t * Ict + 5 * Float32Array.BYTES_PER_ELEMENT,
                            i = a[e],
                            s = a[e + 1],
                            n = a[e + 2],
                            r = a[e + 3] * Ect,
                            o = Act ? r / 255 : 1;
                          (a[e] = Math.floor(o * i * yct)),
                            (a[e + 1] = Math.floor(o * s * Tct)),
                            (a[e + 2] = Math.floor(o * n * Sct)),
                            (a[e + 3] = Math.floor(r)),
                            (a[e + 4] = Math.floor(a[e + 4] * yct)),
                            (a[e + 5] = Math.floor(a[e + 5] * Tct)),
                            (a[e + 6] = Math.floor(a[e + 6] * Sct)),
                            (a[e + 7] = Act ? 255 : 0);
                        }
                      }
                      const l = n.indices;
                      l.set(e.iData);
                      const c = n.chunk.vertexOffset;
                      for (let t = 0; t < s; t++) l[t] += c;
                      const u = e.meshes,
                        _ = u.length;
                      let d = 0,
                        p = 0;
                      for (let e = 0; e < _; e++) {
                        const i = u[e],
                          s = Rct(i.blendMode, t),
                          n = i.textureID;
                        (p = i.iCount), t.requestDrawData(s, n, d, p), (d += p);
                      }
                      const m = Ict / Float32Array.BYTES_PER_ELEMENT;
                      if (t.enableBatch) {
                        const e = t.node.worldMatrix;
                        let s = 0;
                        for (let t = 0; t < i; t++)
                          (s = t * m),
                            (wct.x = r[s]),
                            (wct.y = r[s + 1]),
                            (wct.z = 0),
                            wct.transformMat4(e),
                            (r[s] = wct.x),
                            (r[s + 1] = wct.y),
                            (r[s + 2] = wct.z);
                      }
                    })(t)
                  : (function (t) {
                      var e, i;
                      const s =
                          (t.useTint ? Ict : Oct) /
                          Float32Array.BYTES_PER_ELEMENT,
                        n = t.updateRenderData(),
                        r = n.vCount,
                        a = n.iCount;
                      if (r < 1 || a < 1) return;
                      const o = t.renderData;
                      (o.vertexCount === r && o.indexCount === a) ||
                        (o.resize(r, a),
                        (o.indices = new Uint16Array(a)),
                        (t._vLength = r * Float32Array.BYTES_PER_ELEMENT * s),
                        (t._vBuffer = new Uint8Array(
                          o.chunk.vb.buffer,
                          o.chunk.vb.byteOffset,
                          Float32Array.BYTES_PER_ELEMENT * o.chunk.vb.length
                        )),
                        (t._iLength = Uint16Array.BYTES_PER_ELEMENT * a),
                        (t._iBuffer = new Uint8Array(o.indices.buffer)));
                      const h = o.chunk.vb,
                        l = n.vPtr,
                        c = n.iPtr,
                        u = o.indices,
                        _ = rlt.wasmUtil.wasm.HEAPU8;
                      null === (e = t._vBuffer) ||
                        void 0 === e ||
                        e.set(_.subarray(l, l + t._vLength), 0),
                        null === (i = t._iBuffer) ||
                          void 0 === i ||
                          i.set(_.subarray(c, c + t._iLength), 0);
                      const d = o.chunk.vertexOffset;
                      for (let t = 0; t < a; t++) u[t] += d;
                      const p = n.getData(),
                        m = p.size();
                      let f = 0,
                        g = 0;
                      for (let e = 0; e < m; e += 6) {
                        g = p.get(e + 3);
                        const i = Rct(p.get(e + 4), t),
                          s = p.get(e + 5);
                        t.requestDrawData(i, s, f, g), (f += g);
                      }
                      if (t.enableBatch) {
                        const e = t.node.worldMatrix;
                        let i = 0;
                        for (let t = 0; t < r; t++)
                          (i = t * s),
                            (wct.x = h[i]),
                            (wct.y = h[i + 1]),
                            (wct.z = 0),
                            wct.transformMat4(e),
                            (h[i] = wct.x),
                            (h[i + 1] = wct.y),
                            (h[i + 2] = wct.z);
                      }
                      const y = t._debugRenderer,
                        T = t._skeleton;
                      if (y && (t.debugBones || t.debugSlots || t.debugMesh)) {
                        y.clear();
                        const e = t.getDebugShapes(),
                          i = e.size();
                        for (let n = 0; n < i; n++) {
                          const i = e.get(n);
                          if (0 === i.type && t.debugSlots) {
                            y.strokeColor = pct;
                            const t = i.vOffset * s,
                              e = i.vCount * s;
                            y.moveTo(h[t], h[t + 1]);
                            for (let i = t + s, n = t + e; i < n; i += s)
                              y.lineTo(h[i], h[i + 1]);
                            y.close(), y.stroke();
                          } else if (1 === i.type && t.debugMesh) {
                            y.strokeColor = gct;
                            const t = i.iCount,
                              e = i.iOffset;
                            for (let i = e, n = e + t; i < n; i += 3) {
                              const t = u[i] * s,
                                e = u[i + 1] * s,
                                n = u[i + 2] * s;
                              y.moveTo(h[t], h[t + 1]),
                                y.lineTo(h[e], h[e + 1]),
                                y.lineTo(h[n], h[n + 1]),
                                y.close(),
                                y.stroke();
                            }
                          }
                        }
                        if (t.debugBones) {
                          (y.strokeColor = mct), (y.fillColor = pct);
                          for (let t = 0, e = T.bones.length; t < e; t++) {
                            const e = T.bones[t],
                              i = e.data.length * e.a + e.worldX,
                              s = e.data.length * e.c + e.worldY;
                            y.moveTo(e.worldX, e.worldY),
                              y.lineTo(i, s),
                              y.stroke(),
                              y.circle(e.worldX, e.worldY, 1.5 * Math.PI),
                              y.fill(),
                              0 === t && (y.fillColor = fct);
                          }
                        }
                      }
                    })(t);
              const e = t.renderData,
                i = Cct ? bct : vct;
              t.syncAttachedNode(),
                (e.vertexCount > 0 || e.indexCount > 0) &&
                  i.getMeshBuffer(e.chunk.bufferId).setDirty();
            })(t);
        },
      };
      a.internal.SpineAssembler = Dct;
      const xct = { getAssembler: () => Dct };
      dct.Assembler = xct;
      const Mct = globalThis.spine;
      Mct.EventType = rlt.EventType;
      const Pct = Mct.VertexEffectDelegate;
      let Nct, Lct, Bct, Fct, Uct, kct, zct, Hct, Gct;
      !(function (t) {
        (t[(t.REGION = 0)] = "REGION"),
          (t[(t.BOUNDING_BOX = 1)] = "BOUNDING_BOX"),
          (t[(t.MESH = 2)] = "MESH"),
          (t[(t.SKINNED_MESH = 3)] = "SKINNED_MESH");
      })(Nct || (Nct = {})),
        de(Nct),
        (function (t) {
          (t[(t.START = 0)] = "START"),
            (t[(t.INTERRUPT = 1)] = "INTERRUPT"),
            (t[(t.END = 2)] = "END"),
            (t[(t.DISPOSE = 3)] = "DISPOSE"),
            (t[(t.COMPLETE = 4)] = "COMPLETE"),
            (t[(t.EVENT = 5)] = "EVENT");
        })(Lct || (Lct = {})),
        de(Lct),
        (a.internal.SpineAnimationEventType = Lct),
        t(
          "sp",
          Object.freeze({
            __proto__: null,
            timeScale: 1,
            get AnimationCacheMode() {
              return oct;
            },
            get DefaultSkinsEnum() {
              return hct;
            },
            get DefaultAnimsEnum() {
              return lct;
            },
            get SpineMaterialType() {
              return cct;
            },
            SpineSocket: _ct,
            Skeleton: dct,
            SkeletonData: Ilt,
            simpleSpineAssembler: xct,
            spine: Mct,
            VertexEffectDelegate: Pct,
            get ATTACHMENT_TYPE() {
              return Nct;
            },
            get AnimationEventType() {
              return Lct;
            },
          })
        ),
        (function (t) {
          (t[(t.ORTHO = 0)] = "ORTHO"),
            (t[(t.HEX = 1)] = "HEX"),
            (t[(t.ISO = 2)] = "ISO");
        })(Bct || (Bct = {})),
        de(Bct),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.MAP = 1)] = "MAP"),
            (t[(t.LAYER = 2)] = "LAYER"),
            (t[(t.OBJECTGROUP = 3)] = "OBJECTGROUP"),
            (t[(t.OBJECT = 4)] = "OBJECT"),
            (t[(t.TILE = 5)] = "TILE");
        })(Fct || (Fct = {})),
        de(Fct),
        (function (t) {
          (t[(t.HORIZONTAL = 2147483648)] = "HORIZONTAL"),
            (t[(t.VERTICAL = 1073741824)] = "VERTICAL"),
            (t[(t.DIAGONAL = 536870912)] = "DIAGONAL"),
            (t[(t.FLIPPED_ALL = 4026531840)] = "FLIPPED_ALL"),
            (t[(t.FLIPPED_MASK = 268435455)] = "FLIPPED_MASK");
        })(Uct || (Uct = {})),
        de(Uct),
        (function (t) {
          (t[(t.STAGGERAXIS_X = 0)] = "STAGGERAXIS_X"),
            (t[(t.STAGGERAXIS_Y = 1)] = "STAGGERAXIS_Y");
        })(kct || (kct = {})),
        de(kct),
        (function (t) {
          (t[(t.STAGGERINDEX_ODD = 0)] = "STAGGERINDEX_ODD"),
            (t[(t.STAGGERINDEX_EVEN = 1)] = "STAGGERINDEX_EVEN");
        })(zct || (zct = {})),
        de(zct),
        (function (t) {
          (t[(t.RightDown = 0)] = "RightDown"),
            (t[(t.RightUp = 1)] = "RightUp"),
            (t[(t.LeftDown = 2)] = "LeftDown"),
            (t[(t.LeftUp = 3)] = "LeftUp");
        })(Hct || (Hct = {})),
        de(Hct),
        (function (t) {
          (t[(t.RECT = 0)] = "RECT"),
            (t[(t.ELLIPSE = 1)] = "ELLIPSE"),
            (t[(t.POLYGON = 2)] = "POLYGON"),
            (t[(t.POLYLINE = 3)] = "POLYLINE"),
            (t[(t.IMAGE = 4)] = "IMAGE"),
            (t[(t.TEXT = 5)] = "TEXT");
        })(Gct || (Gct = {})),
        de(Gct);
      class Vct {
        constructor() {
          (this.name = ""),
            (this.firstGid = 0),
            (this.spacing = 0),
            (this.margin = 0),
            (this.sourceImage = void 0),
            (this.imageName = null),
            (this.imageOffset = null),
            (this.imageSize = new ws(0, 0)),
            (this.tileOffset = new Ss(0, 0)),
            (this._tileSize = new ws(0, 0)),
            (this.collection = !1);
        }
        rectForGID(t, e) {
          const i = e || new Ds(0, 0, 0, 0);
          (i.width = this._tileSize.width), (i.height = this._tileSize.height);
          let s = t;
          if (((s &= Uct.FLIPPED_MASK), (s -= this.firstGid), this.imageOffset))
            (i.x = this.imageOffset.x), (i.y = this.imageOffset.y);
          else {
            const t = Math.floor(
              (this.imageSize.width - 2 * this.margin + this.spacing) /
                (this._tileSize.width + this.spacing)
            );
            (i.x = Math.round(
              (s % t) * (this._tileSize.width + this.spacing) + this.margin
            )),
              (i.y = Math.round(
                Math.floor(s / t) * (this._tileSize.height + this.spacing) +
                  this.margin
              ));
          }
          return i;
        }
      }
      class jct {
        constructor() {
          (this.properties = {}),
            (this.name = ""),
            (this.objects = []),
            (this.visible = !0),
            (this.opacity = 0),
            (this.color = new Qi(255, 255, 255, 255)),
            (this.offset = new Ss(0, 0)),
            (this.draworder = "topdown"),
            (this.tintColor = null);
        }
        getProperties() {
          return this.properties;
        }
        setProperties(t) {
          this.properties = t;
        }
      }
      class Wct {
        constructor() {
          (this.properties = {}),
            (this.name = ""),
            (this.layerSize = null),
            (this.tiles = []),
            (this.visible = !0),
            (this.opacity = 0),
            (this.ownTiles = !0),
            (this.minGID = 1e5),
            (this.maxGID = 0),
            (this.offset = new Ss(0, 0)),
            (this.tintColor = null);
        }
        getProperties() {
          return this.properties;
        }
        setProperties(t) {
          this.properties = t;
        }
      }
      (Wct.ATTRIB_NONE = 1),
        (Wct.ATTRIB_BASE64 = 2),
        (Wct.ATTRIB_GZIP = 4),
        (Wct.ATTRIB_ZLIB = 8);
      class Xct {
        constructor() {
          (this.name = ""),
            (this.visible = !0),
            (this.width = 0),
            (this.height = 0),
            (this.offset = new Ss(0, 0)),
            (this.opacity = 0),
            (this.trans = new Qi(255, 255, 255, 255)),
            (this.sourceImage = void 0),
            (this.tintColor = null);
        }
      }
      function Yct(t) {
        const e = Ww.HorizontalAlign;
        switch (t) {
          case "center":
            return e.CENTER;
          case "right":
            return e.RIGHT;
          default:
            return e.LEFT;
        }
      }
      function Kct(t) {
        const e = Ww.VerticalAlign;
        switch (t) {
          case "center":
            return e.CENTER;
          case "bottom":
            return e.BOTTOM;
          default:
            return e.TOP;
        }
      }
      function qct(t) {
        if (!t) return new Qi(0, 0, 0, 255);
        if (8 === (t = -1 !== t.indexOf("#") ? t.substring(1) : t).length) {
          const e = parseInt(t.substr(0, 2), 16) || 255,
            i = parseInt(t.substr(2, 2), 16) || 0,
            s = parseInt(t.substr(4, 2), 16) || 0,
            n = parseInt(t.substr(6, 2), 16) || 0;
          return new Qi(i, s, n, e);
        }
        {
          const e = parseInt(t.substr(0, 2), 16) || 0,
            i = parseInt(t.substr(2, 2), 16) || 0,
            s = parseInt(t.substr(4, 2), 16) || 0;
          return new Qi(e, i, s, 255);
        }
      }
      function $ct(t, e) {
        const i = [],
          s = t.getElementsByTagName("properties");
        for (let t = 0; t < s.length; ++t) {
          const e = s[t].getElementsByTagName("property");
          for (let t = 0; t < e.length; ++t) i.push(e[t]);
        }
        e = e || {};
        for (let t = 0; t < i.length; t++) {
          const s = i[t],
            n = s.getAttribute("name"),
            r = s.getAttribute("type") || "string";
          let a = s.getAttribute("value");
          "int" === r
            ? (a = parseInt(a))
            : "float" === r
            ? (a = parseFloat(a))
            : "bool" === r
            ? (a = "true" === a)
            : "color" === r && (a = qct(a)),
            (e[n] = a);
        }
        return e;
      }
      class Zct {
        get mapSize() {
          return this._mapSize;
        }
        get tileSize() {
          return this._tileSize;
        }
        constructor(t, e, i, s, n) {
          (this.properties = {}),
            (this.orientation = null),
            (this.parentElement = null),
            (this.parentGID = 0),
            (this.layerAttrs = 0),
            (this.storingCharacters = !1),
            (this.currentString = null),
            (this.renderOrder = Hct.RightDown),
            (this._supportVersion = [1, 4, 0]),
            (this._objectGroups = []),
            (this._allChildren = []),
            (this._mapSize = new ws(0, 0)),
            (this._tileSize = new ws(0, 0)),
            (this._layers = []),
            (this._tilesets = []),
            (this._imageLayers = []),
            (this._tileProperties = new Map()),
            (this._tileAnimations = {}),
            (this._tsxContentMap = null),
            (this._spriteFrameMap = null),
            (this._spfSizeMap = {}),
            (this._staggerAxis = null),
            (this._staggerIndex = null),
            (this._hexSideLength = 0),
            (this._imageLayerSPF = null),
            this.initWithXML(t, e, i, s, n);
        }
        getOrientation() {
          return this.orientation;
        }
        setOrientation(t) {
          this.orientation = t;
        }
        getStaggerAxis() {
          return this._staggerAxis;
        }
        setStaggerAxis(t) {
          this._staggerAxis = t;
        }
        getStaggerIndex() {
          return this._staggerIndex;
        }
        setStaggerIndex(t) {
          this._staggerIndex = t;
        }
        getHexSideLength() {
          return this._hexSideLength;
        }
        setHexSideLength(t) {
          this._hexSideLength = t;
        }
        getMapSize() {
          return new ws(this._mapSize.width, this._mapSize.height);
        }
        setMapSize(t) {
          (this._mapSize.width = t.width), (this._mapSize.height = t.height);
        }
        get mapWidth() {
          return this._mapSize.width;
        }
        set mapWidth(t) {
          this._mapSize.width = t;
        }
        get mapHeight() {
          return this._mapSize.height;
        }
        set mapHeight(t) {
          this._mapSize.height = t;
        }
        getTileSize() {
          return new ws(this._tileSize.width, this._tileSize.height);
        }
        setTileSize(t) {
          (this._tileSize.width = t.width), (this._tileSize.height = t.height);
        }
        get tileWidth() {
          return this._tileSize.width;
        }
        set tileWidth(t) {
          this._tileSize.width = t;
        }
        get tileHeight() {
          return this._tileSize.height;
        }
        set tileHeight(t) {
          this._tileSize.height = t;
        }
        getLayers() {
          return this._layers;
        }
        setLayers(t) {
          this._allChildren.push(t), this._layers.push(t);
        }
        getImageLayers() {
          return this._imageLayers;
        }
        setImageLayers(t) {
          this._allChildren.push(t), this._imageLayers.push(t);
        }
        getTilesets() {
          return this._tilesets;
        }
        setTilesets(t) {
          this._tilesets.push(t);
        }
        getObjectGroups() {
          return this._objectGroups;
        }
        setObjectGroups(t) {
          this._allChildren.push(t), this._objectGroups.push(t);
        }
        getAllChildren() {
          return this._allChildren;
        }
        getParentElement() {
          return this.parentElement;
        }
        setParentElement(t) {
          this.parentElement = t;
        }
        getParentGID() {
          return this.parentGID;
        }
        setParentGID(t) {
          this.parentGID = t;
        }
        getLayerAttribs() {
          return this.layerAttrs;
        }
        setLayerAttribs(t) {
          this.layerAttrs = t;
        }
        getStoringCharacters() {
          return this.storingCharacters;
        }
        setStoringCharacters(t) {
          this.storingCharacters = t;
        }
        getProperties() {
          return this.properties;
        }
        setProperties(t) {
          this.properties = t;
        }
        initWithXML(t, e, i, s, n) {
          return (
            (this._tilesets.length = 0),
            (this._layers.length = 0),
            (this._imageLayers.length = 0),
            (this._tsxContentMap = e),
            (this._spriteFrameMap = i),
            (this._imageLayerSPF = n),
            (this._spfSizeMap = s),
            (this._objectGroups.length = 0),
            (this._allChildren.length = 0),
            (this.properties = {}),
            (this._tileProperties = new Map()),
            (this._tileAnimations = new Map()),
            (this.currentString = ""),
            (this.storingCharacters = !1),
            (this.layerAttrs = Wct.ATTRIB_NONE),
            (this.parentElement = null),
            this.parseXMLString(t)
          );
        }
        parseXMLString(t, e) {
          let i;
          const s = new rv().parse(t).documentElement,
            n = s.getAttribute("orientation"),
            r = s.getAttribute("staggeraxis"),
            a = s.getAttribute("staggerindex"),
            o = s.getAttribute("hexsidelength"),
            h = s.getAttribute("renderorder"),
            l = s.getAttribute("version") || "1.0.0";
          if ("map" === s.nodeName) {
            const t = l.split("."),
              e = this._supportVersion;
            for (i = 0; i < e.length; i++) {
              const s = parseInt(t[i]) || 0;
              if (e[i] < s) {
                B(7216, l);
                break;
              }
            }
            "orthogonal" === n
              ? (this.orientation = Bct.ORTHO)
              : "isometric" === n
              ? (this.orientation = Bct.ISO)
              : "hexagonal" === n
              ? (this.orientation = Bct.HEX)
              : null !== n && B(7217, n),
              (this.renderOrder =
                "right-up" === h
                  ? Hct.RightUp
                  : "left-up" === h
                  ? Hct.LeftUp
                  : "left-down" === h
                  ? Hct.LeftDown
                  : Hct.RightDown),
              "x" === r
                ? this.setStaggerAxis(kct.STAGGERAXIS_X)
                : "y" === r && this.setStaggerAxis(kct.STAGGERAXIS_Y),
              "odd" === a
                ? this.setStaggerIndex(zct.STAGGERINDEX_ODD)
                : "even" === a && this.setStaggerIndex(zct.STAGGERINDEX_EVEN),
              o && this.setHexSideLength(parseFloat(o));
            let c = new ws(0, 0);
            (c.width = parseFloat(s.getAttribute("width"))),
              (c.height = parseFloat(s.getAttribute("height"))),
              this.setMapSize(c),
              (c = new ws(0, 0)),
              (c.width = parseFloat(s.getAttribute("tilewidth"))),
              (c.height = parseFloat(s.getAttribute("tileheight"))),
              this.setTileSize(c),
              (this.properties = $ct(s));
          }
          let c = s.getElementsByTagName("tileset");
          for (
            "map" !== s.nodeName && ((c = []), c.push(s)), i = 0;
            i < c.length;
            i++
          ) {
            const t = c[i],
              s = t.getAttribute("source");
            if (s) {
              const e = parseInt(t.getAttribute("firstgid")),
                i = this._tsxContentMap[s];
              i && this.parseXMLString(i, e);
            } else {
              const i = t.getElementsByTagName("image"),
                s = i.length > 1,
                n = i[0];
              let r = n.getAttribute("source");
              r = r.replace(/\\/g, "/");
              const a = t.getElementsByTagName("tile"),
                o = (a && a.length) || 1;
              let h = null;
              const l = t.getAttribute("name") || "",
                c = parseInt(t.getAttribute("spacing")) || 0,
                u = parseInt(t.getAttribute("margin")) || 0,
                _ = e || parseInt(t.getAttribute("firstgid")) || 0,
                d = new ws(0, 0);
              (d.width = parseFloat(t.getAttribute("tilewidth"))),
                (d.height = parseFloat(t.getAttribute("tileheight")));
              const p = t.getElementsByTagName("tileoffset")[0];
              let m = 0,
                f = 0;
              p &&
                ((m = parseFloat(p.getAttribute("x")) || 0),
                (f = parseFloat(p.getAttribute("y")) || 0));
              let g = null;
              for (let t = 0; t < o; t++) {
                const e = i[t] ? i[t] : n;
                if (!e) continue;
                let r = e.getAttribute("source");
                if (((r = r.replace(/\\/g, "/")), !g || s)) {
                  if (
                    ((g = new Vct()),
                    (g.name = l),
                    (g.firstGid = _ & Uct.FLIPPED_MASK),
                    (g.tileOffset.x = m),
                    (g.tileOffset.y = f),
                    (g.collection = s),
                    !s &&
                      ((g.imageName = r),
                      (g.imageSize.width =
                        parseFloat(e.getAttribute("width")) || 0),
                      (g.imageSize.height =
                        parseFloat(e.getAttribute("height")) || 0),
                      (g.sourceImage = this._spriteFrameMap[r]),
                      !g.sourceImage))
                  ) {
                    const t = Zct.getNameWithPostfix(r);
                    if (
                      ((g.imageName = t),
                      (g.sourceImage = this._spriteFrameMap[t]),
                      !g.sourceImage)
                    ) {
                      const t = Zct.getShortName(r);
                      (g.imageName = t),
                        (g.sourceImage = this._spriteFrameMap[t]),
                        g.sourceImage ||
                          (console.error(
                            `[error]: ${t} not find in [${Object.keys(
                              this._spriteFrameMap
                            ).join(", ")}]`
                          ),
                          G(7221, r),
                          console.warn(
                            `Please try asset type of ${r} to 'sprite-frame'`
                          ));
                    }
                  }
                  (g.spacing = c),
                    (g.margin = u),
                    (g._tileSize.width = d.width),
                    (g._tileSize.height = d.height),
                    this.setTilesets(g);
                }
                if (((h = a && a[t]), !h)) continue;
                this.parentGID = _ + (parseInt(h.getAttribute("id")) || 0);
                const o = h.getElementsByTagName("image");
                h.hasAttribute("x") &&
                  h.hasAttribute("y") &&
                  (g.imageOffset = new Ss(
                    parseFloat(h.getAttribute("x")) || 0,
                    parseFloat(h.getAttribute("y")) || 0
                  ));
                const p = h.hasAttribute("width") && h.hasAttribute("height");
                if (
                  (p &&
                    ((g._tileSize.width =
                      parseFloat(h.getAttribute("width")) || 0),
                    (g._tileSize.height =
                      parseFloat(h.getAttribute("height")) || 0)),
                  o && o.length > 0)
                ) {
                  const t = o[0];
                  let e = t.getAttribute("source");
                  if (
                    ((e = e.replace(/\\/g, "/")),
                    (g.imageName = e),
                    (g.imageSize.width =
                      parseFloat(t.getAttribute("width")) || 0),
                    (g.imageSize.height =
                      parseFloat(t.getAttribute("height")) || 0),
                    p ||
                      ((g._tileSize.width = g.imageSize.width),
                      (g._tileSize.height = g.imageSize.height)),
                    (g.sourceImage = this._spriteFrameMap[e]),
                    !g.sourceImage)
                  ) {
                    const t = Zct.getNameWithPostfix(e);
                    if (
                      ((g.imageName = t),
                      (g.sourceImage = this._spriteFrameMap[t]),
                      !g.sourceImage)
                    ) {
                      const t = Zct.getShortName(e);
                      (g.imageName = t),
                        (g.sourceImage = this._spriteFrameMap[t]),
                        g.sourceImage ||
                          (G(7221, e),
                          console.warn(
                            `Please try asset type of ${e} to 'sprite-frame'`
                          ));
                    }
                  }
                  g.firstGid = this.parentGID & Uct.FLIPPED_MASK;
                }
                const y = (Uct.FLIPPED_MASK & this.parentGID) >>> 0;
                this._tileProperties.set(y, $ct(h));
                const T = h.getElementsByTagName("animation");
                if (T && T.length > 0) {
                  const t = T[0].getElementsByTagName("frame"),
                    e = { frames: [], dt: 0, frameIdx: 0 };
                  this._tileAnimations.set(y, e);
                  const i = e.frames;
                  for (let e = 0; e < t.length; e++) {
                    const s = t[e],
                      n = _ + (parseInt(s.getAttribute("tileid")) || 0),
                      r = parseFloat(s.getAttribute("duration")) || 0;
                    i.push({ tileid: n, duration: r / 1e3, grid: null });
                  }
                }
              }
            }
          }
          const u = s.childNodes;
          for (i = 0; i < u.length; i++) {
            const t = u[i];
            if (!this._shouldIgnoreNode(t)) {
              if ("imagelayer" === t.nodeName) {
                const e = this._parseImageLayer(t);
                e && this.setImageLayers(e);
              }
              if ("layer" === t.nodeName) {
                const e = this._parseLayer(t);
                this.setLayers(e);
              }
              if ("objectgroup" === t.nodeName) {
                const e = this._parseObjectGroup(t);
                this.setObjectGroups(e);
              }
            }
          }
          return s;
        }
        _shouldIgnoreNode(t) {
          return 3 === t.nodeType || 8 === t.nodeType || 4 === t.nodeType;
        }
        _parseImageLayer(t) {
          const e = t.getElementsByTagName("image");
          if (!e || 0 === e.length) return null;
          const i = new Xct();
          (i.name = t.getAttribute("name")),
            (i.offset.x = parseFloat(t.getAttribute("offsetx")) || 0),
            (i.offset.y = parseFloat(t.getAttribute("offsety")) || 0);
          const s = t.getAttribute("visible");
          i.visible = !("0" === s);
          const n = t.getAttribute("opacity");
          i.opacity = n ? Math.round(255 * parseFloat(n)) : 255;
          const r = t.getAttribute("tintcolor");
          i.tintColor = r ? qct(r) : null;
          const a = e[0],
            o = a.getAttribute("source");
          return (
            (i.sourceImage = this._imageLayerSPF[o]),
            (i.width = parseInt(a.getAttribute("width")) || 0),
            (i.height = parseInt(a.getAttribute("height")) || 0),
            (i.trans = qct(a.getAttribute("trans"))),
            i.sourceImage
              ? i
              : (G(7221, o),
                console.warn(`Please try asset type of ${o} to 'sprite-frame'`),
                null)
          );
        }
        _parseLayer(t) {
          const e = t.getElementsByTagName("data")[0],
            i = new Wct();
          i.name = t.getAttribute("name");
          const s = new ws(0, 0);
          (s.width = parseFloat(t.getAttribute("width"))),
            (s.height = parseFloat(t.getAttribute("height"))),
            (i.layerSize = s);
          const n = t.getAttribute("visible");
          i.visible = !("0" === n);
          const r = t.getAttribute("opacity");
          (i.opacity = r ? Math.round(255 * parseFloat(r)) : 255),
            (i.offset = new Ss(
              parseFloat(t.getAttribute("offsetx")) || 0,
              parseFloat(t.getAttribute("offsety")) || 0
            ));
          const a = t.getAttribute("tintcolor");
          i.tintColor = a ? qct(a) : null;
          let o = "";
          for (let t = 0; t < e.childNodes.length; t++)
            o += e.childNodes[t].nodeValue;
          o = o.trim();
          const h = e.getAttribute("compression"),
            l = e.getAttribute("encoding");
          if (h && "gzip" !== h && "zlib" !== h) return B(7218), null;
          let c;
          switch (h) {
            case "gzip":
              c = jot.unzipBase64AsArray(o, 4);
              break;
            case "zlib":
              c = (function (t) {
                if (t.length % 4 != 0) return null;
                const e = t.length / 4,
                  i = window.Uint32Array ? new Uint32Array(e) : [];
                for (let s = 0; s < e; s++) {
                  const e = 4 * s;
                  i[s] =
                    t[e] +
                    256 * t[e + 1] +
                    65536 * t[e + 2] +
                    t[e + 3] * (1 << 24);
                }
                return i;
              })(new Uat.Inflate(jot.Base64.decodeAsArray(o, 1)).decompress());
              break;
            case null:
            case "":
              if ("base64" === l) c = jot.Base64.decodeAsArray(o, 4);
              else if ("csv" === l) {
                c = [];
                const t = o.split(",");
                for (let e = 0; e < t.length; e++) c.push(parseInt(t[e]));
              } else {
                const t = e.getElementsByTagName("tile");
                c = [];
                for (let e = 0; e < t.length; e++)
                  c.push(parseInt(t[e].getAttribute("gid")));
              }
              break;
            default:
              this.layerAttrs === Wct.ATTRIB_NONE && B(7219);
          }
          return (
            c && (i.tiles = new Uint32Array(c)), (i.properties = $ct(t)), i
          );
        }
        _parseObjectGroup(t) {
          const e = new jct();
          (e.name = t.getAttribute("name") || ""),
            (e.offset = new Ss(
              parseFloat(t.getAttribute("offsetx")),
              parseFloat(t.getAttribute("offsety"))
            ));
          const i = t.getAttribute("opacity");
          e.opacity = i ? Math.round(255 * parseFloat(i)) : 255;
          const s = t.getAttribute("tintcolor");
          e.tintColor = s ? qct(s) : null;
          const n = t.getAttribute("visible");
          n && 0 === parseInt(n) && (e.visible = !1);
          const r = t.getAttribute("color");
          r && e.color.fromHEX(r);
          const a = t.getAttribute("draworder");
          a && (e.draworder = a), e.setProperties($ct(t));
          const o = t.getElementsByTagName("object");
          if (o) {
            for (let t = 0; t < o.length; t++) {
              const i = o[t],
                s = {};
              (s.id = i.getAttribute("id") || t),
                (s.name = i.getAttribute("name") || ""),
                (s.width = parseFloat(i.getAttribute("width")) || 0),
                (s.height = parseFloat(i.getAttribute("height")) || 0),
                (s.x = parseFloat(i.getAttribute("x")) || 0),
                (s.y = parseFloat(i.getAttribute("y")) || 0),
                (s.rotation = parseFloat(i.getAttribute("rotation")) || 0),
                $ct(i, s);
              const n = i.getAttribute("visible");
              s.visible = !(n && 0 === parseInt(n));
              const r = i.getElementsByTagName("text");
              if (r && r.length > 0) {
                const t = r[0];
                (s.type = Gct.TEXT),
                  (s.wrap = "1" === t.getAttribute("wrap")),
                  (s.color = qct(t.getAttribute("color"))),
                  (s.halign = Yct(t.getAttribute("halign"))),
                  (s.valign = Kct(t.getAttribute("valign"))),
                  (s.pixelsize = parseInt(t.getAttribute("pixelsize")) || 16),
                  (s.text = t.childNodes[0].nodeValue);
              }
              const a = i.getAttribute("gid");
              a && ((s.gid = parseInt(a)), (s.type = Gct.IMAGE));
              const h = i.getElementsByTagName("ellipse");
              h && h.length > 0 && (s.type = Gct.ELLIPSE);
              const l = i.getElementsByTagName("polygon");
              if (l && l.length > 0) {
                s.type = Gct.POLYGON;
                const t = l[0].getAttribute("points");
                t && (s.points = this._parsePointsString(t));
              }
              const c = i.getElementsByTagName("polyline");
              if (c && c.length > 0) {
                s.type = Gct.POLYLINE;
                const t = c[0].getAttribute("points");
                t && (s.polylinePoints = this._parsePointsString(t));
              }
              s.type || (s.type = Gct.RECT), e.objects.push(s);
            }
            "index" !== a && e.objects.sort((t, e) => t.y - e.y);
          }
          return e;
        }
        _parsePointsString(t) {
          if (!t) return null;
          const e = [],
            i = t.split(" ");
          for (let t = 0; t < i.length; t++) {
            const s = i[t].split(",");
            e.push({ x: parseFloat(s[0]), y: parseFloat(s[1]) });
          }
          return e;
        }
        setTileAnimations(t) {
          this._tileAnimations = t;
        }
        getTileAnimations() {
          return this._tileAnimations;
        }
        getTileProperties() {
          return this._tileProperties;
        }
        setTileProperties(t) {
          this._tileProperties = t;
        }
        getCurrentString() {
          return this.currentString;
        }
        setCurrentString(t) {
          this.currentString = t;
        }
        static getNameWithPostfix(t) {
          const e = (t = t.replace(/\\/g, "/")).lastIndexOf("/") + 1,
            i = t.length;
          return t.substring(e, i);
        }
        static getShortName(t) {
          const e = (t = t.replace(/\\/g, "/")).lastIndexOf("/") + 1;
          let i = t.lastIndexOf(".");
          return (i = i < 0 ? t.length : i), t.substring(e, i);
        }
      }
      var Qct, Jct, tut, eut, iut, sut, nut, rut, aut, out, hut;
      let lut = t(
        "TiledTile",
        ((Qct = Ca("cc.TiledTile")),
        (Jct = Oa(CI)),
        (tut = ao(ke)),
        (eut = ao(ke)),
        (iut = ao(ke)),
        (sut = ao(ke)),
        (nut = ao(ke)),
        Qct(
          (rut =
            Jct(
              ((aut = class extends np {
                constructor() {
                  super(),
                    (this._layer = null),
                    (this._x = out && out()),
                    (this._y = hut && hut());
                }
                get x() {
                  return this._x;
                }
                set x(t) {
                  t !== this._x &&
                    (this._layer && this._layer.isInvalidPosition(t, this._y)
                      ? w(
                          "Invalid x, the valid value is between [%s] ~ [%s]",
                          0,
                          this._layer.layerSize.width
                        )
                      : (this._resetTile(), (this._x = t), this.updateInfo()));
                }
                get y() {
                  return this._y;
                }
                set y(t) {
                  t !== this._y &&
                    (this._layer && this._layer.isInvalidPosition(this._x, t)
                      ? w(
                          "Invalid y, the valid value is between [%s] ~ [%s]",
                          0,
                          this._layer.layerSize.height
                        )
                      : (this._resetTile(), (this._y = t), this.updateInfo()));
                }
                get grid() {
                  return this._layer
                    ? this._layer.getTileGIDAt(this._x, this._y)
                    : 0;
                }
                set grid(t) {
                  this._layer && this._layer.setTileGIDAt(t, this._x, this._y);
                }
                onEnable() {
                  const t = this.node.parent;
                  (this._layer = t.getComponent("cc.TiledLayer")),
                    this.node.on(
                      bf.TRANSFORM_CHANGED,
                      this._updatePosition,
                      this
                    ),
                    this.node.on(bf.SIZE_CHANGED, this._updatePosition, this),
                    this._resetTile(),
                    this.updateInfo();
                }
                onDisable() {
                  this._resetTile(),
                    this.node.off(
                      bf.TRANSFORM_CHANGED,
                      this._updatePosition,
                      this
                    ),
                    this.node.off(bf.SIZE_CHANGED, this._updatePosition, this);
                }
                _resetTile() {
                  this._layer &&
                    this._layer.getTiledTileAt(this._x, this._y) === this &&
                    this._layer.setTiledTileAt(this._x, this._y, null);
                }
                updateInfo() {
                  if (!this._layer) return;
                  const t = this._x,
                    e = this._y;
                  if (this._layer.getTiledTileAt(t, e))
                    return void w(
                      "There is already a TiledTile at [%s, %s]",
                      t,
                      e
                    );
                  const i = this._layer.getPositionAt(t, e);
                  this.node.setPosition(i.x, i.y),
                    this._layer.setTiledTileAt(t, e, this),
                    this._layer.markForUpdateRenderData();
                }
                _updatePosition() {
                  this._layer.markForUpdateRenderData();
                }
              }),
              (out = fa(aut.prototype, "_x", [tut], function () {
                return 0;
              })),
              (hut = fa(aut.prototype, "_y", [eut], function () {
                return 0;
              })),
              s(
                aut.prototype,
                "x",
                [iut],
                Object.getOwnPropertyDescriptor(aut.prototype, "x"),
                aut.prototype
              ),
              s(
                aut.prototype,
                "y",
                [sut],
                Object.getOwnPropertyDescriptor(aut.prototype, "y"),
                aut.prototype
              ),
              s(
                aut.prototype,
                "grid",
                [nut],
                Object.getOwnPropertyDescriptor(aut.prototype, "grid"),
                aut.prototype
              ),
              (rut = aut))
            ) || rut)
        ) || rut)
      );
      function cut(t, e, i) {
        const s = i || t.sourceImage,
          n = s.texture,
          r = t.collection;
        if (!t.imageSize.width || !t.imageSize.height) {
          const e = t.sourceImage;
          (t.imageSize.width = e.width), (t.imageSize.height = e.height);
        }
        const a = t.imageSize.width,
          o = t.imageSize.height,
          h = t._tileSize.width,
          l = t._tileSize.height,
          c = s.width,
          u = s.height,
          _ = t.spacing,
          d = t.margin;
        let p = 1;
        if (!r) {
          const t = Math.floor((a - 2 * d + _) / (h + _)),
            e = Math.floor((o - 2 * d + _) / (l + _));
          p = Math.max(1, e * t);
        }
        const m = t.firstGid;
        let f = null,
          g = !!e.get(m);
        const y = t.firstGid + p;
        let T = m;
        for (; T < y && (g && !e.get(T) && (g = !1), g || !e.get(T)); ++T) {
          if (
            ((f = {
              tileset: t,
              x: 0,
              y: 0,
              width: h,
              height: l,
              t: 0,
              l: 0,
              r: 0,
              b: 0,
              cx: 0,
              cy: 0,
              offsetX: 0,
              offsetY: 0,
              rotated: !1,
              gid: T,
              spriteFrame: s,
              texture: n,
            }),
            t.rectForGID(T, f),
            !i || p > 1 || t.imageOffset)
          )
            if (i) {
              f._name = i.name;
              const t = i.unbiasUV[0],
                e = i.rotated ? i.unbiasUV[1] : i.unbiasUV[5];
              (f.l = t + (f.x + 0.5) / c),
                (f.t = e + (f.y + 0.5) / u),
                (f.r = t + (f.x + f.width - 0.5) / c),
                (f.b = e + (f.y + f.height - 0.5) / u),
                (f._rect = new Ds(f.x, f.y, f.width, f.height));
            } else
              (f.l = f.x / c),
                (f.t = f.y / u),
                (f.r = (f.x + f.width) / c),
                (f.b = (f.y + f.height) / u),
                (f._rect = new Ds(f.x, f.y, f.width, f.height));
          else
            i.rotated
              ? ((f._rotated = !0),
                (f._name = i.name),
                (f._rect = i.getRect()),
                (f.l = i.unbiasUV[0]),
                (f.t = i.unbiasUV[1]),
                (f.r = i.unbiasUV[4]),
                (f.b = i.unbiasUV[3]))
              : ((f._name = i.name),
                (f._rect = i.getRect()),
                (f.l = i.unbiasUV[0]),
                (f.t = i.unbiasUV[5]),
                (f.r = i.unbiasUV[2]),
                (f.b = i.unbiasUV[1]));
          (f.cx = (f.l + f.r) / 2), (f.cy = (f.t + f.b) / 2), e.set(T, f);
        }
      }
      var uut, _ut;
      const dut = new ms(),
        put = new Ss(),
        mut = new Yi(),
        fut = new Yi(),
        gut = { row: 0, col: 0 };
      let yut = t(
          "TiledUserNodeData",
          Ca("cc.TiledUserNodeData")(
            (uut = class extends np {
              constructor() {
                super(),
                  (this._index = -1),
                  (this._row = -1),
                  (this._col = -1),
                  (this._tiledLayer = null);
              }
            })
          ) || uut
        ),
        Tut = t(
          "TiledLayer",
          Ca("cc.TiledLayer")(
            (_ut = class t extends ew {
              get cullingRect() {
                return this._cullingRect;
              }
              get rightTop() {
                return this._rightTop;
              }
              get layerSize() {
                return this._layerSize;
              }
              get tiledDataArray() {
                return this._tiledDataArray;
              }
              get leftDownToCenterX() {
                return this._leftDownToCenterX;
              }
              get leftDownToCenterY() {
                return this._leftDownToCenterY;
              }
              requestDrawInfo(t) {
                return (
                  this._drawInfoList[t] ||
                    ((this._drawInfoList[t] = new rI()),
                    this._drawInfoList[t].setDrawInfoType(ZO.MIDDLEWARE)),
                  this._drawInfoList[t]
                );
              }
              constructor() {
                super(),
                  (this._userNodeGrid = {}),
                  (this._userNodeMap = {}),
                  (this._userNodeDirty = !1),
                  (this.tiledTiles = []),
                  (this._viewPort = { x: -1, y: -1, width: -1, height: -1 }),
                  (this._cullingRect = {
                    leftDown: { row: -1, col: -1 },
                    rightTop: { row: -1, col: -1 },
                  }),
                  (this._cullingDirty = !0),
                  (this._rightTop = { row: -1, col: -1 }),
                  (this._layerInfo = null),
                  (this._mapInfo = null),
                  (this._topOffset = 0),
                  (this._downOffset = 0),
                  (this._leftOffset = 0),
                  (this._rightOffset = 0),
                  (this.tiles = []),
                  (this.vertices = []),
                  (this._verticesDirty = !0),
                  (this._layerName = ""),
                  (this._layerSize = void 0),
                  (this._minGID = void 0),
                  (this._maxGID = void 0),
                  (this._layerOrientation = null),
                  (this._opacity = void 0),
                  (this._tintColor = void 0),
                  (this.texGrids = null),
                  (this._textures = []),
                  (this._tilesets = []),
                  (this._leftDownToCenterX = 0),
                  (this._leftDownToCenterY = 0),
                  (this._hasTiledNodeGrid = !1),
                  (this._hasAniGrid = !1),
                  (this._animations = null),
                  (this._enableCulling = void 0),
                  (this.colorChanged = !1),
                  (this._properties = void 0),
                  (this.renderOrder = void 0),
                  (this._staggerAxis = void 0),
                  (this._staggerIndex = void 0),
                  (this._hexSideLength = void 0),
                  (this._mapTileSize = void 0),
                  (this._odd_even = void 0),
                  (this._diffX1 = void 0),
                  (this._diffY1 = void 0),
                  (this._useAutomaticVertexZ = void 0),
                  (this._vertexZvalue = void 0),
                  (this._offset = void 0),
                  (this._tiledDataArray = []),
                  (this._cameraNode = void 0),
                  (this._drawInfoList = []),
                  (this._tiledDataArrayIdx = 0);
              }
              hasTiledNode() {
                return this._hasTiledNodeGrid;
              }
              hasAnimation() {
                return this._hasAniGrid;
              }
              set enableCulling(t) {
                this._enableCulling !== t &&
                  ((this._enableCulling = t),
                  (this._cullingDirty = !0),
                  this.markForUpdateRenderData());
              }
              get enableCulling() {
                return this._enableCulling;
              }
              addUserNode(t) {
                let e = t.getComponent(yut);
                return e
                  ? (w("CCTiledLayer:addUserNode node has been added"), !1)
                  : ((e = t.addComponent(yut)),
                    (t.parent = this.node),
                    (this._userNodeMap[t.uuid] = e),
                    (e._row = -1),
                    (e._col = -1),
                    (e._tiledLayer = this),
                    this._nodeLocalPosToLayerPos(t.getPosition(), put),
                    this._positionToRowCol(put.x, put.y, gut),
                    this._addUserNodeToGrid(e, gut),
                    this._updateCullingOffsetByUserNode(t),
                    t.on(bf.TRANSFORM_CHANGED, this._userNodePosChange, e),
                    t.on(bf.SIZE_CHANGED, this._userNodeSizeChange, e),
                    !0);
              }
              removeUserNode(t) {
                const e = t.getComponent(yut);
                return e
                  ? (t.off(bf.TRANSFORM_CHANGED, this._userNodePosChange, e),
                    t.off(bf.SIZE_CHANGED, this._userNodeSizeChange, e),
                    this._removeUserNodeFromGrid(e),
                    delete this._userNodeMap[t.uuid],
                    t._removeComponent(e),
                    e.destroy(),
                    t.removeFromParent(),
                    !0)
                  : (w("CCTiledLayer:removeUserNode node is not exist"), !1);
              }
              destroyUserNode(t) {
                this.removeUserNode(t), t.destroy();
              }
              _nodeLocalPosToLayerPos(t, e) {
                (e.x = t.x + this._leftDownToCenterX),
                  (e.y = t.y + this._leftDownToCenterY);
              }
              getNodesByRowCol(t, e) {
                const i = this._userNodeGrid[t];
                return i ? i[e] : null;
              }
              getNodesCountByRow(t) {
                const e = this._userNodeGrid[t];
                return e ? e.count : 0;
              }
              _updateAllUserNode() {
                this._userNodeGrid = {};
                for (const t in this._userNodeMap) {
                  const e = this._userNodeMap[t];
                  this._nodeLocalPosToLayerPos(e.node.getPosition(), put),
                    this._positionToRowCol(put.x, put.y, gut),
                    this._addUserNodeToGrid(e, gut),
                    this._updateCullingOffsetByUserNode(e.node);
                }
              }
              _updateCullingOffsetByUserNode(t) {
                const e = t._uiProps.uiTransformComp.contentSize;
                this._topOffset < e.height && (this._topOffset = e.height),
                  this._downOffset < e.height && (this._downOffset = e.height),
                  this._leftOffset < e.width && (this._leftOffset = e.width),
                  this._rightOffset < e.width && (this._rightOffset = e.width);
              }
              _userNodeSizeChange() {
                const t = this.node,
                  e = this._tiledLayer;
                e._updateCullingOffsetByUserNode(t),
                  (e._userNodeDirty = !0),
                  e.markForUpdateRenderData();
              }
              _userNodePosChange() {
                const t = this,
                  e = t.node,
                  i = t._tiledLayer;
                i._nodeLocalPosToLayerPos(e.getPosition(), put),
                  i._positionToRowCol(put.x, put.y, gut),
                  i._limitInLayer(gut),
                  (gut.row === t._row && gut.col === t._col) ||
                    (i._removeUserNodeFromGrid(t),
                    i._addUserNodeToGrid(t, gut));
              }
              _removeUserNodeFromGrid(t) {
                const e = t._row,
                  i = t._col,
                  s = t._index,
                  n = this._userNodeGrid[e],
                  r = n && n[i];
                r &&
                  (n.count--,
                  r.count--,
                  (r.list[s] = null),
                  r.count <= 0 && ((r.list.length = 0), (r.count = 0))),
                  (t._row = -1),
                  (t._col = -1),
                  (t._index = -1),
                  (this._userNodeDirty = !0),
                  this.markForUpdateRenderData();
              }
              _limitInLayer(t) {
                const e = t.row,
                  i = t.col;
                e < 0 && (t.row = 0),
                  e > this._rightTop.row && (t.row = this._rightTop.row),
                  i < 0 && (t.col = 0),
                  i > this._rightTop.col && (t.col = this._rightTop.col);
              }
              _addUserNodeToGrid(t, e) {
                const i = e.row,
                  s = e.col,
                  n = (this._userNodeGrid[i] = this._userNodeGrid[i] || {
                    count: 0,
                  }),
                  r = (n[s] = n[s] || { count: 0, list: [] });
                (t._row = i),
                  (t._col = s),
                  (t._index = r.list.length),
                  n.count++,
                  r.count++,
                  r.list.push(t),
                  (this._userNodeDirty = !0),
                  this.markForUpdateRenderData();
              }
              isUserNodeDirty() {
                return this._userNodeDirty;
              }
              setUserNodeDirty(t) {
                this._userNodeDirty = t;
              }
              _reinstallCamera() {
                const t = Lv.root.batcher2D.getFirstRenderCamera(this.node),
                  e = null == t ? void 0 : t.node;
                return (
                  this._cameraNode !== e &&
                    (this._uninstallCamera(),
                    e &&
                      (e.on(bf.TRANSFORM_CHANGED, this.updateCulling, this),
                      e.on(bf.SIZE_CHANGED, this.updateCulling, this),
                      (this._cameraNode = e))),
                  t
                );
              }
              _uninstallCamera() {
                this._cameraNode &&
                  (this._cameraNode.off(
                    bf.TRANSFORM_CHANGED,
                    this.updateCulling,
                    this
                  ),
                  this._cameraNode.off(
                    bf.SIZE_CHANGED,
                    this.updateCulling,
                    this
                  ),
                  delete this._cameraNode);
              }
              onEnable() {
                super.onEnable(),
                  this.node.on(bf.ANCHOR_CHANGED, this._syncAnchorPoint, this),
                  this.node.on(bf.TRANSFORM_CHANGED, this.updateCulling, this),
                  this.node.on(bf.SIZE_CHANGED, this.updateCulling, this),
                  this.node.parent.on(
                    bf.TRANSFORM_CHANGED,
                    this.updateCulling,
                    this
                  ),
                  this.node.parent.on(
                    bf.SIZE_CHANGED,
                    this.updateCulling,
                    this
                  ),
                  this.markForUpdateRenderData(),
                  this.scheduleOnce(this.updateCulling.bind(this));
              }
              onDisable() {
                var t, e;
                super.onDisable(),
                  null === (t = this.node.parent) ||
                    void 0 === t ||
                    t.off(bf.SIZE_CHANGED, this.updateCulling, this),
                  null === (e = this.node.parent) ||
                    void 0 === e ||
                    e.off(bf.TRANSFORM_CHANGED, this.updateCulling, this),
                  this.node.off(bf.SIZE_CHANGED, this.updateCulling, this),
                  this.node.off(bf.TRANSFORM_CHANGED, this.updateCulling, this),
                  this.node.off(bf.ANCHOR_CHANGED, this._syncAnchorPoint, this),
                  this._uninstallCamera();
              }
              _syncAnchorPoint() {
                const t = this.node,
                  e = t._uiProps.uiTransformComp,
                  i = t.getScale();
                (this._leftDownToCenterX = e.width * e.anchorX * i.x),
                  (this._leftDownToCenterY = e.height * e.anchorY * i.y),
                  (this._cullingDirty = !0),
                  this.markForUpdateRenderData();
              }
              getLayerName() {
                return this._layerName;
              }
              setLayerName(t) {
                this._layerName = t;
              }
              getProperty(t) {
                return this._properties[t];
              }
              getPositionAt(t, e) {
                let i;
                switch (
                  (void 0 !== e
                    ? ((i = Math.floor(t)), (e = Math.floor(e)))
                    : ((i = Math.floor(t.x)), (e = Math.floor(t.y))),
                  this._layerOrientation)
                ) {
                  case Bct.ORTHO:
                    return this._positionForOrthoAt(i, e);
                  case Bct.ISO:
                    return this._positionForIsoAt(i, e);
                  case Bct.HEX:
                    return this._positionForHexAt(i, e);
                }
                return null;
              }
              isInvalidPosition(t, e) {
                return (
                  t >= this._layerSize.width ||
                  e >= this._layerSize.height ||
                  t < 0 ||
                  e < 0
                );
              }
              _positionForIsoAt(t, e) {
                let i = 0,
                  s = 0;
                const n = Math.floor(t) + Math.floor(e) * this._layerSize.width,
                  r = this.tiles[n];
                if (r) {
                  const t = (r & Uct.FLIPPED_MASK) >>> 0,
                    e = this.texGrids.get(t).tileset.tileOffset;
                  (i = e.x), (s = e.y);
                }
                return new Ss(
                  0.5 *
                    this._mapTileSize.width *
                    (this._layerSize.height + t - e - 1) +
                    i,
                  0.5 *
                    this._mapTileSize.height *
                    (this._layerSize.width -
                      t +
                      this._layerSize.height -
                      e -
                      2) -
                    s
                );
              }
              _positionForOrthoAt(t, e) {
                let i = 0,
                  s = 0;
                const n = Math.floor(t) + Math.floor(e) * this._layerSize.width,
                  r = this.tiles[n];
                if (r) {
                  const t = (r & Uct.FLIPPED_MASK) >>> 0,
                    e = this.texGrids.get(t).tileset.tileOffset;
                  (i = e.x), (s = e.y);
                }
                return new Ss(
                  t * this._mapTileSize.width + i,
                  (this._layerSize.height - e - 1) * this._mapTileSize.height -
                    s
                );
              }
              _positionForHexAt(t, e) {
                const i = this._mapTileSize.width,
                  s = this._mapTileSize.height,
                  n = this._layerSize.height,
                  r = Math.floor(t) + Math.floor(e) * this._layerSize.width,
                  a = (this.tiles[r] & Uct.FLIPPED_MASK) >>> 0;
                let o;
                o = this.texGrids.get(a)
                  ? this.texGrids.get(a).tileset.tileOffset
                  : { x: 0, y: 0 };
                const h = this._staggerIndex === zct.STAGGERINDEX_ODD ? 1 : -1;
                let l = 0,
                  c = 0,
                  u = 0,
                  _ = 0;
                switch (this._staggerAxis) {
                  case kct.STAGGERAXIS_Y:
                    (u = 0),
                      e % 2 == 1 && (u = (i / 2) * h),
                      (l = t * i + u + o.x),
                      (c =
                        (n - e - 1) * (s - (s - this._hexSideLength) / 2) -
                        o.y);
                    break;
                  case kct.STAGGERAXIS_X:
                    (_ = 0),
                      t % 2 == 1 && (_ = (s / 2) * -h),
                      (l = t * (i - (i - this._hexSideLength) / 2) + o.x),
                      (c = (n - e - 1) * s + _ - o.y);
                }
                return new Ss(l, c);
              }
              setTilesGIDAt(t, e, i, s) {
                if (!t || 0 === t.length || s <= 0) return;
                i < 0 && (i = 0), e < 0 && (e = 0);
                let n = 0;
                const r = e + s;
                for (let s = i; ; s++)
                  for (let i = e; i < r; i++) {
                    if (n >= t.length) return;
                    this._updateTileForGID(t[n], i, s), n++;
                  }
              }
              setTileGIDAt(t, e, i, s) {
                const n = (t & Uct.FLIPPED_MASK) >>> 0;
                if (
                  ((e = Math.floor(e)),
                  (i = Math.floor(i)),
                  this.isInvalidPosition(e, i))
                )
                  throw new Error(
                    "cc.TiledLayer.setTileGIDAt(): invalid position"
                  );
                this.tiles && this._tilesets && 0 !== this._tilesets.length
                  ? 0 !== n && n < this._tilesets[0].firstGid
                    ? B(7239, t)
                    : ((s = s || 0),
                      this._updateTileForGID((n | s) >>> 0, e, i))
                  : B(7238);
              }
              _updateTileForGID(t, e, i) {
                const s = 0 | (e + i * this._layerSize.width);
                if (s >= this.tiles.length) return;
                if (t === this.tiles[s]) return;
                const n = (t & Uct.FLIPPED_MASK) >>> 0;
                this.texGrids.get(n)
                  ? ((this.tiles[s] = t), this._updateVertex(e, i))
                  : (this.tiles[s] = 0),
                  (this._cullingDirty = !0);
              }
              getTileGIDAt(t, e) {
                if (this.isInvalidPosition(t, e))
                  throw new Error(
                    "cc.TiledLayer.getTileGIDAt(): invalid position"
                  );
                if (!this.tiles) return B(7237), null;
                const i = Math.floor(t) + Math.floor(e) * this._layerSize.width;
                return (this.tiles[i] & Uct.FLIPPED_MASK) >>> 0;
              }
              getTileFlagsAt(t, e) {
                if (this.isInvalidPosition(t, e))
                  throw new Error(
                    "TiledLayer.getTileFlagsAt: invalid position"
                  );
                if (!this.tiles) return B(7240), null;
                const i = Math.floor(t) + Math.floor(e) * this._layerSize.width;
                return (this.tiles[i] & Uct.FLIPPED_ALL) >>> 0;
              }
              setCullingDirty(t) {
                this._cullingDirty = t;
              }
              isCullingDirty() {
                return this._cullingDirty;
              }
              updateViewPort(t, e, i, s) {
                if (
                  this._viewPort.width === i &&
                  this._viewPort.height === s &&
                  this._viewPort.x === t &&
                  this._viewPort.y === e
                )
                  return;
                (this._viewPort.x = t),
                  (this._viewPort.y = e),
                  (this._viewPort.width = i),
                  (this._viewPort.height = s);
                let n = 1;
                this._layerOrientation === Bct.ISO && (n = 2);
                const r =
                    this._viewPort.x - this._offset.x + this._leftDownToCenterX,
                  a =
                    this._viewPort.y - this._offset.y + this._leftDownToCenterY;
                let o = r - this._leftOffset,
                  h = a - this._downOffset;
                const l = r + i + this._rightOffset,
                  c = a + s + this._topOffset,
                  u = this._cullingRect.leftDown,
                  _ = this._cullingRect.rightTop;
                o < 0 && (o = 0),
                  h < 0 && (h = 0),
                  this._positionToRowCol(o, h, gut),
                  (gut.row -= n),
                  (gut.col -= n),
                  (gut.row = gut.row > 0 ? gut.row : 0),
                  (gut.col = gut.col > 0 ? gut.col : 0),
                  (gut.row === u.row && gut.col === u.col) ||
                    ((u.row = gut.row),
                    (u.col = gut.col),
                    (this._cullingDirty = !0)),
                  l < 0 || c < 0
                    ? ((gut.row = -1), (gut.col = -1))
                    : (this._positionToRowCol(l, c, gut), gut.row++, gut.col++),
                  (gut.row === _.row && gut.col === _.col) ||
                    ((_.row = gut.row),
                    (_.col = gut.col),
                    (this._cullingDirty = !0)),
                  this._cullingDirty && this.markForUpdateRenderData();
              }
              _positionToRowCol(t, e, i) {
                const s = this._mapTileSize.width,
                  n = this._mapTileSize.height,
                  r = 0.5 * s,
                  a = 0.5 * n;
                let o = 0,
                  h = 0,
                  l = 0,
                  c = 0;
                const u = this._staggerAxis;
                switch (this._layerOrientation) {
                  case Bct.ORTHO:
                    (h = Math.floor(t / s)), (o = Math.floor(e / n));
                    break;
                  case Bct.ISO:
                    (h = Math.floor(t / r)), (o = Math.floor(e / a));
                    break;
                  case Bct.HEX:
                    u === kct.STAGGERAXIS_Y
                      ? ((o = Math.floor(e / (n - this._diffY1))),
                        (l = o % 2 == 1 ? r * this._odd_even : 0),
                        (h = Math.floor((t - l) / s)))
                      : ((h = Math.floor(t / (s - this._diffX1))),
                        (c = h % 2 == 1 ? a * -this._odd_even : 0),
                        (o = Math.floor((e - c) / n)));
                }
                return (i.row = o), (i.col = h), i;
              }
              updateCulling() {
                if (this._enableCulling) {
                  this.node.updateWorldTransform(),
                    ms.invert(dut, this.node.getWorldMatrix());
                  const t = this._reinstallCamera();
                  t &&
                    ((mut.x = 0),
                    (mut.y = 0),
                    (mut.z = 0),
                    (fut.x = t.width),
                    (fut.y = t.height),
                    (fut.z = 0),
                    t.screenToWorld(mut, mut),
                    t.screenToWorld(fut, fut),
                    Yi.transformMat4(mut, mut, dut),
                    Yi.transformMat4(fut, fut, dut),
                    this.updateViewPort(
                      mut.x,
                      mut.y,
                      fut.x - mut.x,
                      fut.y - mut.y
                    ));
                }
              }
              getLayerOrientation() {
                return this._layerOrientation;
              }
              getProperties() {
                return this._properties;
              }
              _updateVertex(t, e) {
                const i = Uct.FLIPPED_MASK,
                  s = this.vertices,
                  n = this._layerOrientation,
                  r = this.tiles;
                if (!r) return;
                const a = this._rightTop,
                  o = this._mapTileSize.width,
                  h = this._mapTileSize.height,
                  l = 0.5 * o,
                  c = 0.5 * h,
                  u = this._layerSize.height,
                  _ = this._layerSize.width,
                  d = this.texGrids;
                let p,
                  m,
                  f,
                  g,
                  y,
                  T,
                  S = 0,
                  E = 0;
                n === Bct.HEX &&
                  ((p = this._staggerAxis),
                  (m = this._diffX1),
                  (f = this._diffY1),
                  (g = this._odd_even));
                let v = 0,
                  b = 0,
                  A = 0,
                  C = 0,
                  O = 0,
                  I = 0,
                  w = 0;
                const R = e * _ + t;
                A = (r[R] & i) >>> 0;
                const D = d.get(A);
                if (!D) return;
                switch (
                  (this._animations.get(A) &&
                    (this._hasAniGrid = this._hasAniGrid || !0),
                  n)
                ) {
                  case Bct.ORTHO:
                    (v = t), (b = u - e - 1), (S = v * o), (E = b * h);
                    break;
                  case Bct.ISO:
                    (v = u + t - e - 1),
                      (b = u + _ - t - e - 2),
                      (S = l * v),
                      (E = c * b);
                    break;
                  case Bct.HEX:
                    (y = p === kct.STAGGERAXIS_Y && e % 2 == 1 ? l * g : 0),
                      (T = p === kct.STAGGERAXIS_X && t % 2 == 1 ? c * -g : 0),
                      (S = t * (o - m) + y),
                      (E = (u - e - 1) * (h - f) + T),
                      (v = t),
                      (b = u - e - 1);
                }
                const x = (s[b] = s[b] || { minCol: 0, maxCol: 0 }),
                  M = (x[v] = x[v] || { left: 0, bottom: 0, index: 0 });
                x.minCol > v && (x.minCol = v),
                  x.maxCol < v && (x.maxCol = v),
                  a.row < b && ((a.row = b), n === Bct.ISO && (a.row += 1)),
                  a.col < v && ((a.col = v), n === Bct.ISO && (a.col += 1));
                const P = D.tileset.tileOffset;
                (S += this._offset.x + P.x + D.offsetX),
                  (E += this._offset.y - P.y - D.offsetY),
                  (C = -P.y + D.tileset._tileSize.height - h),
                  (C = C < 0 ? 0 : C),
                  (O = P.y < 0 ? 0 : P.y),
                  (I = -P.x < 0 ? 0 : -P.x),
                  (w = P.x + D.tileset._tileSize.width - o),
                  (w = w < 0 ? 0 : w),
                  this._rightOffset < I && (this._rightOffset = I),
                  this._leftOffset < w && (this._leftOffset = w),
                  this._topOffset < O && (this._topOffset = O),
                  this._downOffset < C && (this._downOffset = C),
                  (M.left = S),
                  (M.bottom = E),
                  (M.index = R),
                  (this._cullingDirty = !0);
              }
              _updateVertices() {
                if (((this.vertices.length = 0), !this.tiles)) return;
                const t = this._rightTop;
                (t.row = -1), (t.col = -1);
                const e = this._layerSize.height,
                  i = this._layerSize.width;
                (this._topOffset = 0),
                  (this._downOffset = 0),
                  (this._leftOffset = 0),
                  (this._rightOffset = 0),
                  (this._hasAniGrid = !1);
                for (let t = 0; t < e; ++t)
                  for (let e = 0; e < i; ++e) this._updateVertex(e, t);
                this._verticesDirty = !1;
              }
              getTiledTileAt(t, e, i) {
                if (this.isInvalidPosition(t, e))
                  throw new Error(
                    "TiledLayer.getTiledTileAt: invalid position"
                  );
                if (!this.tiles) return B(7236), null;
                const s = Math.floor(t) + Math.floor(e) * this._layerSize.width;
                let n = this.tiledTiles[s];
                if (!n && i) {
                  const i = new Pf();
                  return (
                    (n = i.addComponent(lut)),
                    (n._x = t),
                    (n._y = e),
                    (n._layer = this),
                    n.updateInfo(),
                    (i.parent = this.node),
                    n
                  );
                }
                return n;
              }
              setTiledTileAt(t, e, i) {
                if (this.isInvalidPosition(t, e))
                  throw new Error(
                    "TiledLayer.setTiledTileAt: invalid position"
                  );
                if (!this.tiles) return B(7236), null;
                const s = Math.floor(t) + Math.floor(e) * this._layerSize.width;
                return (
                  (this.tiledTiles[s] = i),
                  (this._cullingDirty = !0),
                  (this._hasTiledNodeGrid =
                    !!i || this.tiledTiles.some((t) => !!t)),
                  i
                );
              }
              getTexture(t) {
                return (
                  (t = t || 0),
                  this._textures && t >= 0 && this._textures.length > t
                    ? this._textures[t]
                    : null
                );
              }
              getTextures() {
                return this._textures;
              }
              setTexture(t) {
                this.setTextures([t]);
              }
              setTextures(t) {
                (this._textures = t), this.markForUpdateRenderData();
              }
              getLayerSize() {
                return this._layerSize;
              }
              getMapTileSize() {
                return this._mapTileSize;
              }
              getTileSet(t) {
                return (
                  (t = t || 0),
                  this._tilesets && t >= 0 && this._tilesets.length > t
                    ? this._tilesets[t]
                    : null
                );
              }
              getTileSets() {
                return this._tilesets;
              }
              setTileSet(t) {
                this.setTileSets([t]);
              }
              setTileSets(t) {
                this._tilesets = t;
                const e = (this._textures = []),
                  i = this.texGrids;
                i.clear();
                for (let i = 0; i < t.length; i++) {
                  const s = t[i];
                  s && (e[i] = s.sourceImage);
                }
                for (let e = 0, s = t.length; e < s; ++e) {
                  const s = t[e];
                  s && cut(s, i, s.sourceImage);
                }
                this._prepareToRender();
              }
              init(t, e, i, s, n) {
                (this._cullingDirty = !0),
                  (this._layerInfo = t),
                  (this._mapInfo = e);
                const r = t.layerSize;
                (this._layerName = t.name),
                  (this.tiles = t.tiles),
                  (this._properties = t.properties),
                  (this._layerSize = r),
                  (this._minGID = t.minGID),
                  (this._maxGID = t.maxGID),
                  (this._opacity = t.opacity),
                  t.tintColor && (this._tintColor = t.tintColor),
                  (this.renderOrder = e.renderOrder),
                  (this._staggerAxis = e.getStaggerAxis()),
                  (this._staggerIndex = e.getStaggerIndex()),
                  (this._hexSideLength = e.getHexSideLength()),
                  (this._animations = e.getTileAnimations()),
                  (this._tilesets = i),
                  (this._textures = s),
                  (this.texGrids = n),
                  (this._layerOrientation = e.orientation),
                  (this._mapTileSize = e.getTileSize());
                const a = this._mapTileSize.width,
                  o = this._mapTileSize.height,
                  h = this._layerSize.width,
                  l = this._layerSize.height;
                if (this._layerOrientation === Bct.HEX) {
                  let t = 0,
                    e = 0;
                  const i = -2 & a,
                    s = -2 & o;
                  (this._odd_even =
                    this._staggerIndex === zct.STAGGERINDEX_ODD ? 1 : -1),
                    this._staggerAxis === kct.STAGGERAXIS_X
                      ? ((this._diffX1 = (i - this._hexSideLength) / 2),
                        (this._diffY1 = 0),
                        (t =
                          (this._diffX1 + this._hexSideLength) * h +
                          this._diffX1),
                        (e = s * l + s / 2))
                      : ((this._diffX1 = 0),
                        (this._diffY1 = (s - this._hexSideLength) / 2),
                        (t = i * h + i / 2),
                        (e =
                          (this._diffY1 + this._hexSideLength) * l +
                          this._diffY1)),
                    this.node._uiProps.uiTransformComp.setContentSize(t, e);
                } else if (this._layerOrientation === Bct.ISO) {
                  const t = h + l;
                  this.node._uiProps.uiTransformComp.setContentSize(
                    0.5 * a * t,
                    0.5 * o * t
                  );
                } else
                  this.node._uiProps.uiTransformComp.setContentSize(
                    h * a,
                    l * o
                  );
                (this._offset = new Ss(t.offset.x, -t.offset.y)),
                  (this._useAutomaticVertexZ = !1),
                  (this._vertexZvalue = 0),
                  this._syncAnchorPoint(),
                  this._prepareToRender();
              }
              _prepareToRender() {
                this._updateVertices(), this._updateAllUserNode();
              }
              requestTiledRenderData() {
                const t = this._tiledDataArray;
                for (
                  ;
                  t.length > 0 &&
                  t[t.length - 1].subNodes &&
                  0 === t[t.length - 1].subNodes.length;

                )
                  t.pop();
                if (t.length > 0) {
                  const e = t[t.length - 1];
                  if (e.renderData && 0 === e.renderData.vertexCount) return e;
                }
                const e = { renderData: null, texture: null };
                return this._tiledDataArray.push(e), e;
              }
              requestSubNodesData() {
                const t = this._tiledDataArray;
                if (
                  t.length > 0 &&
                  t[t.length - 1].subNodes &&
                  0 === t[t.length - 1].subNodes.length
                )
                  return t[t.length - 1];
                const e = { subNodes: [] };
                return this._tiledDataArray.push(e), e;
              }
              destroyRenderData() {
                this._tiledDataArray.forEach((t) => {
                  const e = t.renderData;
                  e && cI.remove(e);
                }),
                  (this._tiledDataArray.length = 0),
                  super.destroyRenderData();
              }
              _flushAssembler() {
                const e = t.Assembler.getAssembler(this);
                this._assembler !== e &&
                  ((this._assembler = e), this._assembler.createData(this)),
                  0 === this._tiledDataArray.length &&
                    (this.markForUpdateRenderData(), this._updateColor());
              }
              _render(t) {
                for (let e = 0; e < this._tiledDataArray.length; e++) {
                  this._tiledDataArrayIdx = e;
                  const i = this._tiledDataArray[e];
                  if (i.subNodes)
                    i.subNodes.forEach((e) => {
                      e && t.walk(e.node);
                    });
                  else {
                    const e = i;
                    e.texture &&
                      t.commitComp(
                        this,
                        e.renderData,
                        e.texture,
                        this._assembler,
                        null
                      );
                  }
                }
                this.node._static = !0;
              }
              createRenderEntity() {
                return new oI(tI.CROSSED);
              }
              fillIndicesBuffer(t, e) {
                const i = t.chunk.meshBuffer.iData;
                let s = t.chunk.meshBuffer.indexOffset;
                e.setIndexOffset(s);
                let n = t.chunk.vertexOffset;
                const r = t.vertexCount / 4;
                for (let t = 0; t < r; t += 1)
                  (i[s] = n),
                    (i[s + 1] = n + 1),
                    (i[s + 2] = n + 2),
                    (i[s + 3] = n + 2),
                    (i[s + 4] = n + 1),
                    (i[s + 5] = n + 3),
                    (s += 6),
                    (n += 4);
                (t.chunk.meshBuffer.indexOffset = s), e.setIBCount(6 * r);
              }
              prepareDrawData() {
                this._drawInfoList.length = 0;
                const t = this.renderEntity;
                t.clearDynamicRenderDrawInfos();
                const e = this._tiledDataArray;
                let i = 0;
                e.forEach((e) => {
                  if (e.subNodes)
                    e.subNodes.forEach((e) => {
                      if (e) {
                        this._drawInfoList[i] ||
                          (this._drawInfoList[i] = new rI());
                        const s = this._drawInfoList[i];
                        s.setDrawInfoType(ZO.SUB_NODE),
                          s.setSubNode(e.node),
                          t.setDynamicRenderDrawInfo(s, i),
                          i++;
                      }
                    });
                  else {
                    const s = e;
                    if (s.texture) {
                      this._drawInfoList[i] ||
                        (this._drawInfoList[i] = new rI());
                      const e = this._drawInfoList[i];
                      s.renderData.fillDrawInfoAttributes(e),
                        e.setTexture(s.texture.getGFXTexture()),
                        e.setSampler(s.texture.getGFXSampler()),
                        e.setMaterial(this.getRenderMaterial(0)),
                        this.fillIndicesBuffer(s.renderData, e),
                        t.setDynamicRenderDrawInfo(e, i),
                        i++;
                    }
                  }
                });
              }
            })
          ) || _ut
        );
      var Sut, Eut, vut, but, Aut;
      let Cut = t(
        "TiledObjectGroup",
        ((Sut = Ca("cc.TiledObjectGroup")),
        (Eut = Oa(CI)),
        (vut = ao(He)),
        Sut(
          (but =
            Eut(
              (s(
                (Aut = class extends np {
                  constructor(...t) {
                    super(...t),
                      (this._premultiplyAlpha = !1),
                      (this._groupName = void 0),
                      (this._positionOffset = void 0),
                      (this._mapInfo = void 0),
                      (this._properties = void 0),
                      (this._offset = void 0),
                      (this._opacity = void 0),
                      (this._tintColor = null),
                      (this._animations = void 0),
                      (this._hasAniObj = void 0),
                      (this._texGrids = void 0),
                      (this.aniObjects = void 0),
                      (this._objects = []);
                  }
                  get premultiplyAlpha() {
                    return this._premultiplyAlpha;
                  }
                  set premultiplyAlpha(t) {
                    this._premultiplyAlpha = t;
                  }
                  getPositionOffset() {
                    return this._positionOffset;
                  }
                  getProperties() {
                    return this._properties;
                  }
                  getGroupName() {
                    return this._groupName;
                  }
                  getProperty(t) {
                    return this._properties[t.toString()];
                  }
                  getObject(t) {
                    for (let e = 0, i = this._objects.length; e < i; e++) {
                      const i = this._objects[e];
                      if (i && i.name === t) return i;
                    }
                    return null;
                  }
                  getObjects() {
                    return this._objects;
                  }
                  get offset() {
                    return this._offset;
                  }
                  _init(t, e, i) {
                    const s = Uct.FLIPPED_MASK,
                      n = Uct.HORIZONTAL,
                      r = Uct.VERTICAL;
                    (this._groupName = t.name),
                      (this._positionOffset = t.offset),
                      (this._mapInfo = e),
                      (this._properties = t.getProperties()),
                      (this._offset = new Ss(t.offset.x, -t.offset.y)),
                      (this._opacity = t.opacity),
                      t.tintColor && (this._tintColor = t.tintColor),
                      (this._texGrids = i),
                      (this._animations = e.getTileAnimations()),
                      (this.aniObjects = []),
                      (this._hasAniObj = !1);
                    const a = e.mapSize,
                      o = e.tileSize;
                    let h = 0,
                      l = 0;
                    const c = new Qi(),
                      u = Bct.ISO === e.orientation;
                    if (e.orientation === Bct.HEX)
                      e.getStaggerAxis() === kct.STAGGERAXIS_X
                        ? ((l = o.height * (a.height + 0.5)),
                          (h =
                            (o.width + e.getHexSideLength()) *
                              Math.floor(a.width / 2) +
                            o.width * (a.width % 2)))
                        : ((h = o.width * (a.width + 0.5)),
                          (l =
                            (o.height + e.getHexSideLength()) *
                              Math.floor(a.height / 2) +
                            o.height * (a.height % 2)));
                    else if (u) {
                      const t = a.width + a.height;
                      (h = 0.5 * o.width * t), (l = 0.5 * o.height * t);
                    } else (h = a.width * o.width), (l = a.height * o.height);
                    const _ = this.node._uiProps.uiTransformComp;
                    _.setContentSize(h, l);
                    const d = h * _.anchorX,
                      p = l * (1 - _.anchorY),
                      m = t.objects,
                      f = {};
                    for (let t = 0, e = m.length; t < e; t++) {
                      const e = m[t],
                        h = e.type;
                      e.offset = new Ss(e.x, e.y);
                      const _ = e.points || e.polylinePoints;
                      if (_) for (let t = 0; t < _.length; t++) _[t].y *= -1;
                      if (u) {
                        const t = e.x / o.height,
                          i = e.y / o.height;
                        (e.x = 0.5 * o.width * (a.height + t - i)),
                          (e.y = 0.5 * o.height * (a.width + a.height - t - i));
                      } else e.y = l - e.y;
                      if (h === Gct.TEXT) {
                        const i = `text${e.id}`;
                        f[i] = !0;
                        let s = this.node.getChildByName(i);
                        s || (s = new Pf()),
                          s.setRotationFromEuler(0, 0, -e.rotation),
                          s.setPosition(e.x - d, e.y - p),
                          (s.name = i),
                          (s.parent = this.node),
                          s.setSiblingIndex(t),
                          (s.layer = this.node.layer);
                        let n = s.getComponent(Ww);
                        n || (n = s.addComponent(Ww));
                        const r = s._uiProps.uiTransformComp;
                        (s.active = e.visible),
                          (r.anchorX = 0),
                          (r.anchorY = 1),
                          this._tintColor
                            ? (c.set(this._tintColor),
                              (c.a *= this._opacity / 255),
                              n.color.set(c))
                            : (n.color.a *= this._opacity / 255),
                          (n.overflow = Ww.Overflow.SHRINK),
                          (n.lineHeight = e.height),
                          (n.string = e.text),
                          (n.horizontalAlign = e.halign),
                          (n.verticalAlign = e.valign),
                          (n.fontSize = e.pixelsize),
                          r.setContentSize(e.width, e.height);
                      } else if (h === Gct.IMAGE) {
                        const a = e.gid,
                          o = (a & s) >>> 0,
                          h = i.get(o);
                        if (!h) continue;
                        const l = h.tileset,
                          _ = `img${e.id}`;
                        f[_] = !0;
                        let m = this.node.getChildByName(_);
                        (e.width = e.width || h.width),
                          (e.height = e.height || h.height),
                          m &&
                            m._objFlags & $n.Flags.HideInHierarchy &&
                            (m.removeFromParent(),
                            (m.hideFlags |= $n.Flags.DontSave),
                            m.destroy(),
                            (m = null)),
                          m || (m = new Pf()),
                          this._animations.get(o) &&
                            (this.aniObjects.push({
                              object: e,
                              imgNode: m,
                              gridGID: o,
                            }),
                            (this._hasAniObj = !0));
                        const g = l.tileOffset.x,
                          y = l.tileOffset.y;
                        (m.active = e.visible),
                          m.setRotationFromEuler(0, 0, -e.rotation),
                          m.setPosition(e.x - d, e.y - p),
                          (m.name = _),
                          (m.parent = this.node),
                          m.setSiblingIndex(t),
                          (m.layer = this.node.layer);
                        let T = m.getComponent(XD);
                        T || (T = m.addComponent(XD));
                        const S = m._uiProps.uiTransformComp;
                        u
                          ? ((S.anchorX = 0.5 + g / e.width),
                            (S.anchorY = y / e.height))
                          : ((S.anchorX = g / e.width),
                            (S.anchorY = y / e.height)),
                          this._tintColor
                            ? (c.set(this._tintColor),
                              (c.a *= this._opacity / 255),
                              T.color.set(c))
                            : (T.color.a *= this._opacity / 255),
                          (T.sizeMode = XD.SizeMode.CUSTOM);
                        const E = this._premultiplyAlpha
                          ? Pc.ONE
                          : Pc.SRC_ALPHA;
                        T.srcBlendFactor !== E &&
                          ((T.srcBlendFactor = E),
                          T.material && T._updateBlendFunc());
                        let v = h.spriteFrame;
                        (v = v ? v.clone() : new uC()),
                          (a & n) >>> 0 && (v.flipUVX = !v.flipUVX),
                          (a & r) >>> 0 && (v.flipUVY = !v.flipUVY),
                          (v.rotated = h._rotated),
                          (v.rect = h._rect),
                          (T.spriteFrame = v),
                          S.setContentSize(e.width, e.height),
                          T.markForUpdateRenderData();
                      }
                    }
                    this._objects = m;
                    const g = this.node.children,
                      y = /^(?:img|text)\d+$/;
                    for (let t = 0, e = g.length; t < e; t++) {
                      const e = g[t],
                        i = e.name;
                      y.test(i) && !f[i] && e.destroy();
                    }
                  }
                  update(t) {
                    if (!this._hasAniObj) return;
                    const e = this.aniObjects,
                      i = this._texGrids,
                      s = Bct.ISO === this._mapInfo.orientation;
                    for (let t = 0, n = e.length; t < n; t++) {
                      const n = e[t],
                        r = n.gridGID,
                        a = i.get(r);
                      if (!a) continue;
                      const o = a.tileset,
                        h = n.object,
                        l = n.imgNode,
                        c = o.tileOffset.x,
                        u = o.tileOffset.y,
                        _ = l._uiProps.uiTransformComp;
                      s
                        ? ((_.anchorX = 0.5 + c / h.width),
                          (_.anchorY = u / h.height))
                        : ((_.anchorX = c / h.width),
                          (_.anchorY = u / h.height));
                      const d = l.getComponent(XD),
                        p = d.spriteFrame;
                      (p.rotated = a._rotated),
                        (p.rect = a._rect),
                        (d.spriteFrame = p),
                        d.markForUpdateRenderData();
                    }
                  }
                }).prototype,
                "premultiplyAlpha",
                [vut],
                Object.getOwnPropertyDescriptor(
                  Aut.prototype,
                  "premultiplyAlpha"
                ),
                Aut.prototype
              ),
              (but = Aut))
            ) || but)
        ) || but)
      );
      var Out,
        Iut,
        wut,
        Rut,
        Dut,
        xut,
        Mut,
        Put,
        Nut,
        Lut,
        But,
        Fut,
        Uut,
        kut,
        zut,
        Hut,
        Gut,
        Vut;
      let jut = t(
        "TiledMapAsset",
        ((Out = Ca("cc.TiledMapAsset")),
        (Iut = ao([YE])),
        (wut = ao([Ge])),
        (Rut = ao([uC])),
        (Dut = ao([uC])),
        (xut = ao([Ge])),
        (Mut = ao([Ge])),
        (Put = ao([ws])),
        Out(
          ((Lut = class extends Ad {
            constructor(...t) {
              super(...t),
                (this.tmxXmlStr = But && But()),
                (this.tsxFiles = Fut && Fut()),
                (this.tsxFileNames = Uut && Uut()),
                (this.spriteFrames = kut && kut()),
                (this.imageLayerSpriteFrame = zut && zut()),
                (this.imageLayerSpriteFrameNames = Hut && Hut()),
                (this.spriteFrameNames = Gut && Gut()),
                (this.spriteFrameSizes = Vut && Vut());
            }
          }),
          (But = fa(Lut.prototype, "tmxXmlStr", [Na], function () {
            return "";
          })),
          (Fut = fa(Lut.prototype, "tsxFiles", [Na, Iut], function () {
            return [];
          })),
          (Uut = fa(Lut.prototype, "tsxFileNames", [Na, wut], function () {
            return [];
          })),
          (kut = fa(Lut.prototype, "spriteFrames", [Na, Rut], function () {
            return [];
          })),
          (zut = fa(
            Lut.prototype,
            "imageLayerSpriteFrame",
            [Na, Dut],
            function () {
              return [];
            }
          )),
          (Hut = fa(
            Lut.prototype,
            "imageLayerSpriteFrameNames",
            [Na, xut],
            function () {
              return [];
            }
          )),
          (Gut = fa(Lut.prototype, "spriteFrameNames", [Na, Mut], function () {
            return [];
          })),
          (Vut = fa(Lut.prototype, "spriteFrameSizes", [Na, Put], function () {
            return [];
          })),
          (Nut = Lut))
        ) || Nut)
      );
      var Wut, Xut, Yut, Kut, qut, $ut, Zut, Qut, Jut;
      t(
        "TiledMap",
        ((Wut = Ca("cc.TiledMap")),
        (Xut = Oa(CI)),
        (Yut = ao(jut)),
        Wut(
          (Kut =
            Xut(
              (((Jut = class extends np {
                constructor(...t) {
                  super(...t),
                    (this._texGrids = new Map()),
                    (this._textures = []),
                    (this._tilesets = []),
                    (this._animations = new Map()),
                    (this._imageLayers = []),
                    (this._layers = []),
                    (this._groups = []),
                    (this._images = []),
                    (this._properties = {}),
                    (this._tileProperties = new Map()),
                    (this._mapInfo = null),
                    (this._mapSize = new ws(0, 0)),
                    (this._tileSize = new ws(0, 0)),
                    (this._mapOrientation = Bct.ORTHO),
                    (this._isApplied = !1),
                    (this._tmxFile = $ut && $ut()),
                    (this._enableCulling = Zut && Zut()),
                    (this.cleanupImageCache = Qut && Qut());
                }
                get tmxAsset() {
                  return this._tmxFile;
                }
                set tmxAsset(t) {
                  this._tmxFile !== t &&
                    ((this._tmxFile = t),
                    this._applyFile(),
                    (this._isApplied = !0));
                }
                get enableCulling() {
                  return this._enableCulling;
                }
                set enableCulling(t) {
                  this._enableCulling = t;
                  const e = this._layers;
                  for (let i = 0; i < e.length; ++i) e[i].enableCulling = t;
                }
                getMapSize() {
                  return this._mapSize;
                }
                getTileSize() {
                  return this._tileSize;
                }
                getMapOrientation() {
                  return this._mapOrientation;
                }
                getObjectGroups() {
                  return this._groups;
                }
                getObjectGroup(t) {
                  const e = this._groups;
                  for (let i = 0, s = e.length; i < s; i++) {
                    const s = e[i];
                    if (s && s.getGroupName() === t) return s;
                  }
                  return null;
                }
                getProperties() {
                  return this._properties;
                }
                getLayers() {
                  return this._layers;
                }
                getLayer(t) {
                  const e = this._layers;
                  for (let i = 0, s = e.length; i < s; i++) {
                    const s = e[i];
                    if (s && s.getLayerName() === t) return s;
                  }
                  return null;
                }
                _changeLayer(t, e) {
                  const i = this._layers;
                  for (let s = 0, n = i.length; s < n; s++) {
                    const n = i[s];
                    if (n && n.getLayerName() === t) return void (i[s] = e);
                  }
                }
                getProperty(t) {
                  return this._properties[t.toString()];
                }
                getPropertiesForGID(t) {
                  return this._tileProperties.get(t);
                }
                __preload() {
                  this._tmxFile &&
                    !1 === this._isApplied &&
                    (this._applyFile(), (this._isApplied = !0));
                }
                onEnable() {
                  this.node.on(bf.ANCHOR_CHANGED, this._syncAnchorPoint, this);
                }
                onDisable() {
                  this.node.off(bf.ANCHOR_CHANGED, this._syncAnchorPoint, this);
                }
                _applyFile() {
                  const t = [],
                    e = {},
                    i = this._tmxFile;
                  if (i) {
                    let s = i.spriteFrameNames;
                    const n = i.spriteFrameSizes,
                      r = i.spriteFrames,
                      a = {},
                      o = {};
                    for (let i = 0; i < s.length; ++i) {
                      const h = s[i];
                      (o[h] = n[i]), (t[i] = r[i]);
                      const l = t[i];
                      l && ((e[l.name] = l), (a[h] = l));
                    }
                    const h = {},
                      l = i.imageLayerSpriteFrame;
                    s = i.imageLayerSpriteFrameNames;
                    for (let t = 0; t < l.length; ++t) h[s[t]] = l[t];
                    const c = i.tsxFileNames,
                      u = i.tsxFiles,
                      _ = {};
                    for (let t = 0; t < c.length; ++t)
                      c[t].length > 0 && (_[c[t]] = u[t].text);
                    const d = new Zct(i.tmxXmlStr, _, a, o, h),
                      p = d.getTilesets();
                    (p && 0 !== p.length) || B(7241), this._buildWithMapInfo(d);
                  } else this._releaseMapInfo();
                }
                _releaseMapInfo() {
                  const t = this._layers;
                  for (let s = 0, n = t.length; s < n; s++) {
                    var e, i;
                    null === (e = t[s].node.parent) ||
                      void 0 === e ||
                      e.off(bf.SIZE_CHANGED, t[s].updateCulling, t[s]),
                      null === (i = t[s].node.parent) ||
                        void 0 === i ||
                        i.off(bf.TRANSFORM_CHANGED, t[s].updateCulling, t[s]),
                      t[s].node.removeFromParent(),
                      t[s].node.destroy();
                  }
                  t.length = 0;
                  const s = this._groups;
                  for (let t = 0, e = s.length; t < e; t++)
                    s[t].node.removeFromParent(), s[t].node.destroy();
                  s.length = 0;
                  const n = this._images;
                  for (let t = 0, e = n.length; t < e; t++)
                    n[t].removeFromParent(), n[t].destroy();
                  n.length = 0;
                }
                _syncAnchorPoint() {
                  const t = this.node._uiProps.uiTransformComp.anchorPoint,
                    e = this.node._uiProps.uiTransformComp.width * t.x,
                    i = this.node._uiProps.uiTransformComp.height * (1 - t.y);
                  let s, n;
                  for (s = 0, n = this._layers.length; s < n; s++)
                    this._layers[
                      s
                    ].node._uiProps.uiTransformComp.setAnchorPoint(t);
                  for (s = 0, n = this._groups.length; s < n; s++) {
                    const t = this._groups[s],
                      n = t.node._uiProps.uiTransformComp;
                    (n.anchorX = 0.5), (n.anchorY = 0.5);
                    const r = t.offset.x - e + n.width * n.anchorX,
                      a = t.offset.y + i - n.height * n.anchorY;
                    t.node.setPosition(r, a);
                  }
                  for (s = 0, n = this._images.length; s < n; s++) {
                    const t = this._images[s]._uiProps.uiTransformComp;
                    (t.anchorX = 0.5), (t.anchorY = 0.5);
                    const n =
                        this._images[s]._offset.x - e + t.width * t.anchorX,
                      r = this._images[s]._offset.y + i - t.height * t.anchorY;
                    this._images[s].setPosition(n, r);
                  }
                }
                _fillAniGrids(t, e) {
                  for (const i of e.keys()) {
                    const s = e.get(i);
                    if (!s) continue;
                    const n = s.frames;
                    for (let e = 0; e < n.length; e++) {
                      const i = n[e];
                      i.grid = t.get(i.tileid);
                    }
                  }
                }
                _buildLayerAndGroup() {
                  const t = this._tilesets,
                    e = this._texGrids,
                    i = this._animations;
                  e.clear();
                  for (let i = 0, s = t.length; i < s; ++i) {
                    const s = t[i];
                    s &&
                      (s.sourceImage
                        ? cut(s, e, s.sourceImage)
                        : console.warn(
                            `Can't find the spriteFrame of tilesets ${i}`
                          ));
                  }
                  this._fillAniGrids(e, i);
                  let s = this._layers,
                    n = this._groups,
                    r = this._images;
                  const a = {};
                  for (let t = 0, e = s.length; t < e; t++)
                    a[s[t].node.name] = !0;
                  for (let t = 0, e = n.length; t < e; t++)
                    a[n[t].node.name] = !0;
                  for (let t = 0, e = r.length; t < e; t++) a[r[t].name] = !0;
                  (s = this._layers = []),
                    (n = this._groups = []),
                    (r = this._images = []);
                  const o = this._mapInfo,
                    h = this.node,
                    l = o.getAllChildren(),
                    c = this._textures;
                  let u = 0,
                    _ = 0;
                  if (l && l.length > 0)
                    for (let i = 0, d = l.length; i < d; i++) {
                      const d = l[i],
                        p = d.name;
                      let m = this.node.getChildByName(p);
                      if (
                        ((a[p] = !1),
                        m ||
                          ((m = new Pf()),
                          (m.name = p),
                          (m.layer = h.layer),
                          h.addChild(m)),
                        m.setSiblingIndex(i),
                        (m.active = d.visible),
                        d instanceof Wct)
                      ) {
                        let i = m.getComponent(Tut);
                        i || (i = m.addComponent(Tut)),
                          i.init(d, o, t, c, e),
                          (i.enableCulling = this._enableCulling),
                          (d.ownTiles = !1),
                          s.push(i);
                      } else if (d instanceof jct) {
                        let t = m.getComponent(Cut);
                        t || (t = m.addComponent(Cut)),
                          t._init(d, o, e),
                          n.push(t);
                      } else if (d instanceof Xct) {
                        const t = d.sourceImage;
                        (m.layerInfo = d),
                          (m._offset = new Ss(d.offset.x, -d.offset.y));
                        let e = m.getComponent(XD);
                        e || (e = m.addComponent(XD)),
                          (e.color.a *= d.opacity),
                          (e.spriteFrame = t);
                        let i = t.width,
                          s = t.height;
                        t.original &&
                          ((i = t.originalSize.width),
                          (s = t.originalSize.height)),
                          m._uiProps.uiTransformComp.setContentSize(i, s),
                          r.push(m);
                      }
                      (u = Math.max(u, m._uiProps.uiTransformComp.width)),
                        (_ = Math.max(_, m._uiProps.uiTransformComp.height));
                    }
                  const d = h.children;
                  for (let t = 0, e = d.length; t < e; t++) {
                    const e = d[t];
                    a[e.name] && e.destroy();
                  }
                  this.node._uiProps.uiTransformComp.setContentSize(u, _),
                    this._syncAnchorPoint();
                }
                _buildWithMapInfo(t) {
                  (this._mapInfo = t),
                    (this._mapSize = t.getMapSize()),
                    (this._tileSize = t.getTileSize()),
                    (this._mapOrientation = t.orientation),
                    (this._properties = t.properties),
                    (this._tileProperties = t.getTileProperties()),
                    (this._imageLayers = t.getImageLayers()),
                    (this._animations = t.getTileAnimations()),
                    (this._tilesets = t.getTilesets());
                  const e = this._tilesets;
                  this._textures.length = 0;
                  const i = [];
                  for (let t = 0, s = e.length; t < s; ++t) {
                    const s = e[t];
                    s &&
                      s.sourceImage &&
                      ((this._textures[t] = s.sourceImage),
                      i.push(s.sourceImage));
                  }
                  for (let t = 0; t < this._imageLayers.length; t++) {
                    const e = this._imageLayers[t];
                    e && e.sourceImage && i.push(e.sourceImage);
                  }
                  this._buildLayerAndGroup(),
                    this.cleanupImageCache &&
                      this._textures.forEach((t) => {
                        this.doCleanupImageCache(t);
                      });
                }
                doCleanupImageCache(t) {
                  t._image instanceof HTMLImageElement
                    ? ((t._image.src = ""), t._image.destroy())
                    : zr.hasFeature(zr.Feature.IMAGE_BITMAP) &&
                      t._image instanceof ImageBitmap &&
                      t._image.close &&
                      t._image.close(),
                    (t._image = null);
                }
                lateUpdate(t) {
                  const e = this._animations,
                    i = this._texGrids;
                  for (const s of e.keys()) {
                    const n = e.get(s),
                      r = n.frames;
                    let a = r[n.frameIdx];
                    (n.dt += t),
                      a.duration < n.dt &&
                        ((n.dt = 0),
                        n.frameIdx++,
                        n.frameIdx >= r.length && (n.frameIdx = 0),
                        (a = r[n.frameIdx])),
                      i.set(s, a.grid);
                  }
                  const s = this.getLayers();
                  for (let t = 0, e = s.length; t < e; t++) {
                    const e = s[t];
                    (e.hasAnimation() || e.node.hasChangedFlags) &&
                      e.markForUpdateRenderData();
                  }
                }
              }).Orientation = Bct),
              (Jut.Property = Fct),
              (Jut.TileFlag = Uct),
              (Jut.StaggerAxis = kct),
              (Jut.StaggerIndex = zct),
              (Jut.TMXObjectType = Gct),
              (Jut.RenderOrder = Hct),
              ($ut = fa((qut = Jut).prototype, "_tmxFile", [Na], function () {
                return null;
              })),
              s(
                qut.prototype,
                "tmxAsset",
                [Yut],
                Object.getOwnPropertyDescriptor(qut.prototype, "tmxAsset"),
                qut.prototype
              ),
              (Zut = fa(qut.prototype, "_enableCulling", [Na], function () {
                return !0;
              })),
              (Qut = fa(qut.prototype, "cleanupImageCache", [Na], function () {
                return !0;
              })),
              (Kut = qut))
            ) || Kut)
        ) || Kut)
      );
      const t_t = Math.ceil(10922.5),
        e_t = [];
      for (let t = 0; t < 4; t++) e_t.push(new Yi());
      const i_t = new ms(),
        s_t = new Yi(),
        n_t = { row: 0, col: 0 };
      let r_t,
        a_t,
        o_t,
        h_t = { x: 0, y: 0 },
        l_t = { x: 0, y: 0 },
        c_t = { x: 0, y: 0 },
        u_t = { x: 0, y: 0 },
        __t = 0,
        d_t = 0,
        p_t = 0,
        m_t = 0,
        f_t = null,
        g_t = null;
      const y_t = {
        ensureAccessor() {
          if (!g_t) {
            const t = Lv.root.device;
            Lv.root.batcher2D,
              (g_t = new YO(t, PO, this.vCount)),
              Lv.on(Nv.EVENT_BEFORE_DRAW, () => {
                g_t.reset();
              });
          }
        },
        createData(t) {
          this.ensureAccessor();
        },
        fillBuffers(t, e) {
          if (!t || 0 === t.tiledDataArray.length) return;
          const i = t.tiledDataArray[t._tiledDataArrayIdx].renderData,
            s = i.chunk.meshBuffer.iData;
          let n = i.chunk.meshBuffer.indexOffset,
            r = i.chunk.vertexOffset;
          const a = i.vertexCount / 4;
          for (let t = 0; t < a; t += 1)
            (s[n] = r),
              (s[n + 1] = r + 1),
              (s[n + 2] = r + 2),
              (s[n + 3] = r + 2),
              (s[n + 4] = r + 1),
              (s[n + 5] = r + 3),
              (n += 6),
              (r += 4);
          i.chunk.meshBuffer.indexOffset = n;
        },
        updateRenderData(t) {
          if (
            (t.updateCulling(),
            (d_t = t.leftDownToCenterX),
            (p_t = t.leftDownToCenterY),
            t.colorChanged ||
              t.isCullingDirty() ||
              t.isUserNodeDirty() ||
              t.hasAnimation() ||
              t.hasTiledNode() ||
              t.node.hasChangedFlags)
          ) {
            let e, i;
            if (
              ((t.colorChanged = !1), t.destroyRenderData(), t.enableCulling)
            ) {
              const s = t.cullingRect;
              (e = s.leftDown), (i = s.rightTop);
            } else (e = n_t), (i = t.rightTop);
            switch (t.renderOrder) {
              case Hct.RightDown:
                E_t(e, i, -1, 1, t);
                break;
              case Hct.LeftDown:
                E_t(e, i, -1, -1, t);
                break;
              case Hct.RightUp:
                E_t(e, i, 1, 1, t);
                break;
              case Hct.LeftUp:
              default:
                E_t(e, i, 1, -1, t);
            }
            t.setCullingDirty(!1), t.setUserNodeDirty(!1);
          }
          t.prepareDrawData();
        },
        updateColor(t) {
          const e = t.color,
            i = new Float32Array(4);
          (i[0] = e.r / 255),
            (i[1] = e.g / 255),
            (i[2] = e.b / 255),
            (i[3] = e.a / 255);
          const s = t.tiledDataArray;
          for (const t of s) {
            if (!t.renderData) continue;
            const e = t.renderData,
              s = e.vData;
            for (let t = e.vertexStart, n = e.vertexCount; t < n; t++)
              s.set(i, 9 * t + 5);
          }
        },
      };
      function T_t(t, e) {
        let i;
        t._rotated
          ? ((h_t.x = t.r),
            (h_t.y = t.t),
            (l_t.x = t.l),
            (l_t.y = t.t),
            (c_t.x = t.r),
            (c_t.y = t.b),
            (u_t.x = t.l),
            (u_t.y = t.b))
          : ((h_t.x = t.l),
            (h_t.y = t.t),
            (l_t.x = t.l),
            (l_t.y = t.b),
            (c_t.x = t.r),
            (c_t.y = t.t),
            (u_t.x = t.r),
            (u_t.y = t.b)),
          (e & Uct.DIAGONAL) >>> 0 && ((i = l_t), (l_t = c_t), (c_t = i)),
          (e & Uct.HORIZONTAL) >>> 0 &&
            ((i = h_t),
            (h_t = c_t),
            (c_t = i),
            (i = l_t),
            (l_t = u_t),
            (u_t = i)),
          (e & Uct.VERTICAL) >>> 0 &&
            ((i = h_t),
            (h_t = l_t),
            (l_t = i),
            (i = c_t),
            (c_t = u_t),
            (u_t = i));
      }
      function S_t() {
        if (m_t < 1 || !f_t) return;
        const t = 4 * m_t,
          e = 6 * m_t,
          i = a_t.requestTiledRenderData();
        (i.renderData = cI.add(PO, g_t)),
          (i.renderData.drawInfoType = ZO.MIDDLEWARE),
          (i.texture = f_t);
        const s = i.renderData;
        s.resize(t, e),
          s.chunk.vb.set(r_t.subarray(0, 9 * t), 0),
          (m_t = 0),
          (f_t = null);
      }
      function E_t(t, e, i, s, n) {
        if (e.row < 0 || e.col < 0) return;
        a_t = n;
        const r = n.node.worldMatrix;
        __t = 0;
        const a = n.tiledTiles,
          o = n.texGrids,
          h = n.tiles,
          l = 18,
          c = 27,
          u = n.vertices;
        let _,
          d,
          p,
          m,
          f,
          g,
          y,
          T,
          S,
          E = 0,
          v = 0,
          b = 0,
          A = 0,
          C = 0,
          O = 0,
          I = !0;
        o_t = T_t;
        const w = new Float32Array(4);
        (w[0] = n.color.r / 255),
          (w[1] = n.color.g / 255),
          (w[2] = n.color.b / 255),
          (w[3] = n.color.a / 255),
          -1 === i ? ((m = e.row), (f = t.row)) : ((m = t.row), (f = e.row));
        const R = Math.abs(t.row - e.row) + 1,
          D = Math.abs(e.col - t.col) + 1;
        (r_t = new Float32Array(R * D * 36)), (m_t = 0);
        const x = r_t;
        for (; (f - m) * i >= 0; m += i)
          for (
            _ = u[m],
              O = n.getNodesCountByRow(m),
              I = _ && 0 === O,
              1 === s
                ? ((d = I && t.col < _.minCol ? _.minCol : t.col),
                  (p = I && e.col > _.maxCol ? _.maxCol : e.col))
                : ((d = I && e.col > _.maxCol ? _.maxCol : e.col),
                  (p = I && t.col < _.minCol ? _.minCol : t.col));
            (p - d) * s >= 0;
            d += s
          ) {
            if (((g = _ && _[d]), O > 0)) {
              S_t();
              const t = n.requestSubNodesData(),
                e = n.getNodesByRowCol(m, d);
              e && e.count > 0 && (t.subNodes = e.list);
            }
            g &&
              ((E = h[g.index]),
              (T = o.get((E & Uct.FLIPPED_MASK) >>> 0)),
              T &&
                (f_t !== T.texture && (S_t(), (f_t = T.texture)),
                (y = T.tileset._tileSize),
                (v = g.left - d_t),
                (b = g.bottom - p_t),
                (A = v + y.width),
                (C = b + y.height),
                (S = a[g.index]),
                (__t = 36 * m_t),
                S
                  ? S.node.active && v_t(S.node, w, x, v, A, C, b, !1)
                  : ((e_t[0].x = v),
                    (e_t[0].y = C),
                    (e_t[1].x = v),
                    (e_t[1].y = b),
                    (e_t[2].x = A),
                    (e_t[2].y = C),
                    (e_t[3].x = A),
                    (e_t[3].y = b),
                    e_t[0].transformMat4(r),
                    (x[__t] = e_t[0].x),
                    (x[__t + 1] = e_t[0].y),
                    (x[__t + 2] = e_t[0].z),
                    e_t[1].transformMat4(r),
                    (x[__t + 9] = e_t[1].x),
                    (x[__t + 9 + 1] = e_t[1].y),
                    (x[__t + 9 + 2] = e_t[1].z),
                    e_t[2].transformMat4(r),
                    (x[__t + l] = e_t[2].x),
                    (x[__t + l + 1] = e_t[2].y),
                    (x[__t + l + 2] = e_t[2].z),
                    e_t[3].transformMat4(r),
                    (x[__t + c] = e_t[3].x),
                    (x[__t + c + 1] = e_t[3].y),
                    (x[__t + c + 2] = e_t[3].z),
                    x.set(w, __t + 5),
                    x.set(w, __t + 9 + 5),
                    x.set(w, __t + l + 5),
                    x.set(w, __t + c + 5)),
                o_t(T, E),
                (x[__t + 3] = h_t.x),
                (x[__t + 4] = h_t.y),
                (x[__t + 9 + 3] = l_t.x),
                (x[__t + 9 + 4] = l_t.y),
                (x[__t + l + 3] = c_t.x),
                (x[__t + l + 4] = c_t.y),
                (x[__t + c + 3] = u_t.x),
                (x[__t + c + 4] = u_t.y),
                m_t++,
                m_t >= t_t && S_t()));
          }
        S_t();
      }
      function v_t(t, e, i, s, n, r, a, o) {
        const h = 18,
          l = 27;
        t.updateWorldTransform(),
          ms.fromRTS(i_t, t.rotation, t.position, t.scale),
          Yi.set(s_t, -(s + d_t), -(a + p_t), 0),
          ms.transform(i_t, i_t, s_t),
          ms.multiply(i_t, t.parent.worldMatrix, i_t);
        const c = i_t,
          u = c.m12,
          _ = c.m13,
          d = c.m00,
          p = c.m01,
          m = c.m04,
          f = c.m05,
          g = 1 === d && 0 === p && 0 === m && 1 === f;
        if (o) {
          const t = (s + n) / 2,
            e = (r + a) / 2;
          g
            ? ((i[__t] = t + u),
              (i[__t + 1] = r + _),
              (i[__t + 9] = s + u),
              (i[__t + 9 + 1] = e + _),
              (i[__t + h] = n + u),
              (i[__t + h + 1] = e + _),
              (i[__t + l] = t + u),
              (i[__t + l + 1] = a + _))
            : ((i[__t] = t * d + r * m + u),
              (i[__t + 1] = t * p + r * f + _),
              (i[__t + 9] = s * d + e * m + u),
              (i[__t + 9 + 1] = s * p + e * f + _),
              (i[__t + h] = n * d + e * m + u),
              (i[__t + h + 1] = n * p + e * f + _),
              (i[__t + l] = t * d + a * m + u),
              (i[__t + l + 1] = t * p + a * f + _));
        } else
          g
            ? ((i[__t] = s + u),
              (i[__t + 1] = r + _),
              (i[__t + 9] = s + u),
              (i[__t + 9 + 1] = a + _),
              (i[__t + h] = n + u),
              (i[__t + h + 1] = r + _),
              (i[__t + l] = n + u),
              (i[__t + l + 1] = a + _))
            : ((i[__t] = s * d + r * m + u),
              (i[__t + 1] = s * p + r * f + _),
              (i[__t + 9] = s * d + a * m + u),
              (i[__t + 9 + 1] = s * p + a * f + _),
              (i[__t + h] = n * d + r * m + u),
              (i[__t + h + 1] = n * p + r * f + _),
              (i[__t + l] = n * d + a * m + u),
              (i[__t + l + 1] = n * p + a * f + _));
        i.set(e, __t + 5),
          i.set(e, __t + 9 + 5),
          i.set(e, __t + h + 5),
          i.set(e, __t + l + 5);
      }
      const b_t = t("tiledLayerAssembler", { getAssembler: () => y_t });
      Tut.Assembler = b_t;
      const A_t = new Yi(),
        C_t = new Yi();
      function O_t(t, e) {
        let i = null;
        return {
          value: e.length > 0 ? e[e.length - 1] : Yi.ZERO,
          progress: (t, e, s, n) => i.getPoint(n),
          clone: (t) => Yi.clone(t),
          add: (t, e) => t.clone().add(e),
          sub: (t, e) => t.clone().subtract(e),
          onStart(s) {
            const { start: n, end: r, relative: a, reversed: o } = s;
            (i = zl.create(t)), i.addKnot(n);
            let h = null;
            a && o && ((h = C_t), Yi.subtract(h, n, e[e.length - 1]));
            for (let t = 0, s = e.length; t < s; ++t) {
              const r = o ? e[s - 1 - t] : e[t];
              a
                ? o
                  ? t > 0 && i.addKnot(Yi.copy(A_t, h).add(r))
                  : i.addKnot(Yi.copy(A_t, n).add(r))
                : i.addKnot(r);
            }
            a && o && i.addKnot(r);
          },
          onComplete() {
            i = null;
          },
          onStop() {
            i = null;
          },
          legacyProgress: !1,
        };
      }
      t(
        "tweenProgress",
        Object.freeze({
          __proto__: null,
          bezier: function (...t) {
            return O_t(Ml.BEZIER, t);
          },
          catmullRom: function (...t) {
            return O_t(Ml.CATMULL_ROM, t);
          },
        })
      );
      class I_t {
        constructor() {
          (this.originalTarget = null),
            (this.target = null),
            (this.workerTarget = null),
            (this.tag = I_t.TAG_INVALID),
            (this._id = void 0),
            (this._paused = !1);
        }
        isDone() {
          return !0;
        }
        startWithTarget(t) {
          (this.originalTarget = t), (this.target = t);
        }
        stop() {
          this.target = null;
        }
        getTarget() {
          return this.target;
        }
        setTarget(t) {
          this.target = t;
        }
        getOriginalTarget() {
          return this.originalTarget;
        }
        setOriginalTarget(t) {
          this.originalTarget = t;
        }
        getTag() {
          return this.tag;
        }
        setTag(t) {
          this.tag = t;
        }
        setId(t) {
          this._id = t;
        }
        getId() {
          return this._id;
        }
        setPaused(t) {
          this._paused = t;
        }
      }
      I_t.TAG_INVALID = -1;
      class w_t extends I_t {
        constructor() {
          super(), (this._duration = 0);
        }
        getDurationScaled() {
          return this._duration;
        }
        getDuration() {
          return this._duration;
        }
        setDuration(t) {
          this._duration = t;
        }
      }
      class R_t {
        constructor() {
          (this.actions = []),
            (this.target = null),
            (this.actionIndex = 0),
            (this.currentAction = null),
            (this.paused = !1),
            (this.lock = !1);
        }
      }
      class D_t {
        constructor() {
          (this._hashTargets = new Map()),
            (this._arrayTargets = []),
            (this._currentTarget = void 0),
            (this._elementPool = []);
        }
        _getElement(t, e) {
          let i = this._elementPool.pop();
          return i || (i = new R_t()), (i.target = t), (i.paused = !!e), i;
        }
        _putElement(t) {
          (t.actions.length = 0),
            (t.actionIndex = 0),
            (t.currentAction = null),
            (t.paused = !1),
            (t.target = null),
            (t.lock = !1),
            this._elementPool.push(t);
        }
        _onNodeActiveChanged(t, e) {
          e ? this.resumeTarget(t) : this.pauseTarget(t);
        }
        _onNodeDestroy(t) {
          this._removeAllActionsFromTarget(t, !1);
        }
        _registerNodeEvent(t) {
          t.isValid &&
            (t.on(bf.ACTIVE_CHANGED, this._onNodeActiveChanged, this),
            t.on(bf.NODE_DESTROYED, this._onNodeDestroy, this));
        }
        _unregisterNodeEvent(t) {
          t.isValid &&
            (t.off(bf.ACTIVE_CHANGED, this._onNodeActiveChanged, this),
            t.off(bf.NODE_DESTROYED, this._onNodeDestroy, this));
        }
        addAction(t, e, i) {
          if (!t || !e) return void G(1e3);
          let s = this._hashTargets.get(e);
          s
            ? s.actions || (s.actions = [])
            : ((s = this._getElement(e, i)),
              this._hashTargets.set(e, s),
              this._arrayTargets.push(s)),
            0 === s.actions.length &&
              e instanceof Pf &&
              this._registerNodeEvent(e),
            (s.target = e),
            s.actions.push(t),
            t.startWithTarget(e);
        }
        removeAllActions() {
          const t = this._arrayTargets;
          for (let e = 0; e < t.length; e++) {
            const i = t[e];
            i &&
              (i.target instanceof Pf && this._unregisterNodeEvent(i.target),
              this._putElement(i));
          }
          (this._arrayTargets.length = 0), (this._hashTargets = new Map());
        }
        removeAllActionsFromTarget(t) {
          this._removeAllActionsFromTarget(t, !0);
        }
        _removeAllActionsFromTarget(t, e) {
          if (null == t) return;
          const i = this._hashTargets.get(t);
          i &&
            (e && t instanceof Pf && this._unregisterNodeEvent(t),
            (i.actions.length = 0),
            this._deleteHashElement(i));
        }
        removeAction(t) {
          if (null == t) return;
          const e = t.getOriginalTarget(),
            i = this._hashTargets.get(e);
          if (i)
            for (let e = 0; e < i.actions.length; e++)
              if (i.actions[e] === t) {
                i.actions.splice(e, 1), i.actionIndex >= e && i.actionIndex--;
                break;
              }
        }
        _removeActionByTag(t, e, i) {
          for (let s = 0, n = e.actions.length; s < n; ++s) {
            const n = e.actions[s];
            if (n && n.getTag() === t) {
              if (i && n.getOriginalTarget() !== i) continue;
              this._removeActionAtIndex(s, e);
              break;
            }
          }
        }
        _removeAllActionsByTag(t, e, i) {
          for (let s = e.actions.length - 1; s >= 0; --s) {
            const n = e.actions[s];
            if (n && n.getTag() === t) {
              if (i && n.getOriginalTarget() !== i) continue;
              this._removeActionAtIndex(s, e);
            }
          }
        }
        removeActionByTag(t, e) {
          t === I_t.TAG_INVALID && B(1002);
          const i = this._hashTargets;
          if (e) {
            const s = i.get(e);
            s && this._removeActionByTag(t, s, e);
          } else
            i.forEach((e) => {
              this._removeActionByTag(t, e);
            });
        }
        removeAllActionsByTag(t, e) {
          t === I_t.TAG_INVALID && B(1002);
          const i = this._hashTargets;
          if (e) {
            const s = i.get(e);
            s && this._removeAllActionsByTag(t, s, e);
          } else
            i.forEach((e) => {
              this._removeAllActionsByTag(t, e);
            });
        }
        getActionByTag(t, e) {
          t === I_t.TAG_INVALID && B(1004);
          const i = this._hashTargets.get(e);
          if (i) {
            if (null != i.actions)
              for (let e = 0; e < i.actions.length; ++e) {
                const s = i.actions[e];
                if (s && s.getTag() === t) return s;
              }
            B(1005, t);
          }
          return null;
        }
        getNumberOfRunningActionsInTarget(t) {
          const e = this._hashTargets.get(t);
          return e && e.actions ? e.actions.length : 0;
        }
        pauseTarget(t) {
          const e = this._hashTargets.get(t);
          e && (e.paused = !0);
        }
        resumeTarget(t) {
          const e = this._hashTargets.get(t);
          e && (e.paused = !1);
        }
        pauseAllRunningActions() {
          const t = [],
            e = this._arrayTargets;
          for (let i = 0; i < e.length; i++) {
            const s = e[i];
            s && !s.paused && ((s.paused = !0), s.target && t.push(s.target));
          }
          return t;
        }
        resumeTargets(t) {
          if (t)
            for (let e = 0; e < t.length; e++) t[e] && this.resumeTarget(t[e]);
        }
        pauseTargets(t) {
          if (t)
            for (let e = 0; e < t.length; e++) t[e] && this.pauseTarget(t[e]);
        }
        isActionRunning(t) {
          const e = this._hashTargets.get(t.getOriginalTarget());
          let i = -1;
          return e && (i = e.actions.indexOf(t)), -1 !== i;
        }
        _removeActionAtIndex(t, e) {
          e.actions.splice(t, 1),
            e.actionIndex >= t && e.actionIndex--,
            0 === e.actions.length &&
              (e.target instanceof Pf && this._unregisterNodeEvent(e.target),
              this._deleteHashElement(e));
        }
        _deleteHashElement(t) {
          let e = !1;
          if (t && !t.lock && this._hashTargets.get(t.target)) {
            this._hashTargets.delete(t.target);
            const i = this._arrayTargets;
            for (let e = 0, s = i.length; e < s; e++)
              if (i[e] === t) {
                i.splice(e, 1);
                break;
              }
            this._putElement(t), (e = !0);
          }
          return e;
        }
        update(t) {
          const e = this._arrayTargets;
          let i;
          for (let s = 0; s < e.length; s++) {
            (this._currentTarget = e[s]), (i = this._currentTarget);
            const n = i.target;
            if (!Zn(n) || n.isValid) {
              if (!i.paused && i.actions) {
                for (
                  i.lock = !0, i.actionIndex = 0;
                  i.actionIndex < i.actions.length;
                  i.actionIndex++
                )
                  if (
                    ((i.currentAction = i.actions[i.actionIndex]),
                    i.currentAction)
                  ) {
                    if (
                      (i.currentAction.step(t),
                      i.currentAction && i.currentAction.isDone())
                    ) {
                      i.currentAction.stop();
                      const t = i.currentAction;
                      (i.currentAction = null), this.removeAction(t);
                    }
                    i.currentAction = null;
                  }
                i.lock = !1;
              }
              0 === i.actions.length &&
                (n instanceof Pf && this._unregisterNodeEvent(n),
                this._deleteHashElement(i) && s--);
            } else this.removeAllActionsFromTarget(n), s--;
          }
        }
      }
      class x_t extends jl {
        get ActionManager() {
          return this.actionMgr;
        }
        constructor() {
          super(), (this.actionMgr = new D_t());
        }
        update(t) {
          this.actionMgr.update(t);
        }
      }
      t("TweenSystem", x_t),
        (x_t.ID = "TWEEN"),
        (x_t.instance = void 0),
        Lv.on(Nv.EVENT_INIT, () => {
          const t = new x_t();
          (x_t.instance = t), Lv.registerSystem(x_t.ID, t, jl.Priority.MEDIUM);
        });
      class M_t extends w_t {
        isDone() {
          return !0;
        }
        step(t) {
          this.update(1);
        }
        update(t) {}
        reverse() {
          return this.clone();
        }
        isUnknownDuration() {
          return !1;
        }
      }
      class P_t extends M_t {
        update(t) {
          var e;
          const i =
            null !== (e = this.workerTarget) && void 0 !== e ? e : this.target;
          if (!i) return;
          const s = i.getComponentsInChildren(HI);
          for (let t = 0; t < s.length; ++t) s[t].enabled = !0;
        }
        reverse() {
          return new N_t();
        }
        clone() {
          const t = new P_t();
          return (t._id = this._id), t;
        }
      }
      class N_t extends M_t {
        update(t) {
          var e;
          const i =
            null !== (e = this.workerTarget) && void 0 !== e ? e : this.target;
          if (!i) return;
          const s = i.getComponentsInChildren(HI);
          for (let t = 0; t < s.length; ++t) s[t].enabled = !1;
        }
        reverse() {
          return new P_t();
        }
        clone() {
          const t = new N_t();
          return (t._id = this._id), t;
        }
      }
      class L_t extends M_t {
        constructor(t) {
          super(), (this._isNeedCleanUp = !0), void 0 !== t && this.init(t);
        }
        update(t) {
          var e;
          const i =
            null !== (e = this.workerTarget) && void 0 !== e ? e : this.target;
          i && (i.removeFromParent(), this._isNeedCleanUp && i.destroy());
        }
        init(t) {
          return (this._isNeedCleanUp = t), !0;
        }
        reverse() {
          return new L_t(this._isNeedCleanUp);
        }
        clone() {
          const t = new L_t(this._isNeedCleanUp);
          return (t._id = this._id), t;
        }
      }
      function B_t(t) {
        return new L_t(t);
      }
      class F_t extends M_t {
        constructor(t, e, i) {
          super(),
            (this._callbackThis = void 0),
            (this._callback = void 0),
            (this._data = void 0),
            this.initWithFunction(t, e, i);
        }
        initWithFunction(t, e, i) {
          return (
            t && (this._callback = t),
            e && (this._callbackThis = e),
            void 0 !== i && (this._data = i),
            !0
          );
        }
        execute() {
          if (this._callback) {
            var t;
            const e =
              null !== (t = this.workerTarget) && void 0 !== t
                ? t
                : this.target;
            this._callback.call(this._callbackThis, e, this._data);
          }
        }
        update(t) {
          this.execute();
        }
        getTargetCallback() {
          return this._callbackThis;
        }
        setTargetCallback(t) {
          t !== this._callbackThis && (this._callbackThis = t);
        }
        clone() {
          const t = new F_t();
          return (
            (t._id = this._id),
            this._callback &&
              t.initWithFunction(
                this._callback,
                this._callbackThis,
                this._data
              ),
            t
          );
        }
      }
      class U_t extends w_t {
        clone() {
          return new U_t();
        }
        reverse() {
          return this.clone();
        }
        update(t) {}
        step(t) {}
        isUnknownDuration() {
          return !1;
        }
      }
      class k_t extends w_t {
        constructor(t) {
          super(),
            (this.MAX_VALUE = 2),
            (this._elapsed = 0),
            (this._startTime = 0),
            (this._firstTick = !1),
            (this._speed = 1),
            void 0 === t || Number.isNaN(t) || this.initWithDuration(t);
        }
        setStartTime(t) {
          (t = t < 0 ? 0 : t > this._duration ? this._duration : t),
            (this._startTime = t);
        }
        getElapsed() {
          return this._elapsed;
        }
        initWithDuration(t) {
          return (
            (this._duration = 0 === t ? Te.FLT_EPSILON : t),
            (this._elapsed = 0),
            (this._firstTick = !0),
            !0
          );
        }
        isDone() {
          return this._elapsed >= this._duration;
        }
        _cloneDecoration(t) {
          t._speed = this._speed;
        }
        step(t) {
          if (this._paused || 0 === this._speed) return;
          (t *= this._speed),
            this._firstTick
              ? (this._elapsed = this._startTime)
              : (this._elapsed += t);
          let e =
            this._elapsed /
            (this._duration > 1.192092896e-7 ? this._duration : 1.192092896e-7);
          (e = e < 1 ? e : 1),
            this.update(e > 0 ? e : 0),
            this.isUnknownDuration() &&
              !this._firstTick &&
              (this._elapsed -= t),
            this._firstTick &&
              ((this._firstTick = !1),
              this._startTime > 0 && (this._startTime = 0));
        }
        startWithTarget(t) {
          super.startWithTarget(t), (this._elapsed = 0), (this._firstTick = !0);
        }
        getSpeed() {
          return this._speed;
        }
        setSpeed(t) {
          this._speed = t;
        }
        getDurationScaled() {
          return this._duration / this._speed;
        }
      }
      class z_t extends k_t {
        static _actionOneTwo(t, e) {
          const i = new z_t();
          return i.initWithTwoActions(t, e), i;
        }
        constructor(t) {
          if (
            (super(),
            (this._actions = []),
            (this._split = 0),
            (this._last = 0),
            (this._reversed = !1),
            !t || 0 === t.length)
          )
            return;
          1 === t.length && t.push(new U_t());
          const e = t.length - 1;
          if ((e >= 0 && null == t[e] && B(1015), e >= 0)) {
            let i,
              s = t[0];
            for (let n = 1; n < e; n++)
              t[n] && ((i = s), (s = z_t._actionOneTwo(i, t[n])));
            this.initWithTwoActions(s, t[e]);
          }
        }
        initWithTwoActions(t, e) {
          if (!t || !e) return G(1025), !1;
          const i = t.getDurationScaled() + e.getDurationScaled();
          return (
            this.initWithDuration(i),
            (this._actions[0] = t),
            (this._actions[1] = e),
            !0
          );
        }
        clone() {
          const t = new z_t();
          return (
            (t._id = this._id),
            (t._speed = this._speed),
            this._cloneDecoration(t),
            t.initWithTwoActions(
              this._actions[0].clone(),
              this._actions[1].clone()
            ),
            t
          );
        }
        startWithTarget(t) {
          super.startWithTarget(t),
            0 !== this._actions.length &&
              ((this._split =
                this._actions[0].getDurationScaled() / this._duration),
              (this._last = -1));
        }
        stop() {
          0 !== this._actions.length &&
            (-1 !== this._last && this._actions[this._last].stop(),
            super.stop());
        }
        update(t) {
          const e = this._actions;
          if (0 === e.length) return;
          let i = 0,
            s = 0;
          const n = this._split,
            r = this._last;
          if (t < n) {
            if (
              ((i = 0 !== n ? t / n : 1), 0 === s && 1 === r && this._reversed)
            ) {
              const t = e[1];
              if ((t.update(0), t.isUnknownDuration())) return;
              t.stop();
            }
          } else {
            const a = e[0];
            if (((s = 1), (i = 1 === n ? 1 : (t - n) / (1 - n)), -1 === r)) {
              if (
                (a.startWithTarget(this.target),
                a.update(1),
                a.isUnknownDuration())
              )
                return;
              a.stop();
            }
            if (0 === r) {
              if ((a.update(1), a.isUnknownDuration())) return;
              a.stop();
            }
          }
          const a = e[s];
          (r === s && a.isDone()) ||
            (r !== s && a.startWithTarget(this.target),
            a.update(i > 1 ? i % 1 : i),
            (this._last = s));
        }
        reverse() {
          const t = z_t._actionOneTwo(
            this._actions[1].reverse(),
            this._actions[0].reverse()
          );
          return this._cloneDecoration(t), (t._reversed = !0), t;
        }
        updateWorkerTarget(t) {
          if (this._actions.length < 2) return;
          this._actions[1].workerTarget = t;
          const e = this._actions[0];
          e instanceof z_t || e instanceof W_t
            ? e.updateWorkerTarget(t)
            : (e.workerTarget = t);
        }
        findAction(t) {
          for (let e = 0, i = this._actions.length; e < i; ++e) {
            let i = this._actions[e];
            if (i.getId() === t) return i;
            if (
              (i instanceof z_t || i instanceof W_t) &&
              ((i = i.findAction(t)), i && i.getId() === t)
            )
              return i;
          }
          return null;
        }
        isUnknownDuration() {
          if (0 === this._actions.length) return !1;
          const t = this._actions[0],
            e = this._actions[1];
          return this._last < 1 ? t.isUnknownDuration() : e.isUnknownDuration();
        }
      }
      function H_t(t) {
        return new z_t(t);
      }
      class G_t extends k_t {
        constructor(t, e) {
          super(),
            (this._times = 0),
            (this._total = 0),
            (this._nextDt = 0),
            (this._actionInstant = !1),
            (this._innerAction = null),
            this.initWithAction(t, e);
        }
        initWithAction(t, e) {
          if (!t || void 0 === e) return !1;
          const i = t.getDurationScaled() * e;
          return (
            !!this.initWithDuration(i) &&
            ((this._times = e),
            (this._innerAction = t),
            t instanceof M_t &&
              ((this._actionInstant = !0), (this._times -= 1)),
            (this._total = 0),
            !0)
          );
        }
        clone() {
          const t = new G_t();
          return (
            (t._id = this._id),
            (t._speed = this._speed),
            this._cloneDecoration(t),
            this._innerAction &&
              t.initWithAction(this._innerAction.clone(), this._times),
            t
          );
        }
        startWithTarget(t) {
          (this._total = 0),
            (this._nextDt =
              (this._innerAction ? this._innerAction.getDurationScaled() : 0) /
              this._duration),
            super.startWithTarget(t),
            this._innerAction && this._innerAction.startWithTarget(t);
        }
        stop() {
          this._innerAction && this._innerAction.stop(), super.stop();
        }
        update(t) {
          const e = this._innerAction,
            i = this._duration,
            s = this._times;
          let n = this._nextDt;
          if (e)
            if (t >= n) {
              for (; t > n && this._total < s; ) {
                if ((e.update(1), e.isUnknownDuration())) return;
                this._total++,
                  e.stop(),
                  e.startWithTarget(this.target),
                  (n += e.getDurationScaled() / i),
                  (this._nextDt = n > 1 ? 1 : n);
              }
              if (t >= 1 && this._total < s) {
                if ((e.update(1), e.isUnknownDuration())) return;
                this._total++;
              }
              this._actionInstant ||
                (this._total === s
                  ? e.stop()
                  : e.update(t - (n - e.getDurationScaled() / i)));
            } else e.update((t * s) % 1);
        }
        isDone() {
          return this._total === this._times;
        }
        reverse() {
          const t = this._innerAction ? this._innerAction.reverse() : void 0,
            e = new G_t(t, this._times);
          return this._cloneDecoration(e), e;
        }
        setInnerAction(t) {
          this._innerAction !== t && (this._innerAction = t);
        }
        getInnerAction() {
          return this._innerAction;
        }
        isUnknownDuration() {
          return !!this._innerAction && this._innerAction.isUnknownDuration();
        }
      }
      function V_t(t, e) {
        return new G_t(t, e);
      }
      class j_t extends k_t {
        constructor(t) {
          super(), (this._innerAction = null), t && this.initWithAction(t);
        }
        initWithAction(t) {
          return t
            ? ((this._innerAction = t), (this._duration = 1 / 0), !0)
            : (G(1026), !1);
        }
        clone() {
          const t = new j_t();
          return (
            (t._id = this._id),
            (t._speed = this._speed),
            this._cloneDecoration(t),
            this._innerAction && t.initWithAction(this._innerAction.clone()),
            t
          );
        }
        startWithTarget(t) {
          super.startWithTarget(t),
            this._innerAction && this._innerAction.startWithTarget(t);
        }
        stop() {
          this._innerAction && this._innerAction.stop(), super.stop();
        }
        step(t) {
          if (this._paused || 0 === this._speed) return;
          const e = this._innerAction;
          e &&
            ((t *= this._speed),
            e.step(t),
            e.isDone() &&
              (e.startWithTarget(this.target),
              e.step(e.getElapsed() - e.getDurationScaled())));
        }
        update(t) {
          B(1007);
        }
        isDone() {
          return !1;
        }
        reverse() {
          if (this._innerAction) {
            const t = new j_t(this._innerAction.reverse());
            return this._cloneDecoration(t), t;
          }
          return this;
        }
        setInnerAction(t) {
          this._innerAction !== t && (this._innerAction = t);
        }
        getInnerAction() {
          return this._innerAction;
        }
        isUnknownDuration() {
          return !!this._innerAction && this._innerAction.isUnknownDuration();
        }
      }
      class W_t extends k_t {
        static _actionOneTwo(t, e) {
          const i = new W_t();
          return i.initWithTwoActions(t, e), i;
        }
        constructor(t) {
          if (
            (super(),
            (this._one = null),
            (this._two = null),
            (this._finished = !1),
            !t || 0 === t.length)
          )
            return;
          1 === t.length && t.push(new U_t());
          const e = t.length - 1;
          if ((e >= 0 && null == t[e] && B(1015), e >= 0)) {
            let i,
              s = t[0];
            for (let n = 1; n < e; n++)
              t[n] && ((i = s), (s = W_t._actionOneTwo(i, t[n])));
            this.initWithTwoActions(s, t[e]);
          }
        }
        initWithTwoActions(t, e) {
          if (!t || !e) return G(1027), !1;
          let i = !1;
          const s = t.getDurationScaled(),
            n = e.getDurationScaled();
          return (
            this.initWithDuration(Math.max(s, n)) &&
              ((this._one = t),
              (this._two = e),
              s > n
                ? (this._two = z_t._actionOneTwo(e, Y_t(s - n)))
                : s < n && (this._one = z_t._actionOneTwo(t, Y_t(n - s))),
              (i = !0)),
            i
          );
        }
        clone() {
          const t = new W_t();
          return (
            (t._id = this._id),
            (t._speed = this._speed),
            this._cloneDecoration(t),
            this._one &&
              this._two &&
              t.initWithTwoActions(this._one.clone(), this._two.clone()),
            t
          );
        }
        startWithTarget(t) {
          super.startWithTarget(t),
            this._one && this._one.startWithTarget(t),
            this._two && this._two.startWithTarget(t);
        }
        stop() {
          this._one && this._one.stop(),
            this._two && this._two.stop(),
            super.stop();
        }
        update(t) {
          this._one &&
            ((this._finished && !this._one.isUnknownDuration()) ||
              this._one.update(t)),
            this._two &&
              ((this._finished && !this._two.isUnknownDuration()) ||
                this._two.update(t)),
            (this._finished = 1 === t);
        }
        reverse() {
          if (this._one && this._two) {
            const t = W_t._actionOneTwo(
              this._one.reverse(),
              this._two.reverse()
            );
            return this._cloneDecoration(t), t;
          }
          return this;
        }
        updateWorkerTarget(t) {
          if (!this._one || !this._two) return;
          this._two.workerTarget = t;
          const e = this._one;
          e instanceof W_t || e instanceof z_t
            ? e.updateWorkerTarget(t)
            : (e.workerTarget = t);
        }
        findAction(t) {
          const e = this._one,
            i = this._two;
          let s = null;
          const n = (e) => {
            if (e.getId() === t) return e;
            if (e instanceof z_t || e instanceof W_t) {
              const i = e.findAction(t);
              if (i) return i;
            }
            return null;
          };
          return (e && ((s = n(e)), s)) || (i && ((s = n(i)), s)) ? s : null;
        }
        isUnknownDuration() {
          const t = this._one,
            e = this._two;
          if (null == t || null == e) return !1;
          const i = t.isUnknownDuration(),
            s = e.isUnknownDuration();
          if (i || s) {
            if (i && s) return !0;
            if (this._finished) return !0;
          }
          return !1;
        }
      }
      class X_t extends k_t {
        update(t) {}
        reverse() {
          const t = new X_t(this._duration);
          return this._cloneDecoration(t), t;
        }
        clone() {
          const t = new X_t();
          return (
            (t._id = this._id),
            (t._speed = this._speed),
            this._cloneDecoration(t),
            t.initWithDuration(this._duration),
            t
          );
        }
        isUnknownDuration() {
          return !1;
        }
      }
      function Y_t(t) {
        return new X_t(t);
      }
      class K_t extends k_t {
        constructor(t) {
          super(), (this._other = null), t && this.initWithAction(t);
        }
        initWithAction(t) {
          return t
            ? t === this._other
              ? (G(1029), !1)
              : !!super.initWithDuration(t.getDurationScaled()) &&
                ((this._other = t), !0)
            : (G(1028), !1);
        }
        clone() {
          const t = new K_t();
          return (
            (t._id = this._id),
            (t._speed = this._speed),
            this._cloneDecoration(t),
            this._other && t.initWithAction(this._other.clone()),
            t
          );
        }
        startWithTarget(t) {
          super.startWithTarget(t),
            this._other && this._other.startWithTarget(t);
        }
        update(t) {
          this._other && this._other.update(1 - t);
        }
        reverse() {
          return this._other ? this._other.clone() : this;
        }
        stop() {
          this._other && this._other.stop(), super.stop();
        }
        isUnknownDuration() {
          return !1;
        }
      }
      class q_t extends k_t {
        constructor(t, e, i) {
          super(t), (this._cb = e), (this._args = i);
        }
        clone() {
          return new q_t(this._duration, this._cb, this._args);
        }
        update(t) {
          this._cb(this.target, t, ...this._args);
        }
        reverse() {
          return this.clone();
        }
        isUnknownDuration() {
          return !1;
        }
      }
      class $_t extends w_t {
        constructor(t, e) {
          super(), (this._finished = !1), (this._cb = t), (this._args = e);
        }
        clone() {
          return new $_t(this._cb, this._args);
        }
        reverse() {
          return this.clone();
        }
        step(t) {
          throw new Error("should never go here");
        }
        update(t) {
          const e = a.game.deltaTime;
          this._finished = this._cb(this.target, e, ...this._args);
        }
        isDone() {
          return this._finished;
        }
        isUnknownDuration() {
          return !this.isDone();
        }
      }
      class Z_t extends k_t {
        constructor(t, e, i) {
          if ((super(), (this._reversed = !1), null == i))
            i = Object.create(null);
          else if (
            ((function (t) {
              const e = " [Tween:] ",
                i = ` option is not support in v + ${o}`,
                s = t;
              s.delay && w(`${e}delay${i}`),
                s.repeat && w(`${e}repeat${i}`),
                s.repeatDelay && w(`${e}repeatDelay${i}`),
                s.interpolation && w(`${e}interpolation${i}`),
                s.onStop && w(`${e}onStop${i}`);
            })(i),
            i.easing &&
              "string" == typeof i.easing &&
              (i.easing = (function (t) {
                const e = t.charAt(0);
                if (/[A-Z]/.test(e)) {
                  const i = (t = t.replace(e, e.toLowerCase())).split("-");
                  if (2 === i.length) {
                    const e = i[0];
                    if ("linear" === e) t = "linear";
                    else {
                      const s = i[1];
                      switch (e) {
                        case "quadratic":
                          t = `quad${s}`;
                          break;
                        case "quartic":
                          t = `quart${s}`;
                          break;
                        case "quintic":
                          t = `quint${s}`;
                          break;
                        case "sinusoidal":
                          t = `sine${s}`;
                          break;
                        case "exponential":
                          t = `expo${s}`;
                          break;
                        case "circular":
                          t = `circ${s}`;
                          break;
                        default:
                          t = e + s;
                      }
                    }
                  }
                }
                return t;
              })(i.easing)),
            i.progress || (i.progress = this.progress),
            i.easing && "string" == typeof i.easing)
          ) {
            const t = i.easing;
            (i.easing = gh[t]), i.easing || z(1031, t);
          }
          (this._opts = i), (this._props = Object.create(null));
          for (const t in e) {
            var s;
            if (!e.hasOwnProperty(t)) continue;
            let i,
              n,
              r,
              a = e[t];
            if ("function" == typeof a) a = a();
            else if (null == a) continue;
            void 0 !== a.value
              ? ((r = a.value),
                "function" == typeof r && (r = r()),
                void 0 !== a.easing &&
                  ("string" == typeof a.easing
                    ? ((i = gh[a.easing]), i || z(1031, a.easing))
                    : (i = a.easing)),
                void 0 !== a.progress && (n = a.progress))
              : (r = a);
            const o = Object.create(null);
            (o.start = o.current = o.end = null),
              (o.keys = null),
              (o.value = r),
              (o.easing = i),
              (o.progress = n),
              (o.convert = a.convert),
              (o.clone = a.clone),
              (o.add = a.add),
              (o.sub = a.sub),
              (o.legacyProgress =
                null === (s = a.legacyProgress) || void 0 === s || s),
              (o.toFixed = a.toFixed),
              (o.onStart = a.onStart),
              (o.onStop = a.onStop),
              (o.onComplete = a.onComplete),
              (o.valid = !0),
              (this._props[t] = o);
          }
          (this._originProps = e), this.initWithDuration(t);
        }
        get relative() {
          return !!this._opts.relative;
        }
        clone() {
          const t = new Z_t(this._duration, this._originProps, this._opts);
          return (
            (t._reversed = this._reversed),
            (t.workerTarget = this.workerTarget),
            (t._id = this._id),
            this._cloneDecoration(t),
            t
          );
        }
        reverse() {
          if (!this._opts.relative) return z(16382), new Z_t(0, {});
          const t = new Z_t(this._duration, this._originProps, this._opts);
          return (
            this._cloneDecoration(t),
            (t._reversed = !this._reversed),
            (t.workerTarget = this.workerTarget),
            t
          );
        }
        startWithTarget(t) {
          var e;
          super.startWithTarget(t);
          const i =
            null !== (e = this.workerTarget) && void 0 !== e ? e : this.target;
          if (!i) return;
          const s = !!this._opts.relative,
            n = this._props,
            r = this._reversed;
          for (const t in n) {
            const e = i[t];
            if (void 0 === e) continue;
            const a = n[t],
              o = a.value;
            if ("number" == typeof e)
              (a.start = e),
                (a.current = e),
                (a.end = s ? (r ? e - o : e + o) : o);
            else if ("object" == typeof e)
              if (a.legacyProgress) {
                if (null == a.start) {
                  const t = e.constructor;
                  (a.start = new t()), (a.current = new t()), (a.end = new t());
                }
                let t;
                (t = o.getModifiableProperties
                  ? o.getModifiableProperties()
                  : Object.keys(o)),
                  (a.keys = t);
                for (let i = 0, n = t.length; i < n; ++i) {
                  const n = t[i];
                  isNaN(e[n]) ||
                    ((a.start[n] = e[n]),
                    (a.current[n] = e[n]),
                    (a.end[n] = s ? (r ? e[n] - o[n] : e[n] + o[n]) : o[n]));
                }
              } else {
                const i = a.clone;
                if (!i) {
                  z(16383, t), (a.valid = !1);
                  continue;
                }
                {
                  const n = a.add,
                    h = a.sub;
                  if (
                    s &&
                    (n || (z(16384, t), (a.valid = !1)),
                    r && !h && (z(16385, t), (a.valid = !1)),
                    !a.valid)
                  )
                    continue;
                  (a.start = i(e)),
                    (a.current = i(e)),
                    (a.end = s ? (r ? h(e, o) : n(e, o)) : i(o));
                }
              }
            else if ("string" == typeof e) {
              const t = a.convert,
                i = (e) => {
                  if ("number" == typeof e) return e;
                  let i = e;
                  return (
                    t && (i = t(e)),
                    "number" != typeof i && ((i = Number(i)), Number.isNaN(i))
                      ? (z(16386, `${e}`), null)
                      : i
                  );
                },
                n = i(o),
                h = i(e);
              if (null == n || null == h) {
                a.valid = !1;
                continue;
              }
              (a.start = h),
                (a.current = e),
                (a.end = s ? (r ? h - n : h + n) : n);
            }
            a.onStart &&
              a.onStart({
                relative: s,
                reversed: r,
                start: a.start,
                end: a.end,
              });
          }
          this._opts.onStart && this._opts.onStart(i);
        }
        stop() {
          const t = this._props;
          for (const e in t) {
            const i = t[e];
            i.valid && i.onStop && i.onStop();
          }
          super.stop();
        }
        update(t) {
          var e;
          const i =
            null !== (e = this.workerTarget) && void 0 !== e ? e : this.target;
          if (!i) return;
          if (!this._opts) return;
          const s = this._props,
            n = this._opts;
          let r = t;
          "function" == typeof n.easing && (r = n.easing(t));
          const a = n.progress;
          for (const e in s) {
            const n = s[e];
            if (!n.valid) continue;
            const h = n.easing ? n.easing(t) : r,
              l = n.progress ? n.progress : a,
              c = n.start,
              u = n.end,
              _ = n.current;
            if ("number" == typeof _) n.current = l(c, u, n.current, h);
            else if ("object" == typeof c)
              if (n.legacyProgress) {
                const t = n.keys;
                if (!t) {
                  if (window.OnJSException instanceof Function) {
                    let t = {};
                    (t["property.name"] = e),
                      i &&
                        i.name &&
                        ((t.workerTarget = i.name),
                        i.parent &&
                          i.parent.name &&
                          (t["workerTarget.parent"] = i.parent.name)),
                      (t.duration = this._duration),
                      window.OnJSException(
                        "TweenAction::update",
                        "prop.keys is null",
                        JSON.stringify(t)
                      );
                  }
                  continue;
                }
                for (let e = 0, i = t.length; e < i; ++e) {
                  const i = t[e];
                  n.current[i] = l(c[i], u[i], n.current[i], h);
                }
              } else n.current = l(c, u, n.current, h);
            else if ("string" == typeof _) {
              let t = l(c, u, n.current, h);
              var o;
              if ("number" == typeof t)
                t = t.toFixed(null !== (o = n.toFixed) && void 0 !== o ? o : 0);
              else if ("string" != typeof t) {
                z(16387);
                continue;
              }
              n.current = t;
            }
            (i[e] = n.current), 1 === t && n.onComplete && n.onComplete();
          }
          n.onUpdate && n.onUpdate(i, t),
            1 === t && n.onComplete && n.onComplete(i);
        }
        progress(t, e, i, s) {
          return t + (e - t) * s;
        }
        isUnknownDuration() {
          return !1;
        }
      }
      t("TweenAction", Z_t);
      class Q_t extends M_t {
        constructor(t) {
          super(),
            (this._props = void 0),
            (this._props = {}),
            t && this.init(t);
        }
        init(t) {
          for (const e in t) this._props[e] = t[e];
          return !0;
        }
        update() {
          const t = this._props,
            e = this.target;
          for (const i in t) e[i] = t[i];
        }
        clone() {
          const t = new Q_t();
          return (t._id = this._id), t.init(this._props), t;
        }
        isUnknownDuration() {
          return !1;
        }
      }
      class J_t {
        constructor(t) {
          (this._actions = []),
            (this._finalAction = null),
            (this._target = null),
            (this._tag = I_t.TAG_INVALID),
            (this._timeScale = 1),
            (this._target = void 0 === t ? null : t);
        }
        tag(t) {
          return (this._tag = t), this;
        }
        id(t) {
          return (
            this._actions.length > 0 &&
              this._actions[this._actions.length - 1].setId(t),
            this
          );
        }
        then(t) {
          const e = t._union(!0);
          return e && (e.setSpeed(t._timeScale), this._actions.push(e)), this;
        }
        reverse(t, e) {
          if (null == t && null == e) return this.reverseTween();
          let i, s;
          if (
            (t instanceof J_t
              ? ((i = t), void 0 !== e && (s = e))
              : "number" == typeof t && ((i = this), (s = t)),
            i)
          ) {
            const t = J_t.reverseAction(i, s);
            t && this._actions.push(t);
          }
          return this;
        }
        reverseTween() {
          if (0 === this._actions.length)
            return z(16388), this.clone(this._target);
          const t = this._union(!1),
            e = tdt(this._target);
          return (
            (e._timeScale = this._timeScale),
            t && e.insertAction(t.reverse()),
            e
          );
        }
        static reverseAction(t, e) {
          const i = t._actions;
          if (0 === i.length) return null;
          let s = null,
            n = null;
          return (
            "number" == typeof e
              ? (s = t.findAction(e, i))
              : t && (s = t._union(!1)),
            s
              ? ((n = s.reverse()), (n.workerTarget = t._target))
              : z(16391, `${e}`),
            n
          );
        }
        findAction(t, e) {
          let i = null;
          for (let s = 0, n = e.length; s < n; ++s) {
            if (((i = e[s]), i.getId() === t)) return i;
            if (
              (i instanceof z_t || i instanceof W_t) &&
              ((i = i.findAction(t)), i)
            )
              return i;
          }
          return null;
        }
        insertAction(t) {
          const e = t.clone();
          return (
            this.updateWorkerTargetForAction(e), this._actions.push(e), this
          );
        }
        updateWorkerTargetForAction(t) {
          t &&
            (t instanceof z_t || t instanceof W_t
              ? t.updateWorkerTarget(this._target)
              : (t.workerTarget = this._target));
        }
        target(t) {
          this._target = t;
          for (let t = 0, e = this._actions.length; t < e; ++t) {
            const e = this._actions[t];
            this.updateWorkerTargetForAction(e);
          }
          return this;
        }
        getTarget() {
          return this._target;
        }
        start(t = 0) {
          if (!this._target) return z(16392), this;
          this._finalAction &&
            x_t.instance.ActionManager.removeAction(this._finalAction);
          const e = this._unionForStart();
          return (
            (this._finalAction = e),
            e
              ? (e.setTag(this._tag),
                e.setSpeed(this._timeScale),
                e.setStartTime(t),
                e.setPaused(!1),
                x_t.instance.ActionManager.addAction(e, this._target, !1))
              : z(16393),
            this
          );
        }
        stop() {
          return (
            this._finalAction &&
              (this._finalAction.stop(),
              x_t.instance.ActionManager.removeAction(this._finalAction),
              (this._finalAction = null)),
            this
          );
        }
        pause() {
          return (
            this._finalAction ? this._finalAction.setPaused(!0) : z(16389), this
          );
        }
        resume() {
          return (
            this._finalAction ? this._finalAction.setPaused(!1) : z(16390), this
          );
        }
        get running() {
          return (
            !!this._finalAction &&
            x_t.instance.ActionManager.isActionRunning(this._finalAction)
          );
        }
        clone(t) {
          const e = this._union(!1),
            i = tdt(null != t ? t : this._target);
          return (i._timeScale = this._timeScale), e ? i.insertAction(e) : i;
        }
        union(t) {
          if (void 0 === t)
            return (
              (() => {
                const t = this._union(!1);
                (this._actions.length = 0), t && this._actions.push(t);
              })(),
              this
            );
          const e = this._actions,
            i = e.findIndex((e) => e.getId() === t);
          if (e.length > 1) {
            const t = e.splice(i);
            1 === t.length ? e.push(t[0]) : e.push(H_t(t));
          }
          return this;
        }
        to(t, e, i) {
          const s = i || Object.create(null);
          s.relative = !1;
          const n = new Z_t(t, e, s);
          return this._actions.push(n), this;
        }
        by(t, e, i) {
          const s = i || Object.create(null);
          s.relative = !0;
          const n = new Z_t(t, e, s);
          return this._actions.push(n), this;
        }
        update(t, e, ...i) {
          const s = new q_t(t, e, i);
          return this._actions.push(s), this;
        }
        updateUntil(t, ...e) {
          const i = new $_t(t, e);
          return this._actions.push(i), this;
        }
        set(t) {
          const e = new Q_t(t);
          return this._actions.push(e), this;
        }
        delay(t) {
          const e = Y_t(t);
          return this._actions.push(e), this;
        }
        call(t, e, i) {
          const s = (function (t, e, i) {
            return new F_t(t, e, i);
          })(t, e, i);
          return this._actions.push(s), this;
        }
        sequence(...t) {
          const e = J_t._wrappedSequence(t);
          return e && this._actions.push(e), this;
        }
        parallel(...t) {
          const e = J_t._wrappedParallel(t);
          return e && this._actions.push(e), this;
        }
        timeScale(t) {
          return (
            (this._timeScale = t),
            this._finalAction && this._finalAction.setSpeed(t),
            this
          );
        }
        getTimeScale() {
          return this._timeScale;
        }
        get duration() {
          return this._finalAction ? this._finalAction.getDuration() : 0;
        }
        repeat(t, e) {
          if (t === 1 / 0) return this.repeatForever(e);
          const i = this._actions;
          let s;
          return (
            (s = e instanceof J_t ? e._union(!1) : i.pop()),
            s && i.push(V_t(s, t)),
            this
          );
        }
        repeatForever(t) {
          const e = this._actions;
          let i;
          return (
            (i = t instanceof J_t ? t._union(!1) : e.pop()),
            i && 0 !== e.length
              ? e.push(V_t(i, Number.MAX_SAFE_INTEGER))
              : i instanceof k_t
              ? e.push(
                  (function (t) {
                    return new j_t(t);
                  })(i)
                )
              : z(16394),
            this
          );
        }
        reverseTime(t) {
          const e = this._actions;
          let i;
          return (
            (i = t instanceof J_t ? t._union(!1) : e.pop()),
            i instanceof k_t
              ? e.push(
                  (function (t) {
                    return new K_t(t);
                  })(i)
                )
              : z(16395),
            this
          );
        }
        hide() {
          if (this._target instanceof Pf) {
            const t = new N_t();
            this._actions.push(t);
          }
          return this;
        }
        show() {
          if (this._target instanceof Pf) {
            const t = new P_t();
            this._actions.push(t);
          }
          return this;
        }
        removeSelf() {
          if (this._target instanceof Pf) {
            const t = B_t(!1);
            this._actions.push(t);
          }
          return this;
        }
        destroySelf() {
          if (this._target instanceof Pf) {
            const t = B_t(!0);
            this._actions.push(t);
          }
          return this;
        }
        static getRunningCount(t) {
          return x_t.instance.ActionManager.getNumberOfRunningActionsInTarget(
            t
          );
        }
        static stopAll() {
          x_t.instance.ActionManager.removeAllActions();
        }
        static stopAllByTag(t, e) {
          x_t.instance.ActionManager.removeAllActionsByTag(t, e);
        }
        static stopAllByTarget(t) {
          x_t.instance.ActionManager.removeAllActionsFromTarget(t);
        }
        static pauseAllByTarget(t) {
          x_t.instance.ActionManager.pauseTarget(t);
        }
        static resumeAllByTarget(t) {
          x_t.instance.ActionManager.resumeTarget(t);
        }
        _union(t) {
          const e = this._actions;
          if (0 === e.length) return null;
          const i = H_t(e);
          return t && this.updateWorkerTargetForAction(i), i;
        }
        _unionForStart() {
          const t = this._actions;
          if (0 === t.length) return null;
          let e;
          return (e = 1 === t.length && t[0] instanceof j_t ? t[0] : H_t(t)), e;
        }
        static _tweenToActions(t) {
          const e = J_t._tmp_args;
          e.length = 0;
          for (let i = t.length, s = 0; s < i; s++) {
            const i = t[s],
              n = i._union(!0);
            n && (n.setSpeed(i._timeScale), e.push(n));
          }
        }
        static _wrappedSequence(t) {
          return J_t._tweenToActions(t), H_t(J_t._tmp_args);
        }
        static _wrappedParallel(t) {
          return J_t._tweenToActions(t), (e = J_t._tmp_args), new W_t(e);
          var e;
        }
      }
      function tdt(t) {
        return new J_t(t);
      }
      function edt(t) {
        return z(16396), new J_t(t);
      }
      let idt, sdt, ndt;
      var rdt,
        adt,
        odt,
        hdt,
        ldt,
        cdt,
        udt,
        _dt,
        ddt,
        pdt,
        mdt,
        fdt,
        gdt,
        ydt,
        Tdt,
        Sdt,
        Edt,
        vdt,
        bdt,
        Adt,
        Cdt,
        Odt,
        Idt,
        wdt,
        Rdt,
        Ddt,
        xdt;
      t("Tween", J_t),
        (J_t._tmp_args = []),
        (a.Tween = J_t),
        (a.tween = tdt),
        (a.tweenUtil = edt),
        (function (t) {
          (t[(t.Other = 0)] = "Other"),
            (t[(t.Left = 1)] = "Left"),
            (t[(t.Right = 2)] = "Right");
        })(idt || (idt = {})),
        (function (t) {
          (t.XRUI_HOVER_ENTERED = "xrui-hover-entered"),
            (t.XRUI_HOVER_EXITED = "xrui-hover-exited"),
            (t.XRUI_HOVER_STAY = "xrui-hover-stay"),
            (t.XRUI_CLICK = "xrui-click"),
            (t.XRUI_UNCLICK = "xrui-unclick");
        })(sdt || (sdt = {})),
        (function (t) {
          (t.XR_CAPS_LOCK = "xr-caps-lock"),
            (t.XR_KEYBOARD_INIT = "xr-keyboard-init"),
            (t.XR_KEYBOARD_INPUT = "xr-keyboard-input"),
            (t.TO_LATIN = "to-latin"),
            (t.TO_SYMBOL = "to-symbol"),
            (t.TO_MATH_SYMBOL = "to-math-symbol");
        })(ndt || (ndt = {}));
      const Mdt = new Qi();
      var Pdt, Ndt;
      let Ldt;
      !(function (t) {
        (t[(t.NONE = 0)] = "NONE"),
          (t[(t.COLOR = 1)] = "COLOR"),
          (t[(t.SPRITE = 2)] = "SPRITE"),
          (t[(t.SCALE = 3)] = "SCALE");
      })(Pdt || (Pdt = {})),
        de(Pdt),
        (function (t) {
          (t[(t.NORMAL = 0)] = "NORMAL"),
            (t[(t.HOVER = 1)] = "HOVER"),
            (t[(t.PRESSED = 2)] = "PRESSED"),
            (t[(t.DISABLED = 3)] = "DISABLED");
        })(Ndt || (Ndt = {})),
        (function (t) {
          t.CLICK = "click";
        })(Ldt || (Ldt = {}));
      let Bdt,
        Fdt,
        Udt,
        kdt =
          ((rdt = Ca("cc.Button")),
          (adt = Ia(110)),
          (odt = Oa(CI)),
          (hdt = ao(Pf)),
          (ldt = ao(Pdt)),
          (cdt = ao(uC)),
          (udt = ao(uC)),
          (_dt = ao(uC)),
          (ddt = ao(uC)),
          (pdt = ao([Yd])),
          rdt(
            (mdt =
              adt(
                (mdt =
                  odt(
                    (((xdt = class extends np {
                      get target() {
                        return this._target || this.node;
                      }
                      set target(t) {
                        this._target !== t &&
                          (this._target &&
                            this._unregisterTargetEvent(this._target),
                          (this._target = t),
                          this._applyTarget());
                      }
                      get interactable() {
                        return this._interactable;
                      }
                      set interactable(t) {
                        this._interactable !== t &&
                          ((this._interactable = t),
                          this._updateState(),
                          this._interactable || this._resetState());
                      }
                      set _resizeToTarget(t) {
                        t && this._resizeNodeToTargetNode();
                      }
                      get transition() {
                        return this._transition;
                      }
                      set transition(t) {
                        this._transition !== t &&
                          (this._transition === Pdt.COLOR
                            ? this._updateColorTransition(Ndt.NORMAL)
                            : this._transition === Pdt.SPRITE &&
                              this._updateSpriteTransition(Ndt.NORMAL),
                          (this._transition = t),
                          this._updateState());
                      }
                      get normalColor() {
                        return this._normalColor;
                      }
                      set normalColor(t) {
                        this._normalColor !== t &&
                          (this._normalColor.set(t), this._updateState());
                      }
                      get pressedColor() {
                        return this._pressedColor;
                      }
                      set pressedColor(t) {
                        this._pressedColor !== t && this._pressedColor.set(t);
                      }
                      get hoverColor() {
                        return this._hoverColor;
                      }
                      set hoverColor(t) {
                        this._hoverColor !== t && this._hoverColor.set(t);
                      }
                      get disabledColor() {
                        return this._disabledColor;
                      }
                      set disabledColor(t) {
                        this._disabledColor !== t &&
                          (this._disabledColor.set(t), this._updateState());
                      }
                      get duration() {
                        return this._duration;
                      }
                      set duration(t) {
                        this._duration !== t && (this._duration = t);
                      }
                      get zoomScale() {
                        return this._zoomScale;
                      }
                      set zoomScale(t) {
                        this._zoomScale !== t && (this._zoomScale = t);
                      }
                      get normalSprite() {
                        return this._normalSprite;
                      }
                      set normalSprite(t) {
                        if (this._normalSprite === t) return;
                        this._normalSprite = t;
                        const e = Qn(this.node, !0)
                          ? this.node.getComponent(XD)
                          : null;
                        e && (e.spriteFrame = t), this._updateState();
                      }
                      get pressedSprite() {
                        return this._pressedSprite;
                      }
                      set pressedSprite(t) {
                        this._pressedSprite !== t &&
                          ((this._pressedSprite = t), this._updateState());
                      }
                      get hoverSprite() {
                        return this._hoverSprite;
                      }
                      set hoverSprite(t) {
                        this._hoverSprite !== t &&
                          ((this._hoverSprite = t), this._updateState());
                      }
                      get disabledSprite() {
                        return this._disabledSprite;
                      }
                      set disabledSprite(t) {
                        this._disabledSprite !== t &&
                          ((this._disabledSprite = t), this._updateState());
                      }
                      constructor() {
                        super(),
                          (this.clickEvents = gdt && gdt()),
                          (this._interactable = ydt && ydt()),
                          (this._transition = Tdt && Tdt()),
                          (this._normalColor = Sdt && Sdt()),
                          (this._hoverColor = Edt && Edt()),
                          (this._pressedColor = vdt && vdt()),
                          (this._disabledColor = bdt && bdt()),
                          (this._normalSprite = Adt && Adt()),
                          (this._hoverSprite = Cdt && Cdt()),
                          (this._pressedSprite = Odt && Odt()),
                          (this._disabledSprite = Idt && Idt()),
                          (this._duration = wdt && wdt()),
                          (this._zoomScale = Rdt && Rdt()),
                          (this._target = Ddt && Ddt()),
                          (this._pressed = !1),
                          (this._hovered = !1),
                          (this._fromColor = new Qi()),
                          (this._toColor = new Qi()),
                          (this._time = 0),
                          (this._transitionFinished = !0),
                          (this._fromScale = new Yi()),
                          (this._toScale = new Yi()),
                          (this._originalScale = null),
                          (this._sprite = null),
                          (this._targetScale = new Yi());
                      }
                      __preload() {
                        this.target || (this.target = this.node),
                          this._applyTarget(),
                          this._resetState();
                      }
                      onEnable() {
                        this._registerNodeEvent();
                      }
                      onDisable() {
                        this._resetState(), this._unregisterNodeEvent();
                      }
                      onDestroy() {
                        this.target.isValid &&
                          this._unregisterTargetEvent(this.target);
                      }
                      update(t) {
                        const e = this.target;
                        if (this._transitionFinished || !e) return;
                        if (
                          this._transition !== Pdt.COLOR &&
                          this._transition !== Pdt.SCALE
                        )
                          return;
                        this._time += t;
                        let i = 1;
                        if (
                          (this._duration > 0 &&
                            (i = this._time / this._duration),
                          i >= 1 && (i = 1),
                          this._transition === Pdt.COLOR)
                        ) {
                          const t = e._uiProps.uiComp;
                          Qi.lerp(Mdt, this._fromColor, this._toColor, i),
                            t && (t.color = Mdt);
                        } else
                          this.transition === Pdt.SCALE &&
                            (e.getScale(this._targetScale),
                            (this._targetScale.x = vi(
                              this._fromScale.x,
                              this._toScale.x,
                              i
                            )),
                            (this._targetScale.y = vi(
                              this._fromScale.y,
                              this._toScale.y,
                              i
                            )),
                            e.setScale(this._targetScale));
                        1 === i && (this._transitionFinished = !0);
                      }
                      _resizeNodeToTargetNode() {
                        this.target && this.target._uiProps.uiTransformComp;
                      }
                      _resetState() {
                        (this._pressed = !1), (this._hovered = !1);
                        const t = this.target;
                        if (!t) return;
                        const e = this._transition;
                        if (e === Pdt.COLOR && this._interactable) {
                          const e = t.getComponent(ew);
                          e && (e.color = this._normalColor);
                        } else
                          e === Pdt.SCALE &&
                            this._originalScale &&
                            t.setScale(this._originalScale);
                        this._transitionFinished = !0;
                      }
                      _registerNodeEvent() {
                        this.node.on(bf.TOUCH_START, this._onTouchBegan, this),
                          this.node.on(bf.TOUCH_MOVE, this._onTouchMove, this),
                          this.node.on(bf.TOUCH_END, this._onTouchEnded, this),
                          this.node.on(
                            bf.TOUCH_CANCEL,
                            this._onTouchCancel,
                            this
                          ),
                          this.node.on(
                            bf.MOUSE_ENTER,
                            this._onMouseMoveIn,
                            this
                          ),
                          this.node.on(
                            bf.MOUSE_LEAVE,
                            this._onMouseMoveOut,
                            this
                          ),
                          this.node.on(
                            sdt.XRUI_HOVER_ENTERED,
                            this._xrHoverEnter,
                            this
                          ),
                          this.node.on(
                            sdt.XRUI_HOVER_EXITED,
                            this._xrHoverExit,
                            this
                          ),
                          this.node.on(sdt.XRUI_CLICK, this._xrClick, this),
                          this.node.on(sdt.XRUI_UNCLICK, this._xrUnClick, this);
                      }
                      _registerTargetEvent(t) {
                        t.on(
                          bf.TRANSFORM_CHANGED,
                          this._onTargetTransformChanged,
                          this
                        );
                      }
                      _unregisterNodeEvent() {
                        this.node.off(bf.TOUCH_START, this._onTouchBegan, this),
                          this.node.off(bf.TOUCH_MOVE, this._onTouchMove, this),
                          this.node.off(bf.TOUCH_END, this._onTouchEnded, this),
                          this.node.off(
                            bf.TOUCH_CANCEL,
                            this._onTouchCancel,
                            this
                          ),
                          this.node.off(
                            bf.MOUSE_ENTER,
                            this._onMouseMoveIn,
                            this
                          ),
                          this.node.off(
                            bf.MOUSE_LEAVE,
                            this._onMouseMoveOut,
                            this
                          ),
                          this.node.off(
                            sdt.XRUI_HOVER_ENTERED,
                            this._xrHoverEnter,
                            this
                          ),
                          this.node.off(
                            sdt.XRUI_HOVER_EXITED,
                            this._xrHoverExit,
                            this
                          ),
                          this.node.off(sdt.XRUI_CLICK, this._xrClick, this),
                          this.node.off(
                            sdt.XRUI_UNCLICK,
                            this._xrUnClick,
                            this
                          );
                      }
                      _unregisterTargetEvent(t) {
                        t.off(bf.TRANSFORM_CHANGED);
                      }
                      _getTargetSprite(t) {
                        let e = null;
                        return t && (e = t.getComponent(XD)), e;
                      }
                      _applyTarget() {
                        this.target &&
                          ((this._sprite = this._getTargetSprite(this.target)),
                          this._originalScale ||
                            (this._originalScale = new Yi()),
                          Yi.copy(this._originalScale, this.target.scale),
                          this._registerTargetEvent(this.target));
                      }
                      _onTargetSpriteFrameChanged(t) {
                        this._transition === Pdt.SPRITE &&
                          this._setCurrentStateSpriteFrame(t.spriteFrame);
                      }
                      _setCurrentStateSpriteFrame(t) {
                        if (t)
                          switch (this._getButtonState()) {
                            case Ndt.NORMAL:
                              this._normalSprite = t;
                              break;
                            case Ndt.HOVER:
                              this._hoverSprite = t;
                              break;
                            case Ndt.PRESSED:
                              this._pressedSprite = t;
                              break;
                            case Ndt.DISABLED:
                              this._disabledSprite = t;
                          }
                      }
                      _onTargetColorChanged(t) {
                        this._transition === Pdt.COLOR &&
                          this._setCurrentStateColor(t);
                      }
                      _setCurrentStateColor(t) {
                        switch (this._getButtonState()) {
                          case Ndt.NORMAL:
                            this._normalColor = t;
                            break;
                          case Ndt.HOVER:
                            this._hoverColor = t;
                            break;
                          case Ndt.PRESSED:
                            this._pressedColor = t;
                            break;
                          case Ndt.DISABLED:
                            this._disabledColor = t;
                        }
                      }
                      _onTargetTransformChanged(t) {
                        t & Cf.SCALE &&
                          this._originalScale &&
                          this._transition === Pdt.SCALE &&
                          this._transitionFinished &&
                          Yi.copy(this._originalScale, this.target.scale);
                      }
                      _onTouchBegan(t) {
                        this._interactable &&
                          this.enabledInHierarchy &&
                          ((this._pressed = !0),
                          this._updateState(),
                          t && (t.propagationStopped = !0));
                      }
                      _onTouchMove(t) {
                        if (
                          !this._interactable ||
                          !this.enabledInHierarchy ||
                          !this._pressed
                        )
                          return;
                        if (!t) return;
                        const e = t.touch;
                        if (!e) return;
                        const i = this.node._uiProps.uiTransformComp.hitTest(
                          e.getLocation(),
                          t.windowId
                        );
                        if (
                          this._transition === Pdt.SCALE &&
                          this.target &&
                          this._originalScale
                        )
                          i
                            ? (Yi.copy(this._fromScale, this._originalScale),
                              Yi.multiplyScalar(
                                this._toScale,
                                this._originalScale,
                                this._zoomScale
                              ),
                              (this._transitionFinished = !1))
                            : ((this._time = 0),
                              (this._transitionFinished = !0),
                              this.target.setScale(this._originalScale));
                        else {
                          let t;
                          (t = i ? Ndt.PRESSED : Ndt.NORMAL),
                            this._applyTransition(t);
                        }
                        t && (t.propagationStopped = !0);
                      }
                      _onTouchEnded(t) {
                        this._interactable &&
                          this.enabledInHierarchy &&
                          (this._pressed &&
                            (Yd.emitEvents(this.clickEvents, t),
                            Qn(this.node, !0) &&
                              this.node.emit(Ldt.CLICK, this)),
                          (this._pressed = !1),
                          this._updateState(),
                          t && (t.propagationStopped = !0));
                      }
                      _onTouchCancel(t) {
                        this._interactable &&
                          this.enabledInHierarchy &&
                          ((this._pressed = !1), this._updateState());
                      }
                      _onMouseMoveIn(t) {
                        !this._pressed &&
                          this.interactable &&
                          this.enabledInHierarchy &&
                          (this._transition !== Pdt.SPRITE ||
                            this._hoverSprite) &&
                          (this._hovered ||
                            ((this._hovered = !0), this._updateState()));
                      }
                      _onMouseMoveOut(t) {
                        this._hovered &&
                          ((this._hovered = !1), this._updateState());
                      }
                      _updateState() {
                        const t = this._getButtonState();
                        this._applyTransition(t);
                      }
                      _getButtonState() {
                        let t = Ndt.NORMAL;
                        return (
                          this._interactable
                            ? this._pressed
                              ? (t = Ndt.PRESSED)
                              : this._hovered && (t = Ndt.HOVER)
                            : (t = Ndt.DISABLED),
                          t
                        );
                      }
                      _updateColorTransition(t) {
                        var e;
                        const i = this._getColorByState(t),
                          s =
                            null === (e = this.target) || void 0 === e
                              ? void 0
                              : e.getComponent(ew);
                        s &&
                          (t === Ndt.DISABLED
                            ? ((s.color = i), (this._transitionFinished = !0))
                            : ((this._fromColor = s.color.clone()),
                              (this._toColor = i),
                              (this._time = 0),
                              (this._transitionFinished = !1)));
                      }
                      _updateSpriteTransition(t) {
                        const e = this._getSpriteFrameByState(t);
                        this._sprite && e && (this._sprite.spriteFrame = e);
                      }
                      _updateScaleTransition(t) {
                        this._interactable &&
                          (t === Ndt.PRESSED
                            ? this._zoomUp()
                            : this._zoomBack());
                      }
                      _zoomUp() {
                        this._originalScale &&
                          (Yi.copy(this._fromScale, this._originalScale),
                          Yi.multiplyScalar(
                            this._toScale,
                            this._originalScale,
                            this._zoomScale
                          ),
                          (this._time = 0),
                          (this._transitionFinished = !1));
                      }
                      _zoomBack() {
                        this.target &&
                          this._originalScale &&
                          (Yi.copy(this._fromScale, this.target.scale),
                          Yi.copy(this._toScale, this._originalScale),
                          (this._time = 0),
                          (this._transitionFinished = !1));
                      }
                      _applyTransition(t) {
                        const e = this._transition;
                        e === Pdt.COLOR
                          ? this._updateColorTransition(t)
                          : e === Pdt.SPRITE
                          ? this._updateSpriteTransition(t)
                          : e === Pdt.SCALE && this._updateScaleTransition(t);
                      }
                      _getSpriteFrameByState(t) {
                        switch (t) {
                          case Ndt.NORMAL:
                            return this._normalSprite;
                          case Ndt.DISABLED:
                            return this._disabledSprite;
                          case Ndt.HOVER:
                            return this.hoverSprite;
                          case Ndt.PRESSED:
                            return this._pressedSprite;
                          default:
                            return null;
                        }
                      }
                      _getColorByState(t) {
                        switch (t) {
                          case Ndt.NORMAL:
                            return this._normalColor;
                          case Ndt.DISABLED:
                            return this._disabledColor;
                          case Ndt.HOVER:
                            return this._hoverColor;
                          case Ndt.PRESSED:
                            return this._pressedColor;
                          default:
                            return new Qi();
                        }
                      }
                      _xrHoverEnter() {
                        this._onMouseMoveIn(), this._updateState();
                      }
                      _xrHoverExit() {
                        this._onMouseMoveOut(),
                          this._pressed &&
                            ((this._pressed = !1), this._updateState());
                      }
                      _xrClick() {
                        this._interactable &&
                          this.enabledInHierarchy &&
                          ((this._pressed = !0), this._updateState());
                      }
                      _xrUnClick() {
                        this._interactable &&
                          this.enabledInHierarchy &&
                          (this._pressed &&
                            (Yd.emitEvents(this.clickEvents, this),
                            this.node.emit(Ldt.CLICK, this)),
                          (this._pressed = !1),
                          this._updateState());
                      }
                    }).Transition = Pdt),
                    (xdt.EventType = Ldt),
                    s(
                      (fdt = xdt).prototype,
                      "target",
                      [hdt],
                      Object.getOwnPropertyDescriptor(fdt.prototype, "target"),
                      fdt.prototype
                    ),
                    s(
                      fdt.prototype,
                      "transition",
                      [ldt],
                      Object.getOwnPropertyDescriptor(
                        fdt.prototype,
                        "transition"
                      ),
                      fdt.prototype
                    ),
                    s(
                      fdt.prototype,
                      "normalSprite",
                      [cdt],
                      Object.getOwnPropertyDescriptor(
                        fdt.prototype,
                        "normalSprite"
                      ),
                      fdt.prototype
                    ),
                    s(
                      fdt.prototype,
                      "pressedSprite",
                      [udt],
                      Object.getOwnPropertyDescriptor(
                        fdt.prototype,
                        "pressedSprite"
                      ),
                      fdt.prototype
                    ),
                    s(
                      fdt.prototype,
                      "hoverSprite",
                      [_dt],
                      Object.getOwnPropertyDescriptor(
                        fdt.prototype,
                        "hoverSprite"
                      ),
                      fdt.prototype
                    ),
                    s(
                      fdt.prototype,
                      "disabledSprite",
                      [ddt],
                      Object.getOwnPropertyDescriptor(
                        fdt.prototype,
                        "disabledSprite"
                      ),
                      fdt.prototype
                    ),
                    (gdt = fa(
                      fdt.prototype,
                      "clickEvents",
                      [pdt, Na],
                      function () {
                        return [];
                      }
                    )),
                    (ydt = fa(
                      fdt.prototype,
                      "_interactable",
                      [Na],
                      function () {
                        return !0;
                      }
                    )),
                    (Tdt = fa(fdt.prototype, "_transition", [Na], function () {
                      return Pdt.NONE;
                    })),
                    (Sdt = fa(fdt.prototype, "_normalColor", [Na], function () {
                      return Qi.WHITE.clone();
                    })),
                    (Edt = fa(fdt.prototype, "_hoverColor", [Na], function () {
                      return new Qi(211, 211, 211, 255);
                    })),
                    (vdt = fa(
                      fdt.prototype,
                      "_pressedColor",
                      [Na],
                      function () {
                        return Qi.WHITE.clone();
                      }
                    )),
                    (bdt = fa(
                      fdt.prototype,
                      "_disabledColor",
                      [Na],
                      function () {
                        return new Qi(124, 124, 124, 255);
                      }
                    )),
                    (Adt = fa(
                      fdt.prototype,
                      "_normalSprite",
                      [Na],
                      function () {
                        return null;
                      }
                    )),
                    (Cdt = fa(fdt.prototype, "_hoverSprite", [Na], function () {
                      return null;
                    })),
                    (Odt = fa(
                      fdt.prototype,
                      "_pressedSprite",
                      [Na],
                      function () {
                        return null;
                      }
                    )),
                    (Idt = fa(
                      fdt.prototype,
                      "_disabledSprite",
                      [Na],
                      function () {
                        return null;
                      }
                    )),
                    (wdt = fa(fdt.prototype, "_duration", [Na], function () {
                      return 0.1;
                    })),
                    (Rdt = fa(fdt.prototype, "_zoomScale", [Na], function () {
                      return 1.2;
                    })),
                    (Ddt = fa(fdt.prototype, "_target", [Na], function () {
                      return null;
                    })),
                    (mdt = fdt))
                  ) || mdt)
              ) || mdt)
          ) || mdt);
      t({ Button: kdt, ButtonComponent: kdt }), (a.Button = kdt);
      (function (t) {
        (t[(t.DEFAULT = 0)] = "DEFAULT"),
          (t[(t.DONE = 1)] = "DONE"),
          (t[(t.SEND = 2)] = "SEND"),
          (t[(t.SEARCH = 3)] = "SEARCH"),
          (t[(t.GO = 4)] = "GO"),
          (t[(t.NEXT = 5)] = "NEXT");
      })(Bdt || (Bdt = {})),
        ce(Bdt),
        (function (t) {
          (t[(t.ANY = 0)] = "ANY"),
            (t[(t.EMAIL_ADDR = 1)] = "EMAIL_ADDR"),
            (t[(t.NUMERIC = 2)] = "NUMERIC"),
            (t[(t.PHONE_NUMBER = 3)] = "PHONE_NUMBER"),
            (t[(t.URL = 4)] = "URL"),
            (t[(t.DECIMAL = 5)] = "DECIMAL"),
            (t[(t.SINGLE_LINE = 6)] = "SINGLE_LINE");
        })(Fdt || (Fdt = {})),
        ce(Fdt),
        (function (t) {
          (t[(t.PASSWORD = 0)] = "PASSWORD"),
            (t[(t.SENSITIVE = 1)] = "SENSITIVE"),
            (t[(t.INITIAL_CAPS_WORD = 2)] = "INITIAL_CAPS_WORD"),
            (t[(t.INITIAL_CAPS_SENTENCE = 3)] = "INITIAL_CAPS_SENTENCE"),
            (t[(t.INITIAL_CAPS_ALL_CHARACTERS = 4)] =
              "INITIAL_CAPS_ALL_CHARACTERS"),
            (t[(t.DEFAULT = 5)] = "DEFAULT"),
            (t[(t.NEW_PASSWORD = 6)] = "NEW_PASSWORD");
        })(Udt || (Udt = {})),
        ce(Udt);
      var zdt,
        Hdt,
        Gdt,
        Vdt,
        jdt,
        Wdt,
        Xdt,
        Ydt,
        Kdt,
        qdt,
        $dt,
        Zdt,
        Qdt,
        Jdt,
        tpt,
        ept,
        ipt,
        spt,
        npt,
        rpt,
        apt,
        opt,
        hpt,
        lpt,
        cpt,
        upt,
        _pt,
        dpt,
        ppt,
        mpt;
      h.document,
        new ms(),
        new ms(),
        new Yi(),
        (function (t) {
          (t.EDITING_DID_BEGAN = "editing-did-began"),
            (t.EDITING_DID_ENDED = "editing-did-ended"),
            (t.TEXT_CHANGED = "text-changed"),
            (t.EDITING_RETURN = "editing-return"),
            (t.XR_EDITING_DID_BEGAN = "xr-editing-did-began"),
            (t.XR_EDITING_DID_ENDED = "xr-editing-did-ended");
        })(mpt || (mpt = {}));
      let fpt =
        ((zdt = Ca("cc.EditBox")),
        (Hdt = Ia(110)),
        (Gdt = Oa(CI)),
        (Vdt = ao(Ww)),
        (jdt = ao(Ww)),
        (Wdt = ao(uC)),
        (Xdt = ao(Udt)),
        (Ydt = ao(Fdt)),
        (Kdt = ao(Bdt)),
        (qdt = ao([Yd])),
        ($dt = ao([Yd])),
        (Zdt = ao([Yd])),
        (Qdt = ao([Yd])),
        zdt(
          (Jdt =
            Hdt(
              (Jdt =
                Gdt(
                  (((ppt = class t extends np {
                    get string() {
                      return this._string;
                    }
                    set string(t) {
                      this._maxLength >= 0 &&
                        t.length >= this._maxLength &&
                        (t = t.slice(0, this._maxLength)),
                        this._string !== t &&
                          ((this._string = t), this._updateString(t));
                    }
                    get placeholder() {
                      return this._placeholderLabel
                        ? this._placeholderLabel.string
                        : "";
                    }
                    set placeholder(t) {
                      this._placeholderLabel &&
                        (this._placeholderLabel.string = t);
                    }
                    get textLabel() {
                      return this._textLabel;
                    }
                    set textLabel(t) {
                      this._textLabel !== t &&
                        ((this._textLabel = t),
                        this._textLabel &&
                          (this._updateTextLabel(), this._updateLabels()));
                    }
                    get placeholderLabel() {
                      return this._placeholderLabel;
                    }
                    set placeholderLabel(t) {
                      this._placeholderLabel !== t &&
                        ((this._placeholderLabel = t),
                        this._placeholderLabel &&
                          (this._updatePlaceholderLabel(),
                          this._updateLabels()));
                    }
                    get backgroundImage() {
                      return this._backgroundImage;
                    }
                    set backgroundImage(t) {
                      this._backgroundImage !== t &&
                        ((this._backgroundImage = t),
                        this._ensureBackgroundSprite(),
                        (this._background.spriteFrame = t));
                    }
                    get inputFlag() {
                      return this._inputFlag;
                    }
                    set inputFlag(t) {
                      this._inputFlag !== t &&
                        ((this._inputFlag = t),
                        this._updateString(this._string));
                    }
                    get inputMode() {
                      return this._inputMode;
                    }
                    set inputMode(t) {
                      this._inputMode !== t &&
                        ((this._inputMode = t),
                        this._updateTextLabel(),
                        this._updatePlaceholderLabel());
                    }
                    get returnType() {
                      return this._returnType;
                    }
                    set returnType(t) {
                      this._returnType = t;
                    }
                    get maxLength() {
                      return this._maxLength;
                    }
                    set maxLength(t) {
                      this._maxLength = t;
                    }
                    get tabIndex() {
                      return this._tabIndex;
                    }
                    set tabIndex(t) {
                      this._tabIndex !== t &&
                        ((this._tabIndex = t),
                        this._impl && this._impl.setTabIndex(t));
                    }
                    constructor() {
                      super(),
                        (this.editingDidBegan = ept && ept()),
                        (this.textChanged = ipt && ipt()),
                        (this.editingDidEnded = spt && spt()),
                        (this.editingReturn = npt && npt()),
                        (this._impl = null),
                        (this._background = null),
                        (this._textLabel = rpt && rpt()),
                        (this._placeholderLabel = apt && apt()),
                        (this._returnType = opt && opt()),
                        (this._string = hpt && hpt()),
                        (this._tabIndex = lpt && lpt()),
                        (this._backgroundImage = cpt && cpt()),
                        (this._inputFlag = upt && upt()),
                        (this._inputMode = _pt && _pt()),
                        (this._maxLength = dpt && dpt()),
                        (this._isLabelVisible = !1),
                        (this._editBoxBottom = 0);
                    }
                    __preload() {
                      this._init();
                    }
                    onEnable() {
                      this._registerEvent(),
                        this._ensureBackgroundSprite(),
                        this._impl && this._impl.onEnable();
                    }
                    _beforeDraw() {
                      this._impl && this._impl.beforeDraw();
                    }
                    onDisable() {
                      this._unregisterEvent(),
                        this._unregisterBackgroundEvent(),
                        this._impl && this._impl.onDisable();
                    }
                    onDestroy() {
                      Lv.off(Nv.EVENT_BEFORE_DRAW, this._beforeDraw, this),
                        this._impl && this._impl.clear();
                    }
                    setFocus() {
                      this._impl && this._impl.setFocus(!0);
                    }
                    focus() {
                      this._impl && this._impl.setFocus(!0);
                    }
                    blur() {
                      this._impl && this._impl.setFocus(!1);
                    }
                    isFocused() {
                      return !!this._impl && this._impl.isFocused();
                    }
                    _editBoxEditingDidBegan() {
                      Yd.emitEvents(this.editingDidBegan, this),
                        this.node.emit(mpt.EDITING_DID_BEGAN, this);
                    }
                    _editBoxEditingDidEnded(t) {
                      Yd.emitEvents(this.editingDidEnded, this),
                        this.node.emit(mpt.EDITING_DID_ENDED, this, t);
                    }
                    _editBoxTextChanged(t) {
                      (t = this._updateLabelStringStyle(t, !0)),
                        (this.string = t),
                        Yd.emitEvents(this.textChanged, t, this),
                        this.node.emit(mpt.TEXT_CHANGED, this);
                    }
                    _editBoxEditingReturn(t) {
                      Yd.emitEvents(this.editingReturn, this),
                        this.node.emit(mpt.EDITING_RETURN, this, t);
                    }
                    _showLabels() {
                      (this._isLabelVisible = !0), this._updateLabels();
                    }
                    _hideLabels() {
                      (this._isLabelVisible = !1),
                        this._textLabel && (this._textLabel.node.active = !1),
                        this._placeholderLabel &&
                          (this._placeholderLabel.node.active = !1);
                    }
                    _onTouchBegan(t) {
                      t.propagationStopped = !0;
                    }
                    _onTouchCancel(t) {
                      t.propagationStopped = !0;
                    }
                    _onTouchEnded(t) {
                      this._impl && this._impl.beginEditing(),
                        (t.propagationStopped = !0);
                    }
                    _init() {
                      this._updatePlaceholderLabel(),
                        this._updateTextLabel(),
                        (this._isLabelVisible = !0),
                        this.node.on(
                          bf.SIZE_CHANGED,
                          this._resizeChildNodes,
                          this
                        ),
                        Lv.on(Nv.EVENT_BEFORE_DRAW, this._beforeDraw, this),
                        (this._impl = new t._EditBoxImpl()).init(this),
                        this._updateString(this._string),
                        this._syncSize();
                    }
                    _ensureBackgroundSprite() {
                      if (!this._background) {
                        let t = this.node.getComponent(XD);
                        t || (t = this.node.addComponent(XD)),
                          t !== this._background &&
                            ((t.type = XD.Type.SLICED),
                            (t.spriteFrame = this._backgroundImage),
                            (this._background = t),
                            this._registerBackgroundEvent());
                      }
                    }
                    _updateTextLabel() {
                      let t = this._textLabel;
                      if (!t) {
                        let e = this.node.getChildByName("TEXT_LABEL");
                        e ||
                          ((e = new Pf("TEXT_LABEL")),
                          (e.layer = this.node.layer)),
                          (t = e.getComponent(Ww)),
                          t || (t = e.addComponent(Ww)),
                          (e.parent = this.node),
                          (this._textLabel = t);
                      }
                      this._inputMode === Fdt.ANY
                        ? ((t.verticalAlign = Gw.TOP), (t.enableWrapText = !0))
                        : (t.enableWrapText = !1),
                        (t.string = this._updateLabelStringStyle(this._string));
                    }
                    _updatePlaceholderLabel() {
                      let t = this._placeholderLabel;
                      if (!t) {
                        let e = this.node.getChildByName("PLACEHOLDER_LABEL");
                        e ||
                          ((e = new Pf("PLACEHOLDER_LABEL")),
                          (e.layer = this.node.layer)),
                          (t = e.getComponent(Ww)),
                          t || (t = e.addComponent(Ww)),
                          (e.parent = this.node),
                          (this._placeholderLabel = t);
                      }
                      this._inputMode === Fdt.ANY
                        ? (t.enableWrapText = !0)
                        : (t.enableWrapText = !1),
                        (t.string = this.placeholder);
                    }
                    _syncSize() {
                      const t = this.node._uiProps.uiTransformComp,
                        e = t.contentSize;
                      if (this._background) {
                        const i =
                          this._background.node._uiProps.uiTransformComp;
                        (i.anchorPoint = t.anchorPoint), i.setContentSize(e);
                      }
                      this._updateLabelPosition(e),
                        this._impl && this._impl.setSize(e.width, e.height);
                    }
                    _updateLabels() {
                      if (this._isLabelVisible) {
                        const t = this._string;
                        this._textLabel &&
                          (this._textLabel.node.active = "" !== t),
                          this._placeholderLabel &&
                            (this._placeholderLabel.node.active = "" === t);
                      }
                    }
                    _updateString(t) {
                      const e = this._textLabel;
                      if (!e) return;
                      let i = t;
                      i && (i = this._updateLabelStringStyle(i)),
                        (e.string = i),
                        this._updateLabels();
                    }
                    _updateLabelStringStyle(t, e = !1) {
                      const i = this._inputFlag;
                      if (e || (i !== Udt.PASSWORD && i !== Udt.NEW_PASSWORD))
                        i === Udt.INITIAL_CAPS_ALL_CHARACTERS
                          ? (t = t.toUpperCase())
                          : i === Udt.INITIAL_CAPS_WORD
                          ? (t = t.replace(/(?:^|\s)\S/g, (t) =>
                              t.toUpperCase()
                            ))
                          : i === Udt.INITIAL_CAPS_SENTENCE &&
                            (t = (s = t).charAt(0).toUpperCase() + s.slice(1));
                      else {
                        let e = "";
                        const i = t.length;
                        for (let t = 0; t < i; ++t) e += "●";
                        t = e;
                      }
                      var s;
                      return t;
                    }
                    _registerEvent() {
                      this.node.on(bf.TOUCH_START, this._onTouchBegan, this),
                        this.node.on(bf.TOUCH_END, this._onTouchEnded, this),
                        this.node.on(sdt.XRUI_UNCLICK, this._xrUnClick, this),
                        this.node.on(
                          ndt.XR_KEYBOARD_INPUT,
                          this._xrKeyBoardInput,
                          this
                        );
                    }
                    _unregisterEvent() {
                      this.node.off(bf.TOUCH_START, this._onTouchBegan, this),
                        this.node.off(bf.TOUCH_END, this._onTouchEnded, this),
                        this.node.off(sdt.XRUI_UNCLICK, this._xrUnClick, this),
                        this.node.off(
                          ndt.XR_KEYBOARD_INPUT,
                          this._xrKeyBoardInput,
                          this
                        );
                    }
                    _onBackgroundSpriteFrameChanged() {
                      this._background &&
                        (this.backgroundImage = this._background.spriteFrame);
                    }
                    _registerBackgroundEvent() {
                      const t = this._background && this._background.node;
                      null == t ||
                        t.on(
                          XD.EventType.SPRITE_FRAME_CHANGED,
                          this._onBackgroundSpriteFrameChanged,
                          this
                        );
                    }
                    _unregisterBackgroundEvent() {
                      const t = this._background && this._background.node;
                      null == t ||
                        t.off(
                          XD.EventType.SPRITE_FRAME_CHANGED,
                          this._onBackgroundSpriteFrameChanged,
                          this
                        );
                    }
                    _updateLabelPosition(t) {
                      const e = this.node._uiProps.uiTransformComp,
                        i = -e.anchorX * e.width,
                        s = -e.anchorY * e.height,
                        n = this._placeholderLabel,
                        r = this._textLabel;
                      r &&
                        (r.node._uiProps.uiTransformComp.setContentSize(
                          t.width - 2,
                          t.height
                        ),
                        r.node.setPosition(
                          i + 2,
                          s + t.height,
                          r.node.position.z
                        ),
                        this._inputMode === Fdt.ANY &&
                          (r.verticalAlign = Gw.TOP),
                        (r.enableWrapText = this._inputMode === Fdt.ANY)),
                        n &&
                          (n.node._uiProps.uiTransformComp.setContentSize(
                            t.width - 2,
                            t.height
                          ),
                          n.node.setPosition(
                            i + 2,
                            s + t.height,
                            n.node.position.z
                          ),
                          (n.enableWrapText = this._inputMode === Fdt.ANY));
                    }
                    _resizeChildNodes() {
                      const t = this.node._uiProps.uiTransformComp,
                        e = this._textLabel && this._textLabel.node;
                      e &&
                        (e.setPosition(
                          -t.width / 2,
                          t.height / 2,
                          e.position.z
                        ),
                        e._uiProps.uiTransformComp.setContentSize(
                          t.contentSize
                        ));
                      const i =
                        this._placeholderLabel && this._placeholderLabel.node;
                      i &&
                        (i.setPosition(
                          -t.width / 2,
                          t.height / 2,
                          i.position.z
                        ),
                        i._uiProps.uiTransformComp.setContentSize(
                          t.contentSize
                        ));
                      const s = this._background && this._background.node;
                      s &&
                        s._uiProps.uiTransformComp.setContentSize(
                          t.contentSize
                        ),
                        this._syncSize();
                    }
                    _xrUnClick() {
                      this.node.emit(
                        mpt.XR_EDITING_DID_BEGAN,
                        this._maxLength,
                        this.string
                      );
                    }
                    _xrKeyBoardInput(t) {
                      this.string = t;
                    }
                    setEditBoxPosition(t) {
                      (this._editBoxBottom = t),
                        zr.os === zr.OS.ANDROID &&
                          $2.reflection.callStaticMethod(
                            "com/cocos/lib/CocosEditBoxActivity",
                            "setEditBoxPosition",
                            "(F)V",
                            t
                          );
                    }
                    adjustLayoutPosition() {
                      if (!zr.isMobile || !this.node || !this.node.parent)
                        return;
                      const t = this.node._uiProps.uiTransformComp;
                      if (!t) return;
                      const e = this.node.getWorldPosition(),
                        i = Lv.root.batcher2D.getFirstRenderCamera(this.node);
                      if (i) {
                        const s = new Yi(),
                          n = i.worldToScreen(s, e);
                        GA.getVisibleSize().height;
                        const r = t.contentSize,
                          a = this.node.getWorldScale(),
                          o = r.height * a.y,
                          h = GA.getDevicePixelRatio(),
                          l = (n.y - o / 2) * h;
                        zr.os === zr.OS.ANDROID && this.setEditBoxPosition(l);
                      }
                    }
                  })._EditBoxImpl = class {
                    constructor() {
                      (this._editing = !1), (this._delegate = null);
                    }
                    init(t) {}
                    onEnable() {}
                    beforeDraw() {}
                    onDisable() {
                      this._editing && this.endEditing();
                    }
                    clear() {
                      this._delegate = null;
                    }
                    setTabIndex(t) {}
                    setSize(t, e) {}
                    setFocus(t) {
                      t ? this.beginEditing() : this.endEditing();
                    }
                    isFocused() {
                      return this._editing;
                    }
                    beginEditing() {}
                    endEditing() {}
                  }),
                  (ppt.KeyboardReturnType = Bdt),
                  (ppt.InputFlag = Udt),
                  (ppt.InputMode = Fdt),
                  (ppt.EventType = mpt),
                  s(
                    (tpt = ppt).prototype,
                    "textLabel",
                    [Vdt],
                    Object.getOwnPropertyDescriptor(tpt.prototype, "textLabel"),
                    tpt.prototype
                  ),
                  s(
                    tpt.prototype,
                    "placeholderLabel",
                    [jdt],
                    Object.getOwnPropertyDescriptor(
                      tpt.prototype,
                      "placeholderLabel"
                    ),
                    tpt.prototype
                  ),
                  s(
                    tpt.prototype,
                    "backgroundImage",
                    [Wdt],
                    Object.getOwnPropertyDescriptor(
                      tpt.prototype,
                      "backgroundImage"
                    ),
                    tpt.prototype
                  ),
                  s(
                    tpt.prototype,
                    "inputFlag",
                    [Xdt],
                    Object.getOwnPropertyDescriptor(tpt.prototype, "inputFlag"),
                    tpt.prototype
                  ),
                  s(
                    tpt.prototype,
                    "inputMode",
                    [Ydt],
                    Object.getOwnPropertyDescriptor(tpt.prototype, "inputMode"),
                    tpt.prototype
                  ),
                  s(
                    tpt.prototype,
                    "returnType",
                    [Kdt],
                    Object.getOwnPropertyDescriptor(
                      tpt.prototype,
                      "returnType"
                    ),
                    tpt.prototype
                  ),
                  (ept = fa(
                    tpt.prototype,
                    "editingDidBegan",
                    [qdt, Na],
                    function () {
                      return [];
                    }
                  )),
                  (ipt = fa(
                    tpt.prototype,
                    "textChanged",
                    [$dt, Na],
                    function () {
                      return [];
                    }
                  )),
                  (spt = fa(
                    tpt.prototype,
                    "editingDidEnded",
                    [Zdt, Na],
                    function () {
                      return [];
                    }
                  )),
                  (npt = fa(
                    tpt.prototype,
                    "editingReturn",
                    [Qdt, Na],
                    function () {
                      return [];
                    }
                  )),
                  (rpt = fa(tpt.prototype, "_textLabel", [Na], function () {
                    return null;
                  })),
                  (apt = fa(
                    tpt.prototype,
                    "_placeholderLabel",
                    [Na],
                    function () {
                      return null;
                    }
                  )),
                  (opt = fa(tpt.prototype, "_returnType", [Na], function () {
                    return Bdt.DEFAULT;
                  })),
                  (hpt = fa(tpt.prototype, "_string", [Na], function () {
                    return "";
                  })),
                  (lpt = fa(tpt.prototype, "_tabIndex", [Na], function () {
                    return 0;
                  })),
                  (cpt = fa(
                    tpt.prototype,
                    "_backgroundImage",
                    [Na],
                    function () {
                      return null;
                    }
                  )),
                  (upt = fa(tpt.prototype, "_inputFlag", [Na], function () {
                    return Udt.DEFAULT;
                  })),
                  (_pt = fa(tpt.prototype, "_inputMode", [Na], function () {
                    return Fdt.ANY;
                  })),
                  (dpt = fa(tpt.prototype, "_maxLength", [Na], function () {
                    return 20;
                  })),
                  (Jdt = tpt))
                ) || Jdt)
            ) || Jdt)
        ) || Jdt);
      var gpt,
        ypt,
        Tpt,
        Spt,
        Ept,
        vpt,
        bpt,
        Apt,
        Cpt,
        Opt,
        Ipt,
        wpt,
        Rpt,
        Dpt,
        xpt,
        Mpt,
        Ppt,
        Npt,
        Lpt,
        Bpt,
        Fpt,
        Upt,
        kpt,
        zpt,
        Hpt,
        Gpt,
        Vpt,
        jpt,
        Wpt,
        Xpt,
        Ypt,
        Kpt,
        qpt,
        $pt;
      t({ EditBox: fpt, EditBoxComponent: fpt }),
        (a.internal.EditBox = fpt),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.HORIZONTAL = 1)] = "HORIZONTAL"),
            (t[(t.VERTICAL = 2)] = "VERTICAL"),
            (t[(t.GRID = 3)] = "GRID");
        })(Wpt || (Wpt = {})),
        de(Wpt),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.CONTAINER = 1)] = "CONTAINER"),
            (t[(t.CHILDREN = 2)] = "CHILDREN");
        })(Xpt || (Xpt = {})),
        de(Xpt),
        (function (t) {
          (t[(t.HORIZONTAL = 0)] = "HORIZONTAL"),
            (t[(t.VERTICAL = 1)] = "VERTICAL");
        })(Ypt || (Ypt = {})),
        de(Ypt),
        (function (t) {
          (t[(t.BOTTOM_TO_TOP = 0)] = "BOTTOM_TO_TOP"),
            (t[(t.TOP_TO_BOTTOM = 1)] = "TOP_TO_BOTTOM");
        })(Kpt || (Kpt = {})),
        de(Kpt),
        (function (t) {
          (t[(t.LEFT_TO_RIGHT = 0)] = "LEFT_TO_RIGHT"),
            (t[(t.RIGHT_TO_LEFT = 1)] = "RIGHT_TO_LEFT");
        })(qpt || (qpt = {})),
        de(qpt),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.FIXED_ROW = 1)] = "FIXED_ROW"),
            (t[(t.FIXED_COL = 2)] = "FIXED_COL");
        })($pt || ($pt = {})),
        de($pt);
      const Zpt = new Yi();
      let Qpt =
        ((gpt = Ca("cc.Layout")),
        (ypt = Ia(110)),
        (Tpt = Oa(CI)),
        (Spt = ao(Wpt)),
        (Ept = ao(Xpt)),
        (vpt = ao(Ypt)),
        (bpt = ao(Kpt)),
        (Apt = ao(qpt)),
        (Cpt = ao($pt)),
        gpt(
          (Opt =
            ypt(
              (Opt =
                Tpt(
                  (((jpt = class extends np {
                    constructor() {
                      super(),
                        (this._resizeMode = wpt && wpt()),
                        (this._layoutType = Rpt && Rpt()),
                        (this._cellSize = Dpt && Dpt()),
                        (this._startAxis = xpt && xpt()),
                        (this._paddingLeft = Mpt && Mpt()),
                        (this._paddingRight = Ppt && Ppt()),
                        (this._paddingTop = Npt && Npt()),
                        (this._paddingBottom = Lpt && Lpt()),
                        (this._spacingX = Bpt && Bpt()),
                        (this._spacingY = Fpt && Fpt()),
                        (this._verticalDirection = Upt && Upt()),
                        (this._horizontalDirection = kpt && kpt()),
                        (this._constraint = zpt && zpt()),
                        (this._constraintNum = Hpt && Hpt()),
                        (this._affectedByScale = Gpt && Gpt()),
                        (this._isAlign = Vpt && Vpt()),
                        (this._layoutSize = new ws(300, 200)),
                        (this._layoutDirty = !0),
                        (this._childrenDirty = !1),
                        (this._usefulLayoutObj = []),
                        (this._init = !1);
                    }
                    get alignHorizontal() {
                      return this._isAlign;
                    }
                    set alignHorizontal(t) {
                      this._layoutType === Wpt.HORIZONTAL &&
                        ((this._isAlign = t), this._doLayoutDirty());
                    }
                    get alignVertical() {
                      return this._isAlign;
                    }
                    set alignVertical(t) {
                      this._layoutType === Wpt.VERTICAL &&
                        ((this._isAlign = t), this._doLayoutDirty());
                    }
                    get type() {
                      return this._layoutType;
                    }
                    set type(t) {
                      (this._layoutType = t), this._doLayoutDirty();
                    }
                    get resizeMode() {
                      return this._resizeMode;
                    }
                    set resizeMode(t) {
                      this._layoutType !== Wpt.NONE &&
                        ((this._resizeMode = t), this._doLayoutDirty());
                    }
                    get cellSize() {
                      return this._cellSize;
                    }
                    set cellSize(t) {
                      this._cellSize !== t &&
                        (this._cellSize.set(t), this._doLayoutDirty());
                    }
                    get startAxis() {
                      return this._startAxis;
                    }
                    set startAxis(t) {
                      this._startAxis !== t &&
                        ((this._startAxis = t), this._doLayoutDirty());
                    }
                    get paddingLeft() {
                      return this._paddingLeft;
                    }
                    set paddingLeft(t) {
                      this._paddingLeft !== t &&
                        ((this._paddingLeft = t), this._doLayoutDirty());
                    }
                    get paddingRight() {
                      return this._paddingRight;
                    }
                    set paddingRight(t) {
                      this._paddingRight !== t &&
                        ((this._paddingRight = t), this._doLayoutDirty());
                    }
                    get paddingTop() {
                      return this._paddingTop;
                    }
                    set paddingTop(t) {
                      this._paddingTop !== t &&
                        ((this._paddingTop = t), this._doLayoutDirty());
                    }
                    get paddingBottom() {
                      return this._paddingBottom;
                    }
                    set paddingBottom(t) {
                      this._paddingBottom !== t &&
                        ((this._paddingBottom = t), this._doLayoutDirty());
                    }
                    get spacingX() {
                      return this._spacingX;
                    }
                    set spacingX(t) {
                      this._spacingX !== t &&
                        ((this._spacingX = t), this._doLayoutDirty());
                    }
                    get spacingY() {
                      return this._spacingY;
                    }
                    set spacingY(t) {
                      this._spacingY !== t &&
                        ((this._spacingY = t), this._doLayoutDirty());
                    }
                    get verticalDirection() {
                      return this._verticalDirection;
                    }
                    set verticalDirection(t) {
                      this._verticalDirection !== t &&
                        ((this._verticalDirection = t), this._doLayoutDirty());
                    }
                    get horizontalDirection() {
                      return this._horizontalDirection;
                    }
                    set horizontalDirection(t) {
                      this._horizontalDirection !== t &&
                        ((this._horizontalDirection = t),
                        this._doLayoutDirty());
                    }
                    get padding() {
                      return this._paddingLeft;
                    }
                    set padding(t) {
                      (this.paddingLeft === t &&
                        this._paddingRight === t &&
                        this._paddingTop === t &&
                        this._paddingBottom === t) ||
                        ((this._paddingLeft =
                          this._paddingRight =
                          this._paddingTop =
                          this._paddingBottom =
                            t),
                        this._doLayoutDirty());
                    }
                    get constraint() {
                      return this._constraint;
                    }
                    set constraint(t) {
                      this._layoutType !== Wpt.NONE &&
                        this._constraint !== t &&
                        ((this._constraint = t), this._doLayoutDirty());
                    }
                    get constraintNum() {
                      return this._constraintNum;
                    }
                    set constraintNum(t) {
                      this._constraint !== $pt.NONE &&
                        this._constraintNum !== t &&
                        (t <= 0 && w("Limit values to be greater than 0"),
                        (this._constraintNum = t),
                        this._doLayoutDirty());
                    }
                    get affectedByScale() {
                      return this._affectedByScale;
                    }
                    set affectedByScale(t) {
                      (this._affectedByScale = t), this._doLayoutDirty();
                    }
                    updateLayout(t = !1) {
                      (this._layoutDirty || t) &&
                        (this._doLayout(), (this._layoutDirty = !1));
                    }
                    onEnable() {
                      this._addEventListeners();
                      const t = this.node._uiProps.uiTransformComp;
                      t.contentSize.equals(ws.ZERO) &&
                        t.setContentSize(this._layoutSize),
                        this._childrenChanged();
                    }
                    onDisable() {
                      (this._usefulLayoutObj.length = 0),
                        this._removeEventListeners();
                    }
                    _checkUsefulObj() {
                      this._usefulLayoutObj.length = 0;
                      const t = this.node.children;
                      for (let e = 0; e < t.length; ++e) {
                        const i = t[e],
                          s = i._uiProps.uiTransformComp;
                        i.activeInHierarchy &&
                          s &&
                          this._usefulLayoutObj.push(s);
                      }
                    }
                    _addEventListeners() {
                      Lv.on(Nv.EVENT_AFTER_UPDATE, this.updateLayout, this),
                        this.node.on(bf.SIZE_CHANGED, this._resized, this),
                        this.node.on(
                          bf.ANCHOR_CHANGED,
                          this._doLayoutDirty,
                          this
                        ),
                        this.node.on(
                          bf.TRANSFORM_CHANGED,
                          this._scaleDirty,
                          this
                        ),
                        this.node.on(bf.CHILD_ADDED, this._childAdded, this),
                        this.node.on(
                          bf.CHILD_REMOVED,
                          this._childRemoved,
                          this
                        ),
                        this.node.on(
                          bf.CHILDREN_ORDER_CHANGED,
                          this._childrenChanged,
                          this
                        ),
                        this.node.on(
                          "childrenSiblingOrderChanged",
                          this.updateLayout,
                          this
                        ),
                        this._addChildrenEventListeners();
                    }
                    _removeEventListeners() {
                      Lv.off(Nv.EVENT_AFTER_UPDATE, this.updateLayout, this),
                        this.node.off(bf.SIZE_CHANGED, this._resized, this),
                        this.node.off(
                          bf.ANCHOR_CHANGED,
                          this._doLayoutDirty,
                          this
                        ),
                        this.node.off(bf.CHILD_ADDED, this._childAdded, this),
                        this.node.off(
                          bf.CHILD_REMOVED,
                          this._childRemoved,
                          this
                        ),
                        this.node.off(
                          bf.CHILDREN_ORDER_CHANGED,
                          this._childrenChanged,
                          this
                        ),
                        this.node.off(
                          "childrenSiblingOrderChanged",
                          this.updateLayout,
                          this
                        ),
                        this._removeChildrenEventListeners();
                    }
                    _addChildrenEventListeners() {
                      const t = this.node.children;
                      for (let e = 0; e < t.length; ++e) {
                        const i = t[e];
                        i.on(bf.SIZE_CHANGED, this._doLayoutDirty, this),
                          i.on(
                            bf.TRANSFORM_CHANGED,
                            this._transformDirty,
                            this
                          ),
                          i.on(bf.ANCHOR_CHANGED, this._doLayoutDirty, this),
                          i.on(
                            bf.ACTIVE_IN_HIERARCHY_CHANGED,
                            this._childrenChanged,
                            this
                          );
                      }
                    }
                    _removeChildrenEventListeners() {
                      const t = this.node.children;
                      for (let e = 0; e < t.length; ++e) {
                        const i = t[e];
                        i.off(bf.SIZE_CHANGED, this._doLayoutDirty, this),
                          i.off(
                            bf.TRANSFORM_CHANGED,
                            this._transformDirty,
                            this
                          ),
                          i.off(bf.ANCHOR_CHANGED, this._doLayoutDirty, this),
                          i.off(
                            bf.ACTIVE_IN_HIERARCHY_CHANGED,
                            this._childrenChanged,
                            this
                          );
                      }
                    }
                    _childAdded(t) {
                      t.on(bf.SIZE_CHANGED, this._doLayoutDirty, this),
                        t.on(bf.TRANSFORM_CHANGED, this._transformDirty, this),
                        t.on(bf.ANCHOR_CHANGED, this._doLayoutDirty, this),
                        t.on(
                          bf.ACTIVE_IN_HIERARCHY_CHANGED,
                          this._childrenChanged,
                          this
                        ),
                        this._childrenChanged();
                    }
                    _childRemoved(t) {
                      t.off(bf.SIZE_CHANGED, this._doLayoutDirty, this),
                        t.off(bf.TRANSFORM_CHANGED, this._transformDirty, this),
                        t.off(bf.ANCHOR_CHANGED, this._doLayoutDirty, this),
                        t.off(
                          bf.ACTIVE_IN_HIERARCHY_CHANGED,
                          this._childrenChanged,
                          this
                        ),
                        this._childrenChanged();
                    }
                    _resized() {
                      this._layoutSize.set(
                        this.node._uiProps.uiTransformComp.contentSize
                      ),
                        this._doLayoutDirty();
                    }
                    _doLayoutHorizontally(t, e, i, s) {
                      const n = this.node._uiProps.uiTransformComp.anchorPoint,
                        r = this._getFixedBreakingNum();
                      let a = 1,
                        o = this._paddingLeft;
                      this._horizontalDirection === qpt.RIGHT_TO_LEFT &&
                        ((a = -1), (o = this._paddingRight));
                      const h = (this._horizontalDirection - n.x) * t + a * o;
                      let l = h - a * this._spacingX,
                        c = 0,
                        u = 0,
                        _ = 0,
                        d = 0,
                        p = !1;
                      const m = this._usefulLayoutObj.length;
                      let f = this._cellSize.width;
                      const g = this._getPaddingH();
                      this._layoutType !== Wpt.GRID &&
                        this._resizeMode === Xpt.CHILDREN &&
                        (f = (t - g - (m - 1) * this._spacingX) / m);
                      const y = this._usefulLayoutObj;
                      for (let o = 0; o < y.length; ++o) {
                        const m = y[o],
                          T = m.node,
                          S = T.scale,
                          E = this._getUsedScaleValue(S.x),
                          v = this._getUsedScaleValue(S.y);
                        this._resizeMode === Xpt.CHILDREN &&
                          ((m.width = f / E),
                          this._layoutType === Wpt.GRID &&
                            (m.height = this._cellSize.height / v));
                        const b = Math.abs(
                            this._horizontalDirection - m.anchorX
                          ),
                          A = m.width * E,
                          C = m.height * v;
                        C > _ && ((d = Math.max(_, d)), (u = _ || C), (_ = C)),
                          (l += a * (b * A + this._spacingX));
                        const O = a * (1 - b) * A;
                        if (e) {
                          if (r > 0)
                            (p = o / r > 0 && o % r == 0),
                              p && (u = _ > C ? _ : u);
                          else if (A > t - g) l > h + a * b * A && (p = !0);
                          else {
                            const e = (1 - this._horizontalDirection - n.x) * t,
                              i =
                                l +
                                O +
                                a *
                                  (a > 0
                                    ? this._paddingRight
                                    : this._paddingLeft);
                            p = Math.abs(i) > Math.abs(e);
                          }
                          p &&
                            ((l = h + a * b * A),
                            C !== _ && (u = _),
                            (c += u + this._spacingY),
                            (u = _ = C));
                        }
                        const I = i(T, m, c);
                        s && T.setPosition(l, I), (l += O);
                      }
                      return (
                        (u = Math.max(u, _)),
                        Math.max(d, c + u) + this._getPaddingV()
                      );
                    }
                    _doLayoutVertically(t, e, i, s) {
                      const n = this.node._uiProps.uiTransformComp.anchorPoint,
                        r = this._getFixedBreakingNum();
                      let a = 1,
                        o = this._paddingBottom;
                      this._verticalDirection === Kpt.TOP_TO_BOTTOM &&
                        ((a = -1), (o = this._paddingTop));
                      const h = (this._verticalDirection - n.y) * t + a * o;
                      let l = h - a * this._spacingY,
                        c = 0,
                        u = 0,
                        _ = 0,
                        d = 0,
                        p = !1;
                      const m = this._usefulLayoutObj.length;
                      let f = this._cellSize.height;
                      const g = this._getPaddingV();
                      this._layoutType !== Wpt.GRID &&
                        this._resizeMode === Xpt.CHILDREN &&
                        (f = (t - g - (m - 1) * this._spacingY) / m);
                      const y = this._usefulLayoutObj;
                      for (let o = 0; o < y.length; ++o) {
                        const m = y[o],
                          T = m.node,
                          S = T.scale,
                          E = this._getUsedScaleValue(S.x),
                          v = this._getUsedScaleValue(S.y);
                        this._resizeMode === Xpt.CHILDREN &&
                          ((m.height = f / v),
                          this._layoutType === Wpt.GRID &&
                            (m.width = this._cellSize.width / E));
                        const b = Math.abs(this._verticalDirection - m.anchorY),
                          A = m.width * E,
                          C = m.height * v;
                        A > c && ((u = Math.max(c, u)), (_ = c || A), (c = A)),
                          (l += a * (b * C + this._spacingY));
                        const O = a * (1 - b) * C;
                        if (e) {
                          if (r > 0)
                            (p = o / r > 0 && o % r == 0),
                              p && (_ = c > C ? c : _);
                          else if (C > t - g) l > h + a * b * C && (p = !0);
                          else {
                            const e = (1 - this._verticalDirection - n.y) * t,
                              i =
                                l +
                                O +
                                a *
                                  (a > 0
                                    ? this._paddingTop
                                    : this._paddingBottom);
                            p = Math.abs(i) > Math.abs(e);
                          }
                          p &&
                            ((l = h + a * b * C),
                            A !== c && (_ = c),
                            (d += _ + this._spacingX),
                            (_ = c = A));
                        }
                        const I = i(T, m, d);
                        s && (T.getPosition(Zpt), T.setPosition(I, l, Zpt.z)),
                          (l += O);
                      }
                      return (
                        (_ = Math.max(_, c)),
                        Math.max(u, d + _) + this._getPaddingH()
                      );
                    }
                    _doLayoutGridAxisHorizontal(t, e) {
                      const i = e.width;
                      let s = 1,
                        n = -t.y * e.height,
                        r = this._paddingBottom;
                      this._verticalDirection === Kpt.TOP_TO_BOTTOM &&
                        ((s = -1),
                        (n = (1 - t.y) * e.height),
                        (r = this._paddingTop));
                      const a = (t, e, i) =>
                        n +
                        s *
                          (i +
                            (1 - e.anchorY) *
                              e.height *
                              this._getUsedScaleValue(t.scale.y) +
                            r);
                      let o = 0;
                      this._resizeMode === Xpt.CONTAINER &&
                        ((o = this._doLayoutHorizontally(i, !0, a, !1)),
                        (n = -t.y * o),
                        this._verticalDirection === Kpt.TOP_TO_BOTTOM &&
                          ((s = -1), (n = (1 - t.y) * o))),
                        this._doLayoutHorizontally(i, !0, a, !0),
                        this._resizeMode === Xpt.CONTAINER &&
                          this.node._uiProps.uiTransformComp.setContentSize(
                            i,
                            o
                          );
                    }
                    _doLayoutGridAxisVertical(t, e) {
                      const i = e.height;
                      let s = 1,
                        n = -t.x * e.width,
                        r = this._paddingLeft;
                      this._horizontalDirection === qpt.RIGHT_TO_LEFT &&
                        ((s = -1),
                        (n = (1 - t.x) * e.width),
                        (r = this._paddingRight));
                      const a = (t, e, i) =>
                        n +
                        s *
                          (i +
                            (1 - e.anchorX) *
                              e.width *
                              this._getUsedScaleValue(t.scale.x) +
                            r);
                      let o = 0;
                      this._resizeMode === Xpt.CONTAINER &&
                        ((o = this._doLayoutVertically(i, !0, a, !1)),
                        (n = -t.x * o),
                        this._horizontalDirection === qpt.RIGHT_TO_LEFT &&
                          ((s = -1), (n = (1 - t.x) * o))),
                        this._doLayoutVertically(i, !0, a, !0),
                        this._resizeMode === Xpt.CONTAINER &&
                          this.node._uiProps.uiTransformComp.setContentSize(
                            o,
                            i
                          );
                    }
                    _doLayoutGrid() {
                      const t = this.node._uiProps.uiTransformComp,
                        e = t.anchorPoint,
                        i = t.contentSize;
                      this.startAxis === Ypt.HORIZONTAL
                        ? this._doLayoutGridAxisHorizontal(e, i)
                        : this.startAxis === Ypt.VERTICAL &&
                          this._doLayoutGridAxisVertical(e, i);
                    }
                    _getHorizontalBaseWidth(t = !0) {
                      const e = this._usefulLayoutObj;
                      let i = 0;
                      const s = e.length;
                      if (this._resizeMode === Xpt.CONTAINER) {
                        for (let t = 0; t < e.length; ++t) {
                          const s = e[t],
                            n = s.node.scale;
                          i += s.width * this._getUsedScaleValue(n.x);
                        }
                        i += (s - 1) * this._spacingX + this._getPaddingH();
                      } else i = this.node._uiProps.uiTransformComp.width;
                      return i;
                    }
                    _getVerticalBaseHeight() {
                      const t = this._usefulLayoutObj;
                      let e = 0;
                      const i = t.length;
                      if (this._resizeMode === Xpt.CONTAINER) {
                        for (let i = 0; i < t.length; ++i) {
                          const s = t[i],
                            n = s.node.scale;
                          e += s.height * this._getUsedScaleValue(n.y);
                        }
                        e += (i - 1) * this._spacingY + this._getPaddingV();
                      } else e = this.node._uiProps.uiTransformComp.height;
                      return e;
                    }
                    _doLayout() {
                      if (
                        ((this._init && !this._childrenDirty) ||
                          (this._checkUsefulObj(),
                          (this._init = !0),
                          (this._childrenDirty = !1)),
                        this._layoutType === Wpt.HORIZONTAL)
                      ) {
                        const t = this._getHorizontalBaseWidth(),
                          e = (t) => (this._isAlign ? Yi.ZERO : t.position).y;
                        this._doLayoutHorizontally(t, !1, e, !0),
                          (this.node._uiProps.uiTransformComp.width = t);
                      } else if (this._layoutType === Wpt.VERTICAL) {
                        const t = this._getVerticalBaseHeight(),
                          e = (t) => (this._isAlign ? Yi.ZERO : t.position).x;
                        this._doLayoutVertically(t, !1, e, !0),
                          (this.node._uiProps.uiTransformComp.height = t);
                      } else
                        this._layoutType === Wpt.GRID && this._doLayoutGrid();
                    }
                    _getUsedScaleValue(t) {
                      return this._affectedByScale ? Math.abs(t) : 1;
                    }
                    _scaleDirty(t) {
                      t & Cf.SCALE &&
                        this._affectedByScale &&
                        this._doLayoutDirty();
                    }
                    _transformDirty(t) {
                      (t & Cf.SCALE && !this._affectedByScale) ||
                        !(t & Cf.POSITION) ||
                        this._doLayoutDirty();
                    }
                    _doLayoutDirty() {
                      this._layoutDirty = !0;
                    }
                    _childrenChanged() {
                      (this._childrenDirty = !0), this._doLayoutDirty();
                    }
                    _getPaddingH() {
                      return this._paddingLeft + this._paddingRight;
                    }
                    _getPaddingV() {
                      return this._paddingTop + this._paddingBottom;
                    }
                    _getFixedBreakingNum() {
                      if (
                        this._layoutType !== Wpt.GRID ||
                        this._constraint === $pt.NONE ||
                        this._constraintNum <= 0
                      )
                        return 0;
                      let t =
                        this._constraint === $pt.FIXED_ROW
                          ? Math.ceil(
                              this._usefulLayoutObj.length / this._constraintNum
                            )
                          : this._constraintNum;
                      return (
                        this._startAxis === Ypt.VERTICAL &&
                          (t =
                            this._constraint === $pt.FIXED_COL
                              ? Math.ceil(
                                  this._usefulLayoutObj.length /
                                    this._constraintNum
                                )
                              : this._constraintNum),
                        t
                      );
                    }
                  }).Type = Wpt),
                  (jpt.VerticalDirection = Kpt),
                  (jpt.HorizontalDirection = qpt),
                  (jpt.ResizeMode = Xpt),
                  (jpt.AxisDirection = Ypt),
                  (jpt.Constraint = $pt),
                  s(
                    (Ipt = jpt).prototype,
                    "type",
                    [Spt],
                    Object.getOwnPropertyDescriptor(Ipt.prototype, "type"),
                    Ipt.prototype
                  ),
                  s(
                    Ipt.prototype,
                    "resizeMode",
                    [Ept],
                    Object.getOwnPropertyDescriptor(
                      Ipt.prototype,
                      "resizeMode"
                    ),
                    Ipt.prototype
                  ),
                  s(
                    Ipt.prototype,
                    "startAxis",
                    [vpt],
                    Object.getOwnPropertyDescriptor(Ipt.prototype, "startAxis"),
                    Ipt.prototype
                  ),
                  s(
                    Ipt.prototype,
                    "verticalDirection",
                    [bpt],
                    Object.getOwnPropertyDescriptor(
                      Ipt.prototype,
                      "verticalDirection"
                    ),
                    Ipt.prototype
                  ),
                  s(
                    Ipt.prototype,
                    "horizontalDirection",
                    [Apt],
                    Object.getOwnPropertyDescriptor(
                      Ipt.prototype,
                      "horizontalDirection"
                    ),
                    Ipt.prototype
                  ),
                  s(
                    Ipt.prototype,
                    "constraint",
                    [Cpt],
                    Object.getOwnPropertyDescriptor(
                      Ipt.prototype,
                      "constraint"
                    ),
                    Ipt.prototype
                  ),
                  (wpt = fa(Ipt.prototype, "_resizeMode", [Na], function () {
                    return Xpt.NONE;
                  })),
                  (Rpt = fa(Ipt.prototype, "_layoutType", [Na], function () {
                    return Wpt.NONE;
                  })),
                  (Dpt = fa(Ipt.prototype, "_cellSize", [Na], function () {
                    return new ws(40, 40);
                  })),
                  (xpt = fa(Ipt.prototype, "_startAxis", [Na], function () {
                    return Ypt.HORIZONTAL;
                  })),
                  (Mpt = fa(Ipt.prototype, "_paddingLeft", [Na], function () {
                    return 0;
                  })),
                  (Ppt = fa(Ipt.prototype, "_paddingRight", [Na], function () {
                    return 0;
                  })),
                  (Npt = fa(Ipt.prototype, "_paddingTop", [Na], function () {
                    return 0;
                  })),
                  (Lpt = fa(Ipt.prototype, "_paddingBottom", [Na], function () {
                    return 0;
                  })),
                  (Bpt = fa(Ipt.prototype, "_spacingX", [Na], function () {
                    return 0;
                  })),
                  (Fpt = fa(Ipt.prototype, "_spacingY", [Na], function () {
                    return 0;
                  })),
                  (Upt = fa(
                    Ipt.prototype,
                    "_verticalDirection",
                    [Na],
                    function () {
                      return Kpt.TOP_TO_BOTTOM;
                    }
                  )),
                  (kpt = fa(
                    Ipt.prototype,
                    "_horizontalDirection",
                    [Na],
                    function () {
                      return qpt.LEFT_TO_RIGHT;
                    }
                  )),
                  (zpt = fa(Ipt.prototype, "_constraint", [Na], function () {
                    return $pt.NONE;
                  })),
                  (Hpt = fa(Ipt.prototype, "_constraintNum", [Na], function () {
                    return 2;
                  })),
                  (Gpt = fa(
                    Ipt.prototype,
                    "_affectedByScale",
                    [Na],
                    function () {
                      return !1;
                    }
                  )),
                  (Vpt = fa(Ipt.prototype, "_isAlign", [Na], function () {
                    return !1;
                  })),
                  (Opt = Ipt))
                ) || Opt)
            ) || Opt)
        ) || Opt);
      var Jpt, tmt, emt, imt, smt, nmt, rmt, amt, omt, hmt, lmt, cmt, umt, _mt;
      t({ Layout: Qpt, LayoutComponent: Qpt }),
        (a.Layout = Qpt),
        (function (t) {
          (t[(t.HORIZONTAL = 0)] = "HORIZONTAL"),
            (t[(t.VERTICAL = 1)] = "VERTICAL"),
            (t[(t.FILLED = 2)] = "FILLED");
        })(_mt || (_mt = {})),
        ce(_mt);
      let dmt =
        ((Jpt = Ca("cc.ProgressBar")),
        (tmt = Ia(110)),
        (emt = Oa(CI)),
        (imt = ao(XD)),
        (smt = ao(_mt)),
        Jpt(
          (nmt =
            tmt(
              (nmt =
                emt(
                  (((umt = class extends np {
                    constructor() {
                      super(),
                        (this._barSprite = amt && amt()),
                        (this._mode = omt && omt()),
                        (this._totalLength = hmt && hmt()),
                        (this._progress = lmt && lmt()),
                        (this._reverse = cmt && cmt());
                    }
                    get barSprite() {
                      return this._barSprite;
                    }
                    set barSprite(t) {
                      this._barSprite !== t &&
                        ((this._barSprite = t), this._initBarSprite());
                    }
                    get mode() {
                      return this._mode;
                    }
                    set mode(t) {
                      if (
                        this._mode !== t &&
                        ((this._mode = t), this._barSprite)
                      ) {
                        const t = this._barSprite.node;
                        if (!t) return;
                        const e = t._uiProps.uiTransformComp.contentSize;
                        this._mode === _mt.HORIZONTAL
                          ? (this.totalLength = e.width)
                          : this._mode === _mt.VERTICAL
                          ? (this.totalLength = e.height)
                          : this._mode === _mt.FILLED &&
                            (this.totalLength = this._barSprite.fillRange);
                      }
                    }
                    get totalLength() {
                      return this._totalLength;
                    }
                    set totalLength(t) {
                      this._mode === _mt.FILLED && (t = Ei(t)),
                        this._totalLength !== t &&
                          ((this._totalLength = t), this._updateBarStatus());
                    }
                    get progress() {
                      return this._progress;
                    }
                    set progress(t) {
                      this._progress !== t &&
                        ((this._progress = t), this._updateBarStatus());
                    }
                    get reverse() {
                      return this._reverse;
                    }
                    set reverse(t) {
                      this._reverse !== t &&
                        ((this._reverse = t),
                        this._barSprite &&
                          (this._barSprite.fillStart =
                            1 - this._barSprite.fillStart),
                        this._updateBarStatus());
                    }
                    onLoad() {
                      this._updateBarStatus();
                    }
                    _initBarSprite() {
                      if (this._barSprite) {
                        const t = this._barSprite.node;
                        if (!t) return;
                        const e = this.node._uiProps.uiTransformComp,
                          i = e.contentSize,
                          s = e.anchorPoint,
                          n = t._uiProps.uiTransformComp.contentSize;
                        if (
                          (this._barSprite.fillType === XD.FillType.RADIAL &&
                            (this._mode = _mt.FILLED),
                          this._mode === _mt.HORIZONTAL
                            ? (this.totalLength = n.width)
                            : this._mode === _mt.VERTICAL
                            ? (this.totalLength = n.height)
                            : (this.totalLength = this._barSprite.fillRange),
                          t.parent === this.node)
                        ) {
                          const e = -i.width * s.x;
                          t.setPosition(e, 0, 0);
                        }
                      }
                    }
                    _updateBarStatus() {
                      if (this._barSprite) {
                        const t = this._barSprite.node;
                        if (!t) return;
                        const e = t._uiProps.uiTransformComp,
                          i = e.anchorPoint,
                          s = e.contentSize;
                        let n = new Ss(0, 0.5);
                        const r = Ei(this._progress);
                        let a = this._totalLength * r,
                          o = s,
                          h = 0,
                          l = 0;
                        switch (this._mode) {
                          case _mt.HORIZONTAL:
                            this._reverse && (n = new Ss(1, 0.5)),
                              (o = new ws(a, s.height)),
                              (h = this._totalLength),
                              (l = s.height);
                            break;
                          case _mt.VERTICAL:
                            (n = this._reverse
                              ? new Ss(0.5, 1)
                              : new Ss(0.5, 0)),
                              (o = new ws(s.width, a)),
                              (h = s.width),
                              (l = this._totalLength);
                        }
                        if (this._mode === _mt.FILLED)
                          this._barSprite.type !== XD.Type.FILLED
                            ? z(16397)
                            : (this._reverse && (a *= -1),
                              (this._barSprite.fillRange = a));
                        else if (this._barSprite.type !== XD.Type.FILLED) {
                          const s = n.x - i.x,
                            r = n.y - i.y,
                            a = new Yi(t.position);
                          a.add3f(h * s, l * r, 0),
                            t.setPosition(a),
                            e.setAnchorPoint(n),
                            e.setContentSize(o);
                        } else z(16398);
                      }
                    }
                  }).Mode = _mt),
                  s(
                    (rmt = umt).prototype,
                    "barSprite",
                    [imt],
                    Object.getOwnPropertyDescriptor(rmt.prototype, "barSprite"),
                    rmt.prototype
                  ),
                  s(
                    rmt.prototype,
                    "mode",
                    [smt],
                    Object.getOwnPropertyDescriptor(rmt.prototype, "mode"),
                    rmt.prototype
                  ),
                  (amt = fa(rmt.prototype, "_barSprite", [Na], function () {
                    return null;
                  })),
                  (omt = fa(rmt.prototype, "_mode", [Na], function () {
                    return _mt.HORIZONTAL;
                  })),
                  (hmt = fa(rmt.prototype, "_totalLength", [Na], function () {
                    return 1;
                  })),
                  (lmt = fa(rmt.prototype, "_progress", [Na], function () {
                    return 0.1;
                  })),
                  (cmt = fa(rmt.prototype, "_reverse", [Na], function () {
                    return !1;
                  })),
                  (nmt = rmt))
                ) || nmt)
            ) || nmt)
        ) || nmt);
      var pmt, mmt, fmt, gmt, ymt, Tmt, Smt, Emt, vmt, bmt, Amt, Cmt, Omt;
      t({ ProgressBar: dmt, ProgressBarComponent: dmt }), (a.ProgressBar = dmt);
      const Imt = new Yi(),
        wmt = new Yi(),
        Rmt = new Yi(),
        Dmt = new Ss(),
        xmt = new Qi(),
        Mmt = new Ss();
      var Pmt;
      !(function (t) {
        (t[(t.HORIZONTAL = 0)] = "HORIZONTAL"),
          (t[(t.VERTICAL = 1)] = "VERTICAL");
      })(Pmt || (Pmt = {})),
        de(Pmt);
      let Nmt =
        ((pmt = Ca("cc.ScrollBar")),
        (mmt = Ia(110)),
        (fmt = Oa(CI)),
        (gmt = ao(XD)),
        (ymt = ao(Pmt)),
        pmt(
          (Tmt =
            mmt(
              (Tmt =
                fmt(
                  (((Omt = class extends np {
                    constructor() {
                      super(),
                        (this._scrollView = Emt && Emt()),
                        (this._handle = vmt && vmt()),
                        (this._direction = bmt && bmt()),
                        (this._enableAutoHide = Amt && Amt()),
                        (this._autoHideTime = Cmt && Cmt()),
                        (this._touching = !1),
                        (this._opacity = 255),
                        (this._autoHideRemainingTime = 0);
                    }
                    get handle() {
                      return this._handle;
                    }
                    set handle(t) {
                      this._handle !== t &&
                        ((this._handle = t), this.onScroll(Ss.ZERO));
                    }
                    get direction() {
                      return this._direction;
                    }
                    set direction(t) {
                      this._direction !== t &&
                        ((this._direction = t), this.onScroll(Ss.ZERO));
                    }
                    get enableAutoHide() {
                      return this._enableAutoHide;
                    }
                    set enableAutoHide(t) {
                      this._enableAutoHide !== t &&
                        ((this._enableAutoHide = t),
                        this._enableAutoHide && this._setOpacity(0));
                    }
                    get autoHideTime() {
                      return this._autoHideTime;
                    }
                    set autoHideTime(t) {
                      this._autoHideTime !== t && (this._autoHideTime = t);
                    }
                    hide() {
                      (this._autoHideRemainingTime = 0), this._setOpacity(0);
                    }
                    show() {
                      (this._autoHideRemainingTime = this._autoHideTime),
                        (this._opacity = 255),
                        this._setOpacity(this._opacity);
                    }
                    onScroll(t) {
                      if (!this._scrollView) return;
                      const e = this._scrollView.content;
                      if (!e) return;
                      const i = e._uiProps.uiTransformComp.contentSize,
                        s =
                          this._scrollView.node._uiProps.uiTransformComp
                            .contentSize,
                        n = this.node._uiProps.uiTransformComp.contentSize;
                      if (this._conditionalDisableScrollBar(i, s)) return;
                      this._enableAutoHide &&
                        ((this._autoHideRemainingTime = this._autoHideTime),
                        this._setOpacity(this._opacity));
                      let r = 0,
                        a = 0,
                        o = 0,
                        h = 0,
                        l = 0;
                      const c = Mmt;
                      c.set(0, 0),
                        this._direction === Pmt.HORIZONTAL
                          ? ((r = i.width),
                            (a = s.width),
                            (l = n.width),
                            (o = t.x),
                            this._convertToScrollViewSpace(c, e),
                            (h = -c.x))
                          : this._direction === Pmt.VERTICAL &&
                            ((r = i.height),
                            (a = s.height),
                            (l = n.height),
                            (o = t.y),
                            this._convertToScrollViewSpace(c, e),
                            (h = -c.y));
                      const u = this._calculateLength(r, a, l, o),
                        _ = Mmt;
                      this._calculatePosition(_, r, a, l, h, o, u),
                        this._updateLength(u),
                        this._updateHandlerPosition(_);
                    }
                    setScrollView(t) {
                      this._scrollView = t;
                    }
                    onTouchBegan() {
                      this._enableAutoHide && (this._touching = !0);
                    }
                    onTouchEnded() {
                      if (
                        this._enableAutoHide &&
                        ((this._touching = !1), !(this._autoHideTime <= 0))
                      ) {
                        if (this._scrollView) {
                          const t = this._scrollView.content;
                          if (t) {
                            const e = t._uiProps.uiTransformComp.contentSize,
                              i =
                                this._scrollView.node._uiProps.uiTransformComp
                                  .contentSize;
                            if (this._conditionalDisableScrollBar(e, i)) return;
                          }
                        }
                        this._autoHideRemainingTime = this._autoHideTime;
                      }
                    }
                    onEnable() {
                      const t = this.node.getComponent(XD);
                      t && (this._opacity = t.color.a);
                    }
                    start() {
                      this._enableAutoHide && this._setOpacity(0);
                    }
                    update(t) {
                      this._processAutoHide(t);
                    }
                    _convertToScrollViewSpace(t, e) {
                      const i =
                          this._scrollView &&
                          this._scrollView.node._uiProps.uiTransformComp,
                        s = e._uiProps.uiTransformComp;
                      if (i && s) {
                        Imt.set(-s.anchorX * s.width, -s.anchorY * s.height, 0),
                          s.convertToWorldSpaceAR(Imt, wmt);
                        const e = i.convertToNodeSpaceAR(wmt);
                        (e.x += i.anchorX * i.width),
                          (e.y += i.anchorY * i.height),
                          t.set(e.x, e.y);
                      } else t.set(Ss.ZERO);
                    }
                    _setOpacity(t) {
                      if (this._handle) {
                        let e = this.node.getComponent(XD);
                        e && (xmt.set(e.color), (xmt.a = t), (e.color = xmt)),
                          (e = this._handle.getComponent(XD)),
                          e && (xmt.set(e.color), (xmt.a = t), (e.color = xmt));
                      }
                    }
                    _updateHandlerPosition(t) {
                      if (this._handle) {
                        const e = Rmt;
                        this._fixupHandlerPosition(e),
                          this._handle.node.setPosition(
                            t.x + e.x,
                            t.y + e.y,
                            e.z
                          );
                      }
                    }
                    _fixupHandlerPosition(t) {
                      const e = this.node._uiProps.uiTransformComp,
                        i = e.contentSize,
                        s = e.anchorPoint,
                        n =
                          this.handle.node._uiProps.uiTransformComp.contentSize,
                        r = this.handle.node.parent;
                      Yi.set(Imt, -i.width * s.x, -i.height * s.y, 0);
                      const a =
                          this.node._uiProps.uiTransformComp.convertToWorldSpaceAR(
                            Imt,
                            wmt
                          ),
                        o = t;
                      o.set(0, 0, 0),
                        r._uiProps.uiTransformComp.convertToNodeSpaceAR(a, o),
                        this.direction === Pmt.HORIZONTAL
                          ? o.set(o.x, o.y + (i.height - n.height) / 2, o.z)
                          : this.direction === Pmt.VERTICAL &&
                            o.set(o.x + (i.width - n.width) / 2, o.y, o.z),
                        this.handle.node.setPosition(o);
                    }
                    _conditionalDisableScrollBar(t, e) {
                      return (
                        (t.width <= e.width &&
                          this._direction === Pmt.HORIZONTAL) ||
                        (t.height <= e.height &&
                          this._direction === Pmt.VERTICAL)
                      );
                    }
                    _calculateLength(t, e, i, s) {
                      let n = t;
                      return s && (n += 20 * (s > 0 ? s : -s)), i * (e / n);
                    }
                    _calculatePosition(t, e, i, s, n, r, a) {
                      let o = e - i;
                      r && (o += Math.abs(r));
                      let h = 0;
                      o && ((h = n / o), (h = Ei(h)));
                      const l = (s - a) * h;
                      this._direction === Pmt.VERTICAL
                        ? t.set(0, l)
                        : t.set(l, 0);
                    }
                    _updateLength(t) {
                      if (this._handle) {
                        const e = this._handle.node._uiProps.uiTransformComp,
                          i = e.contentSize,
                          s = e.anchorPoint;
                        (s.x === Dmt.x && s.y === Dmt.y) ||
                          e.setAnchorPoint(Dmt),
                          this._direction === Pmt.HORIZONTAL
                            ? e.setContentSize(t, i.height)
                            : e.setContentSize(i.width, t);
                      }
                    }
                    _processAutoHide(t) {
                      if (
                        this._enableAutoHide &&
                        !(this._autoHideRemainingTime <= 0) &&
                        !this._touching &&
                        ((this._autoHideRemainingTime -= t),
                        this._autoHideRemainingTime <= this._autoHideTime)
                      ) {
                        this._autoHideRemainingTime = Math.max(
                          0,
                          this._autoHideRemainingTime
                        );
                        const t =
                          this._opacity *
                          (this._autoHideRemainingTime / this._autoHideTime);
                        this._setOpacity(t);
                      }
                    }
                  }).Direction = Pmt),
                  s(
                    (Smt = Omt).prototype,
                    "handle",
                    [gmt],
                    Object.getOwnPropertyDescriptor(Smt.prototype, "handle"),
                    Smt.prototype
                  ),
                  s(
                    Smt.prototype,
                    "direction",
                    [ymt],
                    Object.getOwnPropertyDescriptor(Smt.prototype, "direction"),
                    Smt.prototype
                  ),
                  (Emt = fa(Smt.prototype, "_scrollView", [Na], function () {
                    return null;
                  })),
                  (vmt = fa(Smt.prototype, "_handle", [Na], function () {
                    return null;
                  })),
                  (bmt = fa(Smt.prototype, "_direction", [Na], function () {
                    return Pmt.HORIZONTAL;
                  })),
                  (Amt = fa(
                    Smt.prototype,
                    "_enableAutoHide",
                    [Na],
                    function () {
                      return !1;
                    }
                  )),
                  (Cmt = fa(Smt.prototype, "_autoHideTime", [Na], function () {
                    return 1;
                  })),
                  (Tmt = Smt))
                ) || Tmt)
            ) || Tmt)
        ) || Tmt);
      var Lmt;
      t({ ScrollBar: Nmt, ScrollBarComponent: Nmt }), (a.ScrollBar = Nmt);
      let Bmt = t(
        "ViewGroup",
        Ca("cc.ViewGroup")(
          (Lmt = Ia(110)((Lmt = class extends np {})) || Lmt)
        ) || Lmt
      );
      var Fmt,
        Umt,
        kmt,
        zmt,
        Hmt,
        Gmt,
        Vmt,
        jmt,
        Wmt,
        Xmt,
        Ymt,
        Kmt,
        qmt,
        $mt,
        Zmt,
        Qmt,
        Jmt,
        tft,
        eft,
        ift,
        sft;
      a.ViewGroup = Bmt;
      const nft = 1e-4,
        rft = new Yi(),
        aft = new Yi(),
        oft = new Ss(),
        hft = new Ss(),
        lft = () => new Date().getMilliseconds(),
        cft = {
          "scroll-to-top": 0,
          "scroll-to-bottom": 1,
          "scroll-to-left": 2,
          "scroll-to-right": 3,
          scrolling: 4,
          "bounce-bottom": 6,
          "bounce-left": 7,
          "bounce-right": 8,
          "bounce-top": 5,
          "scroll-ended": 9,
          "touch-up": 10,
          "scroll-ended-with-threshold": 11,
          "scroll-began": 12,
        };
      let uft;
      var _ft;
      !(function (t) {
        (t.NONE = ""),
          (t.SCROLL_TO_TOP = "scroll-to-top"),
          (t.SCROLL_TO_BOTTOM = "scroll-to-bottom"),
          (t.SCROLL_TO_LEFT = "scroll-to-left"),
          (t.SCROLL_TO_RIGHT = "scroll-to-right"),
          (t.SCROLL_BEGAN = "scroll-began"),
          (t.SCROLL_ENDED = "scroll-ended"),
          (t.BOUNCE_TOP = "bounce-top"),
          (t.BOUNCE_BOTTOM = "bounce-bottom"),
          (t.BOUNCE_LEFT = "bounce-left"),
          (t.BOUNCE_RIGHT = "bounce-right"),
          (t.SCROLLING = "scrolling"),
          (t.SCROLL_ENG_WITH_THRESHOLD = "scroll-ended-with-threshold"),
          (t.TOUCH_UP = "touch-up");
      })(uft || (uft = {})),
        (function (t) {
          (t[(t.NONE = 0)] = "NONE"),
            (t[(t.LEFT = 1)] = "LEFT"),
            (t[(t.RIGHT = 2)] = "RIGHT");
        })(_ft || (_ft = {}));
      let dft =
        ((Fmt = Ca("cc.ScrollView")),
        (Umt = Ia(110)),
        (kmt = Oa(CI)),
        (zmt = ao(Pf)),
        (Hmt = ao(Nmt)),
        (Gmt = ao(Nmt)),
        (Vmt = ao([Yd])),
        Fmt(
          (jmt =
            Umt(
              (jmt =
                kmt(
                  (((sft = class extends Bmt {
                    get content() {
                      return this._content;
                    }
                    set content(t) {
                      if (this._content === t) return;
                      const e =
                        t && t.parent && t.parent._uiProps.uiTransformComp;
                      !t || (t && e)
                        ? ((this._content = t), this._calculateBoundary())
                        : B(4302);
                    }
                    get horizontalScrollBar() {
                      return (
                        this._horizontalScrollBar &&
                          !this._horizontalScrollBar.isValid &&
                          G(4303, "horizontal", this.node.name),
                        this._horizontalScrollBar
                      );
                    }
                    set horizontalScrollBar(t) {
                      this._horizontalScrollBar !== t &&
                        ((this._horizontalScrollBar = t),
                        this._horizontalScrollBar &&
                          (this._horizontalScrollBar.setScrollView(this),
                          this._updateScrollBar(Ss.ZERO)));
                    }
                    get verticalScrollBar() {
                      return (
                        this._verticalScrollBar &&
                          !this._verticalScrollBar.isValid &&
                          G(4303, "vertical", this.node.name),
                        this._verticalScrollBar
                      );
                    }
                    set verticalScrollBar(t) {
                      this._verticalScrollBar !== t &&
                        ((this._verticalScrollBar = t),
                        this._verticalScrollBar &&
                          (this._verticalScrollBar.setScrollView(this),
                          this._updateScrollBar(Ss.ZERO)));
                    }
                    get view() {
                      const t = this._content && this._content.parent;
                      return t ? t._uiProps.uiTransformComp : null;
                    }
                    constructor() {
                      super(),
                        (this.bounceDuration = Xmt && Xmt()),
                        (this.brake = Ymt && Ymt()),
                        (this.elastic = Kmt && Kmt()),
                        (this.inertia = qmt && qmt()),
                        (this.horizontal = $mt && $mt()),
                        (this.vertical = Zmt && Zmt()),
                        (this.cancelInnerEvents = Qmt && Qmt()),
                        (this.scrollEvents = Jmt && Jmt()),
                        (this._autoScrolling = !1),
                        (this._scrolling = !1),
                        (this._content = tft && tft()),
                        (this._horizontalScrollBar = eft && eft()),
                        (this._verticalScrollBar = ift && ift()),
                        (this._topBoundary = 0),
                        (this._bottomBoundary = 0),
                        (this._leftBoundary = 0),
                        (this._rightBoundary = 0),
                        (this._touchMoveDisplacements = []),
                        (this._touchMoveTimeDeltas = []),
                        (this._touchMovePreviousTimestamp = 0),
                        (this._touchMoved = !1),
                        (this._autoScrollAttenuate = !1),
                        (this._autoScrollStartPosition = new Yi()),
                        (this._autoScrollTargetDelta = new Yi()),
                        (this._autoScrollTotalTime = 0),
                        (this._autoScrollAccumulatedTime = 0),
                        (this._autoScrollCurrentlyOutOfBoundary = !1),
                        (this._autoScrollBraking = !1),
                        (this._autoScrollBrakingStartPosition = new Yi()),
                        (this._outOfBoundaryAmount = new Yi()),
                        (this._outOfBoundaryAmountDirty = !0),
                        (this._stopMouseWheel = !1),
                        (this._mouseWheelEventElapsedTime = 0),
                        (this._isScrollEndedWithThresholdEventFired = !1),
                        (this._scrollEventEmitMask = 0),
                        (this._isBouncing = !1),
                        (this._contentPos = new Yi()),
                        (this._deltaPos = new Yi()),
                        (this._deltaAmount = new Yi()),
                        (this._hoverIn = _ft.NONE);
                    }
                    scrollToBottom(t, e = !0) {
                      const i = this._calculateMovePercentDelta({
                        anchor: new Ss(0, 0),
                        applyToHorizontal: !1,
                        applyToVertical: !0,
                      });
                      t
                        ? this._startAutoScroll(i, t, !1 !== e)
                        : this._moveContent(i, !0);
                    }
                    scrollToTop(t, e = !0) {
                      const i = this._calculateMovePercentDelta({
                        anchor: new Ss(0, 1),
                        applyToHorizontal: !1,
                        applyToVertical: !0,
                      });
                      t
                        ? this._startAutoScroll(i, t, !1 !== e)
                        : this._moveContent(i);
                    }
                    scrollToLeft(t, e = !0) {
                      const i = this._calculateMovePercentDelta({
                        anchor: new Ss(0, 0),
                        applyToHorizontal: !0,
                        applyToVertical: !1,
                      });
                      t
                        ? this._startAutoScroll(i, t, !1 !== e)
                        : this._moveContent(i);
                    }
                    scrollToRight(t, e = !0) {
                      const i = this._calculateMovePercentDelta({
                        anchor: new Ss(1, 0),
                        applyToHorizontal: !0,
                        applyToVertical: !1,
                      });
                      t
                        ? this._startAutoScroll(i, t, !1 !== e)
                        : this._moveContent(i);
                    }
                    scrollToTopLeft(t, e = !0) {
                      const i = this._calculateMovePercentDelta({
                        anchor: new Ss(0, 1),
                        applyToHorizontal: !0,
                        applyToVertical: !0,
                      });
                      t
                        ? this._startAutoScroll(i, t, !1 !== e)
                        : this._moveContent(i);
                    }
                    scrollToTopRight(t, e = !0) {
                      const i = this._calculateMovePercentDelta({
                        anchor: new Ss(1, 1),
                        applyToHorizontal: !0,
                        applyToVertical: !0,
                      });
                      t
                        ? this._startAutoScroll(i, t, !1 !== e)
                        : this._moveContent(i);
                    }
                    scrollToBottomLeft(t, e = !0) {
                      const i = this._calculateMovePercentDelta({
                        anchor: new Ss(0, 0),
                        applyToHorizontal: !0,
                        applyToVertical: !0,
                      });
                      t
                        ? this._startAutoScroll(i, t, !1 !== e)
                        : this._moveContent(i);
                    }
                    scrollToBottomRight(t, e = !0) {
                      const i = this._calculateMovePercentDelta({
                        anchor: new Ss(1, 0),
                        applyToHorizontal: !0,
                        applyToVertical: !0,
                      });
                      t
                        ? this._startAutoScroll(i, t, !1 !== e)
                        : this._moveContent(i);
                    }
                    scrollToOffset(t, e, i = !0) {
                      const s = this.getMaxScrollOffset(),
                        n = new Ss(0, 0);
                      0 === s.x ? (n.x = 0) : (n.x = t.x / s.x),
                        0 === s.y ? (n.y = 1) : (n.y = (s.y - t.y) / s.y),
                        this.scrollTo(n, e, i);
                    }
                    getScrollOffset() {
                      const t =
                          this._getContentTopBoundary() - this._topBoundary,
                        e = this._getContentLeftBoundary() - this._leftBoundary;
                      return new Ss(e, t);
                    }
                    getMaxScrollOffset() {
                      if (!this._content || !this.view) return Ss.ZERO;
                      const t =
                        this._content._uiProps.uiTransformComp.contentSize;
                      let e = t.width - this.view.width,
                        i = t.height - this.view.height;
                      return (
                        (e = e >= 0 ? e : 0), (i = i >= 0 ? i : 0), new Ss(e, i)
                      );
                    }
                    scrollToPercentHorizontal(t, e, i) {
                      const s = this._calculateMovePercentDelta({
                        anchor: new Ss(t, 0),
                        applyToHorizontal: !0,
                        applyToVertical: !1,
                      });
                      e
                        ? this._startAutoScroll(s, e, !1 !== i)
                        : this._moveContent(s);
                    }
                    scrollTo(t, e, i) {
                      const s = this._calculateMovePercentDelta({
                        anchor: new Ss(t),
                        applyToHorizontal: !0,
                        applyToVertical: !0,
                      });
                      e ? this._startAutoScroll(s, e, i) : this._moveContent(s);
                    }
                    scrollToPercentVertical(t, e, i) {
                      const s = this._calculateMovePercentDelta({
                        anchor: new Ss(0, t),
                        applyToHorizontal: !1,
                        applyToVertical: !0,
                      });
                      e ? this._startAutoScroll(s, e, i) : this._moveContent(s);
                    }
                    stopAutoScroll() {
                      (this._autoScrolling = !1),
                        (this._autoScrollAccumulatedTime =
                          this._autoScrollTotalTime);
                    }
                    setContentPosition(t) {
                      this._setContentPosition(t);
                    }
                    _setContentPosition(t) {
                      if (!this._content) return;
                      const e = this._getContentPosition();
                      (Math.abs(t.x - e.x) < nft &&
                        Math.abs(t.y - e.y) < nft) ||
                        (this._content.setPosition(t),
                        (this._outOfBoundaryAmountDirty = !0));
                    }
                    getContentPosition() {
                      return this._getContentPosition();
                    }
                    _getContentPosition() {
                      return this._content
                        ? (this._contentPos.set(this._content.position),
                          this._contentPos)
                        : Yi.ZERO.clone();
                    }
                    isScrolling() {
                      return this._scrolling;
                    }
                    isAutoScrolling() {
                      return this._autoScrolling;
                    }
                    getScrollEndedEventTiming() {
                      return nft;
                    }
                    onLoad() {
                      (zr.os != zr.OS.WINDOWS && zr.os != zr.OS.OSX) ||
                        (this.elastic = !1);
                    }
                    start() {
                      this._calculateBoundary(),
                        this._content &&
                          Lv.once(
                            Nv.EVENT_BEFORE_DRAW,
                            this._adjustContentOutOfBoundary,
                            this
                          );
                    }
                    onEnable() {
                      this._registerEvent(),
                        this._content &&
                          (this._content.on(
                            bf.SIZE_CHANGED,
                            this._calculateBoundary,
                            this
                          ),
                          this._content.on(
                            bf.TRANSFORM_CHANGED,
                            this._scaleChanged,
                            this
                          ),
                          this.view &&
                            (this.view.node.on(
                              bf.TRANSFORM_CHANGED,
                              this._scaleChanged,
                              this
                            ),
                            this.view.node.on(
                              bf.SIZE_CHANGED,
                              this._calculateBoundary,
                              this
                            ))),
                        this._calculateBoundary(),
                        this._updateScrollBarState();
                    }
                    update(t) {
                      const e = this._deltaAmount;
                      this._autoScrolling
                        ? (this._processAutoScrolling(t), (e.x = 0), (e.y = 0))
                        : (0 === e.x && 0 === e.y) ||
                          (this._processDeltaMove(e), (e.x = 0), (e.y = 0));
                    }
                    onDisable() {
                      this._unregisterEvent(),
                        this._content &&
                          (this._content.off(
                            bf.SIZE_CHANGED,
                            this._calculateBoundary,
                            this
                          ),
                          this._content.off(
                            bf.TRANSFORM_CHANGED,
                            this._scaleChanged,
                            this
                          ),
                          this.view &&
                            (this.view.node.off(
                              bf.TRANSFORM_CHANGED,
                              this._scaleChanged,
                              this
                            ),
                            this.view.node.off(
                              bf.SIZE_CHANGED,
                              this._calculateBoundary,
                              this
                            ))),
                        this._deltaAmount.set(0, 0),
                        this._hideScrollBar(),
                        this.stopAutoScroll();
                    }
                    _registerEvent() {
                      this.node.on(
                        bf.TOUCH_START,
                        this._onTouchBegan,
                        this,
                        !0
                      ),
                        this.node.on(
                          bf.TOUCH_MOVE,
                          this._onTouchMoved,
                          this,
                          !0
                        ),
                        this.node.on(
                          bf.TOUCH_END,
                          this._onTouchEnded,
                          this,
                          !0
                        ),
                        this.node.on(
                          bf.TOUCH_CANCEL,
                          this._onTouchCancelled,
                          this,
                          !0
                        ),
                        this.node.on(
                          bf.MOUSE_WHEEL,
                          this._onMouseWheel,
                          this,
                          !0
                        ),
                        this.node.on(
                          sdt.XRUI_HOVER_ENTERED,
                          this._xrHoverEnter,
                          this
                        ),
                        this.node.on(
                          sdt.XRUI_HOVER_EXITED,
                          this._xrHoverExit,
                          this
                        ),
                        _f.on(
                          uf.EventType.HANDLE_INPUT,
                          this._dispatchEventHandleInput,
                          this
                        ),
                        _f.on(
                          uf.EventType.GAMEPAD_INPUT,
                          this._dispatchEventHandleInput,
                          this
                        );
                    }
                    _unregisterEvent() {
                      this.node.off(
                        bf.TOUCH_START,
                        this._onTouchBegan,
                        this,
                        !0
                      ),
                        this.node.off(
                          bf.TOUCH_MOVE,
                          this._onTouchMoved,
                          this,
                          !0
                        ),
                        this.node.off(
                          bf.TOUCH_END,
                          this._onTouchEnded,
                          this,
                          !0
                        ),
                        this.node.off(
                          bf.TOUCH_CANCEL,
                          this._onTouchCancelled,
                          this,
                          !0
                        ),
                        this.node.off(
                          bf.MOUSE_WHEEL,
                          this._onMouseWheel,
                          this,
                          !0
                        ),
                        this.node.off(
                          sdt.XRUI_HOVER_ENTERED,
                          this._xrHoverEnter,
                          this
                        ),
                        this.node.off(
                          sdt.XRUI_HOVER_EXITED,
                          this._xrHoverExit,
                          this
                        ),
                        _f.off(
                          uf.EventType.HANDLE_INPUT,
                          this._dispatchEventHandleInput,
                          this
                        ),
                        _f.off(
                          uf.EventType.GAMEPAD_INPUT,
                          this._dispatchEventHandleInput,
                          this
                        );
                    }
                    _onMouseWheel(t, e) {
                      if (!this.enabledInHierarchy) return;
                      if (this._hasNestedViewGroup(t, e)) return;
                      const i = new Yi();
                      let s = -0.1;
                      zr.os === zr.OS.WINDOWS
                        ? (s = -0.43)
                        : zr.os === zr.OS.OSX && (s = -0.29);
                      const n = t.getScrollY();
                      if (this.vertical)
                        if (this.view) {
                          const t = this._getHowMuchOutOfBoundary(),
                            e = 0.2 * this.view.contentSize.y;
                          Math.abs(t.y) > e
                            ? i.set(0, 0, 0)
                            : i.set(0, n * s, 0),
                            (this._mouseWheelEventElapsedTime = 0),
                            this._deltaAmount.add(i);
                          const r = this._getHowMuchOutOfBoundary(
                            this._deltaAmount
                          );
                          Math.abs(r.y) > e &&
                            (this._deltaAmount.subtract(i),
                            n > 0
                              ? (i.y += Math.abs(r.y) - e)
                              : n < 0 && (i.y -= Math.abs(r.y) - e),
                            this._deltaAmount.add(i));
                        } else
                          i.set(0, n * s, 0),
                            (this._mouseWheelEventElapsedTime = 0),
                            this._deltaAmount.add(i);
                      else if (this.horizontal) {
                        let e = t.getScrollX();
                        (e = Math.abs(e) > Math.abs(n) ? -e : n),
                          i.set(e * s, 0, 0),
                          (this._mouseWheelEventElapsedTime = 0),
                          this._deltaAmount.add(i);
                      }
                      this._stopMouseWheel ||
                        (this._handlePressLogic(),
                        this.schedule(this._checkMouseWheel, 1 / 60),
                        (this._stopMouseWheel = !0)),
                        this._stopPropagationIfTargetIsMe(t);
                    }
                    _onTouchBegan(t, e) {
                      this.enabledInHierarchy &&
                        this._content &&
                        (this._hasNestedViewGroup(t, e) ||
                          (this._handlePressLogic(),
                          (this._touchMoved = !1),
                          this._stopPropagationIfTargetIsMe(t)));
                    }
                    _onTouchMoved(t, e) {
                      if (!this.enabledInHierarchy || !this._content) return;
                      if (this._hasNestedViewGroup(t, e)) return;
                      const i = t.touch;
                      if ((this._handleMoveLogic(i), !this.cancelInnerEvents))
                        return;
                      const s = i.getUILocation(oft);
                      if (
                        (s.subtract(i.getUIStartLocation(hft)),
                        s.length() > 7 &&
                          !this._touchMoved &&
                          t.target !== this.node)
                      ) {
                        const e = new fm(
                          t.getTouches(),
                          t.bubbles,
                          cm.TOUCH_CANCEL
                        );
                        (e.touch = t.touch),
                          (e.simulate = !0),
                          t.target.dispatchEvent(e),
                          (this._touchMoved = !0);
                      }
                      this._stopPropagationIfTargetIsMe(t);
                    }
                    _onTouchEnded(t, e) {
                      if (!this.enabledInHierarchy || !this._content || !t)
                        return;
                      if (this._hasNestedViewGroup(t, e)) return;
                      this._dispatchEvent(uft.TOUCH_UP);
                      const i = t.touch;
                      this._handleReleaseLogic(i),
                        this._touchMoved
                          ? (t.propagationStopped = !0)
                          : this._stopPropagationIfTargetIsMe(t);
                    }
                    _onTouchCancelled(t, e) {
                      if (
                        this.enabledInHierarchy &&
                        this._content &&
                        !this._hasNestedViewGroup(t, e)
                      ) {
                        if (t && !t.simulate) {
                          const e = t.touch;
                          this._handleReleaseLogic(e);
                        }
                        this._stopPropagationIfTargetIsMe(t);
                      }
                    }
                    _calculateBoundary() {
                      if (this._content && this.view) {
                        const t = this._content.getComponent(Qpt);
                        t && t.enabledInHierarchy && t.updateLayout();
                        const e = this.view,
                          i = e.width * e.anchorX,
                          s = e.height * e.anchorY;
                        (this._leftBoundary = -i),
                          (this._bottomBoundary = -s),
                          (this._rightBoundary = this._leftBoundary + e.width),
                          (this._topBoundary = this._bottomBoundary + e.height),
                          this._moveContentToTopLeft(e.contentSize);
                      }
                    }
                    _hasNestedViewGroup(t, e) {
                      if (!t || t.eventPhase !== lm.CAPTURING_PHASE) return !1;
                      if (e)
                        for (const i of e) {
                          const e = i;
                          if (this.node === e)
                            return !(!t.target || !t.target.getComponent(Bmt));
                          if (e.getComponent(Bmt)) return !0;
                        }
                      return !1;
                    }
                    _startInertiaScroll(t) {
                      const e = new Yi(t);
                      e.multiplyScalar(0.7),
                        this._startAttenuatingAutoScroll(e, t);
                    }
                    _calculateAttenuatedFactor(t) {
                      return this.brake <= 0
                        ? 1 - this.brake
                        : (1 - this.brake) *
                            (1 / (1 + 14e-6 * t + t * t * 8e-9));
                    }
                    _startAttenuatingAutoScroll(t, e) {
                      const i = t.clone();
                      if ((i.normalize(), this._content && this.view)) {
                        const t =
                            this._content._uiProps.uiTransformComp.contentSize,
                          e = this.view.contentSize,
                          s = t.width - e.width,
                          n = t.height - e.height,
                          r = this._calculateAttenuatedFactor(s),
                          a = this._calculateAttenuatedFactor(n);
                        (i.x = i.x * s * (1 - this.brake) * r),
                          (i.y = i.y * n * a * (1 - this.brake)),
                          (i.z = 0);
                      }
                      const s = t.length();
                      let n = i.length() / s;
                      if ((i.add(t), this.brake > 0 && n > 7)) {
                        n = Math.sqrt(n);
                        const e = t.clone();
                        e.multiplyScalar(n), i.set(e), i.add(t);
                      }
                      let r = this._calculateAutoScrollTimeByInitialSpeed(
                        e.length()
                      );
                      this.brake > 0 && n > 3 && ((n = 3), (r *= n)),
                        0 === this.brake && n > 1 && (r *= n),
                        this._startAutoScroll(i, r, !0);
                    }
                    _calculateAutoScrollTimeByInitialSpeed(t) {
                      return Math.sqrt(Math.sqrt(t / 5));
                    }
                    _startAutoScroll(t, e, i = !1) {
                      const s = this._flattenVectorByDirection(t);
                      (this._autoScrolling = !0),
                        (this._autoScrollTargetDelta = s),
                        (this._autoScrollAttenuate = i),
                        Yi.copy(
                          this._autoScrollStartPosition,
                          this._getContentPosition()
                        ),
                        (this._autoScrollTotalTime = e),
                        (this._autoScrollAccumulatedTime = 0),
                        (this._autoScrollBraking = !1),
                        (this._isScrollEndedWithThresholdEventFired = !1),
                        this._autoScrollBrakingStartPosition.set(0, 0, 0),
                        this._getHowMuchOutOfBoundary().equals(Yi.ZERO, nft) ||
                          (this._autoScrollCurrentlyOutOfBoundary = !0);
                    }
                    _calculateTouchMoveVelocity() {
                      const t = new Yi();
                      let e = 0;
                      if (
                        ((e = this._touchMoveTimeDeltas.reduce(
                          (t, e) => t + e,
                          e
                        )),
                        e <= 0 || e >= 0.5)
                      )
                        t.set(Yi.ZERO);
                      else {
                        let i = new Yi();
                        (i = this._touchMoveDisplacements.reduce(
                          (t, e) => (t.add(e), t),
                          i
                        )),
                          t.set(
                            (i.x * (1 - this.brake)) / e,
                            (i.y * (1 - this.brake)) / e,
                            i.z
                          );
                      }
                      return t;
                    }
                    _flattenVectorByDirection(t) {
                      const e = t;
                      return (
                        (e.x = this.horizontal ? e.x : 0),
                        (e.y = this.vertical ? e.y : 0),
                        e
                      );
                    }
                    _moveContent(t, e) {
                      const i = this._flattenVectorByDirection(t);
                      rft.set(this._getContentPosition()),
                        rft.add(i),
                        rft.set(
                          Math.round(1e4 * rft.x) * nft,
                          Math.round(1e4 * rft.y) * nft,
                          rft.z
                        ),
                        this._setContentPosition(rft);
                      const s = this._getHowMuchOutOfBoundary();
                      oft.set(s.x, s.y),
                        this._updateScrollBar(oft),
                        this.elastic && e && this._startBounceBackIfNeeded();
                    }
                    _getContentLeftBoundary() {
                      if (!this._content) return -1;
                      const t = this._getContentPosition(),
                        e = this._content._uiProps.uiTransformComp;
                      return t.x - e.anchorX * e.width;
                    }
                    _getContentRightBoundary() {
                      if (!this._content) return -1;
                      const t = this._content._uiProps.uiTransformComp;
                      return this._getContentLeftBoundary() + t.width;
                    }
                    _getContentTopBoundary() {
                      if (!this._content) return -1;
                      const t = this._content._uiProps.uiTransformComp;
                      return this._getContentBottomBoundary() + t.height;
                    }
                    _getContentBottomBoundary() {
                      if (!this._content) return -1;
                      const t = this._getContentPosition(),
                        e = this._content._uiProps.uiTransformComp;
                      return t.y - e.anchorY * e.height;
                    }
                    _getHowMuchOutOfBoundary(t) {
                      if (
                        (t = t || new Yi()).equals(Yi.ZERO, nft) &&
                        !this._outOfBoundaryAmountDirty
                      )
                        return this._outOfBoundaryAmount;
                      const e = new Yi(),
                        i = this._getContentLeftBoundary(),
                        s = this._getContentRightBoundary();
                      i + t.x > this._leftBoundary
                        ? (e.x = this._leftBoundary - (i + t.x))
                        : s + t.x < this._rightBoundary &&
                          (e.x = this._rightBoundary - (s + t.x));
                      const n = this._getContentTopBoundary(),
                        r = this._getContentBottomBoundary();
                      return (
                        n + t.y < this._topBoundary
                          ? (e.y = this._topBoundary - (n + t.y))
                          : r + t.y > this._bottomBoundary &&
                            (e.y = this._bottomBoundary - (r + t.y)),
                        t.equals(Yi.ZERO, nft) &&
                          ((this._outOfBoundaryAmount = e),
                          (this._outOfBoundaryAmountDirty = !1)),
                        this._clampDelta(e),
                        e
                      );
                    }
                    _updateScrollBar(t) {
                      this._horizontalScrollBar &&
                        this._horizontalScrollBar.isValid &&
                        this._horizontalScrollBar.onScroll(t),
                        this._verticalScrollBar &&
                          this._verticalScrollBar.isValid &&
                          this._verticalScrollBar.onScroll(t);
                    }
                    _onScrollBarTouchBegan() {
                      this._horizontalScrollBar &&
                        this._horizontalScrollBar.isValid &&
                        this._horizontalScrollBar.onTouchBegan(),
                        this._verticalScrollBar &&
                          this._verticalScrollBar.isValid &&
                          this._verticalScrollBar.onTouchBegan();
                    }
                    _onScrollBarTouchEnded() {
                      this._horizontalScrollBar &&
                        this._horizontalScrollBar.isValid &&
                        this._horizontalScrollBar.onTouchEnded(),
                        this._verticalScrollBar &&
                          this._verticalScrollBar.isValid &&
                          this._verticalScrollBar.onTouchEnded();
                    }
                    _dispatchEvent(t) {
                      if (t === uft.SCROLL_ENDED) this._scrollEventEmitMask = 0;
                      else if (
                        t === uft.SCROLL_TO_TOP ||
                        t === uft.SCROLL_TO_BOTTOM ||
                        t === uft.SCROLL_TO_LEFT ||
                        t === uft.SCROLL_TO_RIGHT
                      ) {
                        const e = 1 << cft[t];
                        if (this._scrollEventEmitMask & e) return;
                        this._scrollEventEmitMask |= e;
                      }
                      Yd.emitEvents(this.scrollEvents, this, cft[t]),
                        this.node.emit(t, this);
                    }
                    _adjustContentOutOfBoundary() {
                      if (!this._content) return;
                      this._outOfBoundaryAmountDirty = !0;
                      const t = this._getHowMuchOutOfBoundary();
                      !t.equals(Yi.ZERO, nft) &&
                        (rft.set(this._getContentPosition()),
                        rft.add(t),
                        this._setContentPosition(rft),
                        this._updateScrollBar(Ss.ZERO));
                    }
                    _hideScrollBar() {
                      this._horizontalScrollBar &&
                        this._horizontalScrollBar.isValid &&
                        this._horizontalScrollBar.hide(),
                        this._verticalScrollBar &&
                          this._verticalScrollBar.isValid &&
                          this._verticalScrollBar.hide();
                    }
                    _updateScrollBarState() {
                      if (!this._content || !this.view) return;
                      const t = this.view,
                        e = this._content._uiProps.uiTransformComp;
                      this._verticalScrollBar &&
                        this._verticalScrollBar.isValid &&
                        (e.height < t.height || Ti(e.height, t.height)
                          ? this._verticalScrollBar.hide()
                          : this._verticalScrollBar.show()),
                        this._horizontalScrollBar &&
                          this._horizontalScrollBar.isValid &&
                          (e.width < t.width || Ti(e.width, t.width)
                            ? this._horizontalScrollBar.hide()
                            : this._horizontalScrollBar.show());
                    }
                    _stopPropagationIfTargetIsMe(t) {
                      t.eventPhase === lm.AT_TARGET &&
                        t.target === this.node &&
                        (t.propagationStopped = !0);
                    }
                    _processDeltaMove(t) {
                      this._scrollChildren(t), this._gatherTouchMove(t);
                    }
                    _handleMoveLogic(t) {
                      this._getLocalAxisAlignDelta(this._deltaPos, t),
                        this._deltaAmount.add(this._deltaPos);
                    }
                    _handleReleaseLogic(t) {
                      this._getLocalAxisAlignDelta(this._deltaPos, t),
                        this._gatherTouchMove(this._deltaPos),
                        this._processInertiaScroll(),
                        this._scrolling &&
                          ((this._scrolling = !1),
                          this._autoScrolling ||
                            this._dispatchEvent(uft.SCROLL_ENDED));
                    }
                    _getLocalAxisAlignDelta(t, e) {
                      const i = this.node._uiProps.uiTransformComp,
                        s = new Yi();
                      i &&
                        (e.getUILocation(oft),
                        e.getUIPreviousLocation(hft),
                        rft.set(oft.x, oft.y, 0),
                        aft.set(hft.x, hft.y, 0),
                        i.convertToNodeSpaceAR(rft, rft),
                        i.convertToNodeSpaceAR(aft, aft),
                        Yi.subtract(s, rft, aft)),
                        t.set(s);
                    }
                    _scrollChildren(t) {
                      this._clampDelta(t);
                      const e = t;
                      let i;
                      this.elastic &&
                        ((i = this._getHowMuchOutOfBoundary()),
                        (e.x *= 0 === i.x ? 1 : 0.5),
                        (e.y *= 0 === i.y ? 1 : 0.5)),
                        this.elastic ||
                          ((i = this._getHowMuchOutOfBoundary(e)), e.add(i));
                      let s = uft.NONE,
                        n = uft.NONE;
                      if (this._content) {
                        const {
                            anchorX: t,
                            anchorY: i,
                            width: r,
                            height: a,
                          } = this._content._uiProps.uiTransformComp,
                          o = this._content.position || Yi.ZERO;
                        this.vertical &&
                          (e.y > 0
                            ? o.y - i * a + e.y >= this._bottomBoundary &&
                              (s = uft.SCROLL_TO_BOTTOM)
                            : e.y < 0 &&
                              o.y - i * a + a + e.y <= this._topBoundary &&
                              (s = uft.SCROLL_TO_TOP)),
                          this.horizontal &&
                            (e.x < 0
                              ? o.x - t * r + r + e.x <= this._rightBoundary &&
                                (n = uft.SCROLL_TO_RIGHT)
                              : e.x > 0 &&
                                o.x - t * r + e.x >= this._leftBoundary &&
                                (n = uft.SCROLL_TO_LEFT));
                      }
                      this._moveContent(e, !1),
                        ((this.horizontal && 0 !== e.x) ||
                          (this.vertical && 0 !== e.y)) &&
                          (this._scrolling ||
                            ((this._scrolling = !0),
                            this._dispatchEvent(uft.SCROLL_BEGAN)),
                          this._dispatchEvent(uft.SCROLLING)),
                        s !== uft.NONE && this._dispatchEvent(s),
                        n !== uft.NONE && this._dispatchEvent(n);
                    }
                    _handlePressLogic() {
                      this._autoScrolling &&
                        this._dispatchEvent(uft.SCROLL_ENDED),
                        (this._autoScrolling = !1),
                        (this._isBouncing = !1),
                        (this._touchMovePreviousTimestamp = lft()),
                        (this._touchMoveDisplacements.length = 0),
                        (this._touchMoveTimeDeltas.length = 0),
                        this._onScrollBarTouchBegan();
                    }
                    _clampDelta(t) {
                      if (this._content && this.view) {
                        const e = this.view.contentSize,
                          i = this._content._uiProps.uiTransformComp;
                        i.width < e.width && (t.x = 0),
                          i.height < e.height && (t.y = 0);
                      }
                    }
                    _gatherTouchMove(t) {
                      const e = t.clone();
                      for (
                        this._clampDelta(e);
                        this._touchMoveDisplacements.length >= 5;

                      )
                        this._touchMoveDisplacements.shift(),
                          this._touchMoveTimeDeltas.shift();
                      this._touchMoveDisplacements.push(e);
                      const i = lft();
                      this._touchMoveTimeDeltas.push(
                        (i - this._touchMovePreviousTimestamp) / 1e3
                      ),
                        (this._touchMovePreviousTimestamp = i);
                    }
                    _startBounceBackIfNeeded() {
                      if (!this.elastic) return !1;
                      const t = this._getHowMuchOutOfBoundary();
                      if ((this._clampDelta(t), t.equals(Yi.ZERO, nft)))
                        return !1;
                      const e = Math.max(this.bounceDuration, 0);
                      return (
                        this._startAutoScroll(t, e, !0),
                        this._isBouncing ||
                          (t.y > 0 && this._dispatchEvent(uft.BOUNCE_TOP),
                          t.y < 0 && this._dispatchEvent(uft.BOUNCE_BOTTOM),
                          t.x > 0 && this._dispatchEvent(uft.BOUNCE_RIGHT),
                          t.x < 0 && this._dispatchEvent(uft.BOUNCE_LEFT),
                          (this._isBouncing = !0)),
                        !0
                      );
                    }
                    _processInertiaScroll() {
                      if (!this._startBounceBackIfNeeded() && this.inertia) {
                        const t = this._calculateTouchMoveVelocity();
                        !t.equals(rft, nft) &&
                          this.brake < 1 &&
                          this._startInertiaScroll(t);
                      }
                      this._onScrollBarTouchEnded();
                    }
                    _isOutOfBoundary() {
                      return !this._getHowMuchOutOfBoundary().equals(
                        Yi.ZERO,
                        nft
                      );
                    }
                    _isNecessaryAutoScrollBrake() {
                      if (this._autoScrollBraking) return !0;
                      if (this._isOutOfBoundary()) {
                        if (!this._autoScrollCurrentlyOutOfBoundary)
                          return (
                            (this._autoScrollCurrentlyOutOfBoundary = !0),
                            (this._autoScrollBraking = !0),
                            Yi.copy(
                              this._autoScrollBrakingStartPosition,
                              this._getContentPosition()
                            ),
                            !0
                          );
                      } else this._autoScrollCurrentlyOutOfBoundary = !1;
                      return !1;
                    }
                    _processAutoScrolling(t) {
                      const e = this._isNecessaryAutoScrollBrake(),
                        i = e ? 0.05 : 1;
                      this._autoScrollAccumulatedTime += t * (1 / i);
                      let s = Math.min(
                        1,
                        this._autoScrollAccumulatedTime /
                          this._autoScrollTotalTime
                      );
                      var n;
                      this._autoScrollAttenuate &&
                        ((n = s), (s = (n -= 1) * n * n * n * n + 1));
                      const r = this._autoScrollTargetDelta.clone();
                      r.multiplyScalar(s);
                      const a = this._autoScrollStartPosition.clone();
                      a.add(r);
                      let o = Math.abs(s - 1) <= nft;
                      if (
                        (Math.abs(s - 1) <= this.getScrollEndedEventTiming() &&
                          !this._isScrollEndedWithThresholdEventFired &&
                          (this._dispatchEvent(uft.SCROLL_ENG_WITH_THRESHOLD),
                          (this._isScrollEndedWithThresholdEventFired = !0)),
                        this.elastic)
                      ) {
                        const t = a.clone();
                        t.subtract(this._autoScrollBrakingStartPosition),
                          e && t.multiplyScalar(i),
                          a.set(this._autoScrollBrakingStartPosition),
                          a.add(t);
                      } else {
                        const t = a.clone();
                        t.subtract(this.getContentPosition());
                        const e = this._getHowMuchOutOfBoundary(t);
                        e.equals(Yi.ZERO, nft) || (a.add(e), (o = !0));
                      }
                      o && (this._autoScrolling = !1);
                      const h = a.clone();
                      h.subtract(this._getContentPosition()),
                        this._clampDelta(h),
                        this._moveContent(h, o),
                        this._dispatchEvent(uft.SCROLLING),
                        this._autoScrolling ||
                          ((this._isBouncing = !1),
                          (this._scrolling = !1),
                          this._dispatchEvent(uft.SCROLL_ENDED));
                    }
                    _checkMouseWheel(t) {
                      (this._mouseWheelEventElapsedTime += t),
                        this._mouseWheelEventElapsedTime > 0.1 &&
                          (this._getHowMuchOutOfBoundary().equals(
                            Yi.ZERO,
                            nft
                          ) || this._processInertiaScroll(),
                          this._onScrollBarTouchEnded(),
                          this._scrolling &&
                            ((this._scrolling = !1),
                            this._autoScrolling ||
                              this._dispatchEvent(uft.SCROLL_ENDED)),
                          this.unschedule(this._checkMouseWheel),
                          (this._stopMouseWheel = !1));
                    }
                    _calculateMovePercentDelta(t) {
                      const e = t.anchor,
                        i = t.applyToHorizontal,
                        s = t.applyToVertical;
                      this._calculateBoundary(), e.clampf(Ss.ZERO, Ss.ONE);
                      let n =
                        this._getContentBottomBoundary() - this._bottomBoundary;
                      n = -n;
                      let r =
                        this._getContentLeftBoundary() - this._leftBoundary;
                      r = -r;
                      const a = new Yi();
                      if (this._content && this.view) {
                        let t = 0;
                        const o =
                            this._content._uiProps.uiTransformComp.contentSize,
                          h = this.view.contentSize;
                        i && ((t = o.width - h.width), (a.x = r - t * e.x)),
                          s && ((t = o.height - h.height), (a.y = n - t * e.y));
                      }
                      return a;
                    }
                    _moveContentToTopLeft(t) {
                      let e =
                        this._getContentBottomBoundary() - this._bottomBoundary;
                      e = -e;
                      const i = new Yi();
                      let s = 0,
                        n = this._getContentLeftBoundary() - this._leftBoundary;
                      if (((n = -n), this._content)) {
                        const r =
                          this._content._uiProps.uiTransformComp.contentSize;
                        r.height < t.height &&
                          ((s = r.height - t.height), (i.y = e - s)),
                          r.width < t.width &&
                            ((s = r.width - t.width), (i.x = n));
                      }
                      this._updateScrollBarState(),
                        this._moveContent(i),
                        this._adjustContentOutOfBoundary();
                    }
                    _scaleChanged(t) {
                      t === Cf.SCALE && this._calculateBoundary();
                    }
                    _xrHoverEnter(t) {
                      t.deviceType === idt.Left
                        ? (this._hoverIn = _ft.LEFT)
                        : t.deviceType === idt.Right &&
                          (this._hoverIn = _ft.RIGHT);
                    }
                    _xrHoverExit(t) {
                      this._hoverIn = _ft.NONE;
                    }
                    _dispatchEventHandleInput(t) {
                      let e, i;
                      t instanceof gm
                        ? (e = t.gamepad)
                        : t instanceof ym && (e = t.handleInputDevice),
                        this.enabledInHierarchy &&
                          this._hoverIn !== _ft.NONE &&
                          (this._hoverIn === _ft.LEFT
                            ? ((i = e.leftStick.getValue()),
                              i.equals(Ss.ZERO) || this._xrThumbStickMove(i))
                            : this._hoverIn === _ft.RIGHT &&
                              ((i = e.rightStick.getValue()),
                              i.equals(Ss.ZERO) || this._xrThumbStickMove(i)));
                    }
                    _xrThumbStickMove(t) {
                      if (!this.enabledInHierarchy) return;
                      const e = new Yi(),
                        i = t.y;
                      this.vertical
                        ? e.set(0, -62.5 * i, 0)
                        : this.horizontal && e.set(-62.5 * i, 0, 0),
                        (this._mouseWheelEventElapsedTime = 0),
                        this._deltaAmount.add(e),
                        this._stopMouseWheel ||
                          (this._handlePressLogic(),
                          this.schedule(this._checkMouseWheel, 1 / 60, NaN, 0),
                          (this._stopMouseWheel = !0));
                    }
                  }).EventType = uft),
                  (Xmt = fa(
                    (Wmt = sft).prototype,
                    "bounceDuration",
                    [Na],
                    function () {
                      return 1;
                    }
                  )),
                  (Ymt = fa(Wmt.prototype, "brake", [Na], function () {
                    return 0.5;
                  })),
                  (Kmt = fa(Wmt.prototype, "elastic", [Na], function () {
                    return !0;
                  })),
                  (qmt = fa(Wmt.prototype, "inertia", [Na], function () {
                    return !0;
                  })),
                  s(
                    Wmt.prototype,
                    "content",
                    [zmt],
                    Object.getOwnPropertyDescriptor(Wmt.prototype, "content"),
                    Wmt.prototype
                  ),
                  ($mt = fa(Wmt.prototype, "horizontal", [Na], function () {
                    return !0;
                  })),
                  s(
                    Wmt.prototype,
                    "horizontalScrollBar",
                    [Hmt],
                    Object.getOwnPropertyDescriptor(
                      Wmt.prototype,
                      "horizontalScrollBar"
                    ),
                    Wmt.prototype
                  ),
                  (Zmt = fa(Wmt.prototype, "vertical", [Na], function () {
                    return !0;
                  })),
                  s(
                    Wmt.prototype,
                    "verticalScrollBar",
                    [Gmt],
                    Object.getOwnPropertyDescriptor(
                      Wmt.prototype,
                      "verticalScrollBar"
                    ),
                    Wmt.prototype
                  ),
                  (Qmt = fa(
                    Wmt.prototype,
                    "cancelInnerEvents",
                    [Na],
                    function () {
                      return !0;
                    }
                  )),
                  (Jmt = fa(
                    Wmt.prototype,
                    "scrollEvents",
                    [Vmt, Na],
                    function () {
                      return [];
                    }
                  )),
                  (tft = fa(Wmt.prototype, "_content", [Na], function () {
                    return null;
                  })),
                  (eft = fa(
                    Wmt.prototype,
                    "_horizontalScrollBar",
                    [Na],
                    function () {
                      return null;
                    }
                  )),
                  (ift = fa(
                    Wmt.prototype,
                    "_verticalScrollBar",
                    [Na],
                    function () {
                      return null;
                    }
                  )),
                  (jmt = Wmt))
                ) || jmt)
            ) || jmt)
        ) || jmt);
      var pft, mft, fft, gft, yft, Tft, Sft, Eft, vft, bft, Aft, Cft, Oft;
      t({ ScrollView: dft, ScrollViewComponent: dft }), (a.ScrollView = dft);
      const Ift = new Yi();
      var wft;
      !(function (t) {
        (t[(t.Horizontal = 0)] = "Horizontal"),
          (t[(t.Vertical = 1)] = "Vertical");
      })(wft || (wft = {})),
        de(wft);
      let Rft =
        ((pft = Ca("cc.Slider")),
        (mft = Ia(110)),
        (fft = Oa(CI)),
        (gft = ao(XD)),
        (yft = ao(wft)),
        (Tft = ao([Yd])),
        pft(
          (Sft =
            mft(
              (Sft =
                fft(
                  (((Oft = class extends np {
                    get handle() {
                      return this._handle;
                    }
                    set handle(t) {
                      this._handle !== t && (this._handle = t);
                    }
                    get direction() {
                      return this._direction;
                    }
                    set direction(t) {
                      this._direction !== t &&
                        ((this._direction = t), this._changeLayout());
                    }
                    get progress() {
                      return this._progress;
                    }
                    set progress(t) {
                      this._progress !== t &&
                        ((this._progress = t), this._updateHandlePosition());
                    }
                    constructor() {
                      super(),
                        (this.slideEvents = vft && vft()),
                        (this._handle = bft && bft()),
                        (this._direction = Aft && Aft()),
                        (this._progress = Cft && Cft()),
                        (this._offset = new Yi()),
                        (this._dragging = !1),
                        (this._touchHandle = !1),
                        (this._handleLocalPos = new Yi()),
                        (this._touchPos = new Yi());
                    }
                    __preload() {
                      this._updateHandlePosition();
                    }
                    onEnable() {
                      this._updateHandlePosition(),
                        this.node.on(bf.TOUCH_START, this._onTouchBegan, this),
                        this.node.on(bf.TOUCH_MOVE, this._onTouchMoved, this),
                        this.node.on(bf.TOUCH_END, this._onTouchEnded, this),
                        this.node.on(
                          bf.TOUCH_CANCEL,
                          this._onTouchCancelled,
                          this
                        ),
                        this.node.on(
                          sdt.XRUI_HOVER_STAY,
                          this._xrHoverStay,
                          this
                        ),
                        this.node.on(sdt.XRUI_CLICK, this._xrClick, this),
                        this.node.on(sdt.XRUI_UNCLICK, this._xrUnClick, this),
                        this._handle &&
                          this._handle.isValid &&
                          (this._handle.node.on(
                            bf.TOUCH_START,
                            this._onHandleDragStart,
                            this
                          ),
                          this._handle.node.on(
                            bf.TOUCH_MOVE,
                            this._onTouchMoved,
                            this
                          ),
                          this._handle.node.on(
                            bf.TOUCH_END,
                            this._onTouchEnded,
                            this
                          ));
                    }
                    onDisable() {
                      this.node.off(bf.TOUCH_START, this._onTouchBegan, this),
                        this.node.off(bf.TOUCH_MOVE, this._onTouchMoved, this),
                        this.node.off(bf.TOUCH_END, this._onTouchEnded, this),
                        this.node.off(
                          bf.TOUCH_CANCEL,
                          this._onTouchCancelled,
                          this
                        ),
                        this.node.off(
                          sdt.XRUI_HOVER_STAY,
                          this._xrHoverStay,
                          this
                        ),
                        this.node.off(sdt.XRUI_CLICK, this._xrClick, this),
                        this.node.off(sdt.XRUI_UNCLICK, this._xrUnClick, this),
                        this._handle &&
                          this._handle.isValid &&
                          (this._handle.node.off(
                            bf.TOUCH_START,
                            this._onHandleDragStart,
                            this
                          ),
                          this._handle.node.off(
                            bf.TOUCH_MOVE,
                            this._onTouchMoved,
                            this
                          ),
                          this._handle.node.off(
                            bf.TOUCH_END,
                            this._onTouchEnded,
                            this
                          ));
                    }
                    _onHandleDragStart(t) {
                      if (
                        !t ||
                        !this._handle ||
                        !this._handle.node._uiProps.uiTransformComp
                      )
                        return;
                      (this._dragging = !0), (this._touchHandle = !0);
                      const e = t.touch.getUILocation();
                      Yi.set(this._touchPos, e.x, e.y, 0),
                        this._handle.node._uiProps.uiTransformComp.convertToNodeSpaceAR(
                          this._touchPos,
                          this._offset
                        ),
                        (t.propagationStopped = !0);
                    }
                    _onTouchBegan(t) {
                      this._handle &&
                        t &&
                        ((this._dragging = !0),
                        this._touchHandle || this._handleSliderLogic(t.touch),
                        (t.propagationStopped = !0));
                    }
                    _onTouchMoved(t) {
                      this._dragging &&
                        t &&
                        (this._handleSliderLogic(t.touch),
                        (t.propagationStopped = !0));
                    }
                    _onTouchEnded(t) {
                      (this._dragging = !1),
                        (this._touchHandle = !1),
                        (this._offset = new Yi()),
                        t && (t.propagationStopped = !0);
                    }
                    _onTouchCancelled(t) {
                      (this._dragging = !1), t && (t.propagationStopped = !0);
                    }
                    _handleSliderLogic(t) {
                      this._updateProgress(t), this._emitSlideEvent();
                    }
                    _emitSlideEvent() {
                      Yd.emitEvents(this.slideEvents, this),
                        this.node.emit("slide", this);
                    }
                    _updateProgress(t) {
                      if (!this._handle || !t) return;
                      const e = t.getUILocation();
                      Yi.set(this._touchPos, e.x, e.y, 0);
                      const i = this.node._uiProps.uiTransformComp,
                        s = i.convertToNodeSpaceAR(this._touchPos, Ift);
                      this.direction === wft.Horizontal
                        ? (this.progress = Ei(
                            0.5 + (s.x - this._offset.x) / i.width
                          ))
                        : (this.progress = Ei(
                            0.5 + (s.y - this._offset.y) / i.height
                          ));
                    }
                    _updateHandlePosition() {
                      if (!this._handle) return;
                      this._handleLocalPos.set(this._handle.node.position);
                      const t = this.node._uiProps.uiTransformComp;
                      this._direction === wft.Horizontal
                        ? (this._handleLocalPos.x =
                            -t.width * t.anchorX + this.progress * t.width)
                        : (this._handleLocalPos.y =
                            -t.height * t.anchorY + this.progress * t.height),
                        this._handle.node.setPosition(this._handleLocalPos);
                    }
                    _changeLayout() {
                      const t = this.node._uiProps.uiTransformComp,
                        e = t.contentSize;
                      if ((t.setContentSize(e.height, e.width), this._handle)) {
                        const t = this._handle.node.position;
                        this._direction === wft.Horizontal
                          ? this._handle.node.setPosition(t.x, 0, t.z)
                          : this._handle.node.setPosition(0, t.y, t.z),
                          this._updateHandlePosition();
                      }
                    }
                    _xrHandleProgress(t) {
                      if (!this._touchHandle) {
                        const e = this.node._uiProps.uiTransformComp;
                        e.convertToNodeSpaceAR(t, Ift),
                          this.direction === wft.Horizontal
                            ? (this.progress = Ei(
                                0.5 + (Ift.x - this.node.position.x) / e.width
                              ))
                            : (this.progress = Ei(
                                0.5 + (Ift.y - this.node.position.y) / e.height
                              ));
                      }
                    }
                    _xrClick(t) {
                      this._handle &&
                        ((this._dragging = !0),
                        this._xrHandleProgress(t.hitPoint),
                        this._emitSlideEvent());
                    }
                    _xrUnClick() {
                      (this._dragging = !1), (this._touchHandle = !1);
                    }
                    _xrHoverStay(t) {
                      this._dragging &&
                        (this._xrHandleProgress(t.hitPoint),
                        this._emitSlideEvent());
                    }
                  }).Direction = wft),
                  s(
                    (Eft = Oft).prototype,
                    "handle",
                    [gft],
                    Object.getOwnPropertyDescriptor(Eft.prototype, "handle"),
                    Eft.prototype
                  ),
                  s(
                    Eft.prototype,
                    "direction",
                    [yft],
                    Object.getOwnPropertyDescriptor(Eft.prototype, "direction"),
                    Eft.prototype
                  ),
                  (vft = fa(
                    Eft.prototype,
                    "slideEvents",
                    [Tft, Na],
                    function () {
                      return [];
                    }
                  )),
                  (bft = fa(Eft.prototype, "_handle", [Na], function () {
                    return null;
                  })),
                  (Aft = fa(Eft.prototype, "_direction", [Na], function () {
                    return wft.Horizontal;
                  })),
                  (Cft = fa(Eft.prototype, "_progress", [Na], function () {
                    return 0.1;
                  })),
                  (Sft = Eft))
                ) || Sft)
            ) || Sft)
        ) || Sft);
      function Dft(...t) {
        return Object.assign({}, ...t);
      }
      var xft, Mft, Pft, Nft, Lft, Bft, Fft, Uft, kft, zft, Hft, Gft;
      t({ Slider: Rft, SliderComponent: Rft }),
        (a.Slider = Rft),
        (function (t) {
          t.TOGGLE = "toggle";
        })(Gft || (Gft = {}));
      let Vft =
        ((xft = Ca("cc.Toggle")),
        (Mft = Ia(110)),
        (Pft = Oa(CI)),
        (Nft = ao(XD)),
        (Lft = ao([Yd])),
        xft(
          (Bft =
            Mft(
              (Bft =
                Pft(
                  (((Hft = class t extends kdt {
                    get isChecked() {
                      return this._isChecked;
                    }
                    set isChecked(t) {
                      this._set(t);
                    }
                    get checkMark() {
                      return this._checkMark;
                    }
                    set checkMark(t) {
                      this._checkMark !== t && (this._checkMark = t);
                    }
                    set _resizeToTarget(t) {
                      t && this._resizeNodeToTargetNode();
                    }
                    get _toggleContainer() {
                      const t = this.node.parent;
                      return a.Node.isNode(t)
                        ? t.getComponent("cc.ToggleContainer")
                        : null;
                    }
                    constructor() {
                      super(),
                        (this.checkEvents = Uft && Uft()),
                        (this._isChecked = kft && kft()),
                        (this._checkMark = zft && zft());
                    }
                    _internalToggle() {
                      this.isChecked = !this.isChecked;
                    }
                    _set(t, e = !0) {
                      if (this._isChecked == t) return;
                      this._isChecked = t;
                      const i = this._toggleContainer;
                      i &&
                        i.enabled &&
                        this.enabled &&
                        (t || (!i.anyTogglesChecked() && !i.allowSwitchOff)) &&
                        ((this._isChecked = !0), i.notifyToggleCheck(this, e)),
                        this.playEffect(),
                        e && this._emitToggleEvents();
                    }
                    playEffect() {
                      this._checkMark &&
                        (this._checkMark.node.active = this._isChecked);
                    }
                    setIsCheckedWithoutNotify(t) {
                      this._set(t, !1);
                    }
                    onEnable() {
                      super.onEnable(),
                        this.playEffect(),
                        this.node.on(
                          t.EventType.CLICK,
                          this._internalToggle,
                          this
                        );
                    }
                    onDisable() {
                      super.onDisable(),
                        this.node.off(
                          t.EventType.CLICK,
                          this._internalToggle,
                          this
                        );
                    }
                    _emitToggleEvents() {
                      this.node.emit(t.EventType.TOGGLE, this),
                        this.checkEvents &&
                          Yd.emitEvents(this.checkEvents, this);
                    }
                  }).EventType = Dft(Gft, Ldt)),
                  s(
                    (Fft = Hft).prototype,
                    "checkMark",
                    [Nft],
                    Object.getOwnPropertyDescriptor(Fft.prototype, "checkMark"),
                    Fft.prototype
                  ),
                  (Uft = fa(
                    Fft.prototype,
                    "checkEvents",
                    [Lft, Na],
                    function () {
                      return [];
                    }
                  )),
                  (kft = fa(Fft.prototype, "_isChecked", [Na], function () {
                    return !0;
                  })),
                  (zft = fa(Fft.prototype, "_checkMark", [Na], function () {
                    return null;
                  })),
                  (Bft = Fft))
                ) || Bft)
            ) || Bft)
        ) || Bft);
      var jft, Wft, Xft, Yft, Kft, qft, $ft, Zft;
      t({ Toggle: Vft, ToggleComponent: Vft }), (a.Toggle = Vft);
      let Qft =
        ((jft = Ca("cc.ToggleContainer")),
        (Wft = Ia(110)),
        (Xft = ao([Yd])),
        jft(
          (Yft =
            Wft(
              ((Kft = class extends np {
                get allowSwitchOff() {
                  return this._allowSwitchOff;
                }
                set allowSwitchOff(t) {
                  this._allowSwitchOff = t;
                }
                get allowNotifyAll() {
                  return this._allowNotifyAll;
                }
                set allowNotifyAll(t) {
                  this._allowNotifyAll = t;
                }
                constructor() {
                  super(),
                    (this._allowSwitchOff = qft && qft()),
                    (this._allowNotifyAll = $ft && $ft()),
                    (this.checkEvents = Zft && Zft());
                }
                get toggleItems() {
                  return this.node.children
                    .map((t) => {
                      const e = t.getComponent("cc.Toggle");
                      return e && e.enabled ? e : null;
                    })
                    .filter(Boolean);
                }
                onEnable() {
                  this.ensureValidState(),
                    this.node.on(bf.CHILD_ADDED, this.ensureValidState, this),
                    this.node.on(bf.CHILD_REMOVED, this.ensureValidState, this);
                }
                onDisable() {
                  this.node.off(bf.CHILD_ADDED, this.ensureValidState, this),
                    this.node.off(
                      bf.CHILD_REMOVED,
                      this.ensureValidState,
                      this
                    );
                }
                activeToggles() {
                  return this.toggleItems.filter((t) => t.isChecked);
                }
                anyTogglesChecked() {
                  return !!this.toggleItems.find((t) => t.isChecked);
                }
                notifyToggleCheck(t, e = !0) {
                  if (this.enabledInHierarchy) {
                    for (let i = 0; i < this.toggleItems.length; i++) {
                      const s = this.toggleItems[i];
                      s !== t &&
                        (e && this._allowNotifyAll
                          ? (s.isChecked = !1)
                          : s.setIsCheckedWithoutNotify(!1));
                    }
                    this.checkEvents &&
                      a.Component.EventHandler.emitEvents(this.checkEvents, t);
                  }
                }
                ensureValidState() {
                  const t = this.toggleItems;
                  if (
                    !this._allowSwitchOff &&
                    !this.anyTogglesChecked() &&
                    0 !== t.length
                  ) {
                    const e = t[0];
                    (e.isChecked = !0), this.notifyToggleCheck(e);
                  }
                  const e = this.activeToggles();
                  if (e.length > 1) {
                    const t = e[0];
                    for (let i = 0; i < e.length; ++i) {
                      const s = e[i];
                      s !== t && (s.isChecked = !1);
                    }
                  }
                }
              }),
              (qft = fa(Kft.prototype, "_allowSwitchOff", [Na], function () {
                return !1;
              })),
              ($ft = fa(Kft.prototype, "_allowNotifyAll", [Na], function () {
                return !1;
              })),
              (Zft = fa(Kft.prototype, "checkEvents", [Xft, Na], function () {
                return [];
              })),
              (Yft = Kft))
            ) || Yft)
        ) || Yft);
      var Jft,
        tgt,
        egt,
        igt,
        sgt,
        ngt,
        rgt,
        agt,
        ogt,
        hgt,
        lgt,
        cgt,
        ugt,
        _gt,
        dgt,
        pgt,
        mgt,
        fgt,
        ggt,
        ygt,
        Tgt,
        Sgt,
        Egt,
        vgt,
        bgt,
        Agt;
      t({ ToggleContainer: Qft, ToggleContainerComponent: Qft }),
        (a.ToggleContainer = Qft);
      const Cgt = new Ss();
      function Ogt(t) {
        return t instanceof sS
          ? t.visibleRect
          : t && t._uiProps && t._uiProps.uiTransformComp
          ? t._uiProps.uiTransformComp.contentSize
          : ws.ZERO;
      }
      function Igt(t, e, i, s) {
        t.parent ? Cgt.set(t.parent.scale.x, t.parent.scale.y) : Cgt.set(0, 0);
        let n = Cgt.x,
          r = Cgt.y,
          a = 0,
          o = 0;
        for (let h = t.parent; ; ) {
          if (!h) return (i.x = i.y = 0), void (s.x = s.y = 1);
          const t = h.position;
          if (((a += t.x), (o += t.y), (h = h.parent), h === e)) break;
          {
            h ? Cgt.set(h.scale.x, h.scale.y) : Cgt.set(0, 0);
            const t = Cgt.x,
              e = Cgt.y;
            (a *= t), (o *= e), (n *= t), (r *= e);
          }
        }
        (s.x = 0 !== n ? 1 / n : 1),
          (s.y = 0 !== r ? 1 / r : 1),
          (i.x = -a),
          (i.y = -o);
      }
      let wgt, Rgt;
      !(function (t) {
        (t[(t.ONCE = 0)] = "ONCE"),
          (t[(t.ALWAYS = 1)] = "ALWAYS"),
          (t[(t.ON_WINDOW_RESIZE = 2)] = "ON_WINDOW_RESIZE");
      })(wgt || (wgt = {})),
        de(wgt),
        (function (t) {
          (t[(t.TOP = 1)] = "TOP"),
            (t[(t.MID = 2)] = "MID"),
            (t[(t.BOT = 4)] = "BOT"),
            (t[(t.LEFT = 8)] = "LEFT"),
            (t[(t.CENTER = 16)] = "CENTER"),
            (t[(t.RIGHT = 32)] = "RIGHT"),
            (t[(t.HORIZONTAL = 56)] = "HORIZONTAL"),
            (t[(t.VERTICAL = 7)] = "VERTICAL");
        })(Rgt || (Rgt = {}));
      const Dgt = Rgt.TOP | Rgt.BOT,
        xgt = Rgt.LEFT | Rgt.RIGHT;
      let Mgt =
        ((Jft = Ca("cc.Widget")),
        (tgt = Ia(110)),
        (egt = Oa(CI)),
        (igt = ao(Pf)),
        (sgt = ao(wgt)),
        Jft(
          (ngt =
            tgt(
              (ngt =
                egt(
                  (((Agt = class extends np {
                    constructor() {
                      super(),
                        (this._lastPos = new Yi()),
                        (this._lastSize = new ws()),
                        (this._dirty = !0),
                        (this._hadAlignOnce = !1),
                        (this._alignFlags = agt && agt()),
                        (this._target = ogt && ogt()),
                        (this._left = hgt && hgt()),
                        (this._right = lgt && lgt()),
                        (this._top = cgt && cgt()),
                        (this._bottom = ugt && ugt()),
                        (this._horizontalCenter = _gt && _gt()),
                        (this._verticalCenter = dgt && dgt()),
                        (this._isAbsLeft = pgt && pgt()),
                        (this._isAbsRight = mgt && mgt()),
                        (this._isAbsTop = fgt && fgt()),
                        (this._isAbsBottom = ggt && ggt()),
                        (this._isAbsHorizontalCenter = ygt && ygt()),
                        (this._isAbsVerticalCenter = Tgt && Tgt()),
                        (this._originalWidth = Sgt && Sgt()),
                        (this._originalHeight = Egt && Egt()),
                        (this._alignMode = vgt && vgt()),
                        (this._lockFlags = bgt && bgt());
                    }
                    get target() {
                      return this._target;
                    }
                    set target(t) {
                      this._target !== t &&
                        (this._unregisterTargetEvents(),
                        (this._target = t),
                        this._registerTargetEvents(),
                        this._validateTargetInDEV(),
                        this._recursiveDirty());
                    }
                    get isAlignTop() {
                      return (this._alignFlags & Rgt.TOP) > 0;
                    }
                    set isAlignTop(t) {
                      this._setAlign(Rgt.TOP, t), this._recursiveDirty();
                    }
                    get isAlignBottom() {
                      return (this._alignFlags & Rgt.BOT) > 0;
                    }
                    set isAlignBottom(t) {
                      this._setAlign(Rgt.BOT, t), this._recursiveDirty();
                    }
                    get isAlignLeft() {
                      return (this._alignFlags & Rgt.LEFT) > 0;
                    }
                    set isAlignLeft(t) {
                      this._setAlign(Rgt.LEFT, t), this._recursiveDirty();
                    }
                    get isAlignRight() {
                      return (this._alignFlags & Rgt.RIGHT) > 0;
                    }
                    set isAlignRight(t) {
                      this._setAlign(Rgt.RIGHT, t), this._recursiveDirty();
                    }
                    get isAlignVerticalCenter() {
                      return (this._alignFlags & Rgt.MID) > 0;
                    }
                    set isAlignVerticalCenter(t) {
                      t
                        ? ((this.isAlignTop = !1),
                          (this.isAlignBottom = !1),
                          (this._alignFlags |= Rgt.MID))
                        : (this._alignFlags &= ~Rgt.MID),
                        this._recursiveDirty();
                    }
                    get isAlignHorizontalCenter() {
                      return (this._alignFlags & Rgt.CENTER) > 0;
                    }
                    set isAlignHorizontalCenter(t) {
                      t
                        ? ((this.isAlignLeft = !1),
                          (this.isAlignRight = !1),
                          (this._alignFlags |= Rgt.CENTER))
                        : (this._alignFlags &= ~Rgt.CENTER),
                        this._recursiveDirty();
                    }
                    get isStretchWidth() {
                      return (this._alignFlags & xgt) === xgt;
                    }
                    get isStretchHeight() {
                      return (this._alignFlags & Dgt) === Dgt;
                    }
                    get top() {
                      return this._top;
                    }
                    set top(t) {
                      (this._top = t), this._recursiveDirty();
                    }
                    get editorTop() {
                      return this._isAbsTop ? this._top : 100 * this._top;
                    }
                    set editorTop(t) {
                      (this._top = this._isAbsTop ? t : t / 100),
                        this._recursiveDirty();
                    }
                    get bottom() {
                      return this._bottom;
                    }
                    set bottom(t) {
                      (this._bottom = t), this._recursiveDirty();
                    }
                    get editorBottom() {
                      return this._isAbsBottom
                        ? this._bottom
                        : 100 * this._bottom;
                    }
                    set editorBottom(t) {
                      (this._bottom = this._isAbsBottom ? t : t / 100),
                        this._recursiveDirty();
                    }
                    get left() {
                      return this._left;
                    }
                    set left(t) {
                      (this._left = t), this._recursiveDirty();
                    }
                    get editorLeft() {
                      return this._isAbsLeft ? this._left : 100 * this._left;
                    }
                    set editorLeft(t) {
                      (this._left = this._isAbsLeft ? t : t / 100),
                        this._recursiveDirty();
                    }
                    get right() {
                      return this._right;
                    }
                    set right(t) {
                      (this._right = t), this._recursiveDirty();
                    }
                    get editorRight() {
                      return this._isAbsRight ? this._right : 100 * this._right;
                    }
                    set editorRight(t) {
                      (this._right = this._isAbsRight ? t : t / 100),
                        this._recursiveDirty();
                    }
                    get horizontalCenter() {
                      return this._horizontalCenter;
                    }
                    set horizontalCenter(t) {
                      (this._horizontalCenter = t), this._recursiveDirty();
                    }
                    get editorHorizontalCenter() {
                      return this._isAbsHorizontalCenter
                        ? this._horizontalCenter
                        : 100 * this._horizontalCenter;
                    }
                    set editorHorizontalCenter(t) {
                      (this._horizontalCenter = this._isAbsHorizontalCenter
                        ? t
                        : t / 100),
                        this._recursiveDirty();
                    }
                    get verticalCenter() {
                      return this._verticalCenter;
                    }
                    set verticalCenter(t) {
                      (this._verticalCenter = t), this._recursiveDirty();
                    }
                    get editorVerticalCenter() {
                      return this._isAbsVerticalCenter
                        ? this._verticalCenter
                        : 100 * this._verticalCenter;
                    }
                    set editorVerticalCenter(t) {
                      (this._verticalCenter = this._isAbsVerticalCenter
                        ? t
                        : t / 100),
                        this._recursiveDirty();
                    }
                    get isAbsoluteTop() {
                      return this._isAbsTop;
                    }
                    set isAbsoluteTop(t) {
                      this._isAbsTop !== t &&
                        ((this._isAbsTop = t),
                        this._autoChangedValue(Rgt.TOP, this._isAbsTop));
                    }
                    get isAbsoluteBottom() {
                      return this._isAbsBottom;
                    }
                    set isAbsoluteBottom(t) {
                      this._isAbsBottom !== t &&
                        ((this._isAbsBottom = t),
                        this._autoChangedValue(Rgt.BOT, this._isAbsBottom));
                    }
                    get isAbsoluteLeft() {
                      return this._isAbsLeft;
                    }
                    set isAbsoluteLeft(t) {
                      this._isAbsLeft !== t &&
                        ((this._isAbsLeft = t),
                        this._autoChangedValue(Rgt.LEFT, this._isAbsLeft));
                    }
                    get isAbsoluteRight() {
                      return this._isAbsRight;
                    }
                    set isAbsoluteRight(t) {
                      this._isAbsRight !== t &&
                        ((this._isAbsRight = t),
                        this._autoChangedValue(Rgt.RIGHT, this._isAbsRight));
                    }
                    get isAbsoluteHorizontalCenter() {
                      return this._isAbsHorizontalCenter;
                    }
                    set isAbsoluteHorizontalCenter(t) {
                      this._isAbsHorizontalCenter !== t &&
                        ((this._isAbsHorizontalCenter = t),
                        this._autoChangedValue(
                          Rgt.CENTER,
                          this._isAbsHorizontalCenter
                        ));
                    }
                    get isAbsoluteVerticalCenter() {
                      return this._isAbsVerticalCenter;
                    }
                    set isAbsoluteVerticalCenter(t) {
                      this._isAbsVerticalCenter !== t &&
                        ((this._isAbsVerticalCenter = t),
                        this._autoChangedValue(
                          Rgt.MID,
                          this._isAbsVerticalCenter
                        ));
                    }
                    get alignMode() {
                      return this._alignMode;
                    }
                    set alignMode(t) {
                      (this._alignMode = t), this._recursiveDirty();
                    }
                    get alignFlags() {
                      return this._alignFlags;
                    }
                    set alignFlags(t) {
                      this._alignFlags !== t &&
                        ((this._alignFlags = t), this._recursiveDirty());
                    }
                    updateAlignment() {
                      a._widgetManager.updateAlignment(this.node);
                    }
                    _validateTargetInDEV() {}
                    setDirty() {
                      this._recursiveDirty();
                    }
                    onEnable() {
                      this.node.getPosition(this._lastPos),
                        this._lastSize.set(
                          this.node._uiProps.uiTransformComp.contentSize
                        ),
                        a._widgetManager.add(this),
                        (this._hadAlignOnce = !1),
                        this._registerEvent(),
                        this._registerTargetEvents(),
                        (this.alignMode !== wgt.ON_WINDOW_RESIZE &&
                          this.alignMode !== wgt.ALWAYS) ||
                          this.setDirty();
                    }
                    onDisable() {
                      this.setDirty(),
                        a._widgetManager.remove(this),
                        this._unregisterEvent(),
                        this._unregisterTargetEvents();
                    }
                    onDestroy() {
                      this._removeParentEvent();
                    }
                    _adjustWidgetToAllowMovingInEditor(t) {}
                    _adjustWidgetToAllowResizingInEditor() {}
                    _adjustWidgetToAnchorChanged() {
                      this.setDirty();
                    }
                    _adjustTargetToParentChanged(t) {
                      t && this._unregisterOldParentEvents(t),
                        this.node.getParent() && this._registerTargetEvents(),
                        this._setDirtyByMode();
                    }
                    _registerEvent() {
                      this.node.on(
                        bf.TRANSFORM_CHANGED,
                        this._setDirtyByMode,
                        this
                      ),
                        this.node.on(
                          bf.SIZE_CHANGED,
                          this._setDirtyByMode,
                          this
                        ),
                        this.node.on(
                          bf.ANCHOR_CHANGED,
                          this._adjustWidgetToAnchorChanged,
                          this
                        ),
                        this.node.on(
                          bf.PARENT_CHANGED,
                          this._adjustTargetToParentChanged,
                          this
                        );
                    }
                    _unregisterEvent() {
                      this.node.off(
                        bf.TRANSFORM_CHANGED,
                        this._setDirtyByMode,
                        this
                      ),
                        this.node.off(
                          bf.SIZE_CHANGED,
                          this._setDirtyByMode,
                          this
                        ),
                        this.node.off(
                          bf.ANCHOR_CHANGED,
                          this._adjustWidgetToAnchorChanged,
                          this
                        );
                    }
                    _removeParentEvent() {
                      this.node.off(
                        bf.PARENT_CHANGED,
                        this._adjustTargetToParentChanged,
                        this
                      );
                    }
                    _autoChangedValue(t, e) {
                      if (!((this._alignFlags & t) > 0)) return;
                      const i = this.node.parent && this.node.parent._uiProps,
                        s = i && i.uiTransformComp,
                        n = s ? s.contentSize : Hr;
                      this.isAlignLeft && t === Rgt.LEFT
                        ? (this._left = e
                            ? this._left * n.width
                            : this._left / n.width)
                        : this.isAlignRight && t === Rgt.RIGHT
                        ? (this._right = e
                            ? this._right * n.width
                            : this._right / n.width)
                        : this.isAlignHorizontalCenter && t === Rgt.CENTER
                        ? (this._horizontalCenter = e
                            ? this._horizontalCenter * n.width
                            : this._horizontalCenter / n.width)
                        : this.isAlignTop && t === Rgt.TOP
                        ? (this._top = e
                            ? this._top * n.height
                            : this._top / n.height)
                        : this.isAlignBottom && t === Rgt.BOT
                        ? (this._bottom = e
                            ? this._bottom * n.height
                            : this._bottom / n.height)
                        : this.isAbsoluteVerticalCenter &&
                          t === Rgt.MID &&
                          (this._verticalCenter =
                            this._verticalCenter / n.height),
                        this._recursiveDirty();
                    }
                    _registerTargetEvents() {
                      const t = this._target || this.node.parent;
                      t &&
                        t.getComponent(CI) &&
                        (t.on(bf.TRANSFORM_CHANGED, this._setDirtyByMode, this),
                        t.on(bf.SIZE_CHANGED, this._setDirtyByMode, this),
                        t.on(bf.ANCHOR_CHANGED, this._setDirtyByMode, this));
                    }
                    _unregisterTargetEvents() {
                      const t = this._target || this.node.parent;
                      t &&
                        (t.off(
                          bf.TRANSFORM_CHANGED,
                          this._setDirtyByMode,
                          this
                        ),
                        t.off(bf.SIZE_CHANGED, this._setDirtyByMode, this),
                        t.off(bf.ANCHOR_CHANGED, this._setDirtyByMode, this));
                    }
                    _unregisterOldParentEvents(t) {
                      const e = this._target || t;
                      e &&
                        (e.off(
                          bf.TRANSFORM_CHANGED,
                          this._setDirtyByMode,
                          this
                        ),
                        e.off(bf.SIZE_CHANGED, this._setDirtyByMode, this));
                    }
                    _setDirtyByMode() {
                      this.alignMode === wgt.ALWAYS && this._recursiveDirty();
                    }
                    _setAlign(t, e) {
                      if (e === (this._alignFlags & t) > 0) return;
                      const i = (t & xgt) > 0,
                        s = this.node._uiProps.uiTransformComp;
                      e
                        ? ((this._alignFlags |= t),
                          i
                            ? ((this.isAlignHorizontalCenter = !1),
                              this.isStretchWidth &&
                                (this._originalWidth = s.width))
                            : ((this.isAlignVerticalCenter = !1),
                              this.isStretchHeight &&
                                (this._originalHeight = s.height)))
                        : (i
                            ? this.isStretchWidth &&
                              (s.width = this._originalWidth)
                            : this.isStretchHeight &&
                              (s.height = this._originalHeight),
                          (this._alignFlags &= ~t));
                    }
                    _recursiveDirty() {
                      this._dirty || (this._dirty = !0);
                    }
                  }).AlignMode = wgt),
                  s(
                    (rgt = Agt).prototype,
                    "target",
                    [igt],
                    Object.getOwnPropertyDescriptor(rgt.prototype, "target"),
                    rgt.prototype
                  ),
                  s(
                    rgt.prototype,
                    "alignMode",
                    [sgt],
                    Object.getOwnPropertyDescriptor(rgt.prototype, "alignMode"),
                    rgt.prototype
                  ),
                  (agt = fa(rgt.prototype, "_alignFlags", [Na], function () {
                    return 0;
                  })),
                  (ogt = fa(rgt.prototype, "_target", [Na], function () {
                    return null;
                  })),
                  (hgt = fa(rgt.prototype, "_left", [Na], function () {
                    return 0;
                  })),
                  (lgt = fa(rgt.prototype, "_right", [Na], function () {
                    return 0;
                  })),
                  (cgt = fa(rgt.prototype, "_top", [Na], function () {
                    return 0;
                  })),
                  (ugt = fa(rgt.prototype, "_bottom", [Na], function () {
                    return 0;
                  })),
                  (_gt = fa(
                    rgt.prototype,
                    "_horizontalCenter",
                    [Na],
                    function () {
                      return 0;
                    }
                  )),
                  (dgt = fa(
                    rgt.prototype,
                    "_verticalCenter",
                    [Na],
                    function () {
                      return 0;
                    }
                  )),
                  (pgt = fa(rgt.prototype, "_isAbsLeft", [Na], function () {
                    return !0;
                  })),
                  (mgt = fa(rgt.prototype, "_isAbsRight", [Na], function () {
                    return !0;
                  })),
                  (fgt = fa(rgt.prototype, "_isAbsTop", [Na], function () {
                    return !0;
                  })),
                  (ggt = fa(rgt.prototype, "_isAbsBottom", [Na], function () {
                    return !0;
                  })),
                  (ygt = fa(
                    rgt.prototype,
                    "_isAbsHorizontalCenter",
                    [Na],
                    function () {
                      return !0;
                    }
                  )),
                  (Tgt = fa(
                    rgt.prototype,
                    "_isAbsVerticalCenter",
                    [Na],
                    function () {
                      return !0;
                    }
                  )),
                  (Sgt = fa(rgt.prototype, "_originalWidth", [Na], function () {
                    return 0;
                  })),
                  (Egt = fa(
                    rgt.prototype,
                    "_originalHeight",
                    [Na],
                    function () {
                      return 0;
                    }
                  )),
                  (vgt = fa(rgt.prototype, "_alignMode", [Na], function () {
                    return wgt.ON_WINDOW_RESIZE;
                  })),
                  (bgt = fa(rgt.prototype, "_lockFlags", [Na, Ba], function () {
                    return 0;
                  })),
                  (ngt = rgt))
                ) || ngt)
            ) || ngt)
        ) || ngt);
      var Pgt, Ngt, Lgt, Bgt, Fgt, Ugt, kgt, zgt, Hgt, Ggt, Vgt, jgt;
      t({ Widget: Mgt, WidgetComponent: Mgt }),
        (a.internal.computeInverseTransForTarget = Igt),
        (a.internal.getReadonlyNodeSize = Ogt),
        (a.Widget = Mgt);
      const Wgt = new Qi();
      var Xgt;
      !(function (t) {
        (t[(t.HORIZONTAL = 0)] = "HORIZONTAL"),
          (t[(t.VERTICAL = 1)] = "VERTICAL");
      })(Xgt || (Xgt = {})),
        de(Xgt);
      let Ygt =
        ((Pgt = Ca("cc.PageViewIndicator")),
        (Ngt = Ia(110)),
        (Lgt = ao(uC)),
        (Bgt = ao(Xgt)),
        (Fgt = ao(ws)),
        Pgt(
          (Ugt =
            Ngt(
              (((jgt = class extends np {
                get spriteFrame() {
                  return this._spriteFrame;
                }
                set spriteFrame(t) {
                  this._spriteFrame !== t && (this._spriteFrame = t);
                }
                get direction() {
                  return this._direction;
                }
                set direction(t) {
                  this._direction !== t && (this._direction = t);
                }
                get cellSize() {
                  return this._cellSize;
                }
                set cellSize(t) {
                  this._cellSize !== t && (this._cellSize = t);
                }
                constructor() {
                  super(),
                    (this.spacing = zgt && zgt()),
                    (this._spriteFrame = Hgt && Hgt()),
                    (this._direction = Ggt && Ggt()),
                    (this._cellSize = Vgt && Vgt()),
                    (this._layout = null),
                    (this._pageView = null),
                    (this._indicators = []);
                }
                onLoad() {
                  this._updateLayout();
                }
                setPageView(t) {
                  (this._pageView = t), this._refresh();
                }
                _updateLayout() {
                  (this._layout = this.getComponent(Qpt)),
                    this._layout || (this._layout = this.addComponent(Qpt));
                  const t = this._layout;
                  this.direction === Xgt.HORIZONTAL
                    ? ((t.type = Qpt.Type.HORIZONTAL),
                      (t.spacingX = this.spacing))
                    : this.direction === Xgt.VERTICAL &&
                      ((t.type = Qpt.Type.VERTICAL),
                      (t.spacingY = this.spacing)),
                    (t.resizeMode = Qpt.ResizeMode.CONTAINER);
                }
                _createIndicator() {
                  const t = new Pf();
                  t.layer = this.node.layer;
                  const e = t.addComponent(XD);
                  return (
                    (e.spriteFrame = this.spriteFrame),
                    (e.sizeMode = XD.SizeMode.CUSTOM),
                    (t.parent = this.node),
                    t._uiProps.uiTransformComp.setContentSize(this._cellSize),
                    t
                  );
                }
                _changedState() {
                  const t = this._indicators;
                  if (0 === t.length || !this._pageView) return;
                  const e = this._pageView.curPageIdx;
                  if (!(e >= t.length)) {
                    for (let e = 0; e < t.length; ++e) {
                      const i = t[e];
                      if (!i._uiProps.uiComp) continue;
                      const s = i._uiProps.uiComp;
                      Wgt.set(s.color), (Wgt.a = 127.5), (s.color = Wgt);
                    }
                    if (t[e]._uiProps.uiComp) {
                      const i = t[e]._uiProps.uiComp;
                      Wgt.set(i.color), (Wgt.a = 255), (i.color = Wgt);
                    }
                  }
                }
                _refresh() {
                  if (!this._pageView) return;
                  const t = this._indicators,
                    e = this._pageView.getPages();
                  if (e.length === t.length) return;
                  let i = 0;
                  if (e.length > t.length)
                    for (i = 0; i < e.length; ++i)
                      t[i] || (t[i] = this._createIndicator());
                  else
                    for (i = t.length - e.length; i > 0; --i) {
                      const e = t[i - 1];
                      this.node.removeChild(e), t.splice(i - 1, 1);
                    }
                  this._layout &&
                    this._layout.enabledInHierarchy &&
                    this._layout.updateLayout(),
                    this._changedState();
                }
              }).Direction = Xgt),
              s(
                (kgt = jgt).prototype,
                "spriteFrame",
                [Lgt],
                Object.getOwnPropertyDescriptor(kgt.prototype, "spriteFrame"),
                kgt.prototype
              ),
              s(
                kgt.prototype,
                "direction",
                [Bgt],
                Object.getOwnPropertyDescriptor(kgt.prototype, "direction"),
                kgt.prototype
              ),
              s(
                kgt.prototype,
                "cellSize",
                [Fgt],
                Object.getOwnPropertyDescriptor(kgt.prototype, "cellSize"),
                kgt.prototype
              ),
              (zgt = fa(kgt.prototype, "spacing", [Na], function () {
                return 0;
              })),
              (Hgt = fa(kgt.prototype, "_spriteFrame", [Na], function () {
                return null;
              })),
              (Ggt = fa(kgt.prototype, "_direction", [Na], function () {
                return Xgt.HORIZONTAL;
              })),
              (Vgt = fa(kgt.prototype, "_cellSize", [Na], function () {
                return new ws(20, 20);
              })),
              (Ugt = kgt))
            ) || Ugt)
        ) || Ugt);
      var Kgt,
        qgt,
        $gt,
        Zgt,
        Qgt,
        Jgt,
        tyt,
        eyt,
        iyt,
        syt,
        nyt,
        ryt,
        ayt,
        oyt,
        hyt,
        lyt,
        cyt,
        uyt,
        _yt,
        dyt,
        pyt,
        myt,
        fyt,
        gyt;
      t({ PageViewIndicator: Ygt, PageViewIndicatorComponent: Ygt }),
        (a.PageViewIndicator = Ygt);
      const yyt = new Ss();
      var Tyt, Syt, Eyt;
      !(function (t) {
        (t[(t.Unified = 0)] = "Unified"), (t[(t.Free = 1)] = "Free");
      })(Tyt || (Tyt = {})),
        de(Tyt),
        (function (t) {
          (t[(t.Horizontal = 0)] = "Horizontal"),
            (t[(t.Vertical = 1)] = "Vertical");
        })(Syt || (Syt = {})),
        de(Syt),
        (function (t) {
          t.PAGE_TURNING = "page-turning";
        })(Eyt || (Eyt = {}));
      let vyt =
        ((Kgt = Ca("cc.PageView")),
        (qgt = Ia(110)),
        ($gt = ao(Tyt)),
        (Zgt = ao(Syt)),
        (Qgt = ao(Ygt)),
        (Jgt = ao(Nmt)),
        (tyt = ao(Nmt)),
        (eyt = ao([Yd])),
        (iyt = ao([Yd])),
        Kgt(
          (syt =
            qgt(
              (((gyt = class t extends dft {
                get sizeMode() {
                  return this._sizeMode;
                }
                set sizeMode(t) {
                  this._sizeMode !== t &&
                    ((this._sizeMode = t), this._syncSizeMode());
                }
                get direction() {
                  return this._direction;
                }
                set direction(t) {
                  this._direction !== t &&
                    ((this._direction = t), this._syncScrollDirection());
                }
                get scrollThreshold() {
                  return this._scrollThreshold;
                }
                set scrollThreshold(t) {
                  this._scrollThreshold !== t && (this._scrollThreshold = t);
                }
                get pageTurningEventTiming() {
                  return this._pageTurningEventTiming;
                }
                set pageTurningEventTiming(t) {
                  this._pageTurningEventTiming !== t &&
                    (this._pageTurningEventTiming = t);
                }
                get indicator() {
                  return this._indicator;
                }
                set indicator(t) {
                  this._indicator !== t &&
                    ((this._indicator = t),
                    this.indicator && this.indicator.setPageView(this));
                }
                get curPageIdx() {
                  return this._curPageIdx;
                }
                get verticalScrollBar() {
                  return super.verticalScrollBar;
                }
                set verticalScrollBar(t) {
                  super.verticalScrollBar = t;
                }
                get horizontalScrollBar() {
                  return super.horizontalScrollBar;
                }
                set horizontalScrollBar(t) {
                  super.horizontalScrollBar = t;
                }
                constructor() {
                  super(),
                    (this.autoPageTurningThreshold = ryt && ryt()),
                    (this.horizontal = ayt && ayt()),
                    (this.vertical = oyt && oyt()),
                    (this.cancelInnerEvents = hyt && hyt()),
                    (this.scrollEvents = lyt && lyt()),
                    (this.pageTurningSpeed = cyt && cyt()),
                    (this.pageEvents = uyt && uyt()),
                    (this._sizeMode = _yt && _yt()),
                    (this._direction = dyt && dyt()),
                    (this._scrollThreshold = pyt && pyt()),
                    (this._pageTurningEventTiming = myt && myt()),
                    (this._indicator = fyt && fyt()),
                    (this._curPageIdx = 0),
                    (this._lastPageIdx = 0),
                    (this._pages = []),
                    (this._initContentPos = Ki()),
                    (this._scrollCenterOffsetX = []),
                    (this._scrollCenterOffsetY = []),
                    (this._touchBeganPosition = Es()),
                    (this._touchEndPosition = Es());
                }
                onEnable() {
                  super.onEnable(),
                    this.node.on(
                      bf.SIZE_CHANGED,
                      this._updateAllPagesSize,
                      this
                    ),
                    this.node.on(
                      t.EventType.SCROLL_ENG_WITH_THRESHOLD,
                      this._dispatchPageTurningEvent,
                      this
                    );
                }
                onDisable() {
                  super.onDisable(),
                    this.node.off(
                      bf.SIZE_CHANGED,
                      this._updateAllPagesSize,
                      this
                    ),
                    this.node.off(
                      t.EventType.SCROLL_ENG_WITH_THRESHOLD,
                      this._dispatchPageTurningEvent,
                      this
                    );
                }
                onLoad() {
                  this._initPages(),
                    this.indicator && this.indicator.setPageView(this);
                }
                getCurrentPageIndex() {
                  return this._curPageIdx;
                }
                setCurrentPageIndex(t) {
                  this.scrollToPage(t, 1);
                }
                getPages() {
                  return this._pages;
                }
                addPage(t) {
                  t &&
                    -1 === this._pages.indexOf(t) &&
                    this.content &&
                    (t._uiProps.uiTransformComp
                      ? (this.content.addChild(t),
                        this._pages.push(t),
                        this._updatePageView())
                      : B(4301));
                }
                insertPage(t, e) {
                  if (
                    !(e < 0) &&
                    t &&
                    -1 === this._pages.indexOf(t) &&
                    this.content
                  )
                    if (e >= this._pages.length) this.addPage(t);
                    else {
                      if (!t._uiProps.uiTransformComp) return void B(4301);
                      this._pages.splice(e, 0, t),
                        this.content.insertChild(t, e),
                        this._updatePageView();
                    }
                }
                removePage(t) {
                  if (!t || !this.content) return;
                  const e = this._pages.indexOf(t);
                  -1 !== e ? this.removePageAtIndex(e) : z(4300, t.name);
                }
                removePageAtIndex(t) {
                  const e = this._pages;
                  if (t < 0 || t >= e.length) return;
                  const i = e[t];
                  i &&
                    this.content &&
                    (this.content.removeChild(i),
                    e.splice(t, 1),
                    this._updatePageView());
                }
                removeAllPages() {
                  if (!this.content) return;
                  const t = this._pages;
                  for (let e = 0, i = t.length; e < i; e++)
                    this.content.removeChild(t[e]);
                  (this._pages.length = 0), this._updatePageView();
                }
                scrollToPage(t, e = 0.3) {
                  t < 0 ||
                    t >= this._pages.length ||
                    ((this._curPageIdx = t),
                    this.scrollToOffset(this._moveOffsetValue(t), e, !0),
                    this.indicator && this.indicator._changedState());
                }
                getScrollEndedEventTiming() {
                  return this.pageTurningEventTiming;
                }
                _updatePageView() {
                  if (!this.content) return;
                  const t = this.content.getComponent(Qpt);
                  t && t.enabled && t.updateLayout();
                  const e = this._pages.length;
                  this._curPageIdx >= e &&
                    ((this._curPageIdx = 0 === e ? 0 : e - 1),
                    (this._lastPageIdx = this._curPageIdx));
                  const i = this._initContentPos;
                  for (let t = 0; t < e; ++t) {
                    const e = this._pages[t].position;
                    this.direction === Syt.Horizontal
                      ? (this._scrollCenterOffsetX[t] = Math.abs(i.x + e.x))
                      : (this._scrollCenterOffsetY[t] = Math.abs(i.y + e.y));
                  }
                  this.indicator && this.indicator._refresh();
                }
                _updateAllPagesSize() {
                  const t = this.view;
                  if (!this.content || !t) return;
                  if (this._sizeMode !== Tyt.Unified) return;
                  const e = this._pages,
                    i = t.contentSize;
                  for (let t = 0, s = e.length; t < s; t++)
                    e[t]._uiProps.uiTransformComp.setContentSize(i);
                }
                _handleReleaseLogic() {
                  this._autoScrollToPage(),
                    this._scrolling &&
                      ((this._scrolling = !1),
                      this._autoScrolling ||
                        this._dispatchEvent(t.EventType.SCROLL_ENDED));
                }
                _onTouchBegan(t, e) {
                  t.touch.getUILocation(yyt),
                    Ss.set(this._touchBeganPosition, yyt.x, yyt.y),
                    super._onTouchBegan(t, e);
                }
                _onTouchMoved(t, e) {
                  super._onTouchMoved(t, e);
                }
                _onTouchEnded(t, e) {
                  t.touch.getUILocation(yyt),
                    Ss.set(this._touchEndPosition, yyt.x, yyt.y),
                    super._onTouchEnded(t, e);
                }
                _onTouchCancelled(t, e) {
                  t.touch.getUILocation(yyt),
                    Ss.set(this._touchEndPosition, yyt.x, yyt.y),
                    super._onTouchCancelled(t, e);
                }
                _onMouseWheel() {}
                _syncScrollDirection() {
                  (this.horizontal = this.direction === Syt.Horizontal),
                    (this.vertical = this.direction === Syt.Vertical);
                }
                _syncSizeMode() {
                  const t = this.view;
                  if (!this.content || !t) return;
                  const e = this.content.getComponent(Qpt);
                  if (e) {
                    if (this._sizeMode === Tyt.Free && this._pages.length > 0) {
                      const i = this._pages[0]._uiProps.uiTransformComp,
                        s =
                          this._pages[this._pages.length - 1]._uiProps
                            .uiTransformComp;
                      this.direction === Syt.Horizontal
                        ? ((e.paddingLeft = (t.width - i.width) / 2),
                          (e.paddingRight = (t.width - s.width) / 2))
                        : this.direction === Syt.Vertical &&
                          ((e.paddingTop = (t.height - i.height) / 2),
                          (e.paddingBottom = (t.height - s.height) / 2));
                    }
                    e.updateLayout();
                  }
                }
                _initPages() {
                  if (!this.content) return;
                  this._initContentPos = this.content.position;
                  const t = this.content.children;
                  for (let e = 0; e < t.length; ++e) {
                    const i = t[e];
                    this._pages.indexOf(i) >= 0 || this._pages.push(i);
                  }
                  this._syncScrollDirection(),
                    this._syncSizeMode(),
                    this._updatePageView();
                }
                _dispatchPageTurningEvent() {
                  this._lastPageIdx !== this._curPageIdx &&
                    ((this._lastPageIdx = this._curPageIdx),
                    Yd.emitEvents(this.pageEvents, this, Eyt.PAGE_TURNING),
                    this.node.emit(Eyt.PAGE_TURNING, this));
                }
                _isQuicklyScrollable(t) {
                  if (this.direction === Syt.Horizontal) {
                    if (Math.abs(t.x) > this.autoPageTurningThreshold)
                      return !0;
                  } else if (
                    this.direction === Syt.Vertical &&
                    Math.abs(t.y) > this.autoPageTurningThreshold
                  )
                    return !0;
                  return !1;
                }
                _moveOffsetValue(t) {
                  const e = new Ss();
                  if (this._sizeMode === Tyt.Free)
                    this.direction === Syt.Horizontal
                      ? (e.x = this._scrollCenterOffsetX[t])
                      : this.direction === Syt.Vertical &&
                        (e.y = this._scrollCenterOffsetY[t]);
                  else {
                    const i = this.view;
                    if (!i) return e;
                    this.direction === Syt.Horizontal
                      ? (e.x = t * i.width)
                      : this.direction === Syt.Vertical && (e.y = t * i.height);
                  }
                  return e;
                }
                _getDragDirection(t) {
                  return this._direction === Syt.Horizontal
                    ? 0 === t.x
                      ? 0
                      : t.x > 0
                      ? 1
                      : -1
                    : 0 === t.y
                    ? 0
                    : t.y < 0
                    ? 1
                    : -1;
                }
                _isScrollable(t, e, i) {
                  if (this._sizeMode === Tyt.Free) {
                    let s = 0,
                      n = 0;
                    if (this.direction === Syt.Horizontal)
                      return (
                        (s = this._scrollCenterOffsetX[e]),
                        (n = this._scrollCenterOffsetX[i]),
                        Math.abs(t.x) >= Math.abs(s - n) * this.scrollThreshold
                      );
                    if (this.direction === Syt.Vertical)
                      return (
                        (s = this._scrollCenterOffsetY[e]),
                        (n = this._scrollCenterOffsetY[i]),
                        Math.abs(t.y) >= Math.abs(s - n) * this.scrollThreshold
                      );
                  } else {
                    const e = this.view;
                    if (!e) return !1;
                    if (this.direction === Syt.Horizontal)
                      return Math.abs(t.x) >= e.width * this.scrollThreshold;
                    if (this.direction === Syt.Vertical)
                      return Math.abs(t.y) >= e.height * this.scrollThreshold;
                  }
                  return !1;
                }
                _autoScrollToPage() {
                  if (this._startBounceBackIfNeeded()) {
                    const t = this._getHowMuchOutOfBoundary();
                    this._clampDelta(t),
                      (t.x > 0 || t.y < 0) &&
                        (this._curPageIdx =
                          0 === this._pages.length
                            ? 0
                            : this._pages.length - 1),
                      (t.x < 0 || t.y > 0) && (this._curPageIdx = 0),
                      this.indicator && this.indicator._changedState();
                  } else {
                    const t = new Ss();
                    Ss.subtract(
                      t,
                      this._touchBeganPosition,
                      this._touchEndPosition
                    );
                    const e = this._curPageIdx,
                      i = e + this._getDragDirection(t),
                      s = this.pageTurningSpeed * Math.abs(e - i);
                    if (i < this._pages.length) {
                      if (this._isScrollable(t, e, i))
                        return void this.scrollToPage(i, s);
                      {
                        const t = this._calculateTouchMoveVelocity();
                        if (this._isQuicklyScrollable(t))
                          return void this.scrollToPage(i, s);
                      }
                    }
                    this.scrollToPage(e, s);
                  }
                }
              }).SizeMode = Tyt),
              (gyt.Direction = Syt),
              (gyt.EventType = Dft(Eyt, uft)),
              s(
                (nyt = gyt).prototype,
                "sizeMode",
                [$gt],
                Object.getOwnPropertyDescriptor(nyt.prototype, "sizeMode"),
                nyt.prototype
              ),
              s(
                nyt.prototype,
                "direction",
                [Zgt],
                Object.getOwnPropertyDescriptor(nyt.prototype, "direction"),
                nyt.prototype
              ),
              s(
                nyt.prototype,
                "indicator",
                [Qgt],
                Object.getOwnPropertyDescriptor(nyt.prototype, "indicator"),
                nyt.prototype
              ),
              (ryt = fa(
                nyt.prototype,
                "autoPageTurningThreshold",
                [Na],
                function () {
                  return 100;
                }
              )),
              s(
                nyt.prototype,
                "verticalScrollBar",
                [Jgt, oo],
                Object.getOwnPropertyDescriptor(
                  nyt.prototype,
                  "verticalScrollBar"
                ),
                nyt.prototype
              ),
              s(
                nyt.prototype,
                "horizontalScrollBar",
                [tyt, oo],
                Object.getOwnPropertyDescriptor(
                  nyt.prototype,
                  "horizontalScrollBar"
                ),
                nyt.prototype
              ),
              (ayt = fa(nyt.prototype, "horizontal", [oo, Na], function () {
                return !0;
              })),
              (oyt = fa(nyt.prototype, "vertical", [oo, Na], function () {
                return !0;
              })),
              (hyt = fa(
                nyt.prototype,
                "cancelInnerEvents",
                [oo, Na],
                function () {
                  return !0;
                }
              )),
              (lyt = fa(
                nyt.prototype,
                "scrollEvents",
                [eyt, Na, oo],
                function () {
                  return [];
                }
              )),
              (cyt = fa(nyt.prototype, "pageTurningSpeed", [Na], function () {
                return 0.3;
              })),
              (uyt = fa(nyt.prototype, "pageEvents", [iyt, Na], function () {
                return [];
              })),
              (_yt = fa(nyt.prototype, "_sizeMode", [Na], function () {
                return Tyt.Unified;
              })),
              (dyt = fa(nyt.prototype, "_direction", [Na], function () {
                return Syt.Horizontal;
              })),
              (pyt = fa(nyt.prototype, "_scrollThreshold", [Na], function () {
                return 0.5;
              })),
              (myt = fa(
                nyt.prototype,
                "_pageTurningEventTiming",
                [Na],
                function () {
                  return 0.1;
                }
              )),
              (fyt = fa(nyt.prototype, "_indicator", [Na], function () {
                return null;
              })),
              (syt = nyt))
            ) || syt)
        ) || syt);
      t({ PageView: vyt, PageViewComponent: vyt }), (a.PageView = vyt);
      const byt = new Yi(),
        Ayt = new Ss(),
        Cyt = new Ss(),
        Oyt = new Ss(1, 1),
        Iyt = new Ss(),
        wyt = new Ss();
      function Ryt(t, e) {
        if (e._hadAlignOnce && e.alignMode === wgt.ONCE) return;
        e.alignMode === wgt.ONCE && (e._hadAlignOnce = !0);
        const i = e.target;
        let s;
        const n = Cyt,
          r = Oyt;
        if (
          (i ? ((s = i), Igt(t, s, n, r)) : (s = Qn(t, !0) ? t.parent : null),
          null == s)
        )
          return;
        const a = Ogt(s),
          o = s instanceof sS || !s.getComponent(CI),
          h = o ? Ayt : s.getComponent(CI).anchorPoint,
          l = o;
        t.getPosition(byt);
        const c = t._uiProps.uiTransformComp;
        let u = byt.x,
          _ = byt.y;
        const d = c.anchorPoint,
          p = t.scale;
        if (e.alignFlags & Rgt.HORIZONTAL) {
          let s = 0,
            o = 0;
          const _ = a.width;
          if (l) {
            var m;
            let e =
              null !== (m = t.scene) && void 0 !== m && m.visibleRect
                ? t.scene.visibleRect
                : Hr;
            (s = e.left.x), (o = e.right.x);
          } else (s = -h.x * _), (o = s + _);
          (s += e.isAbsoluteLeft ? e.left : e.left * _),
            (o -= e.isAbsoluteRight ? e.right : e.right * _),
            i && ((s += n.x), (s *= r.x), (o += n.x), (o *= r.x));
          let f = 0,
            g = d.x,
            y = p.x;
          if ((y < 0 && ((g = 1 - g), (y = -y)), e.isStretchWidth))
            (f = o - s), 0 !== y && (c.width = f / y), (u = s + g * f);
          else {
            if (((f = c.width * y), e.isAlignHorizontalCenter)) {
              let t = e.isAbsoluteHorizontalCenter
                  ? e.horizontalCenter
                  : e.horizontalCenter * _,
                s = (0.5 - h.x) * a.width;
              i && ((t *= r.x), (s += n.x), (s *= r.x)),
                (u = s + (g - 0.5) * f + t);
            } else u = e.isAlignLeft ? s + g * f : o + (g - 1) * f;
            Ti(y, 0, gi) ? (f = c.width) : (f /= y);
          }
          e._lastSize.width = f;
        }
        if (e.alignFlags & Rgt.VERTICAL) {
          let s = 0,
            o = 0;
          const u = a.height;
          if (l) {
            let e = t.scene.visibleRect ? t.scene.visibleRect : Hr;
            (o = e.bottom.y), (s = e.top.y);
          } else (o = -h.y * u), (s = o + u);
          (o += e.isAbsoluteBottom ? e.bottom : e.bottom * u),
            (s -= e.isAbsoluteTop ? e.top : e.top * u),
            i && ((o += n.y), (o *= r.y), (s += n.y), (s *= r.y));
          let m = 0,
            f = d.y,
            g = p.y;
          if ((g < 0 && ((f = 1 - f), (g = -g)), e.isStretchHeight))
            (m = s - o), 0 !== g && (c.height = m / g), (_ = o + f * m);
          else {
            if (((m = c.height * g), e.isAlignVerticalCenter)) {
              let t = e.isAbsoluteVerticalCenter
                  ? e.verticalCenter
                  : e.verticalCenter * u,
                s = (0.5 - h.y) * a.height;
              i && ((t *= r.y), (s += n.y), (s *= r.y)),
                (_ = s + (f - 0.5) * m + t);
            } else _ = e.isAlignBottom ? o + f * m : s + (f - 1) * m;
            Ti(g, 0, gi) ? (m = c.height) : (m /= g);
          }
          e._lastSize.height = m;
        }
        t.setPosition(u, _, byt.z), Yi.set(e._lastPos, u, _, byt.z);
      }
      function Dyt(t) {
        const e = t.getComponent(Mgt);
        if (e && e.enabled) {
          if (!a.isValid(t, !0)) return;
          Myt.push(e);
        }
        const i = t.children;
        if (null != i) for (const t of i) t.active && Dyt(t);
      }
      function xyt() {
        if (Lv.getScene()) {
          if (((Pyt.isAligning = !0), Pyt._nodesOrderDirty)) {
            Myt.length = 0;
            for (let [t, e] of Lv.scenes) Dyt(e);
            Pyt._nodesOrderDirty = !1;
          }
          let t = null;
          const e = Pyt._activeWidgetsIterator;
          for (e.i = 0; e.i < Myt.length; ++e.i)
            (t = Myt[e.i]), t._dirty && (Ryt(t.node, t), (t._dirty = !1));
          Pyt.isAligning = !1;
        }
      }
      const Myt = [],
        Pyt = t(
          "widgetManager",
          (a._widgetManager = {
            isAligning: !1,
            _nodesOrderDirty: !1,
            _activeWidgetsIterator: new Zt(Myt),
            animationState: null,
            init() {
              Lv.on(Nv.EVENT_AFTER_SCENE_LAUNCH, xyt),
                Lv.on(Nv.EVENT_AFTER_UPDATE, xyt),
                UA.instance.on(
                  "design-resolution-changed",
                  this.onResized,
                  this
                );
              {
                const t = this.onResized.bind(this),
                  e = this.onResizedWindow.bind(this);
                UA.instance.on("canvas-resize", t), Ur.on("window-resize", e);
              }
            },
            add(t) {
              (this._nodesOrderDirty = !0), Ryt(t.node, t);
            },
            remove(t) {
              this._activeWidgetsIterator.remove(t);
            },
            onResized(t = 1) {
              var e;
              const i =
                null == Lv || null === (e = Lv.scenes) || void 0 === e
                  ? void 0
                  : e.get(t);
              i && this.refreshWidgetOnResized(i);
            },
            onResizedWindow(t, e, i = 1) {
              var s;
              const n =
                null == Lv || null === (s = Lv.scenes) || void 0 === s
                  ? void 0
                  : s.get(i);
              n && this.refreshWidgetOnResized(n);
            },
            refreshWidgetOnResized(t) {
              const e = Pf.isNode(t) && t.getComponent(Mgt);
              e &&
                e.enabled &&
                (e.alignMode === wgt.ON_WINDOW_RESIZE ||
                  e.alignMode === wgt.ALWAYS) &&
                e.setDirty();
              const i = t.children;
              for (let t = 0, e = i.length; t < e; t++) {
                let e = i[t];
                Qn(e, !0) && e.active && this.refreshWidgetOnResized(e);
              }
            },
            updateOffsetsToStayPut(t, e) {
              function i(t, e) {
                return Math.abs(t - e) > 1e-10 ? e : t;
              }
              const s = t.node;
              let n = s.parent;
              if (n) {
                const r = Iyt;
                r.set(0, 0);
                const a = wyt;
                if (
                  (a.set(1, 1),
                  t.target && ((n = t.target), Igt(s, n, r, a)),
                  !e)
                )
                  return;
                const o = n._uiProps && n._uiProps.uiTransformComp,
                  h = o ? o.anchorPoint : Ayt,
                  l = s._uiProps.uiTransformComp,
                  c = Ogt(n),
                  u = l.anchorPoint,
                  _ = s.position,
                  d = Rgt,
                  p = s.scale;
                let m = 0;
                if (e & d.LEFT) {
                  let e = -h.x * c.width;
                  (e += r.x),
                    (e *= a.x),
                    (m = _.x - u.x * l.width * Math.abs(p.x) - e),
                    t.isAbsoluteLeft || (m /= c.width),
                    (m /= a.x),
                    (t.left = i(t.left, m));
                }
                if (e & d.RIGHT) {
                  let e = (1 - h.x) * c.width;
                  (e += r.x),
                    (m =
                      (e *= a.x) - (_.x + (1 - u.x) * l.width * Math.abs(p.x))),
                    t.isAbsoluteRight || (m /= c.width),
                    (m /= a.x),
                    (t.right = i(t.right, m));
                }
                if (e & d.TOP) {
                  let e = (1 - h.y) * c.height;
                  (e += r.y),
                    (m =
                      (e *= a.y) -
                      (_.y + (1 - u.y) * l.height * Math.abs(p.y))),
                    t.isAbsoluteTop || (m /= c.height),
                    (m /= a.y),
                    (t.top = i(t.top, m));
                }
                if (e & d.BOT) {
                  let e = -h.y * c.height;
                  (e += r.y),
                    (e *= a.y),
                    (m = _.y - u.y * l.height * Math.abs(p.y) - e),
                    t.isAbsoluteBottom || (m /= c.height),
                    (m /= a.y),
                    (t.bottom = i(t.bottom, m));
                }
              }
            },
            updateAlignment: function t(e) {
              if (!Qn(e, !0)) return;
              const i = e.parent;
              i && Pf.isNode(i) && t(i);
              const s = e.getComponent(Mgt);
              s && i && Ryt(e, s);
            },
            AlignMode: wgt,
            AlignFlags: Rgt,
          })
        );
      var Nyt, Lyt, Byt;
      Lv.on(Nv.EVENT_INIT, () => {
        Pyt.init();
      });
      let Fyt =
        Ca("cc.SafeArea")(
          (Nyt =
            Ia(110)(
              (Nyt =
                Oa(Mgt)(
                  ((Lyt = class extends np {
                    get symmetric() {
                      return this._symmetric;
                    }
                    set symmetric(t) {
                      this._symmetric = t;
                    }
                    constructor() {
                      super(), (this._symmetric = Byt && Byt());
                    }
                    onEnable() {
                      this.updateArea(),
                        Ur.on("window-resize", this.updateArea, this),
                        Ur.on("orientation-change", this.updateArea, this);
                    }
                    onDisable() {
                      Ur.off("window-resize", this.updateArea, this),
                        Ur.off("orientation-change", this.updateArea, this);
                    }
                    updateArea() {
                      const t = this.node.getComponent(Mgt),
                        e = this.node.getComponent(CI);
                      if (!t || !e) return;
                      t.updateAlignment();
                      const i = this.node.position.clone(),
                        s = e.anchorPoint.clone();
                      t.isAlignTop =
                        t.isAlignBottom =
                        t.isAlignLeft =
                        t.isAlignRight =
                          !0;
                      const n = GA.getVisibleSize(),
                        r = n.width,
                        a = n.height,
                        o = zr.getSafeAreaRect(this._symmetric);
                      (t.top = a - o.y - o.height),
                        (t.bottom = o.y),
                        (t.left = o.x),
                        (t.right = r - o.x - o.width),
                        t.updateAlignment();
                      const h = this.node.position.clone(),
                        l = s.x - (h.x - i.x) / e.width,
                        c = s.y - (h.y - i.y) / e.height;
                      e.setAnchorPoint(l, c), Pyt.add(t);
                    }
                  }),
                  (Byt = fa(Lyt.prototype, "_symmetric", [Na], function () {
                    return !0;
                  })),
                  (Nyt = Lyt))
                ) || Nyt)
            ) || Nyt)
        ) || Nyt;
      var Uyt, kyt, zyt, Hyt, Gyt, Vyt, jyt, Wyt, Xyt, Yyt, Kyt, qyt;
      t({ SafeArea: Fyt, SafeAreaComponent: Fyt }), (a.SafeArea = Fyt);
      let $yt =
        ((Uyt = Ca("cc.UICoordinateTracker")),
        (kyt = Ia(110)),
        (zyt = ao(Pf)),
        (Hyt = ao(nM)),
        (Gyt = ao([Yd])),
        Uyt(
          (Vyt =
            kyt(
              (s(
                (jyt = class extends np {
                  get target() {
                    return this._target;
                  }
                  set target(t) {
                    this._target !== t &&
                      ((this._target = t), this._checkCanMove());
                  }
                  get camera() {
                    return this._camera;
                  }
                  set camera(t) {
                    this._camera !== t &&
                      ((this._camera = t), this._checkCanMove());
                  }
                  get useScale() {
                    return this._useScale;
                  }
                  set useScale(t) {
                    this._useScale !== t && (this._useScale = t);
                  }
                  get distance() {
                    return this._distance;
                  }
                  set distance(t) {
                    this._distance !== t && (this._distance = t);
                  }
                  constructor() {
                    super(),
                      (this.syncEvents = Wyt && Wyt()),
                      (this._target = Xyt && Xyt()),
                      (this._camera = Yyt && Yyt()),
                      (this._useScale = Kyt && Kyt()),
                      (this._distance = qyt && qyt()),
                      (this._transformPos = Ki()),
                      (this._viewPos = Ki()),
                      (this._canMove = !0),
                      (this._lastWPos = Ki()),
                      (this._lastCameraPos = Ki());
                  }
                  onEnable() {
                    this._checkCanMove();
                  }
                  update() {
                    const t = this.node.worldPosition,
                      e = this._camera;
                    if (
                      this._canMove &&
                      e &&
                      e.camera &&
                      (!this._lastWPos.equals(t) ||
                        !this._lastCameraPos.equals(e.node.worldPosition)) &&
                      (this._lastWPos.set(t),
                      this._lastCameraPos.set(e.node.worldPosition),
                      e.camera.update(),
                      e.convertToUINode(t, this._target, this._transformPos),
                      this._useScale &&
                        Yi.transformMat4(
                          this._viewPos,
                          this.node.worldPosition,
                          e.camera.matView
                        ),
                      this.syncEvents.length > 0)
                    ) {
                      const t = this._distance / Math.abs(this._viewPos.z);
                      Yd.emitEvents(this.syncEvents, this._transformPos, t);
                    }
                  }
                  _checkCanMove() {
                    this._canMove = !(!this._camera || !this._target);
                  }
                }).prototype,
                "target",
                [zyt],
                Object.getOwnPropertyDescriptor(jyt.prototype, "target"),
                jyt.prototype
              ),
              s(
                jyt.prototype,
                "camera",
                [Hyt],
                Object.getOwnPropertyDescriptor(jyt.prototype, "camera"),
                jyt.prototype
              ),
              (Wyt = fa(jyt.prototype, "syncEvents", [Gyt, Na], function () {
                return [];
              })),
              (Xyt = fa(jyt.prototype, "_target", [Na], function () {
                return null;
              })),
              (Yyt = fa(jyt.prototype, "_camera", [Na], function () {
                return null;
              })),
              (Kyt = fa(jyt.prototype, "_useScale", [Na], function () {
                return !0;
              })),
              (qyt = fa(jyt.prototype, "_distance", [Na], function () {
                return 1;
              })),
              (Vyt = jyt))
            ) || Vyt)
        ) || Vyt);
      var Zyt;
      t({ UICoordinateTracker: $yt, UICoordinateTrackerComponent: $yt });
      const Qyt = [
        bf.TOUCH_START,
        bf.TOUCH_END,
        bf.TOUCH_MOVE,
        bf.MOUSE_DOWN,
        bf.MOUSE_MOVE,
        bf.MOUSE_UP,
        bf.MOUSE_ENTER,
        bf.MOUSE_LEAVE,
        bf.MOUSE_WHEEL,
      ];
      function Jyt(t) {
        t.propagationStopped = !0;
      }
      let tTt =
        Ca("cc.BlockInputEvents")(
          (Zyt = class extends np {
            onEnable() {
              for (let t = 0; t < Qyt.length; t++)
                this.node.on(Qyt[t], Jyt, this);
            }
            onDisable() {
              for (let t = 0; t < Qyt.length; t++)
                this.node.off(Qyt[t], Jyt, this);
            }
          })
        ) || Zyt;
      var eTt, iTt, sTt, nTt;
      t({ BlockInputEvents: tTt, BlockInputEventsComponent: tTt });
      let rTt = t(
        "SubContextView",
        Ca("cc.SubContextView")(
          (eTt =
            Ia(110)(
              (eTt =
                Oa(CI)(
                  ((iTt = class extends np {
                    get designResolutionSize() {
                      return this._designResolutionSize;
                    }
                    set designResolutionSize(t) {}
                    get fps() {
                      return this._fps;
                    }
                    set fps(t) {
                      this._fps !== t &&
                        ((this._fps = t), (this._updateInterval = 1e3 / t));
                    }
                    constructor() {
                      super(),
                        (this._fps = sTt && sTt()),
                        (this._sprite = null),
                        (this._imageAsset = new wd()),
                        (this._texture = new sm()),
                        (this._updatedTime = 0),
                        (this._updateInterval = 0),
                        (this._openDataContext = null),
                        (this._content = new Pf("content")),
                        (this._designResolutionSize = nTt && nTt()),
                        (this._content.hideFlags |=
                          $n.Flags.DontSave | $n.Flags.HideInHierarchy),
                        (this._updatedTime = performance.now());
                    }
                    onLoad() {
                      q_.getOpenDataContext
                        ? ((this._updateInterval = 1e3 / this._fps),
                          (this._openDataContext = q_.getOpenDataContext()),
                          this._initSharedCanvas(),
                          this._initContentNode(),
                          this._updateSubContextView(),
                          this._updateContentLayer())
                        : (this.enabled = !1);
                    }
                    onEnable() {
                      this._registerNodeEvent();
                    }
                    onDisable() {
                      this._unregisterNodeEvent();
                    }
                    _initSharedCanvas() {
                      if (this._openDataContext) {
                        const t = this._openDataContext.canvas;
                        let e = this._designResolutionSize.width,
                          i = this._designResolutionSize.height;
                        (t.width = e), (t.height = i);
                      }
                    }
                    _initContentNode() {
                      if (this._openDataContext) {
                        const t = this._openDataContext.canvas,
                          e = this._imageAsset;
                        if (
                          (e.reset(t),
                          (this._texture.image = e),
                          this._texture.create(t.width, t.height),
                          (this._sprite = this._content.getComponent(XD)),
                          this._sprite ||
                            (this._sprite = this._content.addComponent(XD)),
                          this._sprite.spriteFrame)
                        )
                          this._sprite.spriteFrame.texture = this._texture;
                        else {
                          const t = new uC();
                          (t.texture = this._texture),
                            (this._sprite.spriteFrame = t);
                        }
                        this._content.parent = this.node;
                      }
                    }
                    _updateSubContextView() {
                      if (!this._openDataContext) return;
                      const t = this.node.getComponent(CI),
                        e = this._content.getComponent(CI),
                        i = t.width / e.width,
                        s = t.height / e.height,
                        n = i > s ? s : i;
                      (e.width *= n), (e.height *= n);
                      const r = GA.getViewportRect(),
                        a = e.getBoundingBoxToWorld(),
                        o = GA.getVisibleSize(),
                        h = Ur.devicePixelRatio,
                        l = (r.width * (a.x / o.width) + r.x) / h,
                        c = (r.height * (a.y / o.height) + r.y) / h,
                        u = (r.width * (a.width / o.width)) / h,
                        _ = (r.height * (a.height / o.height)) / h;
                      this._openDataContext.postMessage({
                        fromEngine: !0,
                        type: "engine",
                        event: "viewport",
                        x: l,
                        y: c,
                        width: u,
                        height: _,
                      });
                    }
                    _updateSubContextTexture() {
                      const t = this._imageAsset;
                      if (!t || !this._openDataContext) return;
                      if (t.width <= 0 || t.height <= 0) return;
                      const e = this._openDataContext.canvas;
                      t.reset(e),
                        (e.width > t.width || e.height > t.height) &&
                          this._texture.create(e.width, e.height),
                        this._texture.uploadData(e);
                    }
                    _registerNodeEvent() {
                      this.node.on(
                        bf.TRANSFORM_CHANGED,
                        this._updateSubContextView,
                        this
                      ),
                        this.node.on(
                          bf.SIZE_CHANGED,
                          this._updateSubContextView,
                          this
                        ),
                        this.node.on(
                          bf.LAYER_CHANGED,
                          this._updateContentLayer,
                          this
                        );
                    }
                    _unregisterNodeEvent() {
                      this.node.off(
                        bf.TRANSFORM_CHANGED,
                        this._updateSubContextView,
                        this
                      ),
                        this.node.off(
                          bf.SIZE_CHANGED,
                          this._updateSubContextView,
                          this
                        ),
                        this.node.off(
                          bf.LAYER_CHANGED,
                          this._updateContentLayer,
                          this
                        );
                    }
                    _updateContentLayer() {
                      this._content.layer = this.node.layer;
                    }
                    update(t) {
                      void 0 !== t
                        ? performance.now() - this._updatedTime >=
                            this._updateInterval &&
                          ((this._updatedTime += this._updateInterval),
                          this._updateSubContextTexture())
                        : this._updateSubContextTexture();
                    }
                    onDestroy() {
                      this._content.destroy(),
                        this._texture.destroy(),
                        this._sprite && this._sprite.destroy(),
                        this._imageAsset.destroy(),
                        (this._openDataContext = null);
                    }
                  }),
                  (sTt = fa(iTt.prototype, "_fps", [Na], function () {
                    return 60;
                  })),
                  (nTt = fa(
                    iTt.prototype,
                    "_designResolutionSize",
                    [Na],
                    function () {
                      return new ws(640, 960);
                    }
                  )),
                  (eTt = iTt))
                ) || eTt)
            ) || eTt)
        ) || eTt
      );
      var aTt;
      (a.SubContextView = rTt),
        rt({
          ButtonComponent: { newName: "Button", since: "1.2.0", removed: !1 },
          EditBoxComponent: { newName: "EditBox", since: "1.2.0", removed: !1 },
          LayoutComponent: { newName: "Layout", since: "1.2.0", removed: !1 },
          ProgressBarComponent: {
            newName: "ProgressBar",
            since: "1.2.0",
            removed: !1,
          },
          ScrollViewComponent: {
            newName: "ScrollView",
            since: "1.2.0",
            removed: !1,
          },
          ScrollBarComponent: {
            newName: "ScrollBar",
            since: "1.2.0",
            removed: !1,
          },
          SliderComponent: { newName: "Slider", since: "1.2.0", removed: !1 },
          ToggleComponent: { newName: "Toggle", since: "1.2.0", removed: !1 },
          ToggleContainerComponent: {
            newName: "ToggleContainer",
            since: "1.2.0",
            removed: !1,
          },
          WidgetComponent: { newName: "Widget", since: "1.2.0", removed: !1 },
          PageViewComponent: {
            newName: "PageView",
            since: "1.2.0",
            removed: !1,
          },
          PageViewIndicatorComponent: {
            newName: "PageViewIndicator",
            since: "1.2.0",
            removed: !1,
          },
          SafeAreaComponent: {
            newName: "SafeArea",
            since: "1.2.0",
            removed: !1,
          },
          UICoordinateTrackerComponent: {
            newName: "UICoordinateTracker",
            since: "1.2.0",
            removed: !1,
          },
          BlockInputEventsComponent: {
            newName: "BlockInputEvents",
            since: "1.2.0",
            removed: !1,
          },
        });
      let oTt,
        hTt = t(
          "UIReorderComponent",
          Ca("cc.UIReorderComponent")(
            (aTt = class {
              constructor() {
                z(1408, "UIReorderComponent");
              }
            })
          ) || aTt
        );
      (a.UIReorderComponent = hTt),
        (a.ButtonComponent = kdt),
        Vt(kdt, "cc.ButtonComponent"),
        (a.EditBoxComponent = fpt),
        Vt(fpt, "cc.EditBoxComponent"),
        (a.LayoutComponent = Qpt),
        Vt(Qpt, "cc.LayoutComponent"),
        (a.ProgressBarComponent = dmt),
        Vt(dmt, "cc.ProgressBarComponent"),
        (a.ScrollViewComponent = dft),
        Vt(dft, "cc.ScrollViewComponent"),
        (a.ScrollBarComponent = Nmt),
        Vt(Nmt, "cc.ScrollBarComponent"),
        (a.SliderComponent = Rft),
        Vt(Rft, "cc.SliderComponent"),
        (a.ToggleComponent = Vft),
        Vt(Vft, "cc.ToggleComponent"),
        (a.ToggleContainerComponent = Qft),
        Vt(Qft, "cc.ToggleContainerComponent"),
        (a.WidgetComponent = Mgt),
        Vt(Mgt, "cc.WidgetComponent"),
        (a.PageViewComponent = vyt),
        Vt(vyt, "cc.PageViewComponent"),
        (a.PageViewIndicatorComponent = Ygt),
        Vt(Ygt, "cc.PageViewIndicatorComponent"),
        (a.SafeAreaComponent = Fyt),
        Vt(Fyt, "cc.SafeAreaComponent"),
        Vt($yt, "cc.UICoordinateTrackerComponent"),
        (a.BlockInputEventsComponent = tTt),
        Vt(tTt, "cc.BlockInputEventsComponent"),
        Z(UA.prototype, "View.prototype", [
          {
            name: "isAntiAliasEnabled",
            suggest:
              "The API of Texture2d have been largely modified, no alternative",
          },
          {
            name: "enableAntiAlias",
            suggest:
              "The API of Texture2d have been largely modified, no alternative",
          },
        ]),
        Q(UA.prototype, "View.prototype", [
          { name: "adjustViewportMeta" },
          {
            name: "enableAutoFullScreen",
            suggest: "use screen.requestFullScreen() instead.",
          },
          { name: "isAutoFullScreenEnabled" },
          {
            name: "setCanvasSize",
            suggest:
              "setting size in CSS pixels is not recommended, please use screen.windowSize instead.",
          },
          {
            name: "getCanvasSize",
            suggest: "please use screen.windowSize instead.",
          },
          {
            name: "getFrameSize",
            suggest:
              "getting size in CSS pixels is not recommended, please use screen.windowSize instead.",
          },
          {
            name: "setFrameSize",
            suggest:
              "setting size in CSS pixels is not recommended, please use screen.windowSize instead.",
          },
          {
            name: "getDevicePixelRatio",
            suggest: "use screen.devicePixelRatio instead.",
          },
          { name: "convertToLocationInView" },
          { name: "enableRetina" },
          { name: "isRetinaEnabled" },
          { name: "setRealPixelResolution" },
        ]),
        (function (t) {
          (t.NONE = "none"),
            (t.LOADING = "loading"),
            (t.LOADED = "loaded"),
            (t.ERROR = "error");
        })(oTt || (oTt = {}));
      class lTt {
        constructor(t) {
          var e, i;
          (this._componentEventList = new Map()),
            (this._state = oTt.NONE),
            (this._wrapper = void 0),
            (this._webview = null),
            (this._loaded = !1),
            (this._forceUpdate = !1),
            (this._component = null),
            (this._uiTrans = null),
            (this._node = null),
            (this._w = 0),
            (this._h = 0),
            (this._m00 = 0),
            (this._m01 = 0),
            (this._m04 = 0),
            (this._m05 = 0),
            (this._m12 = 0),
            (this._m13 = 0),
            (this._component = t),
            (this._node = t.node),
            (this._uiTrans = t.node.getComponent(CI)),
            this.reset(),
            this.createWebView(
              null === (e = this._node) ||
                void 0 === e ||
                null === (i = e.scene) ||
                void 0 === i
                ? void 0
                : i.windowID
            );
        }
        reset() {
          (this._wrapper = null),
            (this._webview = null),
            (this._loaded = !1),
            (this._w = 0),
            (this._h = 0),
            (this._m00 = 0),
            (this._m01 = 0),
            (this._m04 = 0),
            (this._m05 = 0),
            (this._m12 = 0),
            (this._m13 = 0),
            (this._state = oTt.NONE),
            (this._forceUpdate = !1);
        }
        get loaded() {
          return this._loaded;
        }
        get componentEventList() {
          return this._componentEventList;
        }
        get webview() {
          return this._webview;
        }
        get state() {
          return this._state;
        }
        get UICamera() {
          return Lv.root.batcher2D.getFirstRenderCamera(this._node);
        }
        dispatchEvent(t, ...e) {
          const i = this._componentEventList.get(t);
          i && ((this._state = t), i.call(this, e));
        }
        destroy() {
          this.removeWebView(),
            (this._wrapper = null),
            (this._webview = null),
            (this._loaded = !1),
            (this._component = null),
            (this._uiTrans = null),
            (this._forceUpdate = !1),
            this._componentEventList.clear();
        }
      }
      a.internal.WebViewImpl = lTt;
      const cTt = h.document,
        uTt = ys();
      class _Tt extends lTt {
        constructor(t) {
          super(t);
        }
        _bindDomEvent() {
          this.webview &&
            this.webview.addEventListener("load", (t) => {
              (this._forceUpdate = !0), this.dispatchEvent(oTt.LOADED);
              const e = t.target,
                i = e.contentDocument && e.contentDocument.body;
              i &&
                i.innerHTML.includes("404") &&
                this.dispatchEvent(oTt.ERROR, i.innerHTML);
            });
        }
        loadURL(t) {
          this.webview &&
            ((this.webview.src = t), this.dispatchEvent(oTt.LOADING));
        }
        createWebView(t) {
          const e = cTt.createElement("div");
          (this._wrapper = e),
            (e.id = "webview-wrapper"),
            (e.style["-webkit-overflow"] = "auto"),
            (e.style["-webkit-overflow-scrolling"] = "touch"),
            (e.style.position = "absolute"),
            (e.style.bottom = "0px"),
            (e.style.left = "0px"),
            (e.style.transformOrigin = "0px 100% 0px"),
            (e.style["-webkit-transform-origin"] = "0px 100% 0px"),
            YA.container.appendChild(e);
          const i = cTt.createElement("iframe");
          (this._webview = i),
            (i.id = "webview"),
            (i.style.border = "none"),
            (i.style.width = "100%"),
            (i.style.height = "100%"),
            e.appendChild(i),
            this._bindDomEvent();
        }
        removeWebView() {
          const t = this._wrapper;
          Ce(YA.container, t) && YA.container.removeChild(t), this.reset();
        }
        enable() {
          this._wrapper && (this._wrapper.style.visibility = "visible");
        }
        disable() {
          this._wrapper && (this._wrapper.style.visibility = "hidden");
        }
        evaluateJS(t) {
          if (this.webview) {
            const e = this.webview.contentWindow;
            if (e)
              try {
                e.eval(t);
              } catch (t) {
                this.dispatchEvent(oTt.ERROR, t), R(t);
              }
          }
        }
        setBackgroundTransparent(t) {}
        sendWebViewToBack() {}
        bringWebViewToFront() {}
        setHiddenWebView() {}
        setOnJSCallback(t) {
          w("The platform does not support");
        }
        setJavascriptInterfaceScheme(t) {
          w("The platform does not support");
        }
        syncMatrix() {
          if (
            !this._wrapper ||
            !this._uiTrans ||
            !this._component ||
            "hidden" === this._wrapper.style.visibility
          )
            return;
          const t = this.UICamera;
          if (!t) return;
          this._component.node.getWorldMatrix(uTt),
            t.update(!0),
            t.worldMatrixToScreen(uTt, uTt, YA.canvas.width, YA.canvas.height);
          const { width: e, height: i } = this._uiTrans.contentSize;
          if (
            !this._forceUpdate &&
            this._m00 === uTt.m00 &&
            this._m01 === uTt.m01 &&
            this._m04 === uTt.m04 &&
            this._m05 === uTt.m05 &&
            this._m12 === uTt.m12 &&
            this._m13 === uTt.m13 &&
            this._w === e &&
            this._h === i
          )
            return;
          (this._m00 = uTt.m00),
            (this._m01 = uTt.m01),
            (this._m04 = uTt.m04),
            (this._m05 = uTt.m05),
            (this._m12 = uTt.m12),
            (this._m13 = uTt.m13),
            (this._w = e),
            (this._h = i);
          const s = Ur.devicePixelRatio,
            n = 1 / s,
            r = 1 / s,
            a = YA.container,
            o = uTt.m00 * n,
            h = uTt.m01,
            l = uTt.m04,
            c = uTt.m05 * r;
          (this._wrapper.style.width = `${e}px`),
            (this._wrapper.style.height = `${i}px`);
          const u = this._w * n,
            _ = this._h * r,
            d = u * uTt.m00 * this._uiTrans.anchorX,
            p = _ * uTt.m05 * this._uiTrans.anchorY,
            m = a && a.style.paddingLeft ? parseInt(a.style.paddingLeft) : 0,
            f =
              a && a.style.paddingBottom ? parseInt(a.style.paddingBottom) : 0,
            g = `matrix(${o},${-h},${-l},${c},${uTt.m12 * n - d + m},${-(
              uTt.m13 * r -
              p +
              f
            )})`;
          (this._wrapper.style.transform = g),
            (this._wrapper.style["-webkit-transform"] = g),
            (this._forceUpdate = !1);
        }
      }
      class dTt {
        static getImpl(t) {
          return new _Tt(t);
        }
      }
      var pTt, mTt, fTt, gTt, yTt, TTt, STt, ETt, vTt;
      a.internal.WebViewImplManager = dTt;
      let bTt = t(
        "WebView",
        ((pTt = Ca("cc.WebView")),
        (mTt = Oa(CI)),
        (fTt = ao([Yd])),
        pTt(
          (gTt =
            mTt(
              (((vTt = class extends np {
                constructor(...t) {
                  super(...t),
                    (this._url = TTt && TTt()),
                    (this.hidden = STt && STt()),
                    (this._impl = null),
                    (this.webviewEvents = ETt && ETt());
                }
                get url() {
                  return this._url;
                }
                set url(t) {
                  (this._url = t), this._impl && this._impl.loadURL(t);
                }
                get nativeWebView() {
                  return (this._impl && this._impl.webview) || null;
                }
                get state() {
                  return this._impl ? this._impl.state : oTt.NONE;
                }
                setJavascriptInterfaceScheme(t) {
                  this._impl && this._impl.setJavascriptInterfaceScheme(t);
                }
                setOnJSCallback(t) {
                  this._impl && this._impl.setOnJSCallback(t);
                }
                evaluateJS(t) {
                  this._impl && this._impl.evaluateJS(t);
                }
                setBackgroundTransparent(t) {
                  this._impl && this._impl.setBackgroundTransparent(t);
                }
                sendWebViewToBack() {
                  this._impl && this._impl.sendWebViewToBack();
                }
                bringWebViewToFront() {
                  this._impl && this._impl.bringWebViewToFront();
                }
                setHiddenWebView() {
                  this._impl && this._impl.setHiddenWebView();
                }
                __preload() {
                  (this._impl = dTt.getImpl(this)),
                    this._impl.componentEventList.set(
                      oTt.LOADING,
                      this.onLoading.bind(this)
                    ),
                    this._impl.componentEventList.set(
                      oTt.LOADED,
                      this.onLoaded.bind(this)
                    ),
                    this._impl.componentEventList.set(
                      oTt.ERROR,
                      this.onError.bind(this)
                    ),
                    this.hidden && this._impl.setHiddenWebView(),
                    this._impl.loadURL(this._url);
                }
                onLoading() {
                  Yd.emitEvents(this.webviewEvents, this, oTt.LOADING),
                    this.node.emit(oTt.LOADING, this);
                }
                onLoaded() {
                  Yd.emitEvents(this.webviewEvents, this, oTt.LOADED),
                    this.node.emit(oTt.LOADED, this);
                }
                onError(...t) {
                  Yd.emitEvents(this.webviewEvents, this, oTt.ERROR, t),
                    this.node.emit(oTt.ERROR, this, t);
                }
                onEnable() {
                  this._impl && this._impl.enable();
                }
                onDisable() {
                  this._impl && this._impl.disable();
                }
                onDestroy() {
                  this._impl && (this._impl.destroy(), (this._impl = null));
                }
                update(t) {
                  this._impl && this._impl.syncMatrix();
                }
              }).EventType = oTt),
              (TTt = fa((yTt = vTt).prototype, "_url", [Na], function () {
                return "https://cocos.com";
              })),
              (STt = fa(yTt.prototype, "hidden", [Na], function () {
                return !1;
              })),
              (ETt = fa(yTt.prototype, "webviewEvents", [Na, fTt], function () {
                return [];
              })),
              (gTt = yTt))
            ) || gTt)
        ) || gTt)
      );
      a.internal.WebView = bTt;
    },
  };
});
